<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haoran&#39;s blog</title>
  
  <subtitle>Talk is cheap. Show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javassun.github.io/"/>
  <updated>2020-04-14T15:59:36.036Z</updated>
  <id>http://javassun.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>baidu_verify_7FbBYi4Opw</title>
    <link href="http://javassun.github.io/2020/04/15/baidu_verify_7FbBYi4Opw/"/>
    <id>http://javassun.github.io/2020/04/15/baidu_verify_7FbBYi4Opw/</id>
    <published>2020-04-14T16:14:35.214Z</published>
    <updated>2020-04-14T15:59:36.036Z</updated>
    
    <content type="html"><![CDATA[7FbBYi4Opw]]></content>
    
    <summary type="html">
    
      
      
        7FbBYi4Opw
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>6-GoAccess实现可视化并实时监控access日志</title>
    <link href="http://javassun.github.io/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/"/>
    <id>http://javassun.github.io/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</id>
    <published>2019-11-20T12:00:25.000Z</published>
    <updated>2020-04-14T11:07:16.499Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>access日志</strong> 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。</p><p><strong>GoAccess</strong> 这款工具以图形化的方式通过<strong>web socket</strong>协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。</p><a id="more"></a><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess</a> 是这个工具的站点。如图所示：<br><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/629f3358-d5c5-4889-b24f-bc4e6a87c46b.png" alt></p><p>现在先看一下之前静态web资源服务器所产生的access log日志格式<br><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/9f36080a-71ba-4c59-82e8-226d730d87a1.png" alt></p><p>现在打开 GoAccess中的 <strong>Get started</strong>快速开始页面，依据文档下载安装。</p><p><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/615f6899-491f-4f74-a245-feb5f3a9c0b3.png" alt></p><p>出现此错误</p><p>下载依赖包即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y GeoIP-devel</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;maxmind&#x2F;geoip-api-c&#x2F;releases&#x2F;download&#x2F;v1.6.11&#x2F;GeoIP-1.6.11.tar.gz</span><br><span class="line">tar -zxvf GeoIP-1.16.11.tar.gz</span><br><span class="line">cd GeoIP-1.16.11</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>出现错误：<br>configure: error: *** Missing development libraries for ncursesw</p><p>解决方法：<br>要使用–enable-utf8，你需要安装ncursesw，下面是安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun goaccess]# sudo yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>安装成功后：<br><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/dae8664f-26c8-45d9-b7ae-957833eae1fa.png" alt></p><p>当Nginx所用的access log 的配置没有发生变化时，我们可以使用这种方法：</p><p><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/64b3542d-a4d5-41d4-b8bb-718265f77c69.png" alt></p><p>也就是说，Nginx的 access log非常灵活，我们可以天添加各种不同的各模块的内置变量，</p><p>goaccess 会使用 -o 这个参数去生成一个新的report.html文件，将当前的access.log日志文件内容以 html图表的形式展示出来。</p><p>当 accss.log 变迁的时候，goaccess 会新启一个 web socket进程 通过端口的方式将新的 access.log中的内容推送到我们的客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun logs]# pwd</span><br><span class="line">&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs</span><br><span class="line">[root@haoransun logs]# goaccess host.access.log -o ..&#x2F;html&#x2F;report.html --real-time-html --time-format&#x3D;&#39; %H:%M:%S&#39; --date-format&#x3D;&#39;%d%b%Y&#39; --log-format&#x3D;COMBINED</span><br><span class="line">WebSocket服务器已准备接收来自客户的连接</span><br></pre></td></tr></table></figure><p>首先制定了 access.log的名字 ， 然后会把它输出到 report.html这个文件中，–real-time-html 即实时更新这个HTML页面，时间、日期、日志格式都已经指定好了。</p><p><img src="/2019/11/20/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/4bfbe716-0e7f-4e7b-b1c6-dcc2ca97c202.png" alt></p><p>就是说已经打开了一个新的 web socket</p><p>当我们访问这个report.html页面时，会向这个进程发起连接，由这个进程向我们推送日志的最新变更。</p><p>接下来我们要在 nginx配置文件中搭载如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen      8080;</span><br><span class="line">       # server_name  localhost;</span><br><span class="line"></span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">       # 当我们访问 &#x2F;report.html时，需要用 alias 把它重定向到 我们刚刚访问的 report.html中。</span><br><span class="line">       location &#x2F;report.html&#123;</span><br><span class="line">           alias &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;report.html;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;access日志&lt;/strong&gt; 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GoAccess&lt;/strong&gt; 这款工具以图形化的方式通过&lt;strong&gt;web socket&lt;/strong&gt;协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>8-Nginx配置文件简易解析</title>
    <link href="http://javassun.github.io/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/"/>
    <id>http://javassun.github.io/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/</id>
    <published>2019-11-20T10:03:05.000Z</published>
    <updated>2020-04-14T11:07:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><img src="/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png" alt>)<img src="/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png" alt>)<img src="/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png" alt></p><a id="more"></a><p>#运行用户<br>user nobody;<br>#启动进程,通常设置成和cpu的数量相等<br>worker_processes  1;</p><p>#全局错误日志及PID文件<br>#error_log  logs/error.log;<br>#error_log  logs/error.log  notice;<br>#error_log  logs/error.log  info;</p><p>#pid        logs/nginx.pid;</p><p>#工作模式及连接数上限<br>events {<br>    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,<br>    #仅用于linux2.6以上内核,可以大大提高nginx的性能<br>    use   epoll; </p><pre><code>#单个后台worker process进程的最大并发链接数    worker_connections  1024;# 并发总数是 worker_processes 和 worker_connections 的乘积# nginx作为http服务器的时候#     max_clients = worker_processes * worker_connections# nginx作为反向代理服务器的时候：#    max_clients = worker_processes * worker_connections / 4  # 为什么上面反向代理要除以4，应该说是一个经验值# 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000# worker_connections 值的设置跟物理内存大小有关# 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数# 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右# 我们来看看360M内存的VPS可以打开的文件句柄数是多少：# $ cat /proc/sys/fs/file-max# 输出 34336# 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内# 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置# 使得并发总数小于操作系统可以打开的最大文件数目# 其实质也就是根据主机的物理CPU和内存进行配置# 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。# ulimit -SHn 65535</code></pre><p>}</p><p>http {<br>    #设定mime类型,类型由mime.type文件定义<br>    include    mime.types;<br>    default_type  application/octet-stream;<br>    #设定日志格式<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p><pre><code>access_log  logs/access.log  main;#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，#对于普通应用，必须设为 on,#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，#以平衡磁盘与网络I/O处理速度，降低系统的uptime.sendfile     on;#tcp_nopush     on;#连接超时时间#keepalive_timeout  0;keepalive_timeout  65;tcp_nodelay     on;#开启gzip压缩gzip  on;gzip_disable &quot;MSIE [1-6].&quot;;#设定请求缓冲client_header_buffer_size    128k;large_client_header_buffers  4 128k;#设定虚拟主机配置server {    #侦听80端口    listen    80;    #定义使用 www.nginx.cn访问    server_name  www.nginx.cn;    #定义服务器的默认网站根目录位置    root html;    #设定本虚拟主机的访问日志    access_log  logs/nginx.access.log  main;    #默认请求    location / {        #定义首页索引文件的名称        index index.php index.html index.htm;       }    # 定义错误提示页面    error_page   500 502 503 504 /50x.html;    location = /50x.html {    }    #静态文件，nginx自己处理    location ~ ^/(images|javascript|js|css|flash|media|static)/ {        #过期30天，静态文件不怎么更新，过期可以设大一点，        #如果频繁更新，则可以设置得小一点。        expires 30d;    }    #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.    location ~ .php$ {        fastcgi_pass 127.0.0.1:9000;        fastcgi_index index.php;        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        include fastcgi_params;    }    #禁止访问 .htxxx 文件        location ~ /.ht {        deny all;    }}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png&quot; alt&gt;)&lt;img src=&quot;/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png&quot; alt&gt;)&lt;img src=&quot;/2019/11/20/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>7-Nginx安装详解</title>
    <link href="http://javassun.github.io/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-11-09T11:01:02.000Z</published>
    <updated>2020-04-14T11:07:31.258Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p>Nginx是一款轻量级高性能的Web服务器/反向代理服务器，</p><p>并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，<br>中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><a id="more"></a><h1 id="新方法安装"><a href="#新方法安装" class="headerlink" title="新方法安装"></a>新方法安装</h1><p><strong>Nginx是C语言开发，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. gcc安装</span><br><span class="line">yum install gcc-c++</span><br><span class="line">2. PCRE pcre-devel安装</span><br><span class="line">PCRE（Perl Compatible Regular Expressions）是一个Perl库，包括perl兼容的正则表达式。Nginx的http模块使用pcre来解析正则表达式。所以需要在linux安装pcre库。pcre-devel是pcre开发的一个二次开发库，nginx也需要此命令。</span><br><span class="line">yun install -y pcre pcre-devel</span><br><span class="line">3. zlib安装</span><br><span class="line">zlib库提供了很多种压缩和解压额方式，Nginx使用zlib对http包的内容进行gzip，所以需要</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">4. Open-SSL安装</span><br><span class="line">OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法，常用的密钥和证书封装管理功能以及SSL协议，并提供丰富的应用程序供测试或其他目的。</span><br><span class="line">Nginx不仅支持http协议，还支持https（在ssl协议上传输http）,所以需要安装OpenSSL库</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h2 id="老方法安装"><a href="#老方法安装" class="headerlink" title="老方法安装"></a>老方法安装</h2><ol><li><p>安装gcc</p><p> rpm -Uvh glibc-2.12-1.209.el6_9.2.x86_64.rpm glibc-common-2.12-1.209.el6_9.2.x86_64.rpm libgcc-4.4.7-18.el6_9.2.x86_64.rpm tzdata-2018e-3.el6.noarch.rpm </p><p> rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm cpp-4.4.7-18.el6_9.2.x86_64.rpm glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm     kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm libgomp-4.4.7-18.el6_9.2.x86_64.rpm mpfr-2.4.1-6.el6.x86_64.rpm ppl-0.10.2-11.el6.x86_64.rpm </p><p> rpm -ivh gcc-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装gcc-c++<br> rpm -Uvh libstdc++-4.4.7-18.el6_9.2.x86_64.rpm<br> rpm -ivh libstdc++-devel-4.4.7-18.el6_9.2.x86_64.rpm  gcc-c++-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装pcre<br> tar -zxvf pcre-8.40.tar.gz<br> cd pcre-8.40<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装zlib</p><p> tar -zxvf zlib-1.2.11.tar.gz<br> cd zlib-1.2.11<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装启动</p><p> ./configure –prefix=/usr/local/nginx  配置nginx 并且指定nginx的安装目录</p><p> make &amp;&amp; make install</p><p> cd /usr/local/nginx/sbin</p><p> netstat -ano | grep 80     //检查80端口是否占用</p><p> ./nginx -c /usr/local/nginx/conf/nginx.conf</p><p> 注意：</p><pre><code>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：ln -s /usr/local/lib/libpcre.so.1 /lib64/</code></pre></li></ol><hr><p>Nginx运行和控制<br>    /usr/local/nginx/sbin/nginx 命令</p><pre><code>nginx命令参数：不像许多其他软件系统，Nginx 仅有几个命令行参数，完全通过配置文件来配置。参数如下：-s reload | reopen | stop 进程相关（重新载入配置文件 | 重启Nginx | 停止Nginx）-c &lt;/path/to/config&gt; 为 Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。-v 显示 nginx 的版本。-V 显示 nginx 的版本，编译器版本和配置参数。</code></pre><hr><p>nginx负载均衡</p><p>1.常用的负载均衡策略<br>    a. 轮询（默认）<br>    每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>    upstream backserver {<br>        server 192.168.0.14;<br>        server 192.168.0.15;<br>    }<br>    b. 指定权重<br>    指定轮询几率（权重默认为1），weight和访问比率成正比，用于后端服务器性能不均的情况。<br>    upstream backserver {<br>        server 192.168.0.14 weight=10;<br>        server 192.168.0.15 weight=10;<br>    }<br>    c. IP绑定 ip_hash<br>    每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>    upstream backserver {<br>        ip_hash;<br>        server 192.168.0.14:88;<br>        server 192.168.0.15:80;<br>    }</p><ol start="2"><li><p>完整配置</p><p> #添加tomcat列表，真实应用服务器都放在这<br> upstream tomcat_pool {</p><pre><code>#server tomcat地址:端口号 weight表示权值，权值越大，被分配的几率越大;</code></pre><p>　　    server 192.168.0.223:8080 weight=4 max_fails=2 fail_timeout=30s;<br> 　　server 192.168.0.224:8080 weight=4 max_fails=2 fail_timeout=30s;<br> }</p><p> server{</p><pre><code>......</code></pre></li></ol><pre><code>    location / {        proxy_pass    http://tomcat_pool;    #转向tomcat处理    }    ......}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;Nginx是一款轻量级高性能的Web服务器/反向代理服务器，&lt;/p&gt;
&lt;p&gt;并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，&lt;br&gt;中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>5-Nginx搭建具备缓存功能的反向代理</title>
    <link href="http://javassun.github.io/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://javassun.github.io/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2019-11-05T11:55:57.000Z</published>
    <updated>2020-04-14T11:07:06.114Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面已经展示了<strong>Nginx</strong>如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-<strong>上游服务</strong>，再搭建一个Nginx服务，作为<strong>反向代理</strong>，演示当Nginx作为方向代理时，应该如何使用？</p><p>由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，</p><a id="more"></a><p>现在这个页面仍然是我们刚才搭建的静态资源服务器所展示的页面。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/df2a42be-0e03-4eba-b963-00566fe3011b.jpg" alt></p><p>我们需要将此Nginx服务器变更为<strong>上游服务器</strong>，而上游服务器通常对公网是不进行访问的。我们可以做一个非常简单的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim conf&#x2F;nginx.conf</span><br><span class="line">   server &#123;</span><br><span class="line">        listen      127.0.0.1:8080;</span><br><span class="line">       # server_name  localhost;</span><br><span class="line"></span><br><span class="line"># 在listen上加入IP地址：127.0.0.1:8080</span><br><span class="line">这表示只能本机的进程来访问我们打开的8080端口，</span><br><span class="line"></span><br><span class="line"># 此时我们需要先将原先的Nginx进程停掉</span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line"># 再重新打开Nginx，防止之前的端口仍然可以使用</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/ff657493-3010-44aa-8983-412cc49d08b0.png" alt></p><p>再次访问时，会发现无法访问了，因为Nginx拒绝了由浏览器发过去的请求连接。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/043e0d0a-61f5-4acc-8730-288adfb9ea29.png" alt></p><p>由此，Nginx静态资源服务器已经变成了一个上游服务器。</p><h2 id="开始搭建Nginx反向代理"><a href="#开始搭建Nginx反向代理" class="headerlink" title="开始搭建Nginx反向代理"></a>开始搭建Nginx反向代理</h2><p>之前的 <strong>Nginx</strong> 是1.14版本，而反向代理我们用openrestry的1.16版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun sbin]# .&#x2F;nginx -v</span><br><span class="line">nginx version: nginx&#x2F;1.14.2</span><br></pre></td></tr></table></figure><p>我们进入到openresty所在的nginx服务，修改其配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 在此处添加一个 upstream，即上游服务其中的一台server，它的访问地址是 127.0.0.1:8080</span><br><span class="line"># 如果我有很多上游服务，可以依次放在这里面。（命名为 local,此处可表示一批上游服务器）</span><br><span class="line">  #gzip  on;</span><br><span class="line">    upstream local&#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # 此处设置当前代理服务器的域名，由于没有，就算了</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            # proxy_set_header：因为有了一台反向代理，所以我们再去拿一些变量或者值的时  候，可能就会出错了，</span><br><span class="line">            # 比如：一个TCP连接，是有对端地址的，而有了方向代理后，我们的              反向代理与客户端是一个TCP连接，而反向代理与上游服务器又是另外一个TCP连接，因此，如果我们取 $remote_addr 这个远端地址的时候，在上游服务那里，取到的实际上师我反向代理服务器的地址，而如果我想拿浏览器的客户端地址，作为限制浏览器访问速度功能的一个依据时，其实是拿不到的。因此，proxy_set_header可以把一些值添加为新的header发送给上游服务器，</span><br><span class="line">            # 比如说 X-Real-IP 将它的值设置为我们从TCP连接中拿到的远端IP地址，Host同样道理，因为用户直接访问的域名，是在他的浏览器中输入的，即可由上游服务器处理此域名，也可由反向代理服务器处理此域名，这些所有的配置特性，都可在官网的 http_proxy_module模块中找到。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            # http_proxy_module提供了非常丰富的特性+内置变量，而最重要之一特性就是 proxy_cache。</span><br><span class="line">            # 因为当我们的Nginx作为方向代理时，通常只有动态的请求，即不同的用户访问同一个URL时，看到的内容是不同的，此时才会交由上游服务处理。</span><br><span class="line">            # 但是有一些内容可能是一段时间不会发生变化的。此时，为了减轻上游服务的压力，我们就会让Nginx将上游返回来的内容缓存一段时间，如缓存一天等。在一天之内，即使上游服务器对这个内容的响应发生了变化，也不管，只会去拿已缓存的内容向浏览器发出响应。</span><br><span class="line">            # 因为 Nginx的性能远远领先于上游服务器的性能，所以使用此特性后，对我们一些小的站点，会有非常大的性能提升。</span><br><span class="line">            #proxy_cache my_cache;</span><br><span class="line">            #proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            #proxy_cache_valid 200 304 302 1d;</span><br><span class="line">            # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2ab4b5f1-508b-47c5-af66-188ff2a9c828.png" alt></p><p>此时再去访问我们的代理服务器的IP地址，<strong>如果配置里域名，则用域名访问即可</strong>，因为监听的80端口，所以使用192.168.121.100:80/dangdang/book.html访问即可。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/14217284-3db6-4e6e-86ce-c6b7271843ef.jpg" alt></p><p>由下图可看出，我们的请求是由反向代理服务器发给我们的。其中的 <strong>server:nginx/1.16.0</strong>证明了它的身份。</p><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/06774664-cc31-4dbb-b5f5-bf44b60829d2.png" alt></p><h2 id="开始搭建Nginx缓存服务器"><a href="#开始搭建Nginx缓存服务器" class="headerlink" title="开始搭建Nginx缓存服务器"></a>开始搭建Nginx缓存服务器</h2><p>首先，我们需要<strong>proxy_cache_path</strong>来设置我们的缓存 文件写在那个目录下，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    proxy_cache_path &#x2F;tmp&#x2F;nginxcache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m max_size&#x3D;10g</span><br><span class="line">            inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            .....</span><br></pre></td></tr></table></figure><p>此处写在了 <code>/tmp/nginxcache</code>,以及这些文件的命名方式，这些文件的关键字是要放在共享内存中的，此处开了一个10m的共享内存，命名为my_cache，这些参数都在控制我们的缓存。</p><p>缓存如何使用呢？就是在我们需要做缓存的路径下添加<code>proxy_cache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       #server_name  haoraunsun.pub;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location &#x2F; &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">           proxy_set_header Host $host;</span><br><span class="line">           proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">           # 就在此处</span><br><span class="line">           # proxy_cache 后面跟的就是我们刚才开辟的共享内存</span><br><span class="line">           proxy_cache my_cache;</span><br><span class="line">           # 共享内存中的key设置的是 同一个url 访问时 对不同的用户可能展示的内容不一样。因此，用户这样一个变量就要放在共享内存中。</span><br><span class="line">           # 此处只是简单的放置了 host+资源+参数,这些作为一个整体的Key。</span><br><span class="line">           proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">           # 对于哪些响应不返回，这里做了一些简单处理。</span><br><span class="line">           proxy_cache_valid 200 304 302 1d;</span><br><span class="line">           </span><br><span class="line">           # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dbb3164a-c86b-45cd-97c4-4d0d228aeb3a.png" alt></p><p>加完这些参数后，需要重载配置文件，重新启用方向代理服务的配置。<br>再次直接访问站点，然后将上游服务停掉，看是否能获得同样的结果。</p><p>首先，我们再次访问，让其响应内容刷到缓存文件中。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/f116bae7-d1df-4716-9f3f-a5c461f0eb37.png" alt></p><p>查看进程<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/9733b5f7-3813-4f02-bf20-eda96a4c0ed0.png" alt></p><p>将上游服务停掉。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dfc0abce-1988-43f5-a4df-ae755de9af93.png" alt></p><p>再次访问，实际上读的是缓存系统中的内容作为响应返回给客户端。</p><p>此时，上游服务已经停掉了<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/a3d4faab-fcc5-4ce4-956f-7e75e52d8662.png" alt></p><p>再次访问<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/6f1b4d43-8144-49ac-8676-201d87902b4c.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面已经展示了&lt;strong&gt;Nginx&lt;/strong&gt;如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-&lt;strong&gt;上游服务&lt;/strong&gt;，再搭建一个Nginx服务，作为&lt;strong&gt;反向代理&lt;/strong&gt;，演示当Nginx作为方向代理时，应该如何使用？&lt;/p&gt;
&lt;p&gt;由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>3-Nginx命令行演示-重载-热部署-切割</title>
    <link href="http://javassun.github.io/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/"/>
    <id>http://javassun.github.io/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/</id>
    <published>2019-10-20T11:00:56.000Z</published>
    <updated>2020-04-14T11:06:35.158Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="检查80端口是否被占用"><a href="#检查80端口是否被占用" class="headerlink" title="检查80端口是否被占用"></a>检查80端口是否被占用</h2><p>yum install net-tools<br>netstat -ano | grep 80</p><h1 id="Nginx命令行"><a href="#Nginx命令行" class="headerlink" title="Nginx命令行"></a>Nginx命令行</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg" alt></p><a id="more"></a><h1 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h1><p>此时在 nginx的安装目录下执行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">将Nginx启动了起来。</span><br></pre></td></tr></table></figure><p><font color="red">注意：<br>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：<br>ln -s /usr/local/lib/libpcre.so.1 /lib64/</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">再次修改了 Nginx配置文件中的一些值</span><br><span class="line">[root@haoransun nginx]# vim conf&#x2F;nginx.conf</span><br><span class="line">如需要将 #tcp_nopush这个注释去掉。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/098162e9-ca47-4da3-a22c-b0e1de51a776.png" alt></p><ul><li><p><strong><font color="red">mac</font>：当修改完成后，保存退出后，可以直接执行 <font color="red"> ./nginx -s reload </font>指令。这样是在Nginx在不停止对客户服务的情况下，使用了 tcp_nopush这个新的配置项，</strong></p></li><li><p>**<font color="red">CentOS</font>：<br>cd sbin<br>[root@haoransun sbin]# ./nginx -s reload即可</p></li><li><p><strong>ps -ef | grep nginx 可以看到正在运行的Nginx</strong></p></li></ul><h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><p><strong>即对Nginx在不停机的情况下做版本升级</strong>。<br><font color="red">对现有的Nginx的运行目录中的二进制可执行文件做一次备份：<strong>因为我们更换的只是二进制文件，并不会对其他文件做更换。</strong></font><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/1069c513-57b6-4f14-bf86-e72dc898eacf.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx nginx.old</span><br></pre></td></tr></table></figure><p>先下载一个最新版本的Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line">tar -zxvf 此版本Nginx</span><br><span class="line">编译生成二进制可执行文件</span><br><span class="line">进入新版本Nginx目录中，</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx</span><br><span class="line"></span><br><span class="line">上述命令会在Nginx最新版本目录中生成objs中间文件。</span><br><span class="line">make</span><br><span class="line">上述命令会生成Makerfile文件</span><br><span class="line">make install</span><br><span class="line">上述命令会在 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx目录下生成最新版本Nginx的运行目录文件，里面包含了最新版本的Nginx二进制可执行文件</span><br></pre></td></tr></table></figure><p>将我们编译好的<strong>最新版本的二进制文件</strong>拷贝到旧版本的二进制那个可执行文件目录中，替换掉当前Nginx进程正在使用的旧版本二进制文件。<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/daf5c361-5f4f-42c3-a7b0-26c0f1339f06.png" alt><br><font color="red"><strong>复制成功后，看到新版本的Nginx二进制可执行文件的size与旧版本是不一样的。</strong></font></p><p>现在，需要给<strong>正在运行的Nginx的Master进程发送一个信号，告诉它，我们要进行热部署了，做一次版本升级</strong><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/c1c96e01-89b4-4df0-8302-d5594b0ab572.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 6655 ## master进程号</span><br><span class="line">ps -ef |grep nginx</span><br></pre></td></tr></table></figure><p>接下来会看到，<strong>Nginx Master进程会新起一个Nginx Master进程，新的Nginx Master进程使用了刚刚复制过来的最新的Nginx二级制文件，老的Worker也在运行，新的Master会生成新的Worker，它们会平滑的将所有的请求过渡到新的二进制文件所起的Nginx进程中，由此实现了平滑过度-热部署</strong>，如下所示：<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/086e0e3b-a68e-4e18-b5ca-2d2e14362e01.png" alt><br>我们看到，新老都存在，且新的Master进程父ID 为老的Master进程ID，由此看出新的是由老的新起的。</p><p>但是老的Master进程已经<strong>不再监听80或者443这样的Web端口</strong>，所以，新的连接，都会进入新的Nginx进程中。</p><p>这是，我们需要向老的Nginx进程发生一个信号，告诉它，优雅的关闭所有的 Worker进程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 6655 ## 老的Master 进程号</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/5a48e9e0-f3dc-410c-89d2-bc7de1124ecd.png" alt></p><p>老的Worker进程已经优雅的退出了，但是老的Master进程 6655 还存在，但是它手下已经没有Worker进程了，这说明了一件事情：所有的请求已经去全部切换到我们新升级好的Nginx中了。</p><p>./nginx -v :已经是最新的版本了</p><p><strong>如果升级过程完成后，没有任何问题，需要关闭老的master进程的话，使用以下命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill  -QUIT old_master_pid</span><br></pre></td></tr></table></figure><p><strong>但是 想要版本回退呢？只需要向老的Master进程 6655发送 reload 命令，让它重新拉起Worker进程，再把新的Master进程关掉。<font color="red"> 因此：老的Master进程是不会退出的，保留以允许我们做版本回退</font>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v   # 此时这里是新的nginx版本号</span><br><span class="line"></span><br><span class="line">mv nginx nginx-1.16.0 # 将新的nginx文件命名为它的版本号</span><br><span class="line"></span><br><span class="line">mv nginx.old nginx # 将老的nginx命名为nginx</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">kill -USR1 6728(新的nginx的master的id)</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;nginx -v # 已经是老版本的nginx了</span><br></pre></td></tr></table></figure><h1 id="切割日志文件"><a href="#切割日志文件" class="headerlink" title="切割日志文件"></a>切割日志文件</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/e7955fcb-062b-424e-8db2-3f4cf82ba1ad.png" alt></p><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/ce22072b-b74f-4910-a13b-bc1a2407f577.png" alt></p><p>可以看到，haoransun_access.log日志文件已经有接近16M了，假设它此时已经很大了，想要将当前日志备份到另外一个文件中，而当前Nginx仍然正常运行，该如何做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reopen即可</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/d7da2cf6-25f5-4fc5-b3bd-3618ecaea6a1.png" alt></p><p><strong>./nginx -s  reopen 命令即可做到，但是太麻烦了</strong></p><p><font color="red">具体的便捷做法参考000-Nginx访问日志配置及信息详解.。。。。</font></p><h2 id="日志切割-bash脚本demo"><a href="#日志切割-bash脚本demo" class="headerlink" title="日志切割 bash脚本demo"></a>日志切割 bash脚本demo</h2><p>往往会每一天或者每一周执行一次日志切割。</p><p>可以先写成一个<strong>bash脚本</strong>，在此脚本中，先将 haoransun.log复制一下，在执行 -s reopen命令。<br>最后将此脚本放在<strong>crontab</strong>中，比如：</p><p>在logs目录下新建 history文件夹：用于存放历史日志文件。</p><p><strong>在logs目录下新建rotate.sh脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Rotate the Nginx logs to prevent a single logfile from consuming too much disk space.</span><br><span class="line"># 此处 日志存放目录可以自定义，但一般存放在nginx相关的目录下</span><br><span class="line"># LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line"># CUR_LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs</span><br><span class="line">CUR_LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs</span><br><span class="line">YESTERDAY&#x3D;$(date -d &quot;yesterday&quot;+%Y-%m-%d )</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;haoransun_access.log $(LOGS_PATH)&#x2F;haoransun_access_$(YESTERDAY).log</span><br><span class="line"># 此处可以指定多个日志文件到指定目录下</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;error.log $(LOGS_PATH)&#x2F;error_$(YESTERDAY).log</span><br><span class="line">## 向 Nginx 主进程发送 USR1 信号 USR1 信号是重新打开日志文件</span><br><span class="line">kill -USR1 $(cat &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin)</span><br></pre></td></tr></table></figure><p><strong>查看当前周期任务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">crontab -e</span><br><span class="line">59 23 * * * root &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logx&#x2F;rotate.sh</span><br><span class="line">:wq</span><br><span class="line">再次 crontab -l 即可查看该脚本在每天的23点59分执行。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;检查80端口是否被占用&quot;&gt;&lt;a href=&quot;#检查80端口是否被占用&quot; class=&quot;headerlink&quot; title=&quot;检查80端口是否被占用&quot;&gt;&lt;/a&gt;检查80端口是否被占用&lt;/h2&gt;&lt;p&gt;yum install net-tools&lt;br&gt;netstat -ano | grep 80&lt;/p&gt;
&lt;h1 id=&quot;Nginx命令行&quot;&gt;&lt;a href=&quot;#Nginx命令行&quot; class=&quot;headerlink&quot; title=&quot;Nginx命令行&quot;&gt;&lt;/a&gt;Nginx命令行&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>2-Nginx配置语法</title>
    <link href="http://javassun.github.io/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</id>
    <published>2019-10-17T11:47:52.000Z</published>
    <updated>2020-04-14T11:06:19.254Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="Nginx-配置语法"><a href="#Nginx-配置语法" class="headerlink" title="Nginx 配置语法"></a>Nginx 配置语法</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg" alt></p><a id="more"></a><h1 id="Nginx配置参数：时间单位"><a href="#Nginx配置参数：时间单位" class="headerlink" title="Nginx配置参数：时间单位"></a>Nginx配置参数：时间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/4440df2c-e938-4f44-9a0e-2a9a1b44b32c.jpg" alt></p><h1 id="Nginx配置参数：空间单位"><a href="#Nginx配置参数：空间单位" class="headerlink" title="Nginx配置参数：空间单位"></a>Nginx配置参数：空间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/2a8c6624-55b3-4554-b84c-8c448dc319b6.jpg" alt></p><h1 id="Nginx-语法示例"><a href="#Nginx-语法示例" class="headerlink" title="Nginx 语法示例"></a>Nginx 语法示例</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7a40655-721d-4edb-b990-9d4ef7b60470.jpg" alt></p><ul><li><p><strong>http{} 就是一个指令块</strong></p></li><li><p><strong>include            mime.types; 这是一条指令</strong></p></li><li><p><strong>指令后 可以跟多个参数</strong></p></li><li><p><strong>指令间以;为分隔符，可以将多条指令放在一行</strong></p></li><li><p><strong>指令块可以有名字，如：upstream指令块 thwp,有些指令块是没有名字的，如： http、server等。<font color="red">有名与否是由提供这个指令块的Nginx 模块来决定的</font></strong></p></li><li><p><strong>3m:表示3分钟</strong></p></li><li><p><strong>limit_req_zone 10m 开启10MB大小的共享内存空间，给不同的Worker使用</strong></p></li></ul><hr><h1 id="http配置的指令块"><a href="#http配置的指令块" class="headerlink" title="http配置的指令块"></a>http配置的指令块</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7901424-0375-4abf-869b-7a62ddb552b8.jpg" alt></p><ul><li><p><strong>http模块有四个大的指令块：http、server、location、upstream</strong></p></li><li><p><strong>http{}：表示 大括号内的所有指令都是由<font color="red">http模块去解析、执行。一个非 http模块：stream等是没有办法被解析的</font>。</strong></p></li><li><p><strong>upstream：表示<font color="red">上游服务</font> ，当Nginx需要与Tomcat/DJango等企业内网的其他应用服务交互时，可以定义此 upstream.</strong></p></li><li><p><strong>server：对应一个、组域名</strong></p></li><li><p><strong>location：一个URL表达式</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;Nginx-配置语法&quot;&gt;&lt;a href=&quot;#Nginx-配置语法&quot; class=&quot;headerlink&quot; title=&quot;Nginx 配置语法&quot;&gt;&lt;/a&gt;Nginx 配置语法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>1-Nginx的前世今生</title>
    <link href="http://javassun.github.io/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://javassun.github.io/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2019-10-15T11:00:56.000Z</published>
    <updated>2020-04-14T11:06:05.803Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="Nginx的三个主要应用场景"><a href="#Nginx的三个主要应用场景" class="headerlink" title="Nginx的三个主要应用场景"></a>Nginx的三个主要应用场景</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg" alt></p><p><font color="red">流程解析：</font><br>一个<strong>Web</strong>请求从红色的线走下来后，会先经过<strong>Nginx</strong>,再到<strong>应用服务（Tomcat/Django）</strong>，再去访问<strong>Redis/MySQL</strong>这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有<strong>反向代理</strong>功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，<strong>反向代理</strong>必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于<strong>企业内网的边缘节点</strong>，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来<strong>在一段时间内不变的动态内容缓存到Nginx</strong>中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 <strong>缓存，加速我们的访问</strong>。（<strong>反向代理</strong>）</p><p>一些<strong>css/js/png</strong>等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（<strong>静态资源</strong>）</p><p>如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（<strong>API服务</strong>）</p><a id="more"></a><h1 id="Nginx出现的缘由"><a href="#Nginx出现的缘由" class="headerlink" title="Nginx出现的缘由"></a>Nginx出现的缘由</h1><h2 id="互联网的数据量急速增长"><a href="#互联网的数据量急速增长" class="headerlink" title="互联网的数据量急速增长"></a>互联网的数据量急速增长</h2><p>互联网的快速普及<br>全球化<br>物联网</p><h2 id="摩尔定律：性能提升"><a href="#摩尔定律：性能提升" class="headerlink" title="摩尔定律：性能提升"></a>摩尔定律：性能提升</h2><h2 id="低效的Apache-：一个连接对应一个进程"><a href="#低效的Apache-：一个连接对应一个进程" class="headerlink" title="低效的Apache ：一个连接对应一个进程"></a>低效的Apache ：一个连接对应一个进程</h2><p>当有百万个连接时，Apache并不会建造出百万个进程，就算生成了，进程间的切换会损耗极大的性能。而Nginx可以轻松应对百万级的连接。</p><h1 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h1><p>高并发、高性能<br><strong>高并发</strong>往往需要我们对每个连接所使用的内存尽量的少即可达到，具有高并发的同时又能达到<strong>高性能</strong>，需要非常好的设计。Nginx可以达到什么样的标准呢？如现在的主流服务器（32核，64G）可以轻松地达到数千万并发连接，如果是处理简单的静态资源请求，可以达到100W的RPS(REQUEST PER SECOND)<br>可扩展性好<br>主要体现在<strong>模块化设计</strong>，非常的稳定。使其的第三方模块-生态圈非常稳定、丰富。甚至是有Tengene（淘宝修改了Nginx的源源码，做了定制化开发）/OpenResty（Lua语言开发）这样的第三方插件在他们浙之上，又生成了一套生态圈。<br>高可靠性<br>Nginx可以在服务器上持续不间断的运行数年。对于Nginx这样的一个高并发、高性能的反向代理服务器而言，往往运行在企业内网的边缘节点上，此时，若企业想提供<strong>5个9</strong>或更高的服务时，Nginx的宕机可能1年就1s的时间间隙。<br>热部署<br>在不停止服务的情况下，升级Nginx,此功能<strong>非常重要</strong>，因为在Nginx上可能跑了数百万的并发连接。如果是普通服务，则直接kill掉进程再重启即可。但对于Nginx而言，kill掉Nginx进程，会导致操作系统为所有的已建立连接的客户端发送<strong>TCP中的reset复位包</strong>，然而很多客户端是没有办法，很好的处理复位请求的，<strong>在大并发场景下，一些偶然事件就会导致非常恶劣的结果，因此热部署极其重要</strong><br>BSD许可证<br>开源且可商用</p><h1 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a>Nginx的组成</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/e604a666-da3c-4a91-9866-53e81c4ff90f.jpg" alt></p><h2 id="Nginx二进制可执行文件"><a href="#Nginx二进制可执行文件" class="headerlink" title="Nginx二进制可执行文件"></a>Nginx二进制可执行文件</h2><p>由Nginx自身的官方模块+我们编译的第三方模块一起构建的文件，相当于汽车本身（有完整的系统，所有的功能都由它提供）</p><h2 id="Nginx-conf配置文件"><a href="#Nginx-conf配置文件" class="headerlink" title="Nginx.conf配置文件"></a>Nginx.conf配置文件</h2><p>相当于汽车的驾驶员。</p><h2 id="access-log访问日志"><a href="#access-log访问日志" class="headerlink" title="access.log访问日志"></a>access.log访问日志</h2><p>汽车经过所形成的GPS轨迹。</p><h2 id="error-log错误日志"><a href="#error-log错误日志" class="headerlink" title="error.log错误日志"></a>error.log错误日志</h2><p>黑匣子：定位问题。</p><h1 id="Nginx的版本（nginx-org-开源-nginx-com-商业）"><a href="#Nginx的版本（nginx-org-开源-nginx-com-商业）" class="headerlink" title="Nginx的版本（nginx.org:开源 nginx.com:商业）"></a>Nginx的版本（nginx.org:开源 nginx.com:商业）</h1><p>单数号：最新按本（新功能有待考验）<br>偶数号：稳定版本（一般选择此版本）<br>版本号-feature-bugfix-change<br>openresty.com openresty.org</p><h1 id="编译出适合自己的Nginx"><a href="#编译出适合自己的Nginx" class="headerlink" title="编译出适合自己的Nginx"></a>编译出适合自己的Nginx</h1><p>nginx.org网址 —–&gt; 选择download<br>在选中的版本上 —–&gt; 右键选择复制链接地址<br>在linux系统中  —–&gt; wget 下载地址即可<br><font color="red">ps:Nginx依赖一些第三方软件包，如gcc、gcc-c++、openssl、pcre、zlib,详细见0-Nginx安装过程</font></p><h2 id="目录解析"><a href="#目录解析" class="headerlink" title="目录解析"></a>目录解析</h2><p>解压压缩包： tar -zxvf nginx-xxx.tar.gz<br>进入解压源码包： cd nginx-xxx<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f08f5668-a4bd-4fe4-a790-c25c437b69e3.png" alt></p><p><strong>auto：</strong> 其中主要有四个子目录（cc:用于编译，lib库、os库对操作系统的判断，types），其他的文件是为了辅助<strong>config</strong>脚本执行时判定 当前的Nginx支持哪些模块、当前的操作系统有哪些特性供Nginx使用。</p><p><strong>CHANGES：</strong> Nginx每一个版本提供了哪些 Features、BugFix、Changes这三类特性。</p><p><strong>CHANGES.ru：</strong> 因为作者是 俄罗斯人，所以提供了一个俄罗斯语言的变更说明书。</p><p><strong>conf：</strong> 示例文件，将Nginx安装好后，为了方便运维去配置，会将此目录中的示例文件拷贝到安装目录。</p><p><strong>configure：</strong>这个脚本是用来生成中间文件、执行编译前的一个必备动作。</p><p><strong>contrib：</strong>提供了两个pl脚本和vim的工具，在没有使用vim工具时去打开nginx配置文件，会发现色彩没有什么变化（nginx语法没有在vim），此时，需要将contrib文件夹下的所有文件拷贝到我们自己的vim目录中，即：</p><p><strong>（mac:cp -r contrib/vim/* ~/.vim/ ）</strong></p><p>（ <font color="red">centos:自定义安装vim的话，使用 whereis vim查看vim的安装路径，vimfiles就在 /usr/share/vim/下<br>所以：cp -r contrib/vim/* /usr/share/vim/vimfiles/<br>此时再次打开nginx.conf文件，发现语法高亮显示</font>）<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/a11a6806-0bf0-4908-9f46-2dcb2b590271.png" alt></p><p><strong>html：</strong> 提供了两个标准的html文件。如图：<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ae1df995-18a4-4490-97e6-93aa397516f7.png" alt><br>一个是发现500错误的时候重定向到当前指定文件。<br>一个是默认的Nginx的欢迎页面。</p><p><strong>man：</strong>Nginx的帮助文件<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f5e50c6d-0b16-4494-9580-169a0fe8e3c3.png" alt></p><p><strong>src：</strong>Nginx的源代码。<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5d35e8e4-1b4c-482c-ad22-1b7af2a3d92f.png" alt>。即Nginx的框架都在这些源代码中。</p><h2 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h2><h2 id="编译前首先观察configure都支持哪些参数？"><a href="#编译前首先观察configure都支持哪些参数？" class="headerlink" title="编译前首先观察configure都支持哪些参数？"></a>编译前首先观察configure都支持哪些参数？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/b42567c1-87be-482a-86b1-b3779ec76e2c.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/727a8526-4163-4ed7-9c65-72dcaf6cf2ce.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/bdf16353-460a-49e4-9991-85b84e615d49.png" alt><br><strong>此处主要分为3大块参数内容</strong>：</p><ul><li><p>确定Nginx执行中会去找哪些目录下的文件作为它的辅助文件；如：使用动态模块，则 –modules-path=PATH 就会起作用；确定Nginx.log文件放在那里，则 –lock-path=PATH会起作用；然而，<font color="red">如果没有任何变动的话，只需要指定 –prefix=PATH即可,所有的其他的文件会在prefix目录下建立相应的文件夹</font>。</p></li><li><p>确定使用那些模块，而不使用那些模块。如 –with 与 –without, –with ：需要显示指定的时候，意味着Nginx默认是不会加载此模块的。 –without: 意味着默认会编译到Nginx中，如果加上了，则是显示取消编译的，移出默认的Nginx模块中。</p></li><li><p>确定Nginx编译时所需要的一些特殊参数。如 –with-cc=Path –with-cpp=Path 就是使用gcc编译时需要加一些什么样的优化参数；–with-debug 打印debug级别的日志，–with-pcre –with-zlib 这是需要加一些第三方的模块等等。</p></li></ul><h2 id="编译前的依赖包的安装"><a href="#编译前的依赖包的安装" class="headerlink" title="编译前的依赖包的安装"></a>编译前的依赖包的安装</h2><p>参看 附件 + 0篇内容，此处省略。。。。</p><h2 id="生成指定目录下的-Makefile，为下一步编译做准备"><a href="#生成指定目录下的-Makefile，为下一步编译做准备" class="headerlink" title="生成指定目录下的 Makefile，为下一步编译做准备"></a>生成指定目录下的 Makefile，为下一步编译做准备</h2><p>配置 Nginx的安装目录   /home/geek/nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标目录不存在，会自动创建</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx</span><br><span class="line">如果没有任何报错，则Nginx编译成功，如下图</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/30d9368f-43a9-4413-bef9-08f8311a1657.png" alt></p><p>在 ./configure 成功后，会生成一些中间文件，存储在 /objs 文件夹下。<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/14168daf-02ec-4203-812a-efc660721862.png" alt><br><strong>最重要的是会生成<font color="red"> ngx_modules.c：它决定了我们执行编译时有哪些模块，会被编译到Nginx中</font></strong>。</p><p><strong>所有被编译的模块都会列出来，最后形成一份 ngx_modules[] 数组</strong> <img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/20212437-7463-4e77-9fc2-de2c6a5b5700.png" alt></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make</span><br><span class="line">编译完成后，如果没有错误，就可以看到生成了大量的中间文件，如下图，他们都在 objs文件夹下。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/afa43e4b-c314-4481-a329-a1515a83f24b.jpg" alt></p><h3 id="为什么要知道Nginx的目标文件是放在objs下呢？"><a href="#为什么要知道Nginx的目标文件是放在objs下呢？" class="headerlink" title="为什么要知道Nginx的目标文件是放在objs下呢？"></a>为什么要知道Nginx的目标文件是放在objs下呢？</h3><p>如果是做<font color="red">Nginx版本升级</font>，此时不能执行** make install** ，而是需要从这里将目标文件 Nginx<br>拷贝到安装目录中，</p><p>C语言编译时生成的所有重要文件，都会存放在 *<em>objs/src目录 *</em>中。</p><p>如果使用了动态模块，则动态模块编译生成的<strong>so</strong>动态文件，也会放在<strong>objs 目录</strong>中。</p><h2 id="安装（首次安装时，可以使用此命令）"><a href="#安装（首次安装时，可以使用此命令）" class="headerlink" title="安装（首次安装时，可以使用此命令）"></a>安装（首次安装时，可以使用此命令）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make install</span><br></pre></td></tr></table></figure><h1 id="安装目录下的目录解析"><a href="#安装目录下的目录解析" class="headerlink" title="安装目录下的目录解析"></a>安装目录下的目录解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# cd &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;</span><br><span class="line">ll</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 conf</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 html</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 logs</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 sbin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;Nginx的三个主要应用场景&quot;&gt;&lt;a href=&quot;#Nginx的三个主要应用场景&quot; class=&quot;headerlink&quot; title=&quot;Nginx的三个主要应用场景&quot;&gt;&lt;/a&gt;Nginx的三个主要应用场景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;流程解析：&lt;/font&gt;&lt;br&gt;一个&lt;strong&gt;Web&lt;/strong&gt;请求从红色的线走下来后，会先经过&lt;strong&gt;Nginx&lt;/strong&gt;,再到&lt;strong&gt;应用服务（Tomcat/Django）&lt;/strong&gt;，再去访问&lt;strong&gt;Redis/MySQL&lt;/strong&gt;这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有&lt;strong&gt;反向代理&lt;/strong&gt;功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，&lt;strong&gt;反向代理&lt;/strong&gt;必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于&lt;strong&gt;企业内网的边缘节点&lt;/strong&gt;，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来&lt;strong&gt;在一段时间内不变的动态内容缓存到Nginx&lt;/strong&gt;中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 &lt;strong&gt;缓存，加速我们的访问&lt;/strong&gt;。（&lt;strong&gt;反向代理&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;一些&lt;strong&gt;css/js/png&lt;/strong&gt;等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（&lt;strong&gt;静态资源&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（&lt;strong&gt;API服务&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>0-Nginx访问日志配置及信息详解</title>
    <link href="http://javassun.github.io/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-10-11T10:39:56.000Z</published>
    <updated>2020-04-14T11:05:43.839Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过访问日志，可以知晓用户的地址，网站的哪些部分最受欢迎。用户的浏览时间，对大多数用户的浏览器做出针对性优化。</p><p>Nginx会把每个用户访问的日志信息记录到指定的日志文件里，供网站管理员分析用户浏览行为等，此功能又ngx_http_log_module 模块负责。</p><a id="more"></a><h2 id="访问日志参数"><a href="#访问日志参数" class="headerlink" title="访问日志参数"></a>访问日志参数</h2><p>Nginx访问日志主要有两个参数控制</p><ul><li><strong><font color="red">log_format</font></strong>：用来定义记录日志的格式（可以定义多种日志格式，取不同名字即可）。</li><li><strong><font color="red">access_log</font></strong>：用来指定日至文件的路径及使用的何种日志格式记录日志。</li></ul><h3 id="log-format与-access-log的默认值"><a href="#log-format与-access-log的默认值" class="headerlink" title="log_format与 access_log的默认值"></a>log_format与 access_log的默认值</h3><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/10c95625-1ad9-4c6a-b66e-30822bc362a3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log logs&#x2F;access.log main;</span><br></pre></td></tr></table></figure><p><strong>logs/access.log:这个为日志文件的存放路径，从安装目录开始，意思绝对路径为：/home/geek/nginx/logs/access.log</strong></p><p><strong>main：日志格式，通常为 combined</strong><br>若不想记录Nginx的日志：access_log off;</p><h3 id="log-format语法格式及参数语法说明"><a href="#log-format语法格式及参数语法说明" class="headerlink" title="log_format语法格式及参数语法说明"></a>log_format语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    log_format    &lt;NAME&gt;    &lt;Strin­­­g&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         格式标签   日志格式</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    格式标签：格式标签是给一套日志格式设置一个独特的名字</span><br><span class="line"></span><br><span class="line">    日志格式：给日志设置格式</span><br><span class="line"></span><br><span class="line">log_format格式变量：</span><br><span class="line"></span><br><span class="line">    $remote_addr  #记录访问网站的客户端地址</span><br><span class="line"></span><br><span class="line">    $remote_user  #远程客户端用户名</span><br><span class="line"></span><br><span class="line">    $time_local  #记录访问时间与时区</span><br><span class="line"></span><br><span class="line">    $request  #用户的http请求起始行信息</span><br><span class="line"></span><br><span class="line">    $status  #http状态码，记录请求返回的状态码，例如：200、301、404等</span><br><span class="line"></span><br><span class="line">    $body_bytes_sent  #服务器发送给客户端的响应body字节数</span><br><span class="line"></span><br><span class="line">    $http_referer  #记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。</span><br><span class="line"></span><br><span class="line">    $http_user_agent  #记录客户端访问信息，例如：浏览器、手机客户端等</span><br><span class="line"></span><br><span class="line">    $http_x_forwarded_for  #当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</span><br></pre></td></tr></table></figure><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/4b4b4565ebf3424cb0c325dbd6bbcfd1.png" alt></p><h3 id="x-forwarded-for"><a href="#x-forwarded-for" class="headerlink" title="x_forwarded_for"></a>x_forwarded_for</h3><p>通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_addr拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端请求的服务器地址。</p><p>注意：<br>在定义日志目录中要注意的是，nginx进程设置的用户和组必须有对该路径创建文件的权限，<br>假设nginx的usr指令设置的用户名 和用户组都是www，而logs 目录的用户名和组是root，那么日志文件将无法被创建。</p><p>用nginx做前端代理后，我们发HTTP_X_FORWARDED_FOR 无法获取到客户端真实的IP地址了。</p><p>原因 nginx 默认并不会增加 X_FORWARDED_FOR 头信息，我们给他加上就好了。简单配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass          http:&#x2F;&#x2F;www.xxx.com;</span><br><span class="line">    proxy_set_header    Host             $host;</span><br><span class="line">    proxy_set_header    X-Real-IP        $remote_addr;</span><br><span class="line">    proxy_set_header    X-Forwarded-For  $proxy_add_x_forwarded_for;    &#x2F;&#x2F;别忘了这一句</span><br><span class="line">    proxy_set_header    HTTP_X_FORWARDED_FOR $remote_addr;              &#x2F;&#x2F;或是加上这一句</span><br><span class="line">    proxy_redirect      default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx 加载新的配置文件，就可以获取客户端真实的IP地址了。</p><p><strong>通常情况下用以上配置即可，可以将main换成combined(默认的日志格式)，其他不变即可。</strong></p><h3 id="access-log语法格式及参数语法说明"><a href="#access-log语法格式及参数语法说明" class="headerlink" title="access_log语法格式及参数语法说明"></a>access_log语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  access_log    &lt;FILE&gt;    &lt;NAME&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         日志文件   格式标签</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    日志文件：可以指定任意存放日志的目录</span><br><span class="line"></span><br><span class="line">    格式标签：给日志文件套用指定的日志格式</span><br><span class="line"></span><br><span class="line">其他语法：</span><br><span class="line"></span><br><span class="line">    access_log    off;  #关闭access_log，即不记录访问日志</span><br><span class="line"></span><br><span class="line">    access_log path [format [buffer&#x3D;size [flush&#x3D;time]] [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    access_log path format gzip[&#x3D;level] [buffer&#x3D;size] [flush&#x3D;time] [if&#x3D;condition];</span><br><span class="line"></span><br><span class="line">    access_log syslog:server&#x3D;address[,parameter&#x3D;value] [format [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    说明：</span><br><span class="line"></span><br><span class="line">    buffer&#x3D;size  #为存放访问日志的缓冲区大小</span><br><span class="line"></span><br><span class="line">    flush&#x3D;time  #为缓冲区的日志刷到磁盘的时间</span><br><span class="line"></span><br><span class="line">    gzip[&#x3D;level]  #表示压缩级别</span><br><span class="line"></span><br><span class="line">    [if &#x3D; condition]  #表示其他条件</span><br></pre></td></tr></table></figure><p><strong>一般场景这些参数都无需配置，极端优化才有可能会<br>考虑这些参数</strong>。</p><h4 id="设置刷盘策略："><a href="#设置刷盘策略：" class="headerlink" title="设置刷盘策略："></a>设置刷盘策略：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;access.log buffer&#x3D;32k flush&#x3D;5s;</span><br></pre></td></tr></table></figure><p><strong>buffer 满32k才刷盘；假如buffer不满5s强制刷盘。</strong></p><h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><p>error_log：配置错误日志，例如上例。</p><p>open_log_file_cache：<br>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。语法:</p><p>open_log_file_cache max=N [inactive= time] [min_uses=N] [valid= time];</p><p>参数注释如下：</p><ul><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</li></ul><h2 id="日志分析："><a href="#日志分析：" class="headerlink" title="日志分析："></a>日志分析：</h2><p>通过对日志格式的定义，就可以使用常见的 Linux 命令行工具进行分析了：</p><p>查找访问频率最高的 URL 和次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; print $10&#125;’ | sort | uniq -c</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | wc -l</span><br></pre></td></tr></table></figure><p>查找某一分钟内 500 错误访问的数量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | grep ’09:00’ | wc -l</span><br></pre></td></tr></table></figure><p>查找耗时超过 1s 的慢请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f access.log | awk -F ‘^A’ ‘&#123; if( $6&gt;1) print $0&#125;’</span><br></pre></td></tr></table></figure><h2 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h2><p>为了使Nginx的日志文件存储更合理、有序，我们需要将日志文件进行分开存储。</p><p>可以按时间来分开存储。今天的日志文件存储到一个文件中，明天的日志文件则存储到另一个新的文件中等等。</p><p>有两种方式：</p><ul><li><strong>1 手动切割</strong><br>（1）进入 logs目录，执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv access.log xxx(随便起个名).log</span><br></pre></td></tr></table></figure>即将以前的日志文件重命名为一个新的名字的日志文件。<br>（2）执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR1 主进程号（需要先用 ps -ef| grep nginx命令找到master的进程号）</span><br></pre></td></tr></table></figure>kill -USR1 主进程号 ：</li></ul><p>在logs目录ls一个，会发现又自动多出了一个日志文件(这个日志文件的命名来源于nginx.conf文件里的access_log的路径)，并且里面无内容。这个文件就是切割出来的新文件，再有日志会往这里面写，而不会操作老日志文件。</p><ul><li><strong>2 自动进行切割</strong><br>（1）首先创建个sh文件（称为批处理日志文件），进入nginx的logs目录运行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch cutlog.sh（文件名自定义，后缀.sh即可）</span><br></pre></td></tr></table></figure>（2）编辑cutlog.sh文件。输入如下内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim cutlog.sh</span><br><span class="line"></span><br><span class="line">D&#x3D;$(date +%Y%m%d)</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log &#x2F;$&#123;LOGS_PATH&#125;&#x2F;$&#123;D&#125;.log</span><br><span class="line">kill -USR1 $(cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid)</span><br></pre></td></tr></table></figure><p>说明：<br>D=$(date +%Y%m%d)，声明个变量，名为D（自定义）,值为date（Linux自带的，类似于函数，用于获取当前时间，并且格式为年月日）</p><p>${D}：引用上面变量名为D的变量</p><p>$(cat /usr/local/nginx/nginx.pid)：cat命令意思是查看。nginx.pid：存储的是nginx的主进程号。连起来的意思就是查看nginx主进程号，带上$(xx)就是说拿到xx</p><p>（3）定时执行某个文件，输入如下命令：(注意：运行crontab命令需要先用yum进行安装crontab，否则会出现command not found)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">crontab：定时执行某个文件</span><br><span class="line">crontab -e：编辑定时执行的内容</span><br></pre></td></tr></table></figure><p>（4）执行完（3）后会出现编辑器，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 59 *** &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;cutlog.sh</span><br></pre></td></tr></table></figure><p>即：在每天23点59分定时执行cutlog.sh文件，这样就实现了每天定时切割日志文件了。</p><p>原理：只是将手动切割写成个脚本。</p><p>如有需要每隔1个月就备份日志到其他地方并删除原位置的日志等类似需求都可以写个shell脚本，然后用linux的crontab来定时执行。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>往往需要要对access_log、error_log日志进行切割。切割日志一般利用USR1信号让nginx产生新的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bashlogdir&#x3D;&quot;&#x2F;data&#x2F;logs&#x2F;nginx&quot; pid&#x3D;&#96;cat $logdir&#x2F;nginx.pid&#96; DATE&#x3D;&#96;date -d &quot;1 hours ago&quot; +%Y%m%d%H&#96; DATE_OLD&#x3D;&#96;date -d &quot;7 days ago&quot; +%Y%m%d&#96; for i in &#96;ls $logdir&#x2F;*access.log&#96;; do mv $i $i. $DATE done for i in &#96;ls $logdir&#x2F;*error.log&#96;; do mv $i $i. $DATE done kill -s USR1 $pid rm -v $logdir &quot;&#x2F;access.log.&quot; $DATE_OLD*rm -v $logdir&quot;&#x2F;error.log.&quot; $DATE_OLD*</span><br></pre></td></tr></table></figure><p><strong>1、分析：</strong>将上面的脚本放到crontab中，每小时执行一次（0 ），这样每小时会把当前日志重命名成一个新文件；然后发送USR1这个信号让Nginx 重新生成一个新的日志。（相当于备份日志）将前7天的日志删除；</p><p><strong>2、说明：</strong>在没有执行kill -USR1 $pid之前，即便已经对文件执行了mv命令而改变了文件名称，nginx还是会向新命名的文件”*access.log.2016032623”照常写入日志数据的。原因在于：linux系统中，内核是根据文件描述符来找文件的。</p><p><strong>3、logrotates：</strong>使用系统自带的logrotates，也可以实现nginx的日志分割，查看其bash源码，发现也是发送USR1这个信号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;通过访问日志，可以知晓用户的地址，网站的哪些部分最受欢迎。用户的浏览时间，对大多数用户的浏览器做出针对性优化。&lt;/p&gt;
&lt;p&gt;Nginx会把每个用户访问的日志信息记录到指定的日志文件里，供网站管理员分析用户浏览行为等，此功能又ngx_http_log_module 模块负责。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Swagger2学习与集成</title>
    <link href="http://javassun.github.io/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/"/>
    <id>http://javassun.github.io/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/</id>
    <published>2019-10-09T11:32:34.000Z</published>
    <updated>2020-04-14T11:35:00.469Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="Swagger2介绍"><a href="#Swagger2介绍" class="headerlink" title="Swagger2介绍"></a>Swagger2介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在都奉行<strong>前后端分离</strong>和<strong>微服务</strong>大行其道，分微服务及前后端分离后，前后端开发的沟通成本就增加了。所以一款强大的<strong>RestFul API</strong> 文档则十分重要，而目前在后端领域，基本上就是<font color="red">Swagger</font>的天下了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Swagger</strong>是一款RestFul接口的文档在线自动生成、功能测试功能框架。一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的Web服务，加上Swagger-ui，可以有很好的呈现。</p><a id="more"></a><h1 id="Spring-Boot-集成"><a href="#Spring-Boot-集成" class="headerlink" title="Spring Boot 集成"></a>Spring Boot 集成</h1><p>这里选用的Swagger版本：2.8.0</p><h2 id="POM依赖"><a href="#POM依赖" class="headerlink" title="POM依赖"></a>POM依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--swagger--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="编写配置文件-Swagger2Config-java"><a href="#编写配置文件-Swagger2Config-java" class="headerlink" title="编写配置文件(Swagger2Config.java)"></a>编写配置文件(Swagger2Config.java)</h2><p>主要是添加注解 <strong>@EnableSwagger2</strong> 和定义 <strong>Docket</strong> 的 <strong>bean</strong>类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableSwagger2</span><br><span class="line">@Configuration</span><br><span class="line">public class SwaggerConfig&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否开启Swagger,正式环境一般是需要关闭的，可根据SpringBoot的多环境配置进行设置</span><br><span class="line">    @Value(value&#x3D;&quot;$&#123;swagger.enabled&#125;&quot;)</span><br><span class="line">    Boolean swaggerEnabled;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">              return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">              &#x2F;&#x2F;是否开启</span><br><span class="line">             .enable(swaggerEnabled).select()</span><br><span class="line">             &#x2F;&#x2F;扫描的路径包</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))</span><br><span class="line">            &#x2F;&#x2F;指定路径处理 PathSelectors.any()代表所有的路径</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .pathMapping(&quot;&#x2F;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private ApiInfo apiInfo()&#123;</span><br><span class="line">             return new ApiInfoBuilder()</span><br><span class="line">            .title(&quot;SpringBoot-Swagger2集成Demo &quot;)</span><br><span class="line">            .description(&quot;Allen&quot;)</span><br><span class="line">            &#x2F;&#x2F; 作者信息</span><br><span class="line">            .contact(new Contact(&quot;haoransun&quot;,&quot;demo.com&quot;,&quot;Wechat: SHR---97&quot;))</span><br><span class="line">            .version(&quot;1.0.0&quot;)</span><br><span class="line">            .build();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加文档内容-一般是在Controller，-请求参数上进行注解"><a href="#添加文档内容-一般是在Controller，-请求参数上进行注解" class="headerlink" title="添加文档内容(一般是在Controller， 请求参数上进行注解)"></a>添加文档内容(一般是在Controller， 请求参数上进行注解)</h2><p><img src="/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/ef7d3999287f12ba39cc345681993e8d.png" alt><br><strong>常用的注解<code>@Api</code>、<code>@ApiOperation</code>、<code>@ApiModel</code>、<code>@ApiModelProperty</code>示例中有进行标注，对于其他注解，大家可自动谷歌，毕竟常用的就这几个了。有了<code>swagger</code>之后，原本一些<code>post</code>请求需要<code>postman</code>这样的调试工具来进行发起，而现在直接在页面上就可以进行调试了，是不是很爽！对于服务的调用者而已，有了这份api文档也是一目了然，不需要和后端多少沟通成本，按着api说明进行前端开发即可。</strong></p><p>@ApilmplicatParams(name = “”,value=””,dataType=””,paramType=””)</p><p>paramType:<br>     query—@RequestParam<br>     header—@RequestHeader<br>     path —@PathVariable (RestFul风格)</p><p>ParameterBuilder tokenPar = new ParameterBuilder();<br>List<Parameter> pars = new ArrayList<Parameter>();<br>tokenPar.name(“Authorization”).description(“令牌”)<br>    .modelRef(new ModelRef(“string”)).parameterType(“header”)<br>    //header中的token参数非必填，传空也可以<br>    .required(false).build();<br>//根据每个方法名也知道当前方法在设置什么参数<br>pars.add(tokenPar.build());</Parameter></Parameter></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h1 id=&quot;Swagger2介绍&quot;&gt;&lt;a href=&quot;#Swagger2介绍&quot; class=&quot;headerlink&quot; title=&quot;Swagger2介绍&quot;&gt;&lt;/a&gt;Swagger2介绍&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;现在都奉行&lt;strong&gt;前后端分离&lt;/strong&gt;和&lt;strong&gt;微服务&lt;/strong&gt;大行其道，分微服务及前后端分离后，前后端开发的沟通成本就增加了。所以一款强大的&lt;strong&gt;RestFul API&lt;/strong&gt; 文档则十分重要，而目前在后端领域，基本上就是&lt;font color=&quot;red&quot;&gt;Swagger&lt;/font&gt;的天下了。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;Swagger&lt;/strong&gt;是一款RestFul接口的文档在线自动生成、功能测试功能框架。一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的Web服务，加上Swagger-ui，可以有很好的呈现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swagger" scheme="http://JavaSsun.github.io/categories/Swagger/"/>
    
    
      <category term="Swagger2" scheme="http://JavaSsun.github.io/tags/Swagger2/"/>
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>2018-2019工作总结</title>
    <link href="http://javassun.github.io/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>http://javassun.github.io/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-15T11:18:20.000Z</published>
    <updated>2020-04-14T10:38:29.876Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p>1-  判断一个点是否在不规则多边形内部<br>（用于判断企业是否落在指定区域内）<br>以一个点做射线，计算它与多边形边界的交点个数<br>       奇数个：在多边形内部<br>       偶数个：在多边形外部<br>推论：<br>如果点在多边形内部，射线第一次穿越边界一定是穿出多边形。<br>如果点在多边形外部，射线第一次穿越边界一定是进入多边形。</p><a id="more"></a><p>当射线穿越多边形边界的次数为偶数时，所有第偶数次（包括最后一次）穿越都是穿出，<br>因此所有第奇数次（包括第一次）穿越为穿入，由此可推断点在多边形外部。</p><p>当射线穿越多边形边界的次数为奇数时，所有第奇数次（包括第一次和最后一次）穿越都是穿出<br>由此可推断点在多边形内部。</p><p>判断难点：<br>点在多边形边上：                     点在线上，计算点与两个多边形顶点的连线斜率是否相等。<br>点和多边形的顶点重合：           比较坐标。<br>射线经过多边形顶点：              射线经过的点都属于射线以上的一侧<br>射线经过多边形的一条边：       射线连续经过多边形的两个相邻顶点。</p><p>需要客户提前给出待落区域的经纬度。</p><p>射线法： （java）<br>代码位置：com.aliyun.fin.rebengine.manager.job.task.AnalysisRegionOfEntDataTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 方法1   射线法：判断某一个点(经纬度)是否在一个多边形内  奇数个交点证明在多边形内部，偶数个交点在多边形外部</span><br><span class="line"> * @param longitude</span><br><span class="line"> * @param latitude</span><br><span class="line"> * @param points</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean judgeDom(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line">    int iSum, iCount, iIndex;</span><br><span class="line">    double dLon1 &#x3D; 0, dLon2 &#x3D; 0, dLat1 &#x3D; 0, dLat2 &#x3D; 0, dLon;</span><br><span class="line">    iSum&#x3D;0;</span><br><span class="line">    iCount &#x3D; points.size();</span><br><span class="line">    for(iIndex &#x3D; 0;iIndex&lt;iCount;iIndex++)&#123;</span><br><span class="line">        if(iIndex &#x3D;&#x3D; iCount-1)&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(0).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(0).getLatitude();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(iIndex+1).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(iIndex+1).getLatitude();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断给定点的纵坐标 是否在边的两端点的水平平行线之间，在则可能有交点，继续判断交点是否在左射线上</span><br><span class="line">        boolean isInArea &#x3D; ((latitude&gt;&#x3D;dLat1)&amp;&amp;(latitude&lt;dLat2))|| (latitude&gt;&#x3D;dLat2)&amp;&amp;(latitude&lt;dLat1);</span><br><span class="line">        if(isInArea)&#123;</span><br><span class="line">            &#x2F;&#x2F;因为要做分母，所以判断不能为0,</span><br><span class="line">            if(Math.abs(dLat1-dLat2)&gt;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;得到给定点向左射线与边的  交点  的  经度坐标</span><br><span class="line">                dLon &#x3D; dLon1 - ((dLon1-dLon2)*(dLat1-latitude))&#x2F;(dLat1-dLat2);</span><br><span class="line">                &#x2F;&#x2F;比较交点 经度坐标，如果交点在给定点的左侧：则当前交点是射线与边的交点</span><br><span class="line">                if(dLon&lt;longitude)&#123;</span><br><span class="line">                    iSum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if((iSum%BASE_EVEN)!&#x3D;0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li><p>方法2   判断某一个点(经纬度)是否在一个多边形内  点在线内、线外、线上、面内、面外 来进行多层判断</p></li><li><p>@param longitude</p></li><li><p>@param latitude</p></li><li><p>@param points</p></li><li><p>@return</p></li><li><p>/</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public boolean judgeDom2(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line"></span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0, l&#x3D;points.size(),j&#x3D;l-1;i&lt;l;j&#x3D;i,i++)&#123;</span><br><span class="line"></span><br><span class="line">        double sx &#x3D; points.get(i).getLongitude();</span><br><span class="line"></span><br><span class="line">        double sy &#x3D; points.get(i).getLatitude();</span><br><span class="line"></span><br><span class="line">        double tx &#x3D; points.get(j).getLongitude();</span><br><span class="line"></span><br><span class="line">        double ty &#x3D; points.get(j).getLatitude();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;点与多边形顶点重合</span><br><span class="line"></span><br><span class="line">        boolean isCoincide &#x3D; (sx&#x3D;&#x3D;longitude&amp;&amp;sy&#x3D;&#x3D;latitude)||(tx&#x3D;&#x3D;longitude&amp;&amp;ty&#x3D;&#x3D;latitude);</span><br><span class="line"></span><br><span class="line">        if(isCoincide)&#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断线段两端点是否在射线两侧</span><br><span class="line"></span><br><span class="line">        boolean isTwoSide &#x3D; (sy&lt;latitude&amp;&amp;ty&gt;&#x3D;latitude)||(sy&gt;&#x3D;latitude&amp;&amp;ty&lt;latitude);</span><br><span class="line"></span><br><span class="line">        if(isTwoSide)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 线段上与坐标 Y 相同的 点 X 的坐标</span><br><span class="line"></span><br><span class="line">            double x &#x3D; sx+(latitude-sy)*(tx-sx)&#x2F;(ty-sy);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;点在多边形边上</span><br><span class="line"></span><br><span class="line">            if(x&#x3D;&#x3D;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;射线穿过多边形边界</span><br><span class="line"></span><br><span class="line">            if(x&gt;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                flag &#x3D; !flag;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return  flag?true:false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2-  聚类经纬度数据（全景洞察-全景概览 五角星、实心圆）<br>从reb_ent_location中取出经纬度、企业信息等数据。</p><p>企业经纬度各分10等份（汇总各个区域的最大最小值）。<br>分别统计出 企业经纬度的最大最小值。</p><p>等分公式：对经纬度的 最大最小值分别计算<br>Quadrant:  (minLongitude,minLatitude)—à  (maxLongitude,maxLatitude)<br>在逻辑上勾画出一个象限经纬系。</p><p>勾画出10等份区域：[(max-min)/10]*i+min  i: 0-10</p><p>投射每一个企业对应的经纬度落在所画区域上<br>min + |(当前企业经度-min)/(max-min)/10|<em>(max-min)/10<br>min + |(当前企业维度-min)/(max-min)/10)|</em>(max-min)/10</p><p>| | ：是对其中的数据向下取整</p><p>返回100个左右的点，每一个点所对应的坐标是它周围点的坐标均值。<br>即：每一个点都可以想象成是一个 “黑洞”，吸收它附近的相近点<br>页面上：每一个点 都有它所对应的企业列表集合。</p><p>代码位置：com.aliyun.fin.rebengine.manager.job.task.ClusterEntLocationDataTask</p><p>3-  NLP分词、政策相似度判断<br>（依托于 hanlp jar包，具体用法靠参考官网 <a href="https://github.com/hankcs/HanLP）" target="_blank" rel="noopener">https://github.com/hankcs/HanLP）</a><br>A：政策关键词 + 政策重合度（onecompany提供政策数据）<br> B：热词云 + 舆情数据[公司品牌+企业高管…]（onecompany提供舆情数据）<br> C：自建停分词词典（需要积累）+ 客户自定义词词典。<br>D：舆情数据需要进行：公司品牌+企业高管+产品品质+服务质量+其他风险 的 摘选。</p><p>舆情分词分模块难点：<br>停分词词典需要积累数据，每天都会有新的舆情数据进来，会有新的热词产生，同时也需要追加新的停分词到词典中。（目前是每次对新舆情数据分词，人工过滤掉无意义词）<br>如何分辨当条舆情数据是当前所属公司的哪一类的舆情：（高管、品牌、产品、质量）（产品品质与服务质量没有明显的区分度）<br>特征词数据表：<br>reb_data_db-àpublic_custom  (舆情分类特征词样本太少，目标区分度不明显)<br>读取舆情正文+标题，只要正文中出现特征词，就将当前舆情分类。<br>政策相似度判断：（即：政策分词后的词列表A 与 词列表B 相似度分值）<br>相似度算法位置： com.aliyun.fin.rebengine.nlp.util.algorithm<br>  两两地区的政策进行相似度判断。需要自己进行阈值的调参。</p><p>4-  政策分类、扶持对象<br>   临港项目： onecompany 对政策进行分类+扶持对象的判别。</p><p>   非临港项目：可能需要自己训练一个政策分类器。此处写自己的思路：<br>利用分布式爬虫框架 从网上抓取各省市县以往的各项政策，需要抓取的内容包含：<br>政策标题+政策正文+该项政策的分类（金融、农业、工业..等）+政策扶持对象。</p><p>利用已有的这些数据 “喂养” 自己的 分类器，（我个人觉得这不是一个线性问题，不是二分逻辑[0/1的问题]，是一个多分类问题，可能需要算法同学在隐藏层的激活函数设置的极好。[说的话都会说，关键在实现] ）<br>训练好分类器之后，就可以对现有的政策进行判别。</p><p>或者像 舆情分模块一样：生硬的将政策分类的特征词、政策扶持对象的特征词提取到表中：只要待判别的政策正文中出现了这些特征词，就给当前政策打上分类标记、扶持对象标记。</p><p>5-  python脚本（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import pymysql</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as  np</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">#数据库配置</span><br><span class="line">mysql_config &#x3D; &#123;</span><br><span class="line">    # 规则中心</span><br><span class="line">    &#39;rule&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    # 数据来源</span><br><span class="line">    &#39;data&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx1&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据处理类</span><br><span class="line">class DataDict:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 最值数据的枚举KEY</span><br><span class="line">        self._max_min &#x3D; &#39;max_min&#39;</span><br><span class="line">        self._conn_rule &#x3D; pymysql.connect(**mysql_config[&#39;rule&#39;])</span><br><span class="line">        self._conn_data &#x3D; pymysql.connect(**mysql_config[&#39;data&#39;])</span><br><span class="line"></span><br><span class="line">    # DataFrame转换字典</span><br><span class="line">    def _get_data_dict(self, v):</span><br><span class="line">        if len(v) &#x3D;&#x3D; 1:</span><br><span class="line">            return &#123;col: None if v.iloc[0][col] &#x3D;&#x3D; np.nan else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        elif not v.empty and len(v) &gt; 1:</span><br><span class="line">            min_max &#x3D; &#123;&#125;</span><br><span class="line">            for row in v.iterrows():</span><br><span class="line">                temp &#x3D; &#123;col: row[1][col] for col in v.columns&#125;</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]] &#x3D; temp</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;id&#39;)</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;index_name&#39;)</span><br><span class="line">            min_max_temp &#x3D; &#123;&#125;</span><br><span class="line">            for key in min_max.keys():</span><br><span class="line">                min_max_temp.update(&#123;</span><br><span class="line">                    &#39;min_&#39; + key: min_max[key].get(&#39;min_value&#39;),</span><br><span class="line">                    &#39;max_&#39; + key: min_max[key].get(&#39;max_value&#39;),</span><br><span class="line">                &#125;)</span><br><span class="line">            return min_max_temp</span><br><span class="line">        elif v.empty and len(v) &lt;&#x3D; 0:</span><br><span class="line">            return None</span><br><span class="line">            # return &#123;col: 0.0 if v.empty else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    # 最值数据获取（用于归一化处理）</span><br><span class="line">    def _get_min_max_data(self, conn_data, sql_max_min):</span><br><span class="line">        _v &#x3D; pd.read_sql_query(sql_max_min, con&#x3D;conn_data)</span><br><span class="line">        _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">        return self._get_data_dict(_v)</span><br><span class="line"></span><br><span class="line">    # 获取评分项处理后的数据</span><br><span class="line">    def get_process_data(self, ent_name):</span><br><span class="line">        data_dict &#x3D; dict()</span><br><span class="line">        rts &#x3D; dict()</span><br><span class="line">        _s &#x3D; pd.read_sql_query(&quot;SELECT * FROM data_config &quot;, con&#x3D;self._conn_rule)</span><br><span class="line">        _s.set_index([&#39;index&#39;], inplace&#x3D;True)</span><br><span class="line">        raw_sqls &#x3D; _s.to_dict()[&#39;index_sql&#39;]</span><br><span class="line">        for k in raw_sqls:</span><br><span class="line">            if k in self._max_min:</span><br><span class="line">                data_dict[&#39;min_max&#39;] &#x3D; self._get_min_max_data(self._conn_data, raw_sqls[self._max_min])</span><br><span class="line">            else:</span><br><span class="line">                if &#39;%&#39; in raw_sqls[k]:</span><br><span class="line">                    raw_sqls[k] &#x3D; raw_sqls[k].replace(&quot;%&quot;, &quot;%%&quot;)</span><br><span class="line">                sql &#x3D; raw_sqls[k].replace(&#39;&#123;ent_name&#125;&#39;, &#39;%(ent_name)s&#39;)</span><br><span class="line">                _v &#x3D; pd.read_sql(sql, params&#x3D;&#123;&#39;ent_name&#39;: ent_name&#125;, con&#x3D;self._conn_data)</span><br><span class="line">                # _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">                rts[k] &#x3D; self._get_data_dict(_v)</span><br><span class="line">        for k in rts:</span><br><span class="line">            if rts[k] is not None:</span><br><span class="line">                data_dict.update(rts[k])</span><br><span class="line">        return data_dict</span><br><span class="line"></span><br><span class="line">    # 评分卡数据</span><br><span class="line">    def get_score_card(self):</span><br><span class="line">        sql &#x3D; &#39;&#39;&#39;</span><br><span class="line">        SELECT</span><br><span class="line">   A.score_name,</span><br><span class="line">   A.default_value,</span><br><span class="line">   B.express,</span><br><span class="line">   B.score_value,</span><br><span class="line">   B.default_score</span><br><span class="line">FROM</span><br><span class="line">   base_score_card A,</span><br><span class="line">   base_score_card_item B</span><br><span class="line">WHERE</span><br><span class="line">   A.id &#x3D; B.card_id</span><br><span class="line">ORDER BY</span><br><span class="line">   A.id, B.order_no DESC</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        score_card_df &#x3D; pd.read_sql_query(sql, self._conn_rule)</span><br><span class="line">        score_card_df_dict &#x3D; dict(list(score_card_df.groupby([&#39;score_name&#39;])))</span><br><span class="line">        score_card &#x3D; &#123;&#125;</span><br><span class="line">        for k in score_card_df_dict:</span><br><span class="line">            score_card[k] &#x3D; []</span><br><span class="line">            for index, row in score_card_df_dict[k].iterrows():</span><br><span class="line">                score_card[k].append((row[&#39;express&#39;], row[&#39;score_value&#39;], row[&#39;default_value&#39;], row[&#39;default_score&#39;]))</span><br><span class="line">        return score_card</span><br><span class="line"></span><br><span class="line">    # 获取自定义公式分数节点</span><br><span class="line">    def get_score_node(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM model_score_node&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        sn_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            sn_dict[row[&#39;score_node_id&#39;]] &#x3D; row[&#39;expression&#39;]</span><br><span class="line">        return sn_dict</span><br><span class="line"></span><br><span class="line">    # 获取分数层级数据字典</span><br><span class="line">    def get_socre_level(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM dimensional_score_define&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        level_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            level_dict[row[&#39;node_name&#39;]] &#x3D; &#123;col: row[col] for col in _dim_score_define_df.columns&#125;</span><br><span class="line">        return level_dict</span><br><span class="line"></span><br><span class="line">    def close_all_conn(self):</span><br><span class="line">        self._conn_rule.close()</span><br><span class="line">        self._conn_data.close()</span><br><span class="line"></span><br><span class="line"># 规则执行器</span><br><span class="line">class RuleExecutor:</span><br><span class="line">    def __init__(self, ent_name):</span><br><span class="line">        data_dict &#x3D; DataDict()</span><br><span class="line">        self._original_data_dict &#x3D; data_dict.get_process_data(ent_name)</span><br><span class="line">        self._score_card &#x3D; data_dict.get_score_card()</span><br><span class="line">        self._sn_dict &#x3D; data_dict.get_score_node()</span><br><span class="line">        self._level_dict &#x3D; data_dict.get_socre_level()</span><br><span class="line">        self._tree_node &#x3D; &#123;&#125;</span><br><span class="line">        self._temp &#x3D; []</span><br><span class="line">        self._re_pattern &#x3D; r&#39;(?&lt;&#x3D;\&#123;)[^&#125;]*(?&#x3D;\&#125;)&#39;</span><br><span class="line">        self._result_dict &#x3D; &#123;&#125;</span><br><span class="line">        data_dict.close_all_conn()</span><br><span class="line"></span><br><span class="line">    def _add_node(self, p, node):</span><br><span class="line">        # 节点list</span><br><span class="line">        p[&quot;children&quot;] &#x3D; []</span><br><span class="line">        for n in node:</span><br><span class="line">            if n.get(&quot;pid&quot;) &#x3D;&#x3D; p.get(&quot;id&quot;):</span><br><span class="line">                p[&quot;children&quot;].append(n)</span><br><span class="line">        # 递归子节点，查找子节点的子节点</span><br><span class="line">        for t in p[&quot;children&quot;]:</span><br><span class="line">            if not t.get(&quot;children&quot;):</span><br><span class="line">                t[&quot;children&quot;] &#x3D; []</span><br><span class="line">            t[&quot;children&quot;].append(self._add_node(t, node))</span><br><span class="line">        # 退出递归的条件</span><br><span class="line">        if len(p[&quot;children&quot;]) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def init_score_tree(self):</span><br><span class="line">        root &#x3D; []</span><br><span class="line">        node &#x3D; []</span><br><span class="line">        # 获取根节点 和 其他子节点 list</span><br><span class="line">        for k in self._level_dict:</span><br><span class="line">            if self._level_dict[k][&#39;pid&#39;] &#x3D;&#x3D; 0:</span><br><span class="line">                root.append(self._level_dict[k])</span><br><span class="line">            else:</span><br><span class="line">                node.append(self._level_dict[k])</span><br><span class="line">        # 查找子节点</span><br><span class="line">        for p in root:</span><br><span class="line">            self._add_node(p, node)</span><br><span class="line">        self._tree_node.update(root[0])</span><br><span class="line"></span><br><span class="line">    def _get_card_score(self, sn_id):</span><br><span class="line">        score_list &#x3D; self._score_card[sn_id]</span><br><span class="line"></span><br><span class="line">        for bds in score_list:</span><br><span class="line">            express &#x3D; bds[0]</span><br><span class="line">            score_value &#x3D; bds[1]</span><br><span class="line">            default_value &#x3D; None if np.isnan(bds[2]) else bds[2]</span><br><span class="line">            default_score &#x3D; None if np.isnan(bds[3]) else bds[3]</span><br><span class="line"></span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, express)</span><br><span class="line">            str_list &#x3D; list(set(str_list))</span><br><span class="line">            _data_dict &#x3D; &#123;&#125;</span><br><span class="line">            for c in str_list:</span><br><span class="line">                if c not in self._original_data_dict:</span><br><span class="line">                    return 0</span><br><span class="line">                _data_dict[c] &#x3D; default_score if self._original_data_dict[c] is None  else self._original_data_dict[c]</span><br><span class="line">            express_replaced &#x3D; express.format(**_data_dict)</span><br><span class="line"></span><br><span class="line">            try:</span><br><span class="line">                if eval(express_replaced):</span><br><span class="line">                    if &#39;&#123;&#39; in score_value:</span><br><span class="line">                        sv_express &#x3D; score_value.format(**self._original_data_dict)</span><br><span class="line">                        score_value &#x3D; float(eval(sv_express))</span><br><span class="line">                        score_value &#x3D; score_value if score_value !&#x3D; 0 else abs(score_value)</span><br><span class="line">                    break</span><br><span class="line">            except BaseException:</span><br><span class="line">                return default_value</span><br><span class="line">        return float(score_value)</span><br><span class="line"></span><br><span class="line">    # 执行sn表达式</span><br><span class="line">    def _get_sn_express_value(self, sn_id):</span><br><span class="line">        sn_node_express &#x3D; self._sn_dict[sn_id]</span><br><span class="line">        str_list &#x3D; re.findall(self._re_pattern, sn_node_express)</span><br><span class="line">        v_dict &#x3D; &#123;&#125;</span><br><span class="line">        for new_sn_id in str_list:</span><br><span class="line">            if new_sn_id in self._sn_dict.keys():</span><br><span class="line">                v_dict[new_sn_id] &#x3D; self._get_sn_express_value(new_sn_id)</span><br><span class="line">            else:</span><br><span class="line">                card_score &#x3D; self._get_card_score(new_sn_id)</span><br><span class="line">                v_dict[new_sn_id] &#x3D; card_score</span><br><span class="line">        score &#x3D; eval(sn_node_express.format(**v_dict))</span><br><span class="line">        # print(&quot;sn_id:%s,  %s    %s &#x3D; %s&quot; % (sn_id, sn_node_express, sn_node_express.format(**v_dict) ,score))</span><br><span class="line">        return score</span><br><span class="line"></span><br><span class="line">    # 执行dimensional_score_define的表达式</span><br><span class="line">    def _get_expression_value(self, node_name, level_dict):</span><br><span class="line">        self._temp.append(node_name)</span><br><span class="line"></span><br><span class="line">        item &#x3D; level_dict[node_name]</span><br><span class="line"></span><br><span class="line">        if item[&#39;expression&#39;] is None or item[&#39;expression&#39;] &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">            sn_id &#x3D; item[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line">        else:</span><br><span class="line">            expression &#x3D; item[&#39;expression&#39;]</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for var in str_list:</span><br><span class="line">                v_dict[var] &#x3D; self._get_expression_value(var, level_dict)[1]</span><br><span class="line">            score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line"></span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line"></span><br><span class="line">    def _computer_node_score(self, tree_node&#x3D;&#123;&#125;):</span><br><span class="line">        if tree_node[&#39;node_name&#39;] in self._temp:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        dis_name &#x3D; tree_node[&#39;node_display_name&#39;]</span><br><span class="line">        expression &#x3D; tree_node[&#39;expression&#39;]</span><br><span class="line">        result &#x3D; &#123;&quot;name&quot;: dis_name, &#39;score&#39;: 0&#125;</span><br><span class="line">        if expression is None:</span><br><span class="line">            sn_id &#x3D; tree_node[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            result[&#39;score&#39;] &#x3D; score</span><br><span class="line">        else:</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for score_id in str_list:</span><br><span class="line">                score_info &#x3D; self._get_expression_value(score_id, self._level_dict)</span><br><span class="line">                score &#x3D; score_info[1]</span><br><span class="line">                v_dict[score_id] &#x3D; score</span><br><span class="line">            total_score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line">            result[&#39;score&#39;] &#x3D; total_score</span><br><span class="line">        self._result_dict[tree_node[&#39;node_name&#39;]] &#x3D; &#123;&#39;formula_id&#39;: tree_node[&#39;formula_id&#39;], &#39;value&#39;: result[&#39;score&#39;],</span><br><span class="line">                                                     &#39;dis_name&#39;: tree_node[&#39;node_display_name&#39;]&#125;</span><br><span class="line"></span><br><span class="line">    def _computer_score(self, tree_node):</span><br><span class="line">        children &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        self._computer_node_score(tree_node)</span><br><span class="line">        if len(children) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line">        for child_node in children:</span><br><span class="line">            self._computer_score(child_node)</span><br><span class="line"></span><br><span class="line">    def process_score(self):</span><br><span class="line">        self._computer_score(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def _get_standard_score(self, value, fid, df_value&#x3D;0):</span><br><span class="line">        min_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;min_&#39; + fid]</span><br><span class="line">        max_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;max_&#39; + fid]</span><br><span class="line">        std_score &#x3D; df_value if max_score - min_score &#x3D;&#x3D; 0 else pow((value - min_score) &#x2F; (max_score - min_score), 2) * 100</span><br><span class="line">        # print( &#39;fid:%s \t (%s - %s) &#x2F; (%s - %s ) x2 * 100 &#x3D; %s&#39; % (fid,value,min_score,max_score,min_score,std_score))</span><br><span class="line">        return std_score</span><br><span class="line"></span><br><span class="line">    def _rebuild_node_tree(self, tree_node):</span><br><span class="line">        for v in [&#39;id&#39;, &#39;model_id&#39;, &#39;pid&#39;, &#39;default_value&#39;, &#39;expression&#39;, &#39;sn_id&#39;, &#39;formula_id&#39;]:</span><br><span class="line">            tree_node.pop(v)</span><br><span class="line">        tree_node[&#39;score&#39;] &#x3D; self._get_standard_score(self._result_dict[tree_node[&#39;node_name&#39;]][&#39;value&#39;],</span><br><span class="line">                                                      self._result_dict[tree_node[&#39;node_name&#39;]][&#39;formula_id&#39;])</span><br><span class="line">        child_node &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        if len(child_node) &gt; 0:</span><br><span class="line">            for node in child_node:</span><br><span class="line">                self._rebuild_node_tree(node)</span><br><span class="line">        else:</span><br><span class="line">            tree_node.pop(&#39;children&#39;)</span><br><span class="line">        return tree_node</span><br><span class="line"></span><br><span class="line">    def get_result(self):</span><br><span class="line">        return self._rebuild_node_tree(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def print_data(self):</span><br><span class="line">        print(self._level_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init(context):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calc_ent(ent_info, context):</span><br><span class="line"></span><br><span class="line">    rule_executor &#x3D; RuleExecutor(ent_info[&quot;ent_name&quot;])</span><br><span class="line"></span><br><span class="line">    # 初始化层级树</span><br><span class="line">    rule_executor.init_score_tree()</span><br><span class="line"></span><br><span class="line">    # 计算处理</span><br><span class="line">    rule_executor.process_score()</span><br><span class="line"></span><br><span class="line">    # 获取结果</span><br><span class="line">    result &#x3D; rule_executor.get_result()</span><br><span class="line"></span><br><span class="line">    return json.dumps(result,ensure_ascii&#x3D; False)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ent_info &#x3D; calc_ent(&#123;&quot;ent_name&quot;:&quot;东方成安资产管理有限公司&quot;&#125;,None)</span><br><span class="line">    print(ent_info)</span><br></pre></td></tr></table></figure><p>6-  SQL语句-拼接SQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select TABLE_NAME,</span><br><span class="line">concat( &#39;insert into &#39;, table_name, &#39;(&#39;, GROUP_CONCAT(COLUMN_NAME) , &#39;) select &#39;, GROUP_CONCAT(COLUMN_NAME),</span><br><span class="line">&#39;from reb_lingang_db.&#39;, TABLE_NAME,&#39;;&#39;)</span><br><span class="line">from information_schema.columns where table_schema &#x3D; &#39;reb_lingang_db&#39; and table_name regexp &#39;^dw_bc*&#39; and COLUMN_NAME not in (&#39;id&#39;)</span><br><span class="line">GROUP BY TABLE_NAME;</span><br></pre></td></tr></table></figure><p>7- MySql导出表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">COLUMN_NAME 字段,</span><br><span class="line">COLUMN_TYPE 数据类型,</span><br><span class="line">DATA_TYPE 字段类型,</span><br><span class="line">CHARACTER_MAXIMUM_LENGTH 长度,</span><br><span class="line">IS_NULLABLE 是否为空,</span><br><span class="line">COLUMN_KEY 是否为主键,</span><br><span class="line">COLUMN_DEFAULT 默认值,</span><br><span class="line">COLUMN_COMMENT 备注</span><br><span class="line">FROM</span><br><span class="line">INFORMATION_SCHEMA.COLUMNS</span><br><span class="line">where</span><br><span class="line">-- database为数据库名称，到时候只需要修改成你要导出表结构的数据库即可</span><br><span class="line">table_schema &#x3D;&#39;reb_db&#39;</span><br><span class="line">AND</span><br><span class="line">-- table_name为表名</span><br><span class="line">table_name &#x3D; &#39;reb_overview_comp_index_month&#39;;</span><br></pre></td></tr></table></figure><p>8- 多数据源（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; EngineDataSourceConfig.PACKAGE, sqlSessionFactoryRef &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">public class EngineDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.engine&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.engine&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource engineDatasource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory engineSqlSessionFactory(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(</span><br><span class="line">            new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;engine&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineTransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager engineTransactionManager(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate engineSqlSessionTemplate(</span><br><span class="line">        @Qualifier(&quot;engineSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; RebDataSourceConfig.PACKAGE,sqlSessionFactoryRef &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">public class RebDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.reb&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.reb&quot;)</span><br><span class="line">    public DataSource rebDatasource() &#123;</span><br><span class="line">        DataSource dataSource &#x3D; DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory rebSqlSessionFactory(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;reb&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebTransactionManager&quot;)</span><br><span class="line">    public DataSourceTransactionManager rebTransactionManager(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionTemplate&quot;)</span><br><span class="line">    public SqlSessionTemplate rebSqlSessionTemplate(@Qualifier(&quot;rebSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    reb:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_lingang_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    engine:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_data_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  thymeleaf:</span><br><span class="line">     cache: false</span><br><span class="line">     encoding: utf-8</span><br><span class="line">     mode: HTML5</span><br><span class="line">     servlet:</span><br><span class="line">       content-type: text&#x2F;html</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line"># 日志配置</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org:</span><br><span class="line">      springframework:</span><br><span class="line">        web: info</span><br><span class="line">        transaction: info</span><br><span class="line">    com:</span><br><span class="line">      aliyun:</span><br><span class="line">        fin:</span><br><span class="line">          rebengine:</span><br><span class="line">              manager:</span><br><span class="line">                mapper: error</span><br></pre></td></tr></table></figure><p>9- JWTUtil（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line">    &#x2F;**过期时间30分钟*&#x2F;</span><br><span class="line">    private static final long EXPIRE_TIME &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成签名(生成token字符串)</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param secret 密码</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String sign(String username, String secret)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            return JWT.create()</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得token中的信息无需secret解密也能获得</span><br><span class="line">     * @return token中包含的用户名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getUsername(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DecodedJWT jwt &#x3D; JWT.decode(token);</span><br><span class="line">            return jwt.getClaim(&quot;username&quot;).asString();</span><br><span class="line">        &#125; catch (JWTDecodeException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 校验token是否正确</span><br><span class="line">     * @param token 密钥</span><br><span class="line">     * @param secret 用户的密码</span><br><span class="line">     * @return 是否正确</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean verify(String token, String username, String secret) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            JWTVerifier verifier &#x3D; JWT.require(algorithm)</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .build();</span><br><span class="line">            DecodedJWT jwt &#x3D; verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10- JWTFilterConfig（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class JWTFilterConfig implements Filter&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest &#x3D; (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse httpResponse &#x3D; (HttpServletResponse) servletResponse;</span><br><span class="line">        String url &#x3D; httpRequest.getRequestURI().substring(httpRequest.getContextPath().length());</span><br><span class="line">        ServletContext sc &#x3D; httpRequest.getServletContext();</span><br><span class="line">        WebApplicationContext cxt &#x3D; WebApplicationContextUtils.getWebApplicationContext(sc);</span><br><span class="line">        if(cxt !&#x3D; null &amp;&amp; cxt.getBean(&quot;redisTemplate&quot;) !&#x3D; null &amp;&amp; redisTemplate &#x3D;&#x3D; null) &#123;</span><br><span class="line">            redisTemplate &#x3D; (RedisTemplate) cxt.getBean(&quot;redisTemplate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 跨域请求</span><br><span class="line">         *&#x2F;</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, httpRequest.getHeader(&quot;Origin&quot;));</span><br><span class="line">&#x2F;&#x2F;        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Content-Disposition&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin&quot;);</span><br><span class="line">        &#x2F;&#x2F;是否支持cookie跨域</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);</span><br><span class="line">        &#x2F;&#x2F;允许在请求头里存放token</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Authorization,Content-Disposition&quot;);</span><br><span class="line"></span><br><span class="line">        String method &#x3D; httpRequest.getMethod();</span><br><span class="line">&#x2F;&#x2F;        filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line"></span><br><span class="line">        if (&quot;OPTIONS&quot;.equals(method)) &#123;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String authorization &#x3D; httpRequest.getHeader(&quot;Authorization&quot;);</span><br><span class="line">            &#x2F;&#x2F;不需要拦截的路径</span><br><span class="line">            if (!url.contains(&quot;&#x2F;swagger&quot;) &amp;&amp; !url.contains(&quot;&#x2F;login&quot;) &amp;&amp; !url.contains(&quot;&#x2F;registerDepartmentSelected&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;getSecurityCode&quot;) &amp;&amp; !url.contains(&quot;&#x2F;register&quot;) &amp;&amp; !url.contains(&quot;&#x2F;downLoadExcel&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;exportEntRelation&quot;) &amp;&amp; !url.contains(&quot;&#x2F;exportCompanyList&quot;) &amp;&amp; !url.contains(&quot;&#x2F;api&#x2F;merchantsradar&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;.ico&quot;) &amp;&amp; !url.contains(&quot;.json&quot;) &amp;&amp; !url.contains(&quot;&#x2F;statics&quot;) &amp;&amp; !url.contains(&quot;.js&quot;) &amp;&amp; !url.contains(&quot;.css&quot;) &amp;&amp; !url.contains(&quot;&#x2F;static&quot;) &amp;&amp; !url.contains(&quot;&#x2F;media&quot;) &amp;&amp; !url.contains(&quot;&#x2F;synchronization&quot;)) &#123;</span><br><span class="line">                if (StringUtils.isNotBlank(authorization))&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String token &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F;避免redis为空报错，先一步校验key是否存在</span><br><span class="line">                        Boolean aBoolean &#x3D; redisTemplate.hasKey(&quot;reb_backend_&quot; + authorization);</span><br><span class="line">                        if (!aBoolean)&#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            token &#x3D; redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + authorization).toString();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">                            redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + authorization, authorization, TokenUtil.getToken(), TimeUnit.SECONDS);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                        jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                        jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                        jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                        httpResponse.setStatus(200);</span><br><span class="line">                        httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                        httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                    jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                    jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                    jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                    httpResponse.setStatus(200);</span><br><span class="line">                    httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                    httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11- Login（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags &#x3D; &#123;&quot;后台管理&quot;&#125;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(UserController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rebBackend.token.expirationDate&#125;&quot;)</span><br><span class="line">    private long tokenExpirationDate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户登录</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;10&#x2F;10 18:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户登录&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;account&quot;,value &#x3D; &quot;用户账号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public JSONObject login(String account, String password,HttpServletRequest request)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if(StringUtils.isBlank(password) )&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(account))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;account&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String userStatus &#x3D; (String) redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + account);</span><br><span class="line">            String index &#x3D; &quot;3&quot;;</span><br><span class="line">            if (StringUtils.equals(userStatus,index))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误次数过多,请5分钟之后重试&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            if (null&#x3D;&#x3D;user)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户不存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index2 &#x3D; &quot;2&quot;;</span><br><span class="line">            if (user.getStatus().equals(index2))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户已被锁定&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index3 &#x3D; &quot;3&quot;;</span><br><span class="line">            if (user.getStatus().equals(index3))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户正在审批中&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password,&quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            if (user.getPassword().equals(md5Password))&#123;</span><br><span class="line">                &#x2F;&#x2F;登录成功之后保存用户操作日志</span><br><span class="line">                UserLogger userLogger &#x3D; new UserLogger()&#123;&#123;</span><br><span class="line">                    setUserAccount(account);</span><br><span class="line">                    setUserName(user.getUsername());</span><br><span class="line">                    setLoggerType(&quot;1&quot;);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                userService.saveUserLogger(userLogger);</span><br><span class="line">                &#x2F;&#x2F;登录成功之后将token缓存到redis</span><br><span class="line">                String token &#x3D; JwtUtil.sign(account,user.getPassword());</span><br><span class="line">                RedisModel redisModel &#x3D; new RedisModel()&#123;&#123;</span><br><span class="line">                    setKey(&quot;reb_backend_&quot; + token);</span><br><span class="line">                    setValue(token);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                redisTemplate.opsForValue().set(redisModel.getKey(),redisModel.getValue(),tokenExpirationDate,TimeUnit.SECONDS);</span><br><span class="line">                jsonObject.put(&quot;token&quot;,token);</span><br><span class="line">                jsonObject.put(&quot;username&quot;,user.getUsername());</span><br><span class="line">                jsonObject.put(&quot;userId&quot;,user.getId());</span><br><span class="line">                List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">                &#x2F;&#x2F;获取用户所属部门</span><br><span class="line">                Integer departmentId &#x3D; userService.findDepartmentIdByUserId(user.getId());</span><br><span class="line">                jsonObject.put(&quot;role&quot;,roleList.get(0));</span><br><span class="line">                jsonObject.put(&quot;departmentId&quot;,departmentId);</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                userStatus &#x3D; userStatus&#x3D;&#x3D;null ? &quot;1&quot; : Integer.parseInt(userStatus)  + 1 + &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                if (userStatus.equals(index3))&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300, TimeUnit.SECONDS);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300,TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-用户登录&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-登出接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;23 11:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @GetMapping(&quot;exit&quot;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-登出接口&quot;)</span><br><span class="line">    public JSONObject exit(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            redisTemplate.delete(&quot;reb_backend_&quot; + token);</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            userService.exit(user);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-登出接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户注册</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;11&#x2F;20 10:05</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册&quot;)</span><br><span class="line">    @GetMapping(&quot;register&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;code&quot;,value &#x3D; &quot;验证码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject register(String username,String phone,Integer departmentId,String password,String code,HttpServletRequest request) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        String checkCode &#x3D; (String) request.getSession().getAttribute(&quot;code&quot;);</span><br><span class="line">        String newCheckCode &#x3D; checkCode.toLowerCase();</span><br><span class="line">        String newCode &#x3D; code.toLowerCase();</span><br><span class="line">        if (!newCode.equals(newCheckCode)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;验证码错误&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(username)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(phone)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(password)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">        User user &#x3D; userService.findUserByAccount(phone);</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;该手机号已被注册&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password, &quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            userService.register(username, phone, departmentId, md5Password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 后台管理-用户登录首次加载列表</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;10 13:53</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;后台管理-用户登录首次加载列表&quot;)</span><br><span class="line">    @GetMapping(&quot;userLoginFirstLoadList&quot;)</span><br><span class="line">    public JSONObject userLoginFirstLoadList(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            jsonObject &#x3D; userService.userLoginFirstLoadList(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;后台管理-用户登录首次加载列表&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-模块授权下拉</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;11 16:10</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-模块授权下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;authorizationModuleSelected&quot;)</span><br><span class="line">    public JSONObject authorizationModuleSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject &#x3D; userService.authorizationModuleSelected();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-模块授权下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;12 10:55</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readUserListShow&quot;)</span><br><span class="line">    public JSONObject readUserListShow(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;UserVO&gt; list &#x3D; userService.readUserListShow(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户列表展示&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-角色下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 10:06</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-角色下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readRoleSelected&quot;)</span><br><span class="line">    public JSONObject readRoleSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            JSONArray jsonArray &#x3D; userService.readRoleSelected(roleList.get(0));</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,jsonArray);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-角色下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号删除&#x2F;拒绝通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:26</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号删除&#x2F;拒绝通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;delAndRefuseUser&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    public JSONObject delAndRefuseUser(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delAndRefuseUser(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号删除&#x2F;拒绝通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号启用&#x2F;禁用通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:43</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号启用&#x2F;禁用通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;enableAndDisabledUser&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userStatus&quot;,value &#x3D; &quot;用户状态 1：启用 2：禁用 3：申请中&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject enableAndDisabledUser(Integer userId,Integer userStatus)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.enableAndDisabledUser(userId,userStatus);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号启用&#x2F;禁用通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户通过申请</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 14:41</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户通过申请&quot;)</span><br><span class="line">    @GetMapping(&quot;adoptUser&quot;)</span><br><span class="line">    public JSONObject adoptUser(Integer userId,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.adoptUser(userId,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户通过申请&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-管理员添加用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;14 17:08</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-管理员添加用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;adminAddUser&quot;)</span><br><span class="line">    public JSONObject adminAddUser(String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,0);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.adminAddUser(username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-管理员添加用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;17 14:45</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updateUser&quot;)</span><br><span class="line">    public JSONObject updateUser(Integer id,String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验手机号是否已存在</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,id);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updateUser(id,username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-添加部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 10:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-添加部门&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentName&quot;, value &#x3D; &quot;部门名称&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;addDepartment&quot;)</span><br><span class="line">    public JSONObject addDepartment(String departmentName,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (StringUtils.isBlank(departmentName))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;departmentName&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(model))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;model&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验部门名称是否已存在</span><br><span class="line">            Integer id &#x3D; userService.findDepartmentByDepartmentName(departmentName);</span><br><span class="line">            if (id !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;部门名称已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.addDepartment(departmentName,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;部门管理-添加部门&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-部门列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 11:00</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-部门列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentShow&quot;)</span><br><span class="line">    public JSONObject readDepartmentShow(@RequestHeader(&quot;Authorization&quot;) String token) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentShow(roleList.get(0), user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;, list);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;部门管理-部门列表展示&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-删除部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;29 9:52</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-删除部门&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;delDepartment&quot;)</span><br><span class="line">    public JSONObject delDepartment(Integer departmentId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delDepartment(departmentId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-删除部门&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-授权模块</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 16:31</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-授权模块&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;authorizationModule&quot;)</span><br><span class="line">    public JSONObject authorizationModule(Integer departmentId,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.authorizationModule(departmentId,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-授权模块&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-部门下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject readDepartmentSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentSelected(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @Description: 用户管理-用户注册部门下拉框</span><br><span class="line">     * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">     * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">     **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;registerDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject registerDepartmentSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.registerDepartmentSelected();</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-获取验证码</span><br><span class="line">      * @return void</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;26 14:58</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-获取验证码&quot;)</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;getSecurityCode&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public void getSecurityCode(HttpServletResponse response, HttpServletRequest request,Integer random)&#123;</span><br><span class="line">        &#x2F;&#x2F; 设置响应的类型格式为图片格式</span><br><span class="line">        response.setContentType(&quot;image&#x2F;jpeg&quot;);</span><br><span class="line">        &#x2F;&#x2F; 通知浏览器不要缓存</span><br><span class="line">        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;, &quot;-1&quot;);</span><br><span class="line">        SecurityUtil util &#x3D; SecurityUtil.instance();</span><br><span class="line">        &#x2F;&#x2F; 将验证码输入到session中，用来验证</span><br><span class="line">        String code &#x3D; util.getString();</span><br><span class="line">        request.getSession().setAttribute(&quot;code&quot;, code);</span><br><span class="line">        &#x2F;&#x2F; 输出打web页面</span><br><span class="line">        try &#123;</span><br><span class="line">            ImageIO.write(util.getImage(), &quot;jpg&quot;, response.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:21</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改密码&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updatePassword&quot;)</span><br><span class="line">    public JSONObject updatePassword(Integer userId,String password)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updatePassword(userId,password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-校验原密码是否正确</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:36</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-校验原密码是否正确&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;checkPassword&quot;)</span><br><span class="line">    public JSONObject checkPassword(String password,Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean check &#x3D; userService.checkPassword(userId,password);</span><br><span class="line">            if (!check)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-校验原密码是否正确&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-重置密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:57</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-重置密码&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;resetPassword&quot;)</span><br><span class="line">    public JSONObject resetPassword(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.resetPassword(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-重置密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12 Pom配置（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;reb_backend&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;reb_service&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;reb_service&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&#39;s website --&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;www.example.com&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;shiro.version&gt;1.4.0&lt;&#x2F;shiro.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Spring Boot中使用Swagger2构建强大的RESTful API文档--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 连接池  --&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;version&gt;1.1.5&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- esay poi --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- guava --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;18.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- shiro 配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- json --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 缓存 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.sf.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reb_common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--easypoi--&gt;</span><br><span class="line">        &lt;!--easypoi导出excel --&gt;</span><br><span class="line">        &lt;!--easypoi-base 导入导出的工具包,可以完成Excel导出,导入,Word的导出,Excel的导出功能 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- springboot整合redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;!-- 指定该Main Class为全局的唯一入口 --&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.aliyun.finintell.rebbackend.RebBackendApplication&lt;&#x2F;mainClass&gt;</span><br><span class="line">                    &lt;layout&gt;ZIP&lt;&#x2F;layout&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-clean-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;!-- see http:&#x2F;&#x2F;maven.apache.org&#x2F;ref&#x2F;current&#x2F;maven-core&#x2F;default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.7.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.20.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-install-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.5.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-deploy-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.8.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;&#x2F;pluginManagement&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;1-  判断一个点是否在不规则多边形内部&lt;br&gt;（用于判断企业是否落在指定区域内）&lt;br&gt;以一个点做射线，计算它与多边形边界的交点个数&lt;br&gt;       奇数个：在多边形内部&lt;br&gt;       偶数个：在多边形外部&lt;br&gt;推论：&lt;br&gt;如果点在多边形内部，射线第一次穿越边界一定是穿出多边形。&lt;br&gt;如果点在多边形外部，射线第一次穿越边界一定是进入多边形。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="搬砖结晶" scheme="http://JavaSsun.github.io/tags/%E6%90%AC%E7%A0%96%E7%BB%93%E6%99%B6/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析-下部</title>
    <link href="http://javassun.github.io/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/"/>
    <id>http://javassun.github.io/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/</id>
    <published>2019-08-12T14:00:30.000Z</published>
    <updated>2020-04-14T10:16:51.277Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="浅析最好、最坏、平均、均摊时间复杂度"><a href="#浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="浅析最好、最坏、平均、均摊时间复杂度"></a>浅析最好、最坏、平均、均摊时间复杂度</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最好情况时间法则度</font>(best case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最坏情况时间复杂度</font>(worst case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">平均情况时间复杂度</font>(average case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">均摊时间复杂度</font>(amortized time complexity)</p><a id="more"></a><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码的功能：在一个无序的数组(array)中，查找变量x出现的位置。如果没有找到，就返回 -1。这段代码的时间复杂度就是 O(n)，其中，n代表数组的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，我们在数组中查找一个数据时，并不需要每次都把整个数据都遍历一遍，因为有可能中途找到提前结束循环了。因此，改写后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这段优化后的代码，时间复杂度还是O(n)吗？很显然，暂时还解决不了这个问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)，但如果数组中不存在变量 x , 那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)，所以，不同情况下，这段代码的时间复杂度是不一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了表示代码在不同情况下的不同时间复杂度，需要3种概念：最好情况时间复杂度、最坏情况时间复杂度、平局情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>最好情况时间复杂度：最理想的情况下，执行这段代码的时间复杂度。</strong>如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这种情况下的时间复杂度即是最好情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，<strong>最坏情况时间复杂度，在最糟糕的情况下，执行这段代码的时间复杂度。</strong>如：在数组中没有要查找的变量 x , 需要把整个数组都遍历一遍才行，这种情况下的时间复杂度即是最坏情况时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最好情况时间复杂度和最坏请款时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大为了更好地表示平均情况下的复杂度，需要引入一个新的概念：<strong>平均情况时间复杂度</strong>，即平均时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然是上述代码，要查找变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong> 和 <strong>不在数组中</strong>。把每种情况下，查找需要遍历的元素个数累加起来，再除以 n+1，就可以得到需要遍历的元素个数的平均值，即（等数列求和公式）：<br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 大O 标记法中，可以省略掉系数、低阶、常量，所以，简化后的平均时间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结论是正确的，但是计算过程稍稍有点问题，因为有 n+1 种情况，出现的概率并不是一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要查找的变量 x, 要么在数组里，要不不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0<del>n-1 这 n 个位置的概率是一样的，为 1/n，所以，根据概率乘法法则，要查找的数组出现在 0</del> n-1 中任意位置的概率就是 1/(2n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<font color="red">前面推导的存在的最大问题就是，没有讲各种情况发生的概率考虑进去。如果我们把每种情况发生的概率考虑进去，那么平均时间复杂度的计算过程就变成饿了这样：</font><br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/36c0aabdac69032f8a43368f5e90c67f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值就是概率论中的<strong>加权平均值</strong>，即<strong>期望值</strong>，所以平均时间复杂度的全称就是<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入概率之后，上述代码的加权平均值为(3n+1)/4。用 大O 表示法表示，去掉系数和常量，这段代码的加权平均时间复杂仍然是 O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，并不需要区分最好、最坏、平均时间复杂度三种情况。很多时候，只用一种复杂度就可以满足需求。<strong>只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。</strong></p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>均摊时间复杂度</strong>，一种更加高级的概念，它对应的分析方法，<strong>摊还分析(平摊分析)</strong> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度，听起来与平均时间复杂度有点像。长容易混淆，大部分情况下，并不需要区分最好、最坏、平均时间复杂度。平均复杂度只有在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，用for循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再讲新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最理想的情况下，数组中有空闲空间，只需要将数据插入到数组下表为 count 的为位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况，数组中没有空闲空间了，需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平均时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定数组的长度是 n,根据数据插入的位置的不同，就可以分为 n 种情况，每种情况的时间复杂度都是 O(1),除此之外，还有一种“额外“的情况，就是数组在没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率是一样的，即 1/(n+1)。所以，根据加权平均计算方法，求得的平均情况时间复杂度：<br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/6df62366a60336d9de3bc34f488d8bed.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子的平均时间复杂度其实并不需要这么复杂，并不需要引入概率论的知识。由对比得知，insert() 的例子和 上面的那个 find() 的列子，会发现二者有很大的差别。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，find() 函数在极端情况下，时间复杂度采薇 O(1)。但是 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert() <strong>第一个</strong>区别于find() 的地方。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第二个</strong>，对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，后面紧跟着 n-1 个 O(1) 的插入操作，循环往复。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种特殊场景的复杂度分析，并不需要像之前将平均时间复杂度分析方法那样，找出所有的输入情况以及相应的发生概率，然后在计算加权平均值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度：<strong>均摊时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何用摊还分析发来分析算法的均摊时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续啊观看数组插入数的这个例子，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的<strong>那次操作</strong>均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到，为了方便理解，简单总结他们的应用场景。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">对一个数据结构进行一组连续操作中，大部分情况下的时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好时间复杂度</strong>。</font></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一、复杂度分析的4个概念<br>1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。<br>2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。<br>3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p><p>二、为什么要引入这4个概念？<br>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><p>三、如何分析平均、均摊时间复杂度？<br>1.平均时间复杂度<br>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>2.均摊时间复杂度<br>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p><hr><h2 id="试试分析下面-add-函数"><a href="#试试分析下面-add-函数" class="headerlink" title="试试分析下面 add()函数"></a>试试分析下面 add()函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1. 最好情况时间复杂度为 O(1)<br>2.最坏情况分析：<br>最坏情况代码执行的次数跟每次数组的长度有关<br>第1次调用insert的执行的次数为 n ,<br>第2次调用insert的执行的次数为 2n ,<br>第3次调用insert的执行的次数为 2^2 * n<br>第k次调用insert的执行的次数为 2^(k-1) * n<br>最坏时间复杂度为 O(n)。<br>3. 平均情况分析<br>当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0<del>len-1, len</del>(2len-1),….；<br>插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1，<br>最后求出加权平均时间复杂度为 1<em>p + 2</em>p+ ▪▪▪ + len*p + len * p = O(1) ;<br>4. 均摊时间复杂度 O(1)<br>而均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;a href=&quot;#浅析最好、最坏、平均、均摊时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;浅析最好、最坏、平均、均摊时间复杂度&quot;&gt;&lt;/a&gt;浅析最好、最坏、平均、均摊时间复杂度&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&quot;red&quot;&gt;最好情况时间法则度&lt;/font&gt;(best case time complexity)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&quot;red&quot;&gt;最坏情况时间复杂度&lt;/font&gt;(worst case time complexity)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&quot;red&quot;&gt;平均情况时间复杂度&lt;/font&gt;(average case time complexity)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=&quot;red&quot;&gt;均摊时间复杂度&lt;/font&gt;(amortized time complexity)&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析-上部</title>
    <link href="http://javassun.github.io/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/"/>
    <id>http://javassun.github.io/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/</id>
    <published>2019-08-10T13:00:30.000Z</published>
    <updated>2020-04-14T10:16:05.130Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，数据结构与算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，<font color="red">执行效率</font>是算法一个非常重要的考量指标。</p><h2 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将代码跑一遍，通过统计、监控，就能得到算法执行时间个占用的内存大小。为什么要使用空间、时间复杂度分析呢？难道比我实实在在跑一遍得到的数据还要准确吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述评估算法执行效率的方法是正确的。大部分人称它为<strong>事后统计法</strong>，但它有非常大的局限性。</p><a id="more"></a><h3 id="1-测试结果非常依赖测试环境"><a href="#1-测试结果非常依赖测试环境" class="headerlink" title="1 测试结果非常依赖测试环境"></a>1 测试结果非常依赖测试环境</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试环境中硬件的不同会对测试结果有很大的影响。比如，用同样一段代码，用I9处理器与I3处理器，效率自然不同。</p><h3 id="2-测试结果受数据规模的影响很大"><a href="#2-测试结果受数据规模的影响很大" class="headerlink" title="2 测试结果受数据规模的影响很大"></a>2 测试结果受数据规模的影响很大</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对同一个排序算法，待排序数据的有序度不一样，排序的执行时间会有很大的差别。极端情况下，如果数据已经有序，排序算法不需要做任何操作，执行时间非常短。除此之外，如果测试数据规模小，测试结果可能无法真实的反应算法的性能。如：对于小规模的数据排序，插入排序可能反倒会比快速排序要快！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>–<font color="red">时间、空间复杂度分析方法</font>。</p><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法的执行效率，粗略的说，就是算法代码的执行时间。但是，如何在不运行代码的情况下，用 “肉眼” 得到一段代码的执行时间呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从CPU的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行对应的CPU执行的个数、执行的时间都不一样，但是，只是粗略的估计，所以可以假设每行代码的执行时间都一样，为<font color="red"> unit_time</font>。在这个假设的基础上，这段代码的总执行时间是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3行代码分别需要1个unit_time的执行时间，第4、5行代码都运行了n遍，所以需要2n &#42; unit_time的执行时间，所以这段代码总的执行时间就是 (2n+2) &#42;   unit_time</font>。因此， <strong>所有代码的执行时间T(n)与每行代码的执行次数成正比</strong>。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这个思路，再次分析如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依旧假设每个语句的执行时间是 unit_time ，那么这段代码的总执行时间T(n)是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3、4行代码，每行代码都需要1个 unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n &#42; unit_time的执行时间，第7、8行代码循环执行了n<sup>2</sup>遍，所以需要2n<sup>2</sup> &#42; unit_time的执行时间。</font><font color="red">所以，整段代码的执行时间T(n)与每行代码的执行次数n成正比</font>。</p><h2 id="大-O-登场"><a href="#大-O-登场" class="headerlink" title="大 O 登场"></a>大 O 登场</h2><p><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/22900968aa2b190072c985a08b0e92ef.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T(n)已经解释过，表示代码的执行时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为它是一个公式。所以用f(n)来表示。公式中的 O ，表示代码的执行时间T(n) 与 f(n) 表达式成正比。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，第一个例子中的T(n)=O(2n+2)，第二个例子中的T(n)=O(2n<sup>2</sup>+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，因此，也称之为<strong>渐进时间复杂度</strong>(asymptotic time complexity),即<strong>时间复杂度</strong>。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 n 很大时，可以把它想象成10000,10000000。而公式中的<font color="red">低阶、常量、系数</font>三部分并不左右增长趋势，所以可以忽略。因此，只需要记录一个最大量级就可以了，如果用大 O 表示法表示上述两段代码的时间复杂度，既可以记为：T(n)=O(n); T(n)=O(n<sup>2</sup>)</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了大 O 时间复杂度的由来和表示方法。现在看看如何分析一段代码的时间复杂度？</p><h3 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1 只关注循环执行次数最多的一段代码"></a>1 只关注循环执行次数最多的一段代码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大 O 这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉工事中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以，<strong>在分析一个算法，一段代码的时间复杂度的时候，只关注循环执行次数最多的那一段代码就可以了。</strong>这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p><h3 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个代码分为3个部分分别是求sum_1、sum_2、sum_3。分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一段代码的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">这里强调一下，即便这段代码循环了10000次，1亿次，只要是一个已知的数，跟n无关。照样是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉，因为它本身对增长趋势并没有影响。</font><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n) 和 O(n<sup>2</sup>)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合这三段代码的时间复杂度，取其中最大的量级，所以，整段代码的时间复杂度就为O(n<sup>2</sup>)。也就是说：<strong>总的时间复杂度就是等于量级最大的那段代码的时间复杂度</strong>。那可以讲规律抽象为公式：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))。</p><h3 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类比加法法则，乘法法则公式：T1(n)=O(f(n))，T2(n)=O(g(n));那么 T(n)=T1(n) &#42; T2(n)=O(f(n)) &#42; O(g(n))=O(f(n) &#42; g(n))。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设T1(n)=O(n)，T2(n)=O(n<sup>2</sup>)，则T1(n) &#42; T2(n) = O(n<sup>3</sup>)。落实到具体的代码中：可以把乘法法则看成是<strong>嵌套循环</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单独看cal()函数，假设f()只是一个普通的操作，那第4~6行的时间复杂度就是，T1(n) = O(n),但是f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以整个cal()函数的时间复杂度就是：T(n) = T1(n) &#42; T2(n) = O(n &#42; n) = O(n<sup>2</sup>)</p><h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然代码千差万别，但是常见的复杂度量级并不多，以下几乎涵盖了所有一般代码的复杂度量级。<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述可粗略的分为两类：<strong>多项式量级</strong> 和 <strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度需要再次学习。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1 O(1)"></a>1 O(1)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先必须知道，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，比如下面这段代码的时间复杂度就是 O(1)，而不是O(3)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度都记作 O(1)，或者：<strong>一般情况下，只要算法中不存在循环、递归，即使有成千上万行的代码，其时间复杂度也是 O(1)</strong></p><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2 O(logn)、O(nlogn)"></a>2 O(logn)、O(nlogn)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第3行代码是循环执行次数最多的。所以，只要能计算出这行代码执行了多少次，就知道整段代码的时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2.当大于n时，循环结束。这就是一个等比数列。如下所示：<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/9b1c88264e7a1a20b5954be9bc4bec9a_20_281_29.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<sup>x</sup>=n 求解这个x这个问题。x=log<sub>2</sub>n。所以这段代码的时间复杂度是O(log<sub>2</sub>n)。<br>下面呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度：O(log<sub>3</sub>n)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，不管是以2位底、还是以3为底，还是以10位底，可以把所有对数阶的时间复杂度都记为O(logn)。为什么呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为对数可以互相转换的。<br>log<sub>3</sub>n = log<sub>3</sub>2 &#42; log<sub>2</sub>n，所以O(log<sub>3</sub>n) = O(C &#42; log<sub>2</sub>n)，其中 C = log<sub>3</sub>2 是一个常量。基于前面的一个理论：采用** 大O标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))** 。 因此，O(log<sub>2</sub>n) 等于 log<sub>3</sub>n，所以在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一标示为O（logn）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此说来，O(nlogn)不难理解，就乘法法则而言，如果一段代码的时间复杂度是O(logn)，循环执行了n遍，其时间复杂度就是O(nlogn)。而且，O(nlogn)是一种非常常见的算法时间复杂度。如：归并排序、快速排序的时间复杂度都是O(nlogn)。</p><h3 id="3-O-m-n-、O-m-42-n"><a href="#3-O-m-n-、O-m-42-n" class="headerlink" title="3 O(m+n)、O(m &#42; n)"></a>3 O(m+n)、O(m &#42; n)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果代码的复杂度由<strong>两个数据的规模</strong>来决定的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由代码看出，m和n表示两个数据规模。无法事先评估m和n谁的量极大，所以在表示复杂度的时候，就不能简单的利用加法法则，省略掉一种一个。因此上面代码的时间复杂度就是O(m+n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种情况，原来的加法法则就不在正确，需要将加法法则改写：T1(m)+T2(n) = O(f(m) + g(n))。但是乘法法则依然有效：T1(m)&#42;T2(n) = O(f(m) &#42; f(n))。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面得知，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</strong>类比可知，空间复杂度全称就是<strong>渐进空间复杂度</strong>(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仿照时间复杂度，可以得知，第2行代码中，申请了一个空间存储变量 i , 但是它是常量阶，跟数据规模 n 没有关系，所以可以忽略。第 3 行申请了一个大小为n的int类型数组，除此之外剩下的代码都没有占用更多的空间，所以，整段代码的空间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常见的空间复杂度是：O(1)，O(n),O(n<sup>2</sup>)，如O(logn)、O(nlogn)这样的对数阶复杂度平时很难用到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂度也称为渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，由低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)。<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/497a3f120b7debee07dc0d03984faf04.jpg" alt></p><hr><h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>一、什么是复杂度分析？<br>1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。<br>二、为什么要进行复杂度分析？<br>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<br>三、如何进行复杂度分析？<br>1.大O表示法<br>1）来源<br>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>2）特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br>2.复杂度分析法则<br>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<br>四、常用的复杂度级别？<br>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）<br>五、如何掌握好复杂度分析方法？<br>复杂度分析关键在于多练，所谓孰能生巧</p><hr><h3 id="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"><a href="#项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？" class="headerlink" title="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"></a>项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？</h3><p>我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。</p><p>当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。</p><p>综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;众所周知，数据结构与算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，&lt;font color=&quot;red&quot;&gt;执行效率&lt;/font&gt;是算法一个非常重要的考量指标。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要复杂度分析？&quot;&gt;&lt;a href=&quot;#为什么需要复杂度分析？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要复杂度分析？&quot;&gt;&lt;/a&gt;为什么需要复杂度分析？&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我将代码跑一遍，通过统计、监控，就能得到算法执行时间个占用的内存大小。为什么要使用空间、时间复杂度分析呢？难道比我实实在在跑一遍得到的数据还要准确吗？&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上述评估算法执行效率的方法是正确的。大部分人称它为&lt;strong&gt;事后统计法&lt;/strong&gt;，但它有非常大的局限性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法概览</title>
    <link href="http://javassun.github.io/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>http://javassun.github.io/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</id>
    <published>2019-08-08T12:00:30.000Z</published>
    <updated>2020-04-14T10:12:50.519Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>&nbsp;&nbsp;&nbsp;广义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据结构</strong>：<font color="red">一组数据的存储结构</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法</strong>：<font color="red">操作数据的一组方法</font>。<br>&nbsp;&nbsp;&nbsp;狭义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些<font color="red">著名</font>的数据结构与算法,如队列、栈、堆、二分查找、动态规划等等。</p><h1 id="二者关系"><a href="#二者关系" class="headerlink" title="二者关系"></a>二者关系</h1><p>&nbsp;&nbsp;&nbsp;数据结构与算法相辅相成。<font color="red">数据结构是为算法服务的，算法要作用在特定的数据结构之上</font>。因此，孤立而单独的讲解两者毫无意义。<br>&nbsp;&nbsp;&nbsp;比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但是我们选择链表这种数据结构，二分查找就无法工作了，因为链表不支持随机访问。<br>&nbsp;&nbsp;&nbsp;数据结构是<font color="red">静态</font>的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构是没有用的。</p><a id="more"></a><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><p>&nbsp;&nbsp;&nbsp;<font color="red">复杂度分析</font>占据了数据结构与算法的半壁江山，是数据结构与算法的精髓。<br>&nbsp;&nbsp;&nbsp;数据结构与算法解决的是如何更省、更快的存储和处理数据的问题，因此，需要考量效率和资源消耗的方法，这就是复杂度分析方法。所以，只掌握了数据结构与算法的特点、用法，没有学会复杂度分析，相当于只知口诀，而无心法，只有把心法了然于胸，才能做到无招胜有招！</p><h1 id="学习图"><a href="#学习图" class="headerlink" title="学习图"></a>学习图</h1><p><img src="/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/913e0ababe43a2d57267df5c5f0832a7.jpg" alt></p><h1 id="20个基础"><a href="#20个基础" class="headerlink" title="20个基础"></a>20个基础</h1><p>&nbsp;&nbsp;&nbsp;<font color="blue">10个数据结构</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</font><br>&nbsp;&nbsp;&nbsp;<font color="blue">10个算法</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</font></p><h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>&nbsp;&nbsp;&nbsp;学习 <strong>‘它’</strong> 的<font color="red">来历、自身特点、适合解决的问题、实际应用场景</font>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;广义上：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;数据结构&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;一组数据的存储结构&lt;/font&gt;。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;算法&lt;/strong&gt;：&lt;font color=&quot;red&quot;&gt;操作数据的一组方法&lt;/font&gt;。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;狭义上：&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;某些&lt;font color=&quot;red&quot;&gt;著名&lt;/font&gt;的数据结构与算法,如队列、栈、堆、二分查找、动态规划等等。&lt;/p&gt;
&lt;h1 id=&quot;二者关系&quot;&gt;&lt;a href=&quot;#二者关系&quot; class=&quot;headerlink&quot; title=&quot;二者关系&quot;&gt;&lt;/a&gt;二者关系&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据结构与算法相辅相成。&lt;font color=&quot;red&quot;&gt;数据结构是为算法服务的，算法要作用在特定的数据结构之上&lt;/font&gt;。因此，孤立而单独的讲解两者毫无意义。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但是我们选择链表这种数据结构，二分查找就无法工作了，因为链表不支持随机访问。&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据结构是&lt;font color=&quot;red&quot;&gt;静态&lt;/font&gt;的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构是没有用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>3-3-Docker容器用法</title>
    <link href="http://javassun.github.io/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</id>
    <published>2019-06-10T12:15:20.000Z</published>
    <updated>2020-04-14T06:42:43.555Z</updated>
    
    <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><a id="more"></a><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;</span><br><span class="line">Unable to find image &#39;ubuntu:14.04&#39; locally 14.04: Pulling from  library&#x2F;ubuntu cb56c90f0b30: Pull complete 0acc551e5716: Pull complete 8956dcd35143: Pull complete 908242721214: Pull complete b44ff14dd3bb: Pull complete Digest: sha256:5faf6cb681da2be979a177b60d8c18497f962e3d82268c49db6c74008d0c294d Status: Downloaded newer image for ubuntu:14.04 Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 &#x2F;bin&#x2F;bash root@af8bae53bdd3:&#x2F;#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@af8bae53bdd3:&#x2F;# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:&#x2F;# ps</span><br><span class="line">PID  TTY  TIME  CMD  </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="查看正在运行中的容器"><a href="#查看正在运行中的容器" class="headerlink" title="查看正在运行中的容器"></a>查看正在运行中的容器</h3><p>利用 <code>docker ps</code> 命令可以查看正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  25 minutes ago Exited (0) 25 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><p>可以利用 <code>docker start</code> 命令和上面使用 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，直接将一个已经终止的容器启动运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker start relaxed_kilby</span><br><span class="line"></span><br><span class="line">relaxed_kilby</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  45 minutes ago Exited (0) 3 seconds ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><p>这里把 <strong>新建并启动</strong> 章节中的容器又启动了一次,这次这个容器和之前不一样,他启动之后就会被终止,不会输出一个 “Hello World”，之后才终止容器。可以看 <code>STATUS</code> 输出,这个容器的确被启动过.</p><h3 id="容器后台运行"><a href="#容器后台运行" class="headerlink" title="容器后台运行"></a>容器后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; </span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果(STDOUT)打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和docker run指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 命令来查看容器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">77b2dc01fe0f ubuntu:14.04 &#x2F;bin&#x2F;sh -c &#39;while tr 2 minutes ago Up 1 minute agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs [container ID  or  NAMES] hello world </span><br><span class="line">hello world </span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop web2 </span><br><span class="line"></span><br><span class="line">web2</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot; About an hour ago Exited (0) 15 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Exited (0) 3  seconds ago web2 71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world &quot;&#x2F;hello&quot;  2 days ago Exited (0) 2 days ago peaceful_brown</span><br></pre></td></tr></table></figure><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p><code>docker restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，有很多种方法，包括使用 <code>docker attach</code> 命令或 <code>nsenter</code> 工具等。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><p><code>docker attach</code> 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550  </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><p>是使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h3 id="nsenter-命令"><a href="#nsenter-命令" class="headerlink" title="nsenter 命令"></a>nsenter 命令</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>nsenter</code> 工具在 util-linux 包2.23版本后包含。<br>可以使用 <code>nsenter -V</code> 查看系统是否安装了 <code>nsenter</code> 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter -V</span><br><span class="line"></span><br><span class="line">nsenter from util-linux  2.23.2</span><br></pre></td></tr></table></figure><p>如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; curl https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;utils&#x2F;util-linux&#x2F;v2.24&#x2F;util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24; </span><br><span class="line">$ .&#x2F;configure --without-ncurses </span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>senter</code> 启动一个新的shell进程(默认是/bin/bash), 同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限。</p><p>为了连接到容器，你还需要找到容器的第一个进程的 PID，可以通过下面的命令获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID&#x3D;$(docker inspect --format  &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个 PID，就可以连接到这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $PID  --mount  --uts  --ipc  --net  --pid</span><br></pre></td></tr></table></figure><p>如果无法通过以上命令连接到这个容器，有可能是因为宿主的默认 shell 在容器中并不存在，比如zsh，可以使用如下命令显式地使用bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $pid  --mount  --uts  --ipc  --net  --pid  --  &#x2F;usr&#x2F;bin&#x2F;env  \  --ignore-environment  HOME&#x3D;&#x2F;root  &#x2F;bin&#x2F;bash  --login</span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubunt</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  </span><br><span class="line">243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia $ PID&#x3D;$(docker-pid 243c32535da7) 10981 </span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid </span><br><span class="line">root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><h2 id="导出和导入容器快照"><a href="#导出和导入容器快照" class="headerlink" title="导出和导入容器快照"></a>导出和导入容器快照</h2><h3 id="导出容器快照"><a href="#导出容器快照" class="headerlink" title="导出容器快照"></a>导出容器快照</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">7691a814370e ubuntu:14.04  &quot;&#x2F;bin&#x2F;bash&quot;  36 hours ago Exited (0) 21 hours ago test </span><br><span class="line">$ sudo docker export  7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test&#x2F;ubuntu v1.0  </span><br><span class="line">9d37a6082e97 About a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure><p>*注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也$sudo docker rm trusting_newton trusting_newton要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker rm trusting_newton trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="清理所有处于终止状态的容器-不建议使用"><a href="#清理所有处于终止状态的容器-不建议使用" class="headerlink" title="清理所有处于终止状态的容器(不建议使用)"></a>清理所有处于终止状态的容器(不建议使用)</h2><p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的 <code>docker rm</code> 默认并不会删除运行中的容器</p><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用阿里云这样的公共仓库可能不方便，用户可以创建一个本地仓库供自己使用。</p><h3 id="如何使用本地仓库"><a href="#如何使用本地仓库" class="headerlink" title="如何使用本地仓库"></a>如何使用本地仓库</h3><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器中运行-docker-registry"><a href="#容器中运行-docker-registry" class="headerlink" title="容器中运行 docker-registry"></a>容器中运行 docker-registry</h4><p>在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 registry 镜像来启动本地的私有仓库。<br>用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run \ </span><br><span class="line">-e SETTINGS_FLAVOR&#x3D;s3 \ </span><br><span class="line">-e AWS_BUCKET&#x3D;acme-docker \ </span><br><span class="line">-e STORAGE_PATH&#x3D;&#x2F;registry \ </span><br><span class="line">-e AWS_KEY&#x3D;AKIAHSHB43HS3J92MXZ \ </span><br><span class="line">-e AWS_SECRET&#x3D;xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \ </span><br><span class="line">-e SEARCH_BACKEND&#x3D;sqlalchemy \ </span><br><span class="line">-p 5000:5000 \ </span><br><span class="line">registry</span><br></pre></td></tr></table></figure><p>此外，还可以指定本地路径（如 <code>/home/user/registry-conf</code> ）下的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;home&#x2F;user&#x2F;registry-conf:&#x2F;registry-conf  -e DOCKER_REGISTRY_CONFIG&#x3D;&#x2F;registry-conf&#x2F;config.yml registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>（v1 中是<code>/tmp/registry</code>）下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry</span><br></pre></td></tr></table></figure><h4 id="本地安装-docker-registry"><a href="#本地安装-docker-registry" class="headerlink" title="本地安装 docker-registry"></a>本地安装 docker-registry</h4><p>对于 CentOS 发行版，可以直接通过源安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel </span><br><span class="line">$ sudo python-pip install docker-registry</span><br></pre></td></tr></table></figure><p>也可以从 <a href="https://link.jianshu.com/?t=https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a> 项目下载源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev </span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-registry.git </span><br><span class="line">$ cd docker-registry </span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>然后修改配置文件，主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp config&#x2F;config_sample.yml config&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>之后启动 Web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn -c contrib&#x2F;gunicorn.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn --access-logfile  -  --error-logfile  -  -k gevent -b  0.0.0.0:5000  -w  4  --max-requests  100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功</p><p>*注：<code>config/config_sample.yml</code> 文件是示例配置文件。</p><h3 id="在私有仓库上传、下载、搜索镜像"><a href="#在私有仓库上传、下载、搜索镜像" class="headerlink" title="在私有仓库上传、下载、搜索镜像"></a>在私有仓库上传、下载、搜索镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 <code>192.168.7.26:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用<code>docker tag</code> 将 <code>ba58</code> 这个镜像标记为 <code>192.168.7.26:5000/test</code>（格式为 <code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag ba58 192.168.7.26:5000&#x2F;test</span><br><span class="line">root ~ # docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.7.26:5000&#x2F;test</span><br><span class="line">The push refers to  a repository [192.168.7.26:5000&#x2F;test] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository 192.168.7.26:5000&#x2F;test (1 tags)</span><br><span class="line">Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping</span><br><span class="line">Pushing tag for rev [ba5877dc9bec] on &#123;http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;repositories&#x2F;test&#x2F;tags&#x2F;latest&#125;</span><br></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;search</span><br><span class="line">&#123;&quot;num_results&quot;:  7, &quot;query&quot;:  &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;tomcat&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu_office&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;desktop_ubu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;dockerfile&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;test&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code>，表明镜像已经被成功上传了。</p><p>现在可以到另外一台机器去下载这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull 192.168.7.26:5000&#x2F;test</span><br><span class="line">Pulling repository 192.168.7.26:5000&#x2F;test</span><br><span class="line">ba5877dc9bec: Download complete </span><br><span class="line">511136ea3c5a: Download complete </span><br><span class="line">9bad880da3d2: Download complete </span><br><span class="line">25f11f5fb0cb: Download complete </span><br><span class="line">ebc34468f71d: Download complete </span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><h1 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li><li>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3></li></ul><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>*注意：也可以在 Dockerfile 中使用 <code>VOLUME</code> 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个<a href="https://github.com/moby/moby/pull/8484" target="_blank" rel="noopener">PR</a>。</p><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>-v</code> 标记也可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code><br>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><p>*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>:ro</code> 之后，就挂载为只读了。</p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看指定容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的<code>/var/lib/docker/volumes/</code>下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123; &quot;&#x2F;webapp&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;fac362...80535&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123; &quot;&#x2F;webapp&quot;: true &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的<code>/mnt/sda1/var/lib/docker/volumes/....</code>下面了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mounts&quot;: [ </span><br><span class="line">    &#123; </span><br><span class="line">        &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, </span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&#x2F;_data&quot;, </span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;webapp&quot;, </span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;, </span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;, </span><br><span class="line">        &quot;RW&quot;: true, </span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot; </span><br><span class="line">    &#125; </span><br><span class="line">] </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>-v</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><p>*注意：如果直接挂载一个文件，很多文件编辑工具，包括 <code>vi</code> 或者 <code>sed --in-place</code>，可能会造成文件 inode 的改变，从 Docker 1.1<br>.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>首先，创建一个名为 dbdata 的数据卷容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -v &#x2F;dbdata --name dbdata training&#x2F;postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure><p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training&#x2F;postgres </span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>可以使用超过一个的 <code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷。<br>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db3 --volumes-from db1 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。<br>这可以让用户在容器之间升级和移动数据卷。</p><h2 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><p>可以利用数据卷对其中的数据进行进行备份、恢复和迁移</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 <code>backup.tar</code> 的文件。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</span><br></pre></td></tr></table></figure><p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run  --volumes-from dbdata2 busybox &#x2F;bin&#x2F;ls &#x2F;dbdata</span><br></pre></td></tr></table></figure><h2 id="Docker-中的网络功能介绍"><a href="#Docker-中的网络功能介绍" class="headerlink" title="Docker 中的网络功能介绍"></a>Docker 中的网络功能介绍</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P training&#x2F;webapp python app.py</span><br><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">bc533791f3f5 training&#x2F;webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000&#x2F;tcp nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f nostalgic_morse</span><br><span class="line">* Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F;</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F; HTTP&#x2F;1.1&quot;  200 -</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;  404 -</span><br></pre></td></tr></table></figure><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 udp 标记来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 使用 &#96;docker port&#96; 来查看当前映射的端口配置，也可以查看到绑定的地址127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -p  3000:80 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li></ul><p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p><p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有2个好处</p><ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul><p>使用 <code>--name</code> 标记可以为容器自定义命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>使用 <code>docker ps</code> 来验证设定的命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f  &quot;&#123;&#123; .Name &#125;&#125;&quot; aed84ee21bde</span><br><span class="line">&#x2F;web</span><br></pre></td></tr></table></figure><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用<code>docker rm</code> 来删除之前创建的同名容器。</p><p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code>参数不能同时使用。</p><h3 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p><p>下面先创建一个新的数据库容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>除之前创建的 web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f web</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web --link db:db training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。</p><p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p><p>使用 <code>docker ps</code> 来查看容器的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">349169744e49 training&#x2F;postgres:latest su postgres -c &#39;&#x2F;usr About a minute ago Up About a minute 5432&#x2F;tcp db, web&#x2F;db </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 16 hours ago Up 2 minutes 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p><p>Docker 通过 2 种方式为容器公开连接信息</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件<br>使用 <code>env</code> 命令来查看 web 容器的环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training&#x2F;webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME&#x3D;&#x2F;web2&#x2F;db DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP_PROTO&#x3D;tcp DB_PORT_5000_TCP_PORT&#x3D;5432 DB_PORT_5000_TCP_ADDR&#x3D;172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</li></ul><p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training&#x2F;webapp &#x2F;bin&#x2F;bash</span><br><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">. . . </span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 </p><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# apt-get install -yqq inetutils-ping root@aed84ee21bde:&#x2F;opt&#x2F;webapp# ping db  </span><br><span class="line">PING db (172.17.0.5):  48 data bytes </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.267 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.250 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.256 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试db容器，它会解析成 <code>172.17.0.5</code>。<br>*注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/xc_zhou/article/details/80952307&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xc_zhou/article/details/80952307&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker-容器&quot;&gt;&lt;a href=&quot;#Docker-容器&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器&quot;&gt;&lt;/a&gt;Docker 容器&lt;/h2&gt;&lt;p&gt;容器是 Docker 又一核心概念。&lt;/p&gt;
&lt;p&gt;简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。&lt;/p&gt;
&lt;h2 id=&quot;启动容器&quot;&gt;&lt;a href=&quot;#启动容器&quot; class=&quot;headerlink&quot; title=&quot;启动容器&quot;&gt;&lt;/a&gt;启动容器&lt;/h2&gt;&lt;p&gt;启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。&lt;/p&gt;
&lt;p&gt;因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>3.2-Docker镜像用法</title>
    <link href="http://javassun.github.io/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/</id>
    <published>2019-06-05T11:37:41.000Z</published>
    <updated>2020-04-14T06:42:34.458Z</updated>
    
    <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><a id="more"></a><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx&#x2F;</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 <code>RUN</code>指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每一层构建需要的命令写出来,比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make&#39;  \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y  $buildDeps  \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.5.tar.gz&quot;  \  &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1  \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/23fb64e2-2346-432d-8f39-dad51df5c6a3.png" alt></p><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2/2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>785a648f6b86</code>，执行了所要求的命令，并最后提交了这一层 <code>3974e15fde03</code>，随后删除了所用到的这个容器 <code>785a648f6b86</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，我原本以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是_相对路径_。这也是新人经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 . </span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code>命令了。</p><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。<br><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo  $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。0</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>NTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run myip -i </span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通 </span><br><span class="line">$ docker run myip -i </span><br><span class="line">HTTP&#x2F;1.1  200 OK </span><br><span class="line">Server: nginx&#x2F;1.8.0  </span><br><span class="line">Date: Tue, 22 Nov 2016  05:12:40 GMT </span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8 </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2 </span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6 </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Via: 1.1  cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4  </span><br><span class="line">... </span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis </span><br><span class="line">... </span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] </span><br><span class="line"></span><br><span class="line">EXPOSE 6379 CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">... </span><br><span class="line"># allow the container to be started with &#96;--user&#96;  </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39;  -a  &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then </span><br><span class="line">chown -R redis . </span><br><span class="line">exec su-exec redis &quot;$0&quot;  &quot;$@&quot;  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec  &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \ </span><br><span class="line">NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ </span><br><span class="line">&amp;&amp; curl -SLO  &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \ </span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ </span><br><span class="line">&amp;&amp; grep  &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c -\ </span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \ </span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ </span><br><span class="line">&amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量引用： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v mydata:&#x2F;data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app </span><br><span class="line">RUN echo  &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常.</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code>格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \ </span><br><span class="line">CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker  run  -d  --name  web  -p 80:80  myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  3  seconds ago Up 2  seconds (health: starting) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  18  seconds ago Up 16  seconds (healthy) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code></p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool </span><br><span class="line">&#123; </span><br><span class="line">    &quot;FailingStreak&quot;: 0, </span><br><span class="line">    &quot;Log&quot;: [ </span><br><span class="line">        &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, </span><br><span class="line">        &quot;ExitCode&quot;: 0, </span><br><span class="line">        &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;&#x2F;p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.org&#x2F;\&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;\nCommercial support is available at\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.com&#x2F;\&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&quot;, </span><br><span class="line">        &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; </span><br><span class="line">    &#125; </span><br><span class="line">], </span><br><span class="line">&quot;Status&quot;: &quot;healthy&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ONBUILD-镜像复用及项目环境管理"><a href="#ONBUILD-镜像复用及项目环境管理" class="headerlink" title="ONBUILD 镜像复用及项目环境管理"></a>ONBUILD 镜像复用及项目环境管理</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F; </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。�第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新</p><p>么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">ONBUILD COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">ONBUILD COPY . &#x2F;app&#x2F;</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker rmi</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><em>注意 <code>docker rm</code> 命令是删除容器，不要混淆</em></p><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。<br>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY  TAG  IMAGE  ID  CREATED  SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5  MB redis alpine 501ad78535f0  3 weeks ago 21.03  MB docker latest cf693ec9b5c7 3 weeks ago 105.1  MB nginx latest e43d811ce2f4 5 weeks ago 181.5  MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 501</span><br><span class="line">Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi centos </span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged:centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c </span><br><span class="line">Deleted:sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted:sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests </span><br><span class="line">REPOSITORY  TAG  DIGEST  IMAGE  ID  CREATED  SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214  MB  $ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="用-docker-images-命令来配合"><a href="#用-docker-images-命令来配合" class="headerlink" title="用 docker images 命令来配合"></a>用 docker images 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。如删除虚悬镜像的指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/xc_zhou/article/details/80952307&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xc_zhou/article/details/80952307&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-Dockerfile-定制镜像&quot;&gt;&lt;a href=&quot;#使用-Dockerfile-定制镜像&quot; class=&quot;headerlink&quot; title=&quot;使用 Dockerfile 定制镜像&quot;&gt;&lt;/a&gt;使用 Dockerfile 定制镜像&lt;/h2&gt;&lt;p&gt;从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的&lt;strong&gt;指令(Instruction)&lt;/strong&gt;，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;
&lt;p&gt;还以之前定制 &lt;code&gt;nginx&lt;/code&gt; 镜像为例，这次我们使用 Dockerfile 来定制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>3.1-Docker用法</title>
    <link href="http://javassun.github.io/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/</id>
    <published>2019-05-24T09:34:17.000Z</published>
    <updated>2020-04-14T06:42:24.637Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="开启docker服务"><a href="#开启docker服务" class="headerlink" title="开启docker服务"></a>开启docker服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动并加入开机启动</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line">验证安装是否成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">有 client 和 server两部分即表示安装成功。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取镜像命令-docker-pull"><a href="#获取镜像命令-docker-pull" class="headerlink" title="获取镜像命令 docker pull"></a>获取镜像命令 docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，而镜像名称的格式：</p><ul><li><p>Docker Registry地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，既 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像.一定要配置镜像加速器,不然下载速度很慢。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="pull下来的-镜像-存储在哪里呢？"><a href="#pull下来的-镜像-存储在哪里呢？" class="headerlink" title="pull下来的 镜像 存储在哪里呢？"></a>pull下来的 镜像 存储在哪里呢？</h3></li></ul><p>1 进入 docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">ls</span><br><span class="line">builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>2 进入containers,每一个序列号，都是一个镜像，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd containers&#x2F;</span><br><span class="line"></span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a</span><br><span class="line">a0356a312020a4941b257ada41d72efb041f7034a70a987ec3d0f44e9cc19402</span><br><span class="line">b81decb15c1f1f821d1c56bdadc15b62506b6cc102a6f083ec7a9b5f89c2685b</span><br><span class="line">ea1236fd8c7f4ce919c0f56b87b642487ecd2bbec243d416dd1e34b313b27b92</span><br></pre></td></tr></table></figure><p>3 进入其中一个镜像，发现目录结构如下，这就是这个镜像的内容了，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun 61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a]# ls</span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a-json.log  hostconfig.json  mounts</span><br><span class="line">checkpoints                                                                hostname         resolv.conf</span><br><span class="line">config.v2.json                                                             hosts            resolv.conf.hash</span><br></pre></td></tr></table></figure><p>4 在containers同级目录，有个叫image的文件夹，进入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd images&#x2F;aufs</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution imagedb layerdb repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br><span class="line"></span><br><span class="line">如果image没有aufs目录的，可能是这样的</span><br><span class="line"></span><br><span class="line">cd image&#x2F;overlay2&#x2F;</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution  imagedb  layerdb  repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br></pre></td></tr></table></figure><h2 id="查看已下载的镜像-docker-images"><a href="#查看已下载的镜像-docker-images" class="headerlink" title="查看已下载的镜像 docker images"></a>查看已下载的镜像 docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">列表 包含了仓库名、标签、镜像ID、创建时间、所占空间。</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               2c5e00d77a67        3 weeks ago         188MB</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">[root@haoransun docker]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9de828f70b6d:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.6 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">root@9de828f70b6d:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令</p><ul><li><p><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:14.04</code>：这是指用<code>ubuntu:14.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 14.04.5 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><p>以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址,还要配置安全组放通对应的端口。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/749278bc-1a21-42ee-9643-a541b55dd3b5.png" alt></p><p>现在，改动这个欢迎页面，改成<code>Hello, Docker!</code>，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker exec -it webserver bash</span><br><span class="line">root@6415ebcbd369:&#x2F;# echo &#39;&lt;h1&gt;Hello,Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">root@6415ebcbd369:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e2cf02a5-8db5-451b-ad15-7144d09e93f2.png" alt></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff webserver</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/dd927ddb-c0ba-47dc-96fa-e7a5f48e5d4f.png" alt></p><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><p>现在已经定制好了,那我们如何把它保存下来形成镜像?</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而<strong>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>下面的命令将容器保存为镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker commit --author &#39;haoransun&lt;xxxx@qq.com&gt;&#39; --message &#39;修改Nginx欢迎页面&#39; webserver nginx:v2</span><br><span class="line">sha256:cef47606fca7dd6a5ee72986d18641ac754973120312a7015bb228dee64cc02a</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/d21dbdd8-e230-4888-b179-46ba0b5d22fd.png" alt></p><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。</p><p>可以用 <code>docker images</code> 命令看到这个新定制的镜像：</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e168773c-e547-4d5a-86fb-d72e60cee08d.png" alt></p><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/782171db-773a-4ade-8335-092e6da4d2d6.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。否则访问 虚拟机的地址如：192.168.121.100:81。</p><p>完成了第一次定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用  docker commit"></a>慎用  docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心没有清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p><code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制行为应该使用 <code>Dockerfile</code> 来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;开启docker服务&quot;&gt;&lt;a href=&quot;#开启docker服务&quot; class=&quot;headerlink&quot; title=&quot;开启docker服务&quot;&gt;&lt;/a&gt;开启docker服务&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;启动并加入开机启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl start docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl enable docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;验证安装是否成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有 client 和 server两部分即表示安装成功。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2.2-Docker启动报错</title>
    <link href="http://javassun.github.io/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
    <id>http://javassun.github.io/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</id>
    <published>2019-05-23T10:32:24.000Z</published>
    <updated>2020-04-14T06:42:17.874Z</updated>
    
    <content type="html"><![CDATA[<p>出处：<a href="https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA</a></p><h2 id="Docker虚拟化故障"><a href="#Docker虚拟化故障" class="headerlink" title="Docker虚拟化故障"></a>Docker虚拟化故障</h2><p>Docker虚拟化主要有三类故障：<br><strong>应用故障：</strong>应用执行状态与预期不一致。</p><p><strong>容器故障：</strong>无法正确创建、停止、更新容器等。</p><p><strong>集群故障：</strong>集群创建失败、更新失败、无法连接等。</p><a id="more"></a><h2 id="Docker-虚拟化故障排错"><a href="#Docker-虚拟化故障排错" class="headerlink" title="Docker 虚拟化故障排错"></a>Docker 虚拟化故障排错</h2><p>所有的Docker虚拟化故障排查诊断，都可以通过Docker命令行工具或者Web控制台来完成。</p><p>通过WEB控制台查看，需要自建控制台，对于Docker运维管理员来说，命令行工具排错是一个不错的帮手。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><strong>案例描述：</strong><br>生产环境，全新安装的Docker无法启动，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  docker.service</span><br><span class="line">Job for docker.service failed because the control process exited with  error code.See</span><br><span class="line">&quot;systemctl status docker.service&quot;  and  &quot;journalctl -xe&quot;  for details</span><br></pre></td></tr></table></figure><p>通过journalctl -xe命令查看启动的详细日志，启动daemon错误，因为Selinux不支持，Selinux阻挡了Docker引擎的启动，如图所示：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/bffe455a-b137-4cd1-b009-874dbeaaebf8.jpg" alt></p><p><strong>解决方案：</strong><br>如上问题，解决方法有两种：</p><p>1.Selinux主配置文件：</p><p>/etc/selinux/config，将配置文件中enforcing设置为disabled，然后重启系统，然后重启docker引擎即可。</p><p>2.docker主配置文件：</p><p>/etc/sysconfig/docker，将配置文件中–selinux-enabled选项为false，改成：–selinux-enabled=false即可。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  socket at step GROUP: No such process</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/3bf44228-5466-47a3-a7fb-eae0c2c85e13.jpg" alt></p><p><strong>解决方案：</strong><br>如上错误提示是因为Docker无法找到Group组信息，docker组有可能被误删除，解决方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.创建宿主机docker组即可，命令：groupadd docker；</span><br><span class="line">2.&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket文件，SocketGroup&#x3D;修改为root也可以；</span><br></pre></td></tr></table></figure><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/4c8256fb-0669-4cc5-9381-30b95b45422f.jpg" alt></p><p>如上错误提示是因为Linux操作系统没有更多的Loopback 设备给Docker使用。</p><p><strong>解决方案：</strong><br>创建更多的Loopback设备即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i inseq 0 6;do mknod -m 0660 &#x2F;dev&#x2F;loop$i b 7 $i;done</span><br></pre></td></tr></table></figure><h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><p><strong>案例描述：</strong></p><p>Docker命令执行，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:</span><br><span class="line">&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>根据如上错误提示，该错误很明显可能是docker没有启动。</p><p><strong>解决方案：</strong></p><p>检测docker进程是否启动，ps -ef|grep docker，如果没有启动，启动Docker即可。</p><p>检测Docker进程存在，但是无法连接，可以重启一下Docker服务，检测一下Sock路径是否正确；<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/0e4560e9-3eff-484b-8da3-96e821d660ab.jpg" alt></p><h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><p><strong>案例描述：</strong><br>Docker获取远程镜像，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: dial tcp: lookup registry-1.docker.io</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/57f33576-3246-41b0-be58-c5382485a341.png" alt></p><p>该错误表示无法连接远程仓库Docker.io。</p><p><strong>解决方案：</strong></p><p>查看本地是否配置DNS，能否ping通docker.io；</p><p>如果能够ping通，但是下载还是比较慢，可以修改Docker仓库源为国内或者自建的仓库源；</p><p>Docker镜像修改方法，vim /etc/docker/daemon.json，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at&gt;&#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="案例6"><a href="#案例6" class="headerlink" title="案例6"></a>案例6</h3><p><strong>案例描述：</strong><br>启动Docker容器，报错信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;&#x2F;bin&#x2F;bash\&quot;: executable file not found in $PATH&quot;.</span><br></pre></td></tr></table></figure><p>如上报错，通常是由于容器启动时，不支持该命令：/bin/bash。</p><p><strong>解决方案：</strong></p><p>解决方法有如下两种：</p><p>修改启动命令为正确的Docker容器启动命令，例如修改为：/bin/sh或者sleep 99999d等；</p><p>Docker镜像自身问题或者Docker引擎版本比较低导致，可以升级Docker引擎版本服务；</p><h3 id="案例7"><a href="#案例7" class="headerlink" title="案例7"></a>案例7</h3><p><strong>案例描述：</strong><br>Docker虚拟化运行中，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br></pre></td></tr></table></figure><p>如上错误，表示Docker虚拟化引擎平台，没有多月的空间设备所使用，证明容器磁盘不足或者物理机磁盘不足。</p><p><strong>解决方案：</strong></p><p>手工删除Docker容器占用数据比较大的目录；</p><p>或者通过docker system prune自动删除一些日志目录，此种方法会停止所有容器；</p><p>或者临时增加Docker存储硬盘等；</p><h3 id="案例8"><a href="#案例8" class="headerlink" title="案例8"></a>案例8</h3><p><strong>案例描述：</strong><br>Docker push上传镜像至本地仓库报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [106.12.133.186:5000&#x2F;busybox] Get https:&#x2F;&#x2F;106.12.133.186:5000&#x2F;v1&#x2F;_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>根据如上错误提示，错误是由于客户端采用https，docker registry未采用https服务所致。一种处理方式是把客户对地址“106.12.133.186:5000”请求改为http。</p><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件。</span><br><span class="line">在文件中写入：&#123; &quot;insecure-registries&quot;:[&quot;106.12.133.186:5000&quot;] &#125; 。</span><br></pre></td></tr></table></figure><p>保存退出后，重启docker服务，问题即可解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出处：&lt;a href=&quot;https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker虚拟化故障&quot;&gt;&lt;a href=&quot;#Docker虚拟化故障&quot; class=&quot;headerlink&quot; title=&quot;Docker虚拟化故障&quot;&gt;&lt;/a&gt;Docker虚拟化故障&lt;/h2&gt;&lt;p&gt;Docker虚拟化主要有三类故障：&lt;br&gt;&lt;strong&gt;应用故障：&lt;/strong&gt;应用执行状态与预期不一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器故障：&lt;/strong&gt;无法正确创建、停止、更新容器等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群故障：&lt;/strong&gt;集群创建失败、更新失败、无法连接等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2.1-Docker安装与部署</title>
    <link href="http://javassun.github.io/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://javassun.github.io/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</id>
    <published>2019-05-18T11:29:53.000Z</published>
    <updated>2020-04-14T06:37:00.514Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.</p><a id="more"></a><figure class="highlight plain"><figcaption><span>库必须启用。默认情况下，此存储库已启用，但是如果将其禁用，则需要**重启启用它**。（自行搜索）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">overlay2 建议使用存储驱动程序。</span><br></pre></td></tr></table></figure><p>uname -r # 可查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 卸载旧版本</span><br><span class="line">旧版本的Docker被称为 docker 或 docker-engine。如果已安装这些，请卸载它们及相关的依赖项、</span><br></pre></td></tr></table></figure><p>$ sudo yum remove docker <br>                  docker-client <br>                  docker-client-latest <br>                  docker-common <br>                  docker-latest <br>                  docker-latest-logrotate <br>                  docker-logrotate <br>                  docker-engine</p><p>如果 yum报告没有安装这些软件包，则可以了、<br>/var/lib/docker/ 保留包括图像、容器、卷和网络在内的内容。现在调用Docker CE包  docker-ce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 安裝 Docker</span><br><span class="line">参考0-Docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Docker 通过运行 hello-world 映像验证是否正确安装。**</span><br></pre></td></tr></table></figure><p>docker run hello-world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此命令下载测试镜像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。如果你没有配置镜像加速器的话,运行 hello-world 命令来验证也是不会成功的.因为国内网络的原因,无法下载测试镜像,更别说运行测试镜像了,&lt;font color&#x3D;red&gt;配置镜像加速器--参考0&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">## 查看当前Docker版本</span><br></pre></td></tr></table></figure><p>docker -v</p><p>docker version</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;系统要求&quot;&gt;&lt;a href=&quot;#系统要求&quot; class=&quot;headerlink&quot; title=&quot;系统要求&quot;&gt;&lt;/a&gt;系统要求&lt;/h2&gt;&lt;p&gt;Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 &lt;code&gt;overlay2&lt;/code&gt; 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>NIO学习</title>
    <link href="http://javassun.github.io/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/"/>
    <id>http://javassun.github.io/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-05-15T12:01:13.000Z</published>
    <updated>2020-04-14T14:35:16.373Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一、高并发互联网应用架构设计"><a href="#一、高并发互联网应用架构设计" class="headerlink" title="一、高并发互联网应用架构设计"></a>一、高并发互联网应用架构设计</h2><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/428003e0-81bd-46c5-9fd9-a97c25281220.jpg" alt></p><a id="more"></a><h3 id="架构的演变过程"><a href="#架构的演变过程" class="headerlink" title="架构的演变过程"></a>架构的演变过程</h3><h4 id="1-单一应用架构"><a href="#1-单一应用架构" class="headerlink" title="1. 单一应用架构"></a>1. 单一应用架构</h4><p>简单，维护成本高<br>ORM</p><h4 id="2-垂直应用架构"><a href="#2-垂直应用架构" class="headerlink" title="2. 垂直应用架构"></a>2. 垂直应用架构</h4><p>各司其职<br>MVC</p><h4 id="3-分布式服务架构"><a href="#3-分布式服务架构" class="headerlink" title="3. 分布式服务架构"></a>3. 分布式服务架构</h4><p>Cross JVM | Cross Machine<br>RPC (Remote Procedure Call)</p><h4 id="4-流动计算架构"><a href="#4-流动计算架构" class="headerlink" title="4. 流动计算架构"></a>4. 流动计算架构</h4><p>资源调度和服务治理<br>SOA (Service-Oriented Architecture)</p><h3 id="高并发网站的设计原则"><a href="#高并发网站的设计原则" class="headerlink" title="高并发网站的设计原则"></a>高并发网站的设计原则</h3><ol><li>X轴：硬件(水平扩展，比性能的垂直提升成本低-摩尔定律)、应用水平复制(应用无状态) 水平扩展</li><li>Y轴：硬件、业务垂直拆分 各司其职(泳道设计)</li><li>Z轴：X和Y轴打包之后 物理隔离</li></ol><h3 id="如何设计高效、高性能的应用服务？"><a href="#如何设计高效、高性能的应用服务？" class="headerlink" title="如何设计高效、高性能的应用服务？"></a>如何设计高效、高性能的应用服务？</h3><p>在分布式服务架构中，我们需要Cross JVM 或者 Cross Machine 传输数据，所以高效的RPC通信木星(Socket+IO) 是设计关键</p><h2 id="二、Java中网络-IO-模型"><a href="#二、Java中网络-IO-模型" class="headerlink" title="二、Java中网络(IO)模型"></a>二、Java中网络(IO)模型</h2><h3 id="IO模型分类"><a href="#IO模型分类" class="headerlink" title="IO模型分类"></a>IO模型分类</h3><h4 id="1-BIO"><a href="#1-BIO" class="headerlink" title="1. BIO"></a>1. BIO</h4><p>传统IO 或者 Blocking IO<br>特点：面向流 Input | Output</p><h4 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2. NIO"></a>2. NIO</h4><p>New IO 或者 Non Blocking IO<br>特点：面向缓冲区 Buffer(基于通道)</p><h4 id="3-AIO-Async-Non-Blocking-IO"><a href="#3-AIO-Async-Non-Blocking-IO" class="headerlink" title="3. AIO(Async Non Blocking IO)"></a>3. AIO(Async Non Blocking IO)</h4><h3 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h3><ol><li>方向————输入、输出流(InputStream | OutputStream)</li><li>类型————字节、字符流(Reader | Writer)</li><li>功能————节点、过滤流(BufferedInputStream |BufferedOutputStream)</li></ol><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><h4 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h4><p>通道、双向、可读可写<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2ffb3a8b-93fd-4ee4-bb66-9e61078a565c.jpg" alt></p><p>Channel的主要实现类有：</p><ul><li>FileChannel       —-文件IO</li><li>DatagramChannel   —-UDP</li><li>SocketChannel     —-TCP Client</li><li>ServerSocketChannel —-TCP Server</li></ul><h4 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h4><p>缓冲区<br>Buffer的主要实现类有：</p><ul><li>除boolean外的其余七种基本类型(ByteBuffer、ShortBuffer、IntBuffer等)</li></ul><h4 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h4><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/a3cad6d4-ec4c-46c6-b8e7-1374afcf5482.jpg" alt></p><h3 id="NIO-Buffer详解"><a href="#NIO-Buffer详解" class="headerlink" title="NIO Buffer详解"></a>NIO Buffer详解</h3><p>一个用于特定基本类型的数据容器，除数据内容外，还包含以下属性：</p><ol><li>capacity 缓冲区大小，常量不可变</li><li>limit 缓冲区允许读写操作的最大范围</li><li>position 缓冲区下一个可读写元素的索引</li></ol><p><strong>注：所有可操作的数据在position和limit之间</strong><br>操作图示：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3cbb0329-a79a-4926-903a-3f148f94acb4.jpg" alt></p><p>示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5ac188f8-dc23-4ab1-973d-3135401f0371.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/610fb173-c877-443f-b39c-224a341cdd5d.png" alt></p><p>测试结果：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/ce63f053-3583-46d2-b91a-fa4e5faa1bbf.jpg" alt></p><h3 id="NIO-IO操作-文件拷贝"><a href="#NIO-IO操作-文件拷贝" class="headerlink" title="NIO IO操作(文件拷贝)"></a>NIO IO操作(文件拷贝)</h3><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/49016de5-5e38-4d09-a159-7efc2b832248.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2bc74fd6-297d-4d5c-b7df-009a7c86a5ca.png" alt></p><h3 id="BIO-网络编程"><a href="#BIO-网络编程" class="headerlink" title="BIO 网络编程"></a>BIO 网络编程</h3><h4 id="服务器：ServerSocket"><a href="#服务器：ServerSocket" class="headerlink" title="服务器：ServerSocket"></a>服务器：ServerSocket</h4><ol><li>初始化服务器ServerSocket，绑定监听端口</li><li>等待客户端连接 ServerSocket.accept();</li><li>处理请求/响应 Socket.getInputStream(); / socket.getOutputStream();</li><li>关闭资源</li></ol><h4 id="客户端：Socket"><a href="#客户端：Socket" class="headerlink" title="客户端：Socket"></a>客户端：Socket</h4><ol><li>初始化客户端 Socket, 绑定服务器IP/端口</li><li>发起请求/获取响应 socket.getOutputStream(); /socket.getInputStream();</li><li>关闭资源</li></ol><p>客户端示例代码:<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bbfb9d5c-9766-4fe3-b51f-3500cd3356ed.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c36c47b4-7966-40b2-a434-a39c8667e2d8.jpg" alt></p><p>服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/db0236b3-4aea-47c6-a98e-f4c5da6c6a2b.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8bbcb471-fb02-4bc9-ae4c-8f247cb24bbb.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/18da21e4-9afa-4e04-be65-29c3c41596e7.jpg" alt></p><ol><li><strong>特点:</strong> accept() 是一个阻塞方法，当有客户端连接时，返回Socket对象，通过Socket对象的InputStream()或者 OutputStream() 接受请求发送响应结果。单请求服务器模型只能处理一个客户端的请求。</li><li><strong>缺点:</strong> 服务器必须能够处理多个客户端的请求和响应</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/53c62143-1d4a-4bdf-b96e-b98298b6d3f5.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/52bb442e-2f83-4bd4-a439-fd2067698169.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/78634985-5e0e-4fc7-a847-07ec068d69ae.png" alt></p><ol><li><strong>特点:</strong> 通过循环可以不断的接受客户端请求</li><li><strong>缺点:</strong> 请求的接受和IO处理在同一个线程中，客户端请求本质上是串行处理，无法支持高并发。</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/1f73e9db-1e95-49c7-b31c-b679f600d0b7.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3c1cd1d2-7b7b-4e09-bacc-caab7b0638c5.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5b2a809a-51e3-4776-802d-9acbc0d6063e.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/69989ce9-07a8-4342-b41b-5a4d44b897e0.png" alt></p><ol><li><strong>特点:</strong> 请求转发和IO处理，主线程只负责接受请求，IO的处理通过子线程完成。实现服务器的高性能</li><li><strong>缺点:</strong> 缺乏弹性伸缩能力，当客户端的访问量增加后，服务器的线程个数和客户端并发访问数量1:1正比关系，线程是宝贵的系统资源，数量过多，会造成系统性能急剧下降，导致服务器“宕机”</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bc55ffeb-ac01-4ddb-a223-ff3e4a57b0ab.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/aa445693-1c30-4853-a53c-3b4d37fb14aa.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/50c35557-c48e-4dd3-b338-fe76d919f54b.png" alt></p><ol><li><strong>特点:</strong> 通过线程池有效的管理线程，避免线程的重复创建、销毁而导致的系统资源过渡开销</li><li><strong>缺点:</strong> 限制了线程的数量，当有大量的并发请求时，超过最大线程数量的请求只能等待，直到线程池中有空闲的线程可以使用。对于BIO，当你发送一个请求的时候，你必须等待直到你获得返回结果。在服务端，这个意味着，一个线程同一时间最多只能和一个传入的连接相关联（直到这个连接被关闭)。<strong>先开线程，在线程中可能没有就绪的IO，导致线程的利用率不高。</strong></li></ol><h3 id="NIO-网络编程"><a href="#NIO-网络编程" class="headerlink" title="NIO 网络编程"></a>NIO 网络编程</h3><ul><li><strong>使用NIO API，替换BIO的多请求多线程版网络模型</strong></li></ul><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8db4046c-68c2-431c-91d3-ffcd02f72d11.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/92f0ac56-8ad0-456d-88d4-1515df43a651.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8080c448-9917-4193-aa79-f9f393884649.png" alt></p><ol><li><strong>特点:</strong> 使用NIO的API，通过面向通道的编程方式替换了BIO的编程模型</li><li><strong>缺点:</strong> 此模型跟BIO编程模型本质上没有区别(API差异)，实际上也没有解决IO的阻塞问题</li></ol><ul><li><strong>Selector</strong></li></ul><p>在NIO使用Channel管理所有的IO操作，<strong>Selector</strong>用于管理通道（注：需确保通道的操作都是非阻塞的），Channel和Selector配合使用</p><ol><li>通道需注册到选择器中（通道+关注的事件类型+附件信息）</li><li>选择器中的通道必须是非阻塞的</li><li>常用的事件类型<br>a. SelectionKey.OP_CONNECT 连接就绪<br>b. SelectionKey.OP_ACCEPT 接受就绪<br>c. SelctionKey.OP_READ 读就绪</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b26ac541-513f-4b25-adaa-f94cb240c700.jpg" alt></p><ul><li><p>NIO服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/15810dee-7cc1-429e-b4b7-a4f0d829fd3b.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/93b80458-99c0-4549-ac2a-f250076da709.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c43ce081-8600-4fae-8794-36245c068850.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8d05f649-64ab-4946-ab58-b8de71bfe6f1.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/322d23d0-d305-4dbc-b80d-ea44129accf5.png" alt></p></li><li><p>NIO客户端示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b76038c5-9207-4c33-8bc2-58e724a01935.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/23afa843-b264-4730-b742-ed428cc6420c.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/0eb2fee4-d836-469f-8d88-e62cb7557156.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/9cebd7f5-558c-4fa3-8f11-183f7206899b.png" alt></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;一、高并发互联网应用架构设计&quot;&gt;&lt;a href=&quot;#一、高并发互联网应用架构设计&quot; class=&quot;headerlink&quot; title=&quot;一、高并发互联网应用架构设计&quot;&gt;&lt;/a&gt;一、高并发互联网应用架构设计&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/428003e0-81bd-46c5-9fd9-a97c25281220.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网络编程" scheme="http://JavaSsun.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="NIO" scheme="http://JavaSsun.github.io/tags/NIO/"/>
    
      <category term="网络编程" scheme="http://JavaSsun.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
