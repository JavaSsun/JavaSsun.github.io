<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haoran&#39;s blog</title>
  
  <subtitle>Talk is cheap. Show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javassun.github.io/"/>
  <updated>2020-04-14T06:42:43.555Z</updated>
  <id>http://javassun.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3-3-Docker容器用法</title>
    <link href="http://javassun.github.io/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</id>
    <published>2019-06-10T12:15:20.000Z</published>
    <updated>2020-04-14T06:42:43.555Z</updated>
    
    <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><a id="more"></a><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;</span><br><span class="line">Unable to find image &#39;ubuntu:14.04&#39; locally 14.04: Pulling from  library&#x2F;ubuntu cb56c90f0b30: Pull complete 0acc551e5716: Pull complete 8956dcd35143: Pull complete 908242721214: Pull complete b44ff14dd3bb: Pull complete Digest: sha256:5faf6cb681da2be979a177b60d8c18497f962e3d82268c49db6c74008d0c294d Status: Downloaded newer image for ubuntu:14.04 Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 &#x2F;bin&#x2F;bash root@af8bae53bdd3:&#x2F;#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@af8bae53bdd3:&#x2F;# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:&#x2F;# ps</span><br><span class="line">PID  TTY  TIME  CMD  </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="查看正在运行中的容器"><a href="#查看正在运行中的容器" class="headerlink" title="查看正在运行中的容器"></a>查看正在运行中的容器</h3><p>利用 <code>docker ps</code> 命令可以查看正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  25 minutes ago Exited (0) 25 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><p>可以利用 <code>docker start</code> 命令和上面使用 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，直接将一个已经终止的容器启动运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker start relaxed_kilby</span><br><span class="line"></span><br><span class="line">relaxed_kilby</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  45 minutes ago Exited (0) 3 seconds ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><p>这里把 <strong>新建并启动</strong> 章节中的容器又启动了一次,这次这个容器和之前不一样,他启动之后就会被终止,不会输出一个 “Hello World”，之后才终止容器。可以看 <code>STATUS</code> 输出,这个容器的确被启动过.</p><h3 id="容器后台运行"><a href="#容器后台运行" class="headerlink" title="容器后台运行"></a>容器后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; </span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果(STDOUT)打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和docker run指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 命令来查看容器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">77b2dc01fe0f ubuntu:14.04 &#x2F;bin&#x2F;sh -c &#39;while tr 2 minutes ago Up 1 minute agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs [container ID  or  NAMES] hello world </span><br><span class="line">hello world </span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop web2 </span><br><span class="line"></span><br><span class="line">web2</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot; About an hour ago Exited (0) 15 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Exited (0) 3  seconds ago web2 71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world &quot;&#x2F;hello&quot;  2 days ago Exited (0) 2 days ago peaceful_brown</span><br></pre></td></tr></table></figure><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p><code>docker restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，有很多种方法，包括使用 <code>docker attach</code> 命令或 <code>nsenter</code> 工具等。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><p><code>docker attach</code> 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550  </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><p>是使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h3 id="nsenter-命令"><a href="#nsenter-命令" class="headerlink" title="nsenter 命令"></a>nsenter 命令</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>nsenter</code> 工具在 util-linux 包2.23版本后包含。<br>可以使用 <code>nsenter -V</code> 查看系统是否安装了 <code>nsenter</code> 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter -V</span><br><span class="line"></span><br><span class="line">nsenter from util-linux  2.23.2</span><br></pre></td></tr></table></figure><p>如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; curl https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;utils&#x2F;util-linux&#x2F;v2.24&#x2F;util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24; </span><br><span class="line">$ .&#x2F;configure --without-ncurses </span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>senter</code> 启动一个新的shell进程(默认是/bin/bash), 同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限。</p><p>为了连接到容器，你还需要找到容器的第一个进程的 PID，可以通过下面的命令获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID&#x3D;$(docker inspect --format  &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个 PID，就可以连接到这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $PID  --mount  --uts  --ipc  --net  --pid</span><br></pre></td></tr></table></figure><p>如果无法通过以上命令连接到这个容器，有可能是因为宿主的默认 shell 在容器中并不存在，比如zsh，可以使用如下命令显式地使用bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $pid  --mount  --uts  --ipc  --net  --pid  --  &#x2F;usr&#x2F;bin&#x2F;env  \  --ignore-environment  HOME&#x3D;&#x2F;root  &#x2F;bin&#x2F;bash  --login</span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubunt</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  </span><br><span class="line">243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia $ PID&#x3D;$(docker-pid 243c32535da7) 10981 </span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid </span><br><span class="line">root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><h2 id="导出和导入容器快照"><a href="#导出和导入容器快照" class="headerlink" title="导出和导入容器快照"></a>导出和导入容器快照</h2><h3 id="导出容器快照"><a href="#导出容器快照" class="headerlink" title="导出容器快照"></a>导出容器快照</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">7691a814370e ubuntu:14.04  &quot;&#x2F;bin&#x2F;bash&quot;  36 hours ago Exited (0) 21 hours ago test </span><br><span class="line">$ sudo docker export  7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test&#x2F;ubuntu v1.0  </span><br><span class="line">9d37a6082e97 About a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure><p>*注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也$sudo docker rm trusting_newton trusting_newton要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker rm trusting_newton trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="清理所有处于终止状态的容器-不建议使用"><a href="#清理所有处于终止状态的容器-不建议使用" class="headerlink" title="清理所有处于终止状态的容器(不建议使用)"></a>清理所有处于终止状态的容器(不建议使用)</h2><p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的 <code>docker rm</code> 默认并不会删除运行中的容器</p><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用阿里云这样的公共仓库可能不方便，用户可以创建一个本地仓库供自己使用。</p><h3 id="如何使用本地仓库"><a href="#如何使用本地仓库" class="headerlink" title="如何使用本地仓库"></a>如何使用本地仓库</h3><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器中运行-docker-registry"><a href="#容器中运行-docker-registry" class="headerlink" title="容器中运行 docker-registry"></a>容器中运行 docker-registry</h4><p>在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 registry 镜像来启动本地的私有仓库。<br>用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run \ </span><br><span class="line">-e SETTINGS_FLAVOR&#x3D;s3 \ </span><br><span class="line">-e AWS_BUCKET&#x3D;acme-docker \ </span><br><span class="line">-e STORAGE_PATH&#x3D;&#x2F;registry \ </span><br><span class="line">-e AWS_KEY&#x3D;AKIAHSHB43HS3J92MXZ \ </span><br><span class="line">-e AWS_SECRET&#x3D;xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \ </span><br><span class="line">-e SEARCH_BACKEND&#x3D;sqlalchemy \ </span><br><span class="line">-p 5000:5000 \ </span><br><span class="line">registry</span><br></pre></td></tr></table></figure><p>此外，还可以指定本地路径（如 <code>/home/user/registry-conf</code> ）下的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;home&#x2F;user&#x2F;registry-conf:&#x2F;registry-conf  -e DOCKER_REGISTRY_CONFIG&#x3D;&#x2F;registry-conf&#x2F;config.yml registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>（v1 中是<code>/tmp/registry</code>）下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry</span><br></pre></td></tr></table></figure><h4 id="本地安装-docker-registry"><a href="#本地安装-docker-registry" class="headerlink" title="本地安装 docker-registry"></a>本地安装 docker-registry</h4><p>对于 CentOS 发行版，可以直接通过源安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel </span><br><span class="line">$ sudo python-pip install docker-registry</span><br></pre></td></tr></table></figure><p>也可以从 <a href="https://link.jianshu.com/?t=https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a> 项目下载源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev </span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-registry.git </span><br><span class="line">$ cd docker-registry </span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>然后修改配置文件，主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp config&#x2F;config_sample.yml config&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>之后启动 Web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn -c contrib&#x2F;gunicorn.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn --access-logfile  -  --error-logfile  -  -k gevent -b  0.0.0.0:5000  -w  4  --max-requests  100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功</p><p>*注：<code>config/config_sample.yml</code> 文件是示例配置文件。</p><h3 id="在私有仓库上传、下载、搜索镜像"><a href="#在私有仓库上传、下载、搜索镜像" class="headerlink" title="在私有仓库上传、下载、搜索镜像"></a>在私有仓库上传、下载、搜索镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 <code>192.168.7.26:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用<code>docker tag</code> 将 <code>ba58</code> 这个镜像标记为 <code>192.168.7.26:5000/test</code>（格式为 <code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag ba58 192.168.7.26:5000&#x2F;test</span><br><span class="line">root ~ # docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.7.26:5000&#x2F;test</span><br><span class="line">The push refers to  a repository [192.168.7.26:5000&#x2F;test] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository 192.168.7.26:5000&#x2F;test (1 tags)</span><br><span class="line">Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping</span><br><span class="line">Pushing tag for rev [ba5877dc9bec] on &#123;http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;repositories&#x2F;test&#x2F;tags&#x2F;latest&#125;</span><br></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;search</span><br><span class="line">&#123;&quot;num_results&quot;:  7, &quot;query&quot;:  &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;tomcat&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu_office&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;desktop_ubu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;dockerfile&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;test&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code>，表明镜像已经被成功上传了。</p><p>现在可以到另外一台机器去下载这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull 192.168.7.26:5000&#x2F;test</span><br><span class="line">Pulling repository 192.168.7.26:5000&#x2F;test</span><br><span class="line">ba5877dc9bec: Download complete </span><br><span class="line">511136ea3c5a: Download complete </span><br><span class="line">9bad880da3d2: Download complete </span><br><span class="line">25f11f5fb0cb: Download complete </span><br><span class="line">ebc34468f71d: Download complete </span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><h1 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li><li>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3></li></ul><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>*注意：也可以在 Dockerfile 中使用 <code>VOLUME</code> 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个<a href="https://github.com/moby/moby/pull/8484" target="_blank" rel="noopener">PR</a>。</p><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>-v</code> 标记也可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code><br>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><p>*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>:ro</code> 之后，就挂载为只读了。</p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看指定容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的<code>/var/lib/docker/volumes/</code>下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123; &quot;&#x2F;webapp&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;fac362...80535&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123; &quot;&#x2F;webapp&quot;: true &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的<code>/mnt/sda1/var/lib/docker/volumes/....</code>下面了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mounts&quot;: [ </span><br><span class="line">    &#123; </span><br><span class="line">        &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, </span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&#x2F;_data&quot;, </span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;webapp&quot;, </span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;, </span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;, </span><br><span class="line">        &quot;RW&quot;: true, </span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot; </span><br><span class="line">    &#125; </span><br><span class="line">] </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>-v</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><p>*注意：如果直接挂载一个文件，很多文件编辑工具，包括 <code>vi</code> 或者 <code>sed --in-place</code>，可能会造成文件 inode 的改变，从 Docker 1.1<br>.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>首先，创建一个名为 dbdata 的数据卷容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -v &#x2F;dbdata --name dbdata training&#x2F;postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure><p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training&#x2F;postgres </span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>可以使用超过一个的 <code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷。<br>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db3 --volumes-from db1 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。<br>这可以让用户在容器之间升级和移动数据卷。</p><h2 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><p>可以利用数据卷对其中的数据进行进行备份、恢复和迁移</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 <code>backup.tar</code> 的文件。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</span><br></pre></td></tr></table></figure><p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run  --volumes-from dbdata2 busybox &#x2F;bin&#x2F;ls &#x2F;dbdata</span><br></pre></td></tr></table></figure><h2 id="Docker-中的网络功能介绍"><a href="#Docker-中的网络功能介绍" class="headerlink" title="Docker 中的网络功能介绍"></a>Docker 中的网络功能介绍</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P training&#x2F;webapp python app.py</span><br><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">bc533791f3f5 training&#x2F;webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000&#x2F;tcp nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f nostalgic_morse</span><br><span class="line">* Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F;</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F; HTTP&#x2F;1.1&quot;  200 -</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;  404 -</span><br></pre></td></tr></table></figure><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 udp 标记来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 使用 &#96;docker port&#96; 来查看当前映射的端口配置，也可以查看到绑定的地址127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -p  3000:80 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li></ul><p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p><p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有2个好处</p><ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul><p>使用 <code>--name</code> 标记可以为容器自定义命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>使用 <code>docker ps</code> 来验证设定的命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f  &quot;&#123;&#123; .Name &#125;&#125;&quot; aed84ee21bde</span><br><span class="line">&#x2F;web</span><br></pre></td></tr></table></figure><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用<code>docker rm</code> 来删除之前创建的同名容器。</p><p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code>参数不能同时使用。</p><h3 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p><p>下面先创建一个新的数据库容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>除之前创建的 web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f web</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web --link db:db training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。</p><p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p><p>使用 <code>docker ps</code> 来查看容器的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">349169744e49 training&#x2F;postgres:latest su postgres -c &#39;&#x2F;usr About a minute ago Up About a minute 5432&#x2F;tcp db, web&#x2F;db </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 16 hours ago Up 2 minutes 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p><p>Docker 通过 2 种方式为容器公开连接信息</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件<br>使用 <code>env</code> 命令来查看 web 容器的环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training&#x2F;webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME&#x3D;&#x2F;web2&#x2F;db DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP_PROTO&#x3D;tcp DB_PORT_5000_TCP_PORT&#x3D;5432 DB_PORT_5000_TCP_ADDR&#x3D;172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</li></ul><p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training&#x2F;webapp &#x2F;bin&#x2F;bash</span><br><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">. . . </span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 </p><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# apt-get install -yqq inetutils-ping root@aed84ee21bde:&#x2F;opt&#x2F;webapp# ping db  </span><br><span class="line">PING db (172.17.0.5):  48 data bytes </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.267 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.250 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.256 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试db容器，它会解析成 <code>172.17.0.5</code>。<br>*注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/xc_zhou/article/details/80952307&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xc_zhou/article/details/80952307&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker-容器&quot;&gt;&lt;a href=&quot;#Docker-容器&quot; class=&quot;headerlink&quot; title=&quot;Docker 容器&quot;&gt;&lt;/a&gt;Docker 容器&lt;/h2&gt;&lt;p&gt;容器是 Docker 又一核心概念。&lt;/p&gt;
&lt;p&gt;简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。&lt;/p&gt;
&lt;h2 id=&quot;启动容器&quot;&gt;&lt;a href=&quot;#启动容器&quot; class=&quot;headerlink&quot; title=&quot;启动容器&quot;&gt;&lt;/a&gt;启动容器&lt;/h2&gt;&lt;p&gt;启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。&lt;/p&gt;
&lt;p&gt;因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>3.2-Docker镜像用法</title>
    <link href="http://javassun.github.io/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/</id>
    <published>2019-06-05T11:37:41.000Z</published>
    <updated>2020-04-14T06:42:34.458Z</updated>
    
    <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><a id="more"></a><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx&#x2F;</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 <code>RUN</code>指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每一层构建需要的命令写出来,比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make&#39;  \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y  $buildDeps  \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.5.tar.gz&quot;  \  &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1  \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/23fb64e2-2346-432d-8f39-dad51df5c6a3.png" alt></p><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2/2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>785a648f6b86</code>，执行了所要求的命令，并最后提交了这一层 <code>3974e15fde03</code>，随后删除了所用到的这个容器 <code>785a648f6b86</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，我原本以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是_相对路径_。这也是新人经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 . </span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code>命令了。</p><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。<br><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo  $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。0</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>NTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run myip -i </span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通 </span><br><span class="line">$ docker run myip -i </span><br><span class="line">HTTP&#x2F;1.1  200 OK </span><br><span class="line">Server: nginx&#x2F;1.8.0  </span><br><span class="line">Date: Tue, 22 Nov 2016  05:12:40 GMT </span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8 </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2 </span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6 </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Via: 1.1  cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4  </span><br><span class="line">... </span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis </span><br><span class="line">... </span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] </span><br><span class="line"></span><br><span class="line">EXPOSE 6379 CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">... </span><br><span class="line"># allow the container to be started with &#96;--user&#96;  </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39;  -a  &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then </span><br><span class="line">chown -R redis . </span><br><span class="line">exec su-exec redis &quot;$0&quot;  &quot;$@&quot;  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec  &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \ </span><br><span class="line">NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ </span><br><span class="line">&amp;&amp; curl -SLO  &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \ </span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ </span><br><span class="line">&amp;&amp; grep  &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c -\ </span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \ </span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ </span><br><span class="line">&amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量引用： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v mydata:&#x2F;data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app </span><br><span class="line">RUN echo  &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常.</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code>格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \ </span><br><span class="line">CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker  run  -d  --name  web  -p 80:80  myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  3  seconds ago Up 2  seconds (health: starting) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  18  seconds ago Up 16  seconds (healthy) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code></p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool </span><br><span class="line">&#123; </span><br><span class="line">    &quot;FailingStreak&quot;: 0, </span><br><span class="line">    &quot;Log&quot;: [ </span><br><span class="line">        &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, </span><br><span class="line">        &quot;ExitCode&quot;: 0, </span><br><span class="line">        &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;&#x2F;p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.org&#x2F;\&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;\nCommercial support is available at\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.com&#x2F;\&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&quot;, </span><br><span class="line">        &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; </span><br><span class="line">    &#125; </span><br><span class="line">], </span><br><span class="line">&quot;Status&quot;: &quot;healthy&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ONBUILD-镜像复用及项目环境管理"><a href="#ONBUILD-镜像复用及项目环境管理" class="headerlink" title="ONBUILD 镜像复用及项目环境管理"></a>ONBUILD 镜像复用及项目环境管理</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F; </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。�第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新</p><p>么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">ONBUILD COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">ONBUILD COPY . &#x2F;app&#x2F;</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker rmi</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><em>注意 <code>docker rm</code> 命令是删除容器，不要混淆</em></p><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。<br>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY  TAG  IMAGE  ID  CREATED  SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5  MB redis alpine 501ad78535f0  3 weeks ago 21.03  MB docker latest cf693ec9b5c7 3 weeks ago 105.1  MB nginx latest e43d811ce2f4 5 weeks ago 181.5  MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 501</span><br><span class="line">Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi centos </span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged:centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c </span><br><span class="line">Deleted:sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted:sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests </span><br><span class="line">REPOSITORY  TAG  DIGEST  IMAGE  ID  CREATED  SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214  MB  $ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="用-docker-images-命令来配合"><a href="#用-docker-images-命令来配合" class="headerlink" title="用 docker images 命令来配合"></a>用 docker images 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。如删除虚悬镜像的指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/xc_zhou/article/details/80952307&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xc_zhou/article/details/80952307&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-Dockerfile-定制镜像&quot;&gt;&lt;a href=&quot;#使用-Dockerfile-定制镜像&quot; class=&quot;headerlink&quot; title=&quot;使用 Dockerfile 定制镜像&quot;&gt;&lt;/a&gt;使用 Dockerfile 定制镜像&lt;/h2&gt;&lt;p&gt;从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的&lt;strong&gt;指令(Instruction)&lt;/strong&gt;，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;
&lt;p&gt;还以之前定制 &lt;code&gt;nginx&lt;/code&gt; 镜像为例，这次我们使用 Dockerfile 来定制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>3.1-Docker用法</title>
    <link href="http://javassun.github.io/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/</id>
    <published>2019-05-24T09:34:17.000Z</published>
    <updated>2020-04-14T06:42:24.637Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="开启docker服务"><a href="#开启docker服务" class="headerlink" title="开启docker服务"></a>开启docker服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动并加入开机启动</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line">验证安装是否成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">有 client 和 server两部分即表示安装成功。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取镜像命令-docker-pull"><a href="#获取镜像命令-docker-pull" class="headerlink" title="获取镜像命令 docker pull"></a>获取镜像命令 docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，而镜像名称的格式：</p><ul><li><p>Docker Registry地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，既 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像.一定要配置镜像加速器,不然下载速度很慢。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="pull下来的-镜像-存储在哪里呢？"><a href="#pull下来的-镜像-存储在哪里呢？" class="headerlink" title="pull下来的 镜像 存储在哪里呢？"></a>pull下来的 镜像 存储在哪里呢？</h3></li></ul><p>1 进入 docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">ls</span><br><span class="line">builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>2 进入containers,每一个序列号，都是一个镜像，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd containers&#x2F;</span><br><span class="line"></span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a</span><br><span class="line">a0356a312020a4941b257ada41d72efb041f7034a70a987ec3d0f44e9cc19402</span><br><span class="line">b81decb15c1f1f821d1c56bdadc15b62506b6cc102a6f083ec7a9b5f89c2685b</span><br><span class="line">ea1236fd8c7f4ce919c0f56b87b642487ecd2bbec243d416dd1e34b313b27b92</span><br></pre></td></tr></table></figure><p>3 进入其中一个镜像，发现目录结构如下，这就是这个镜像的内容了，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun 61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a]# ls</span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a-json.log  hostconfig.json  mounts</span><br><span class="line">checkpoints                                                                hostname         resolv.conf</span><br><span class="line">config.v2.json                                                             hosts            resolv.conf.hash</span><br></pre></td></tr></table></figure><p>4 在containers同级目录，有个叫image的文件夹，进入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd images&#x2F;aufs</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution imagedb layerdb repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br><span class="line"></span><br><span class="line">如果image没有aufs目录的，可能是这样的</span><br><span class="line"></span><br><span class="line">cd image&#x2F;overlay2&#x2F;</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution  imagedb  layerdb  repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br></pre></td></tr></table></figure><h2 id="查看已下载的镜像-docker-images"><a href="#查看已下载的镜像-docker-images" class="headerlink" title="查看已下载的镜像 docker images"></a>查看已下载的镜像 docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">列表 包含了仓库名、标签、镜像ID、创建时间、所占空间。</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               2c5e00d77a67        3 weeks ago         188MB</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">[root@haoransun docker]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9de828f70b6d:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.6 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">root@9de828f70b6d:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令</p><ul><li><p><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:14.04</code>：这是指用<code>ubuntu:14.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 14.04.5 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><p>以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址,还要配置安全组放通对应的端口。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/749278bc-1a21-42ee-9643-a541b55dd3b5.png" alt></p><p>现在，改动这个欢迎页面，改成<code>Hello, Docker!</code>，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker exec -it webserver bash</span><br><span class="line">root@6415ebcbd369:&#x2F;# echo &#39;&lt;h1&gt;Hello,Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">root@6415ebcbd369:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e2cf02a5-8db5-451b-ad15-7144d09e93f2.png" alt></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff webserver</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/dd927ddb-c0ba-47dc-96fa-e7a5f48e5d4f.png" alt></p><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><p>现在已经定制好了,那我们如何把它保存下来形成镜像?</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而<strong>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>下面的命令将容器保存为镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker commit --author &#39;haoransun&lt;xxxx@qq.com&gt;&#39; --message &#39;修改Nginx欢迎页面&#39; webserver nginx:v2</span><br><span class="line">sha256:cef47606fca7dd6a5ee72986d18641ac754973120312a7015bb228dee64cc02a</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/d21dbdd8-e230-4888-b179-46ba0b5d22fd.png" alt></p><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。</p><p>可以用 <code>docker images</code> 命令看到这个新定制的镜像：</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e168773c-e547-4d5a-86fb-d72e60cee08d.png" alt></p><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/782171db-773a-4ade-8335-092e6da4d2d6.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。否则访问 虚拟机的地址如：192.168.121.100:81。</p><p>完成了第一次定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用  docker commit"></a>慎用  docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心没有清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p><code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制行为应该使用 <code>Dockerfile</code> 来完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;开启docker服务&quot;&gt;&lt;a href=&quot;#开启docker服务&quot; class=&quot;headerlink&quot; title=&quot;开启docker服务&quot;&gt;&lt;/a&gt;开启docker服务&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;启动并加入开机启动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl start docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl enable docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;验证安装是否成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有 client 和 server两部分即表示安装成功。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2.2-Docker启动报错</title>
    <link href="http://javassun.github.io/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
    <id>http://javassun.github.io/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</id>
    <published>2019-05-23T10:32:24.000Z</published>
    <updated>2020-04-14T06:42:17.874Z</updated>
    
    <content type="html"><![CDATA[<p>出处：<a href="https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA</a></p><h2 id="Docker虚拟化故障"><a href="#Docker虚拟化故障" class="headerlink" title="Docker虚拟化故障"></a>Docker虚拟化故障</h2><p>Docker虚拟化主要有三类故障：<br><strong>应用故障：</strong>应用执行状态与预期不一致。</p><p><strong>容器故障：</strong>无法正确创建、停止、更新容器等。</p><p><strong>集群故障：</strong>集群创建失败、更新失败、无法连接等。</p><a id="more"></a><h2 id="Docker-虚拟化故障排错"><a href="#Docker-虚拟化故障排错" class="headerlink" title="Docker 虚拟化故障排错"></a>Docker 虚拟化故障排错</h2><p>所有的Docker虚拟化故障排查诊断，都可以通过Docker命令行工具或者Web控制台来完成。</p><p>通过WEB控制台查看，需要自建控制台，对于Docker运维管理员来说，命令行工具排错是一个不错的帮手。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><strong>案例描述：</strong><br>生产环境，全新安装的Docker无法启动，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  docker.service</span><br><span class="line">Job for docker.service failed because the control process exited with  error code.See</span><br><span class="line">&quot;systemctl status docker.service&quot;  and  &quot;journalctl -xe&quot;  for details</span><br></pre></td></tr></table></figure><p>通过journalctl -xe命令查看启动的详细日志，启动daemon错误，因为Selinux不支持，Selinux阻挡了Docker引擎的启动，如图所示：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/bffe455a-b137-4cd1-b009-874dbeaaebf8.jpg" alt></p><p><strong>解决方案：</strong><br>如上问题，解决方法有两种：</p><p>1.Selinux主配置文件：</p><p>/etc/selinux/config，将配置文件中enforcing设置为disabled，然后重启系统，然后重启docker引擎即可。</p><p>2.docker主配置文件：</p><p>/etc/sysconfig/docker，将配置文件中–selinux-enabled选项为false，改成：–selinux-enabled=false即可。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  socket at step GROUP: No such process</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/3bf44228-5466-47a3-a7fb-eae0c2c85e13.jpg" alt></p><p><strong>解决方案：</strong><br>如上错误提示是因为Docker无法找到Group组信息，docker组有可能被误删除，解决方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.创建宿主机docker组即可，命令：groupadd docker；</span><br><span class="line">2.&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket文件，SocketGroup&#x3D;修改为root也可以；</span><br></pre></td></tr></table></figure><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/4c8256fb-0669-4cc5-9381-30b95b45422f.jpg" alt></p><p>如上错误提示是因为Linux操作系统没有更多的Loopback 设备给Docker使用。</p><p><strong>解决方案：</strong><br>创建更多的Loopback设备即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i inseq 0 6;do mknod -m 0660 &#x2F;dev&#x2F;loop$i b 7 $i;done</span><br></pre></td></tr></table></figure><h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><p><strong>案例描述：</strong></p><p>Docker命令执行，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:</span><br><span class="line">&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>根据如上错误提示，该错误很明显可能是docker没有启动。</p><p><strong>解决方案：</strong></p><p>检测docker进程是否启动，ps -ef|grep docker，如果没有启动，启动Docker即可。</p><p>检测Docker进程存在，但是无法连接，可以重启一下Docker服务，检测一下Sock路径是否正确；<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/0e4560e9-3eff-484b-8da3-96e821d660ab.jpg" alt></p><h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><p><strong>案例描述：</strong><br>Docker获取远程镜像，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: dial tcp: lookup registry-1.docker.io</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/57f33576-3246-41b0-be58-c5382485a341.png" alt></p><p>该错误表示无法连接远程仓库Docker.io。</p><p><strong>解决方案：</strong></p><p>查看本地是否配置DNS，能否ping通docker.io；</p><p>如果能够ping通，但是下载还是比较慢，可以修改Docker仓库源为国内或者自建的仓库源；</p><p>Docker镜像修改方法，vim /etc/docker/daemon.json，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at&gt;&#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="案例6"><a href="#案例6" class="headerlink" title="案例6"></a>案例6</h3><p><strong>案例描述：</strong><br>启动Docker容器，报错信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;&#x2F;bin&#x2F;bash\&quot;: executable file not found in $PATH&quot;.</span><br></pre></td></tr></table></figure><p>如上报错，通常是由于容器启动时，不支持该命令：/bin/bash。</p><p><strong>解决方案：</strong></p><p>解决方法有如下两种：</p><p>修改启动命令为正确的Docker容器启动命令，例如修改为：/bin/sh或者sleep 99999d等；</p><p>Docker镜像自身问题或者Docker引擎版本比较低导致，可以升级Docker引擎版本服务；</p><h3 id="案例7"><a href="#案例7" class="headerlink" title="案例7"></a>案例7</h3><p><strong>案例描述：</strong><br>Docker虚拟化运行中，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br></pre></td></tr></table></figure><p>如上错误，表示Docker虚拟化引擎平台，没有多月的空间设备所使用，证明容器磁盘不足或者物理机磁盘不足。</p><p><strong>解决方案：</strong></p><p>手工删除Docker容器占用数据比较大的目录；</p><p>或者通过docker system prune自动删除一些日志目录，此种方法会停止所有容器；</p><p>或者临时增加Docker存储硬盘等；</p><h3 id="案例8"><a href="#案例8" class="headerlink" title="案例8"></a>案例8</h3><p><strong>案例描述：</strong><br>Docker push上传镜像至本地仓库报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [106.12.133.186:5000&#x2F;busybox] Get https:&#x2F;&#x2F;106.12.133.186:5000&#x2F;v1&#x2F;_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>根据如上错误提示，错误是由于客户端采用https，docker registry未采用https服务所致。一种处理方式是把客户对地址“106.12.133.186:5000”请求改为http。</p><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件。</span><br><span class="line">在文件中写入：&#123; &quot;insecure-registries&quot;:[&quot;106.12.133.186:5000&quot;] &#125; 。</span><br></pre></td></tr></table></figure><p>保存退出后，重启docker服务，问题即可解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出处：&lt;a href=&quot;https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Docker虚拟化故障&quot;&gt;&lt;a href=&quot;#Docker虚拟化故障&quot; class=&quot;headerlink&quot; title=&quot;Docker虚拟化故障&quot;&gt;&lt;/a&gt;Docker虚拟化故障&lt;/h2&gt;&lt;p&gt;Docker虚拟化主要有三类故障：&lt;br&gt;&lt;strong&gt;应用故障：&lt;/strong&gt;应用执行状态与预期不一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器故障：&lt;/strong&gt;无法正确创建、停止、更新容器等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集群故障：&lt;/strong&gt;集群创建失败、更新失败、无法连接等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>2.1-Docker安装与部署</title>
    <link href="http://javassun.github.io/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://javassun.github.io/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</id>
    <published>2019-05-18T11:29:53.000Z</published>
    <updated>2020-04-14T06:37:00.514Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.</p><a id="more"></a><figure class="highlight plain"><figcaption><span>库必须启用。默认情况下，此存储库已启用，但是如果将其禁用，则需要**重启启用它**。（自行搜索）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">overlay2 建议使用存储驱动程序。</span><br></pre></td></tr></table></figure><p>uname -r # 可查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 卸载旧版本</span><br><span class="line">旧版本的Docker被称为 docker 或 docker-engine。如果已安装这些，请卸载它们及相关的依赖项、</span><br></pre></td></tr></table></figure><p>$ sudo yum remove docker <br>                  docker-client <br>                  docker-client-latest <br>                  docker-common <br>                  docker-latest <br>                  docker-latest-logrotate <br>                  docker-logrotate <br>                  docker-engine</p><p>如果 yum报告没有安装这些软件包，则可以了、<br>/var/lib/docker/ 保留包括图像、容器、卷和网络在内的内容。现在调用Docker CE包  docker-ce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 安裝 Docker</span><br><span class="line">参考0-Docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Docker 通过运行 hello-world 映像验证是否正确安装。**</span><br></pre></td></tr></table></figure><p>docker run hello-world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此命令下载测试镜像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。如果你没有配置镜像加速器的话,运行 hello-world 命令来验证也是不会成功的.因为国内网络的原因,无法下载测试镜像,更别说运行测试镜像了,&lt;font color&#x3D;red&gt;配置镜像加速器--参考0&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">## 查看当前Docker版本</span><br></pre></td></tr></table></figure><p>docker -v</p><p>docker version</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;系统要求&quot;&gt;&lt;a href=&quot;#系统要求&quot; class=&quot;headerlink&quot; title=&quot;系统要求&quot;&gt;&lt;/a&gt;系统要求&lt;/h2&gt;&lt;p&gt;Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 &lt;code&gt;overlay2&lt;/code&gt; 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>1-Docker缘由</title>
    <link href="http://javassun.github.io/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/"/>
    <id>http://javassun.github.io/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/</id>
    <published>2019-05-12T12:23:22.000Z</published>
    <updated>2020-04-14T06:29:27.123Z</updated>
    
    <content type="html"><![CDATA[<p>作者：雪雁<br><a href="https://www.cnblogs.com/codelove/p/10030439.html" target="_blank" rel="noopener">文章转载出自这里</a>：<a href="https://www.cnblogs.com/codelove/" target="_blank" rel="noopener">https://www.cnblogs.com/codelove/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着生产力的发展尤其是弹性架构的广泛应用（如微服务），许多一流开发者都将应用托管到了应用容器上，如Google、微软、亚马逊、阿里、京东、新浪等等。</p><a id="more"></a><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093206616-399407280.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093217472-1718656903.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093230803-632908603.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093244576-449593766.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093301329-915864692.png" alt></p><p>从未来的发展方向来看，容器引擎将会越来越成为主流，哪怕不是弹性架构，托管到应用容器也将是一种趋势——因为更低的开发运维和托管成本以及对服务器资源的优化配置，而且未来一个很大的趋势是————<strong>无服务器计算服务</strong></p><p>因为相对于软件、硬件在本地设备上的分裂，云计算的一大特性就是将服务构建在云上，供多种设备同时无缝调用。但事实上，云服务在发展的过程中还没能实现<strong>共融共通</strong>的理想————比如，各家的云服务是相对割裂的，开发者基于Google云服务构建的软件拿到亚马逊的AWS上也许就不能用了，阿里云的应用迁移到腾讯云可能就存在问题了；在任务执行层面，为防止互相干扰，云服务厂商在同一台服务器上执行多个任务时也会将他们隔离进行、很明显，这样的实例情况和云服务器的初始理念相去甚远。而利用容器技术，软件可以快速在各类云服务和基础设施上转换。而且，当割裂问题被解决后，软件也有希望在瞬间获取大量的计算能力。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093417505-465374977.png" alt></p><p>而Docker,就是容器引擎中的佼佼者，并且已经得到了广泛的实践和应用。有了Docker之后，软件的开发工作将会变得更加容易。如：开发者在笔记本电脑上写完一个软件后，可以将它转移到云服务上运行而无需做出更改；无论是自己的服务器、数据中心还是Google、微软、阿里云的云计算服务器，开发人员都可以按自己的想法在任何基础设施之间转移自己的软件。这也是未来的一个愿景——————<strong>机器和基础设施之间是可以互相替代的，整个互联网就是一个巨大的计算机</strong>。</p><p>Docker是如此的令人向往和引人深入，但是在国内，开发者普遍迁移到云端基本上也都是只用到了虚拟机等基础设施，其实大家都听过Docker,但是有一些偏见：</p><ul><li>缺乏完整的系统的教程和实践。开发者普遍认为使用Docker很麻烦，只有大公司用，门槛高‘</li><li>云端容器服务产品用户体验不多，对于初学者门槛太高——————此处是指消化这列概念和理念，并且能够掌握和可控。</li><li>对容器服务的认知还不够，对它的好处及吸引之处不太了解。</li><li>认为对现有系统、架构改造太大，成本太高；</li><li>认为Docker只是一种单纯的相对先进的技术，并不能给现有的开发带来什么概念；</li></ul><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译通过的容器可以批量的在生产环境中部署，包括VMs(虚拟机)、bare metal、OpenStack集群和其他的基础应用平台。</p><p>简单理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093811704-1643592196.png" alt></p><p>因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器就充当着 软件部署 的标准单元，其中可以包含不同的代码和依赖项。按照这种方式的容器化软件。开发人员和IT专业人员只需要进行极少修改或者不修改，即可将其部署到不同的环境。</p><p>总而言这，Docker是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA和生产环境之间进行高效的应用程序生命周期管理。</p><h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093906502-569967575.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093915205-139200956.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093934953-2128627412.png" alt></p><p>如上图所示，由于容器所需的资源要少很多（例如，他们不需要一个完整的OS），所以它们易于部署且可以快速启动、这使得你能够具有更高部署密度。即<strong>允许在同一硬件单元上运行更多服务，从而降低了成本。</strong></p><p>在同一内核上运行的时候，你获得的隔离比VM少。</p><p><font color="red">镜像的主要目标是使环境（依赖项）在不同的部署中保持不变。</font>，即可以在计算机上调试它，然后将其部署到保证具有相同环境的另一台计算机上。</p><p>借助容器镜像，可打包应用或者服务 并采用可靠且可重现的方式对其进行部署。可以说Docker不只是一种技术，还是一种原理和过程。</p><p>在使用Docker之前，经常听到，“这个问题在开发环境是正常的！”。而在使用Docker后，你不会听到开发人员说：“为什么它能在我的计算机上使用却不能用在生产中？”。开发人员只需要说 “它在Docker上运行”，因为打包的Docker应用程序可在任何支持的Docker环境上执行，而且它在所有部署目标（开发、QA、暂停和生产）上都按期运行。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a>镜像：一个特殊的文件系统</h2><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂在root文件系统为其提供用户空间支持。而Docker镜像相当于是一个root文件系统。</p><p><strong>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（匿名卷、环境变量、用户等）。</strong></p><p>镜像是不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时。就充分利用 <strong>Union FS</strong>技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如：删除前一层文件的操作，实际上不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像时，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变得更为容易，甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的容器，构建新的镜像。</p><h2 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a>容器：镜像运行时的实体</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中 类 和 实例一样，镜像时静态的定义，容器是进行运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己独立的命名空间，前面说过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按着Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态变化。</p><p>所有文件的写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094117580-274999612.png" alt></p><p><strong><font color="red">注意：</font></strong><br>容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。最重要的优点是可在开发和运营之间提供隔离。</p><h2 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a>仓库：集中存放镜像文件的地方</h2><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。<strong>Docker Registry</strong>就是这样的服务。</p><p>一个Docker Registry 中可以包含多个仓库（Repository）:每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。</p><p>所以说，镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以latest作为默认标签。</p><p>这里补充一下：Docker Registry公开服务和私有 Docker Registry 的概念。</p><p>一般这类公共服务允许用户免费上传、下载公开镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常用的Registry 公开服务是官方的 <a href="hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>在国内访问Docker Hub可能比较慢，国内有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了公开服务外，用户还可以在本地搭建私有Docker Registry。Docker官方提供了 Docker Registry 镜像，可以直接使用作为私有Registry服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API的服务端实现，足以支持Docker命令，不影响使用，但不含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h2 id="Docker的主要应用场景"><a href="#Docker的主要应用场景" class="headerlink" title="Docker的主要应用场景"></a>Docker的主要应用场景</h2><h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p><p>简单来说，容器镜像打包完成后，它就是个独立的个体了，丢到哪里都能跑，而无需针对各个平台去独立配置。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094246244-759574629.png" alt></p><h2 id="代码流水线（Code-Pipeline）管理"><a href="#代码流水线（Code-Pipeline）管理" class="headerlink" title="代码流水线（Code Pipeline）管理"></a>代码流水线（Code Pipeline）管理</h2><p>前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094322089-159857776.png" alt></p><h2 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h2><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想要快速搭建开发环境。</p><p>使用Docker非常简单的就能实现这两点，哪怕是开发环境的机器配置一般的情况下搭建多个生产服务应用。一台一般配置服务器或者开发机器也能轻松的跑起多个Docker应用，而无需额外增加机器配置。因为Docker有个非常NB的特性，<strong>拥有虚拟化的特性</strong>，而几乎没有额外的开销。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094410700-1435124978.png" alt></p><h2 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h2><p>很多情况下，我们需要在一台服务器上运行多个不同的应用，比如上面提到的提高开发效率的场景等。</p><p>考虑三点：一是因为要降低成本而进行服务器整合，二是讲一个整体式的应用拆分成松耦合的单个服务（如微服务架构），三是还需要考虑应用之间的兼容性。而对于Docker来说，支持起来非常简单。同一台机器，可以同时运行N个Docker Web应用，托管到不同的Web服务器（Kestrel、Nginx、Tomcat），而无需担心他们会搞起3Q大战，也不用担心开发机器跑步起来。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094456537-87357208.png" alt></p><h2 id="整合服务器"><a href="#整合服务器" class="headerlink" title="整合服务器"></a>整合服务器</h2><p>虚拟机可以整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p><p>这意味着资源得到更有效的利用——————可以做更多的衣服，而且没有边角料，成本更低。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094534267-1497649789.png" alt></p><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Docker提供很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多功能，包含可以设置容器检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094617391-1947396056.png" alt></p><h2 id="多租户环境"><a href="#多租户环境" class="headerlink" title="多租户环境"></a>多租户环境</h2><p>在多租户的应用中，它可以避免关键应用的重写。比如IoT(物联网)的应用中，开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间、也浪费金钱。</p><p>使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。</p><p>就如同我们现在写了一个不支持多租户的业务程序，而实际的业务中经常会出现需要支持多租户或者有新客户需要使用的场景，这时们通常的简单是——————部署一套新的代码。当站点达到一定量的适合，要么重写程序，要么维护人员Game Over。</p><h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。</p><p>你可以在服务器中或云端创建销毁资源而无需担心重新启动带来的开销。通常情况下，服务器的资源利用率只有30%，而通过使用Docker并进行有效的资源分配可以提高资源的利用率。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094717810-819940111.png" alt></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094748866-356935721.png" alt></p><p>Docker 带来的敏捷性（响应速度和灵活性）吸引了越来越多的开发者。他们不仅能知道容器内部到底跑了什么，也能进一步理解 Docker 如何加速了软件开发进程。另外，41% 的用户表示应用的可移植性是他们决定使用 Docker 的关键因素。</p><p><strong>通过 DevOps 的实践，Docker 正在给应用交付带来很多可以量化的提升</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094834979-29905994.png" alt></p><p>大约一半的受访者表示已经采用了持续集成（CI）和 DevOps，并且希望把这些实战经验应用到生产环境的持续交付中。剩下的受访者则准备尽快跟上步伐，尽快尝试 DevOps 和持续集成。另外，据调查显示，用户使用 Docker 发布应用的频率平均提升了 13 倍。</p><p><strong>Docker 对混合云策略至关重要，它使得用户可以根据需求自由选择私有和公有环境</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094910142-643670153.png" alt></p><p>通过容器来交付的应用可以在任何基础设施之上灵活迁移，同时这些基础设施又可以提供不同层次的应用管理方式，而当业务在多个服务供应商之中寻求混合云或全云模式时，又可以完美避免被平台捆绑。</p><p>对于按需部署或部署到云环境，Docker 提供了独一无二的选择。 80% 的用户表示 Docker 已经成为他们云策略的一部分，超过 35% 的用户使用 Docker 来避免被云服务供应商绑定。</p><p><strong>Docker 实现了微服务架构，也让遗留的单体应用转变为现代应用</strong></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094948673-1019599700.png" alt></p><p>Docker 使得微服务架构的快速发展成为可能，同时它也将传统的业务迁移到容器环境中，以此使得应用程序变得更加可移植。<strong>使用微服务架构进行交付是 Docker 的关键优势！</strong></p><h2 id="Docker改变了什么？"><a href="#Docker改变了什么？" class="headerlink" title="Docker改变了什么？"></a>Docker改变了什么？</h2><ul><li><p>Docker改变了云服务，使云服务的共融共通的理想逐步成为了可能。并且Docker 已经是云策略的一部分，许多开发者正在计划使用 Docker 将业务迁移到云端。另外，为了避免被云服务供应商绑定，Docker成为很多开发者的首选。</p></li><li><p>Docker改变了产品交付，为产品的整个生命周期提供了一整套的解决方案和流程。</p></li><li><p>Docker改变了开发方式，提供了简化的环境配置、封装的运行环境以及统一的环境。并且提供了快速部署的方式。</p></li><li><p>Docker改变了测试，多版本测试变得极为方便，快速构建测试环境也变得更加简单并且无需开发人员干预或者搭建。</p></li><li><p>Docker改变了运维，环境的一致性让运维变得更加简单，同时热更新的支持让运维不再需要半夜加班部署更新，更新可以随时进行。当出现重大问题时，还能快速回滚到指定版本。</p></li><li><p>Docker改变了架构，自动化扩容支持让架构变得更加简单，分布式系统也更加易于搭建和支持。同时遗留的单体应用也很易于转变为现代应用。</p></li></ul><p>总之，在某种程度上，Docker改变了产品开发中的一些游戏规则。虽然Docker是一项技术，但是它也带来了新的思维，新的流程和工作方法，Docker在推动行业的发展，Docker已经在改变世界，并且在逐步的变为事实……<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128095105560-528324521.png" alt></p><h1 id="Docker持续开发工作流"><a href="#Docker持续开发工作流" class="headerlink" title="Docker持续开发工作流"></a>Docker持续开发工作流</h1><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203093658359-1691324108.png" alt></p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094045768-1316009773.png" alt></p><p>虽然我们可以通过docker commit命令来手动创建镜像，但是通过Dockerfile文件，可以帮助我们自动创建镜像，并且能够自定义创建过程。本质上，Dockerfile就是由一系列<strong>命令</strong>和<strong>参数</strong>构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它简化了从头到尾的构建流程并极大的简化了部署工作。使用dockerfile构建镜像有以下好处：</p><ul><li><p>像编程一样构建镜像，支持分层构建以及缓存；</p></li><li><p>可以快速而精确地重新创建镜像以便于维护和升级；</p></li><li><p>便于持续集成；</p></li><li><p>可以在任何地方快速构建镜像</p></li></ul><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>Dockerfile 指令为 Docker 引擎提供了创建容器映像所需的步骤。这些指令按顺序逐一执行。</p><h4 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1.FROM"></a><strong>1.FROM</strong></h4><p>ROM 指令用于设置在新镜像创建过程期间将使用的容器映像。<br>格式：FROM<br>示例：<br>FROM nginx</p><h4 id="2-RUN"><a href="#2-RUN" class="headerlink" title="2.RUN"></a><strong>2.RUN</strong></h4><p>RUN 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。<br>格式：<br>RUN [“”, “”, “”]<br>RUN<br>示例：<br>RUN apt-get update<br>RUN mkdir -p /usr/src/redis<br>RUN apt-get update &amp;&amp; apt-get install -y libgdiplus<br>RUN [“apt-get”,”install”,”-y”,”nginx”]</p><p>注意：<font color="red">每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。使用换行符时，可能会遇到一些问题，具体可以参阅下节的转义字符</font>。</p><h4 id="3-COPY"><a href="#3-COPY" class="headerlink" title="3.COPY"></a><strong>3.COPY</strong></h4><p>COPY 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 Dockerfile 的路径中。<br>式：<br>COPY<br>如果源或目标包含空格，请将路径括在方括号和双引号中。<br>COPY [“”, “”]<br>示例：<br>COPY . .<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY . /usr/share/nginx/html<br>COPY hom* /mydir/</p><h4 id="4-ADD"><a href="#4-ADD" class="headerlink" title="4.ADD"></a><strong>4.ADD</strong></h4><p>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。<br>格式：<br>ADD<source> <destination><br>示例：<br>ADD <a href="https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe</a> /temp/python-3.5.1.exe<br>此示例会将 Python for Windows下载到容器映像的 c:\temp 目录。</destination></p><h4 id="5-WORKDIR"><a href="#5-WORKDIR" class="headerlink" title="5.WORKDIR"></a><strong>5.WORKDIR</strong></h4><p>WORKDIR 指令用于为其他 Dockerfile 指令（如 RUN、CMD）设置一个工作目录，并且还设置用于运行容器映像实例的工作目录。<br>格式：<br>WORKDIR<br>示例：<br>WORKDIR /app</p><h4 id="6-CMD"><a href="#6-CMD" class="headerlink" title="6.CMD"></a><strong>6.CMD</strong></h4><p>CMD指令用于设置部署容器映像的实例时要运行的默认命令。例如，如果该容器将承载 NGINX Web 服务器，则 CMD 可能包括用于启动Web服务器的指令，如 nginx.exe。 如果 Dockerfile 中指定了多个CMD 指令，只会计算最后一个指令。<br>格式：<br>CMD [“&lt;executable”, “<br>CMD<br>示例：<br>CMD [“c:\Apache24\bin\httpd.exe”, “-w”]<br>CMD c:\Apache24\bin\httpd.exe -w</p><h4 id="7-ENTRYPOINT"><a href="#7-ENTRYPOINT" class="headerlink" title="7.ENTRYPOINT"></a><strong>7.ENTRYPOINT</strong></h4><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。<br>格式：<br>ENTRYPOINT [“”, “”]<br>示例：<br>ENTRYPOINT [“dotnet”, “Magicodes.Admin.Web.Host.dll”]</p><h4 id="8-ENV"><a href="#8-ENV" class="headerlink" title="8.ENV"></a><strong>8.ENV</strong></h4><p>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。<br>格式：<br>ENV==…<br>示例：<br>ENV VERSION=1.0 DEBUG=on <br>NAME=”Magicodes”</p><h4 id="9-EXPOSE"><a href="#9-EXPOSE" class="headerlink" title="9.EXPOSE"></a><strong>9.EXPOSE</strong></h4><p>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。<br>格式：<br>EXPOSE<br>示例：<br>EXPOSE 80<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094342684-400475059.png" alt></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>有几点值得注意的是：</p><ol><li><p>不能忽视dockerfile的优化，通常情况下，我们可以忽略那些细小的优化，但是我们需要知道优化的原理，为什么要优化</p></li><li><p>不能为了优化而优化。镜像的构建过程视业务情况情况不同，指令就有多到少的区别，在很多情况下，我们先要以满足业务目标为准，而不是镜像层数。如果需要减少镜像的层数，我们一定要选择合适的基础镜像，或者创建符合我们需要的基础镜像。</p></li></ol><p>优化准则：</p><ul><li><p>选择合适的基础镜像</p><p>这点相对最为重要。为什么这么说，我们结合现实社会也可以看到，在大部分情况下，一个人一生的成就更多的是看出身。很多情况下，基因和出身决定了你的高度和终点，这点拿到技术层面来说，也是有很大道理的，因此我们需要选择合适的父母——一个合适的镜像。</p><p>一个合适的基础镜像是指能满足运行应用所需要的最小的镜像，理论上是能用小的就不要用大的，能用轻量的就不要用重量级的，能用性能好的就不要用性能差的。这里有时候还需要考虑那些能够减少我们构建层数的基础镜像。</p></li><li><p>优化指令顺序</p><p>Docker会缓存Dockerfile中尚未更改的所有步骤，但是，如果更改任何指令，将重做其后的所有步骤。也就是指令3有变动，那么4、5、6就会重做。因此，我们需要将最不可能产生更改的指令放在前面，按照这个顺序来编写dockerfile指令。这样，在构建过程中，就可以节省很多时间。比如，我们可以把WORKDIR、ENV等命令放前面，COPY、ADD放后面。</p></li><li><p>合并指令</p><p>前面其实我们提到过这点，甚至还特地讲到了转义字符，其实主要是为此服务。前面我们说到了，每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p></li><li><p>删除多余文件和清理没用的中间结果</p><p>这点很易于理解，通常来讲，体积更小，部署更快！因此在构建过程中，我们需要清理那些最终不需要的代码或文件。比如说，临时文件、源代码、缓存等等。</p></li><li><p>使用 .dockerignore</p><p>.dockerignore文件用于忽略那些镜像构建时非必须的文件，这些文件可以是开发文档、日志、其他无用的文件。例如:<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094654908-278191045.png" alt></p></li></ul><h2 id="创建自定义Docker镜像"><a href="#创建自定义Docker镜像" class="headerlink" title="创建自定义Docker镜像"></a>创建自定义Docker镜像</h2><p>创建了Dockerfile之后，需为应用程序中的每项服务创建一个相关镜像。如果应用程序由单个服务或 Web 应用程序组成，则只需创建一个镜像。</p><p>我们可以使用docker build命令来创建镜像，例如：<br>docker build ./ -t {镜像名称}</p><p>镜像打包好后，我们使用docker image ls命令即可查看当前镜像。</p><p>注意：Docker镜像使用分层存储的架构，也就是说镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。因为分层存储的特征，使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。所以，当我们使用Docker images命令，会列出这么多的镜像，我们可以定期清理那些无用的镜像。</p><h2 id="在-docker-compose-yml中定义服务"><a href="#在-docker-compose-yml中定义服务" class="headerlink" title="在 docker-compose.yml中定义服务"></a>在 docker-compose.yml中定义服务</h2><h3 id="关于-Compose"><a href="#关于-Compose" class="headerlink" title="关于 Compose"></a>关于 Compose</h3><p>Compose是一个用于定义和运行多Docker应用程序的工具。使用Compose，我们可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，我们就可以从配置中创建并启动所有服务。</p><p>Compose适用于所有环境：生产环境、模拟（演示）环境、开发环境和测试环境以及CI工作流程。</p><p>主要功能和特性：</p><ul><li><p>单个主机上的多个隔离环境</p><p>Compose使用项目名称来隔离环境，因此可以根据不同的环境要求来进行定义。</p></li><li><p>创建容器时保留卷数据</p><p>Compose会保留服务使用的所有卷和数据。当使用docker-compose up命令运行时，如果发现该服务之前运行过，它会将进行增量操作，可确保在卷中创建的数据都不会丢失。</p></li><li><p>仅重新创建已更改的容器</p><p>Compose存在缓存，可用于创建容器。当重新启动未更改的服务时，Compose将重用现有容器。</p></li><li><p>可以定义变量，而且可以根据不同环境不同用户之间进行组合使用</p><p>Compose支持Compose文件的变量定义，我们可以使用这些变量为不同环境或不同用户进行自定义组合。</p></li></ul><p>另外，Compose能够通过命令管理应用程序的整个生命周期，通过命令可以：</p><ul><li><p>启动，停止和重建服务等</p></li><li><p>查看正在运行的服务的状态</p></li><li><p>通过流输出正在运行的服务的日志</p></li><li><p>对某个服务执行命令</p></li></ul><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li><p>开发或本地环境运行多个服务</p><p>在开发过程时，在隔离环境中运行应用程序并与之交互的能力至关重要。Compose命令行工具可用于创建环境并与之交互。比如通过Compose文件，配置所有应用程序的服务依赖（数据库，消息队列，高速缓存，Web服务的API，等等），然后使用单个命令（docker-compose up）为每个依赖项创建和启动一个或多个容器，使整个程序能够正常运行起来。</p></li><li><p>自动化测试环境</p><p>任何持续部署或持续集成过程的一个重要部分是自动化测试套件。自动化端到端测试需要一个运行测试的环境。Compose提供了一种方便的方法来创建和销毁隔离的测试环境。我们只需要通过在Compose文件，即可定义完整环境，并且可以在几个命令中创建和销毁这些环境，如下所示：</p></li></ul><h2 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h2><p>使用Compose有以下三个步骤：</p><ol><li><p>使用Dockerfile定义应用环境，以便在任意地方进行复制</p></li><li><p>在 docker-compose.yml 中定义组合应用，以便它们可以在隔离的环境中一起运行</p></li><li><p>最后，执行docker-compose up命令，Compose 将启动并运行整个应用程序。</p></li></ol><h2 id="了解docker-compose-yml"><a href="#了解docker-compose-yml" class="headerlink" title="了解docker-compose.yml"></a>了解docker-compose.yml</h2><p>借助 docker-compose.yml 文件，我们可以定义一组相关服务，通过部署命令将其部署为组合应用程序。简单的说，我们可以通过docker-compose.yml来定义多个服务，以便一次执行。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094402699-10239551.png" alt></p><h2 id="了解YAML语言"><a href="#了解YAML语言" class="headerlink" title="了解YAML语言"></a>了解YAML语言</h2><p>YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p><p>这里提供一个YAML语法验证网站：<a href="http://nodeca.github.io/js-yaml/" target="_blank" rel="noopener">http://nodeca.github.io/js-yaml/</a></p><p>基本规则</p><ol><li><p>大小写敏感</p></li><li><p>使用缩进表示层级关系</p></li><li><p>禁止使用tab缩进，只能使用空格键</p></li><li><p>缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级</p></li><li><p>使用#表示注释</p></li><li><p>字符串可以不用引号标注</p></li></ol><p>YAML中允许表示三种格式，分别是常量值，对象和数组，如下所示：<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094613899-1061816782.png" alt></p><h2 id="docker-compose-yml文件配置项"><a href="#docker-compose-yml文件配置项" class="headerlink" title="docker-compose.yml文件配置项"></a>docker-compose.yml文件配置项</h2><p>docker-compose.yml 文件不仅指定正在使用的容器，还指定如何单独配置各容器。常用的配置项如下所示：</p><ul><li><p>uild：定义镜像生成，可以指定Dockerfile文件所在的目录路径，支持绝对路径和相对路径；</p></li><li><p>image：从指定的镜像中启动容器，可以是存储仓库、标签以及镜像 ID，如果镜像不存在，Compose 会自动拉去镜像；</p></li><li><p>environment：定义环境变量和配置；</p></li><li><p>ports：定义端口映射，比如上面配置中将容器上的公开端口 80 转接到主机上的外部端口 9901和9902；</p></li><li><p>depends_on，定义依赖关系。此定义会让当前服务处于等待状态，直到这些依赖服务启动。比如某个服务依赖数据库服务，那么通过此配置解决了服务的启动顺序的问题；</p></li><li><p>volumes，挂载一个目录或者一个已存在的数据卷容器，可以直接使用 HOST:CONTAINER 这样的格式，或者使用 HOST:CONTAINER:ro 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统；</p></li><li><p>context，指定Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url；</p></li><li><p>args,指定构建参数，这些参数只能在构建过程中访问；</p></li><li><p>target，定义构建指定的阶段Dockerfile，比如针对不同阶段使用不同的dockerfile，开发阶段使用支持编译调试的dockerfile，而生产环境，则使用轻量级的dockerfile；command，覆盖默认命令；</p></li><li><p>container_name，指定自定义容器名称，而不是生成的默认名称。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094653278-1319182904.png" alt></p></li></ul><p>小技巧：</p><ul><li><p>可以通过配置项depends_on来定义依赖关系，这点对于控制服务的执行顺序尤为重要，比如先启动数据库然后再启动web服务。</p></li><li><p>如何使用JSON文件进行配置？可以指定文件名称，如下所示：</p><p>docker-compose -f docker-compose.json up</p></li><li><p>如何分阶段构建？推荐使用target配置项。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作者：雪雁&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/codelove/p/10030439.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章转载出自这里&lt;/a&gt;：&lt;a href=&quot;https://www.cnblogs.com/codelove/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/codelove/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着生产力的发展尤其是弹性架构的广泛应用（如微服务），许多一流开发者都将应用托管到了应用容器上，如Google、微软、亚马逊、阿里、京东、新浪等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>0-Docker配置国内免费registry_mirror</title>
    <link href="http://javassun.github.io/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/"/>
    <id>http://javassun.github.io/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/</id>
    <published>2019-05-08T11:23:22.000Z</published>
    <updated>2020-04-14T06:29:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内特殊的网络环境，往往我们从 <strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></strong>中拉取镜像并不能成功，而且速度特别慢。</p><p>那么我们可以给Docker配置一个国内的registry mirror，当我们需要的镜像在mirror中则直接返回，如果没有则从Docker Hub中拉取。<font color="red">是否使用registry mirror对Docker用户来说是透明的</font>。</p><p>DaoCloud在国内提供了首个Docker Hub镜像服务，而且免费，大大提高了国内Docker用户的使用热情。</p><a id="more"></a><h2 id="DaoCloud使用方法"><a href="#DaoCloud使用方法" class="headerlink" title="DaoCloud使用方法"></a>DaoCloud使用方法</h2><p>修改Docker配置文件/etc/default/docker如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;aad0405c.m.daocloud.io&quot;</span><br></pre></td></tr></table></figure><p>使用<code>service docker restart</code>重启Docker服务即可。</p><p>在使用docker下载镜像时，在国内使用官方的Docker registry下载时速度很慢，庆幸国内还镜像加速服务。目前支持Docker镜像的有阿里云和DaoCloud两家。本文将详细讲解镜像服务的具体配置方法。</p><h2 id="Docker使用阿里云镜像库加速（推荐）"><a href="#Docker使用阿里云镜像库加速（推荐）" class="headerlink" title="Docker使用阿里云镜像库加速（推荐）"></a>Docker使用阿里云镜像库加速（推荐）</h2><p>注册阿里云开发者账号<br><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></p><p>登陆后取得专属加速器地址，类似这样 <code>https://9mpi2k3r.mirror.aliyuncs.com</code></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-安装-升级Docker客户端"><a href="#1-安装-升级Docker客户端" class="headerlink" title="1 安装/升级Docker客户端"></a>1 安装/升级Docker客户端</h4><p>推荐安装1.10.0以上版本的Docker客户端，参考文档 <a href="https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.13be1991qOQrLG" target="_blank" rel="noopener">docker-ce</a></p><h5 id="Docker-CE镜像源站"><a href="#Docker-CE镜像源站" class="headerlink" title="Docker CE镜像源站"></a>Docker CE镜像源站</h5><p>官网下载手册</p><h5 id="CentOS7（使用yum进行安装-阿里云）"><a href="#CentOS7（使用yum进行安装-阿里云）" class="headerlink" title="CentOS7（使用yum进行安装-阿里云）"></a>CentOS7（使用yum进行安装-阿里云）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># Step 3: 更新并安装 Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"># Step 4: 开启Docker服务</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">注意：其他注意事项在下面的注释中</span><br><span class="line"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line"># vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br><span class="line">#   将 [docker-ce-test] 下方的 enabled&#x3D;0 修改为 enabled&#x3D;1</span><br><span class="line">#</span><br><span class="line"># 安装指定版本的Docker-CE:</span><br><span class="line"># Step 1: 查找Docker-CE的版本:</span><br><span class="line"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="line">#   Loading mirror speeds from cached hostfile</span><br><span class="line">#   Loaded plugins: branch, fastestmirror, langpacks</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   Available Packages</span><br><span class="line"># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span><br><span class="line"># sudo yum -y install docker-ce-[VERSION]</span><br><span class="line"># 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。</span><br><span class="line"># yum list docker-ce-selinux- --showduplicates | sort -r</span><br><span class="line"># sudo yum -y install docker-ce-selinux-[VERSION]</span><br><span class="line"></span><br><span class="line"># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令</span><br><span class="line"># 经典网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># VPC网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.could.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h5 id="安装校验"><a href="#安装校验" class="headerlink" title="安装校验"></a>安装校验</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><h4 id="2-配置镜像加速器"><a href="#2-配置镜像加速器" class="headerlink" title="2 配置镜像加速器"></a>2 配置镜像加速器</h4><p>针对Docker客户端版本大于 1.10.0 的用户</p><p><img src="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/1f87538c-e8a2-455e-af33-8e0b3ff4a3f9.png" alt></p><p>您可以通过修改daemon配置文件（没有的话，需手动创建）<code>/etc/docker/daemon.json</code>来使用加速器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker </span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: # 此处使用自己的加速器[&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;]&#125;EOF </span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h2><p><strong>docker安装后默认是没有 daemon.json此配置文件的，需手动创建。</strong></p><p>daemon.json文件可配置的参数表，我们在配置的过程中，只需要设置我们需要的参数即可，不必全部写出来。详细参考官网。</p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#options</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;api-cors-header&quot;:&quot;&quot;,</span><br><span class="line">&quot;authorization-plugins&quot;:[],</span><br><span class="line">&quot;bip&quot;: &quot;&quot;,</span><br><span class="line">&quot;bridge&quot;:&quot;&quot;,</span><br><span class="line">&quot;cgroup-parent&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store-opts&quot;:&#123;&#125;,</span><br><span class="line">&quot;cluster-advertise&quot;:&quot;&quot;,</span><br><span class="line">&quot;debug&quot;: true, #启用debug的模式，启用后，可以看到很多的启动信息。默认false</span><br><span class="line">&quot;default-gateway&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-gateway-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-runtime&quot;:&quot;runc&quot;,</span><br><span class="line">&quot;default-ulimits&quot;:&#123;&#125;,</span><br><span class="line">&quot;disable-legacy-registry&quot;:false,</span><br><span class="line">&quot;dns&quot;: [&quot;192.168.1.1&quot;], # 设定容器DNS的地址，在容器的 &#x2F;etc&#x2F;resolv.conf文件中可查看。</span><br><span class="line">&quot;dns-opts&quot;: [], # 容器 &#x2F;etc&#x2F;resolv.conf 文件，其他设置</span><br><span class="line">&quot;dns-search&quot;: [], # 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜</span><br><span class="line">索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。</span><br><span class="line"> </span><br><span class="line">&quot;exec-opts&quot;: [],</span><br><span class="line">&quot;exec-root&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;graph&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃已废弃，使用data-root代替,这个主要看docker的版本</span><br><span class="line">&quot;data-root&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃Docker运行时使用的根路径,根路径下的内容稍后介绍，默认&#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line">&quot;group&quot;: &quot;&quot;, #Unix套接字的属组,仅指&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">&quot;hosts&quot;: [], #设置容器hosts</span><br><span class="line">&quot;icc&quot;: false,</span><br><span class="line">&quot;insecure-registries&quot;: [], #配置docker的私库地址</span><br><span class="line">&quot;ip&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;iptables&quot;: false,</span><br><span class="line">&quot;ipv6&quot;: false,</span><br><span class="line">&quot;ip-forward&quot;: false, #默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看</span><br><span class="line"> </span><br><span class="line">&quot;ip-masq&quot;:false,</span><br><span class="line">&quot;labels&quot;:[&quot;nodeName&#x3D;node-121&quot;], # docker主机的标签，很实用的功能,例如定义：–label nodeName&#x3D;host-121</span><br><span class="line"> </span><br><span class="line">&quot;live-restore&quot;: true,</span><br><span class="line">&quot;log-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-level&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-opts&quot;: &#123;&#125;,</span><br><span class="line">&quot;max-concurrent-downloads&quot;:3,</span><br><span class="line">&quot;max-concurrent-uploads&quot;:5,</span><br><span class="line">&quot;mtu&quot;: 0,</span><br><span class="line">&quot;oom-score-adjust&quot;:-500,</span><br><span class="line">&quot;pidfile&quot;: &quot;&quot;, #Docker守护进程的PID文件</span><br><span class="line">&quot;raw-logs&quot;: false,</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;xxxx&quot;], #镜像加速的地址，增加后在 docker info中可查看。</span><br><span class="line">&quot;runtimes&quot;: &#123;</span><br><span class="line">&quot;runc&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;runc&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;custom&quot;: &#123;</span><br><span class="line">&quot;path&quot;:&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;my-runc-replacement&quot;,</span><br><span class="line">&quot;runtimeArgs&quot;: [</span><br><span class="line">&quot;--debug&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;selinux-enabled&quot;: false, #默认 false，启用selinux支持</span><br><span class="line"> </span><br><span class="line">&quot;storage-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;storage-opts&quot;: [],</span><br><span class="line">&quot;swarm-default-advertise-addr&quot;:&quot;&quot;,</span><br><span class="line">&quot;tls&quot;: true, #默认 false, 启动TLS认证开关</span><br><span class="line">&quot;tlscacert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;ca.pem，通过CA认证过的的certificate文件路径</span><br><span class="line">&quot;tlscert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;cert.pem ，TLS的certificate文件路径</span><br><span class="line">&quot;tlskey&quot;: &quot;&quot;, #默认~&#x2F;.docker&#x2F;key.pem，TLS的key文件路径</span><br><span class="line">&quot;tlsverify&quot;: true, #默认false，使用TLS并做后台进程与客户端通讯的验证</span><br><span class="line">&quot;userland-proxy&quot;:false,</span><br><span class="line">&quot;userns-remap&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是官网docs提供的一个示例配置，我们可以参考，选择性的配置其中的部分内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>1、如何配置 registry 私库相关的参数<br>涉及以下2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [],  #这个私库的服务地址</span><br><span class="line">&quot;registry-mirrors&quot;: [],    #私库加速器</span><br></pre></td></tr></table></figure><p>2.配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line"># 配置阿里云镜像加速器 ：此处需使用自己个人加速器</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;],</span><br><span class="line"></span><br><span class="line"># 私库服务地址：个人一般用不到</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;https:&#x2F;&#x2F;ower.site.com&quot;]，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 重载配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"># 重启docker服务</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"># 查看状态</span><br><span class="line">sudo systemctl status docker -i</span><br><span class="line"># 查看服务</span><br><span class="line">sudo docker info</span><br><span class="line"># 当我们需要对docker服务进行调整配置时，不用去修改主文件 docker.service的参数，通过daemon.json配置文件来管理，更为安全、合理。</span><br></pre></td></tr></table></figure><h2 id="docker-hub官网提供国内镜像"><a href="#docker-hub官网提供国内镜像" class="headerlink" title="docker hub官网提供国内镜像"></a>docker hub官网提供国内镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;registry.docker-cn.com</span><br></pre></td></tr></table></figure><h2 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h2><p>如果 加速器太慢，可以更改加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"># 如果看到如下，则表示配置成功</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于国内特殊的网络环境，往往我们从 &lt;strong&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt;&lt;/strong&gt;中拉取镜像并不能成功，而且速度特别慢。&lt;/p&gt;
&lt;p&gt;那么我们可以给Docker配置一个国内的registry mirror，当我们需要的镜像在mirror中则直接返回，如果没有则从Docker Hub中拉取。&lt;font color=&quot;red&quot;&gt;是否使用registry mirror对Docker用户来说是透明的&lt;/font&gt;。&lt;/p&gt;
&lt;p&gt;DaoCloud在国内提供了首个Docker Hub镜像服务，而且免费，大大提高了国内Docker用户的使用热情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>8-GitLab简单操作</title>
    <link href="http://javassun.github.io/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
    <id>http://javassun.github.io/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</id>
    <published>2019-03-25T11:04:47.000Z</published>
    <updated>2020-04-14T06:10:45.094Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-国内为什么普遍使用GitLab"><a href="#1-国内为什么普遍使用GitLab" class="headerlink" title="1.国内为什么普遍使用GitLab"></a>1.国内为什么普遍使用GitLab</h2><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">https://about.gitlab.com/</a><br>大公司有能力自己基于GitLab做二次开发，有利于将代码保存在自己手中。</p><a id="more"></a><h2 id="2-GitLab上有哪些核心功能"><a href="#2-GitLab上有哪些核心功能" class="headerlink" title="2.GitLab上有哪些核心功能"></a>2.GitLab上有哪些核心功能</h2><p>几乎包含一个项目的所有开发流程。<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/f06b4b21-3b4a-4c7b-b3a7-5ef2d7a60ce4.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/79e63bc0-48e9-4b18-bb60-1ebbc1745ace.png" alt></p><h2 id="3-GitLab如何做项目管理"><a href="#3-GitLab如何做项目管理" class="headerlink" title="3.GitLab如何做项目管理"></a>3.GitLab如何做项目管理</h2><p>主要是通过 <strong>issues</strong> 对项目进行追踪管理<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/24bbbb0d-d736-4783-90d9-c6f063636555.png" alt></p><p>也可以看仪表盘等等。</p><h2 id="4-GitLab怎样做-code-review"><a href="#4-GitLab怎样做-code-review" class="headerlink" title="4.GitLab怎样做 code review"></a>4.GitLab怎样做 code review</h2><p><strong>Merge Requests</strong></p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e0577ac-52cb-4cd8-b700-633abb8d59aa.png" alt></p><p><strong>仓库设置及变更保护</strong><br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/3f1d9ab7-f837-4b7c-a463-b3004d9a02a7.jpg" alt></p><h2 id="5-GitLab怎样保证集成质量"><a href="#5-GitLab怎样保证集成质量" class="headerlink" title="5.GitLab怎样保证集成质量"></a>5.GitLab怎样保证集成质量</h2><p>配置.gitlab-ci.yml文件 + 跑 runners</p><p><strong>GitLab</strong> 有自己的<strong>CI</strong><br>通过源文件可以查看</p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/aa33cc03-7b0f-405e-8203-8e0ea05d0644.png" alt></p><p>在自己的项目中可以看到 Runners：就是跑CI/CD的代理，类似于管家，有了它之后，GitLab自身的CI才能运行起来、<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/834dfa86-48f3-474f-a4ca-a2cfa2e1ca68.jpg" alt></p><p>跑一套之后的效果（做一个完备的检查）<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a88563d3-da82-4ecc-a297-c27baf6646c7.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/39ad396c-484a-4e12-a44a-cbfdea758b81.jpg" alt></p><h2 id="6-如何把应用部署到AWS上"><a href="#6-如何把应用部署到AWS上" class="headerlink" title="6.如何把应用部署到AWS上"></a>6.如何把应用部署到AWS上</h2><p>见 GitLab Help文档</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-国内为什么普遍使用GitLab&quot;&gt;&lt;a href=&quot;#1-国内为什么普遍使用GitLab&quot; class=&quot;headerlink&quot; title=&quot;1.国内为什么普遍使用GitLab&quot;&gt;&lt;/a&gt;1.国内为什么普遍使用GitLab&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://about.gitlab.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://about.gitlab.com/&lt;/a&gt;&lt;br&gt;大公司有能力自己基于GitLab做二次开发，有利于将代码保存在自己手中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>7-基于GitHub进行团队协作</title>
    <link href="http://javassun.github.io/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    <id>http://javassun.github.io/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</id>
    <published>2019-03-09T12:01:08.000Z</published>
    <updated>2020-04-14T06:11:16.591Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-创建团队项目"><a href="#1-创建团队项目" class="headerlink" title="1.创建团队项目"></a>1.创建团队项目</h2><p>先在settings中创建组织类型的托管。然后在组织中创建团队的仓库。</p><a id="more"></a><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/64446d90-2b9c-449f-a087-5f965818e04e.png" alt><br>点击 Create后出现当前画面</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e2f857e9-f884-4e0c-9add-09e13a4c4d6f.png" alt></p><p>给予不同的人不同的权限</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31adef54-e872-40b9-899a-b1de0bc43a23.png" alt></p><hr><p>创建Team</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/205f2e23-e3a9-4ef3-9ead-a885002f398b.png" alt></p><h2 id="2-选择适合自己团队的工作流"><a href="#2-选择适合自己团队的工作流" class="headerlink" title="2.选择适合自己团队的工作流"></a>2.选择适合自己团队的工作流</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a8c719c7-af57-49cd-be78-22c37ef1a453.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/20094dc9-d19f-4455-bcf6-a6cd1ba16704.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/ca8f17b4-8f25-4a4b-9f72-3fa4220767c9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/86497509-61d6-475f-9e09-644a4c11269b.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fd472e76-3fdf-41d3-99f4-cfa77888cc46.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/36620676-47e4-41be-9609-c4511a38485e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/10ed3ecd-acac-457e-862b-520139270bd8.jpg" alt></p><h2 id="3-挑选合适的分支集成策略"><a href="#3-挑选合适的分支集成策略" class="headerlink" title="3.挑选合适的分支集成策略"></a>3.挑选合适的分支集成策略</h2><p>Insights &gt;&gt; Network 中可以查看版本树的演进。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/49ab1fe1-5685-40f2-aa6c-27e585533b76.jpg" alt></p><p>集成策略：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/051f3a09-38a5-4957-9510-dfcbb34c93d2.png" alt></p><p>有的团队希望最后的历史树像<strong>一条线</strong>一样，应选择 *<em>Allow rebase merging 或者 squash *</em></p><p><font color="red"><strong>Beijing为例</strong></font></p><p><strong>Merge</strong>：特性分支合并到base分支上</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a9ee48f2-74ca-4d36-9461-ff631b46c870.jpg" alt></p><p><strong>Squash</strong>: 特性分支不动，base分支自动添加特性分支的所有变更为1个（如特性分支上有5个commit，base分支会5合1）</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5b3df45b-80df-4c4c-93a8-81b8c641fa1a.jpg" alt></p><p><strong>Rebase</strong>: 不改变特性分支，base分支会自动添加特性分支的所有变更，且<strong>不会</strong>合成一个</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3010b401-fd66-4425-b675-4556c67cb407.jpg" alt></p><h2 id="4-启用issue跟踪需求和任务"><a href="#4-启用issue跟踪需求和任务" class="headerlink" title="4.启用issue跟踪需求和任务"></a>4.启用issue跟踪需求和任务</h2><p>选用 stars:&gt;100000 的开源项目来查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/16e07275-4d2b-402a-a50e-0648631716e4.png" alt></p><p>点击 Lables 以 标签的形式查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0a6cc850-3f29-4abd-b282-26daee4a2e06.png" alt></p><p>如何启用issue呢？</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfe21652-2b4e-46e1-b534-4c02ec6dd531.png" alt></p><p>建立 issue后会出现类似的文件</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/186c0666-1dfa-4ced-b588-ece60d6c9605.png" alt></p><h2 id="5-使用project管理issue"><a href="#5-使用project管理issue" class="headerlink" title="5.使用project管理issue"></a>5.使用project管理issue</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fc10fa87-3b54-48a4-9a20-1723d6b72ed3.png" alt></p><p>不同的看板类型 显示效果不一样，以bug为例：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/1ecccc60-40dd-40be-b6ed-2befb2a266ad.png" alt></p><p>可以对任务分发，项目进度把握进行观察</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/026076bc-ccd1-4208-ae96-196c3982138e.png" alt></p><h2 id="6-项目内部如何-code-review"><a href="#6-项目内部如何-code-review" class="headerlink" title="6.项目内部如何 code review"></a>6.项目内部如何 code review</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c53619b8-9fdc-4d69-8d0b-436f94468ad2.png" alt></p><p>根据需求对匹配到的不同分支做限制。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b0768be8-0078-4c68-8538-0197138b47a6.png" alt></p><p>下面做了限制，防止对远端代码造成破坏。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/2c20094b-8f8e-405c-90e5-65521154518c.png" alt></p><h2 id="7-团队协作如何做多分支的集成"><a href="#7-团队协作如何做多分支的集成" class="headerlink" title="7.团队协作如何做多分支的集成"></a>7.团队协作如何做多分支的集成</h2><p>特性分支总是有先有后的合成到base分支上，看看GitHub上是如何做</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b118050-ca7b-4d73-a633-2f02ae35ad12.jpg" alt></p><p><strong>Merge</strong>:</p><p>beijing merge 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e3a600d5-8897-42c2-bcaf-1f138379e255.jpg" alt></p><p>shanghai  也要 merge 到 base:</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/075b0539-7ff0-49aa-ba54-01f29e128bf4.jpg" alt></p><p>在线编辑解决冲突。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/770e44a3-857c-4cc6-810b-05eee2d4640c.jpg" alt></p><p>此时的代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b1137354-7eef-4570-8d51-5be16c5b72a8.jpg" alt></p><p>pull request 选择 merge 后查看代码树的变化：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfec3bde-f53e-4737-bb7a-08ff0189c793.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8d941049-4846-4bac-9876-0c50d213395a.jpg" alt></p><p>为了演示，将分支回退到之前的版本，实际上禁止这样处理</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/275f14ab-7c2e-4403-bd7b-63d28bc0ace3.jpg" alt></p><p><font color="red">此时 master 回退</font></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d645c180-1732-4ec9-a945-263f855089fa.jpg" alt></p><p><strong>Squash</strong>:</p><p>beijing  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55844bec-4ee4-4da7-aa6e-2242bf65c3db.jpg" alt></p><p>将 beijing 特性分支上做的3次变更 集成到 master分支上，且3合1<br>新生成1个commit,不会改动特性分支。</p><p>shanghai  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f7b90cae-d238-40a6-8895-fb271e1f7ab9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55521f26-e985-4afb-bbb1-5eb2375edf5e.jpg" alt></p><p>选中后就会报错 不能自动的merge,需要手动处理冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/70de5e05-2d68-44b3-9a05-ea28bf2ab4df.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d096a3d6-a46e-4b96-99f8-03635923aa0f.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c88f62c3-680b-49c3-b6f7-12777c634d2f.jpg" alt></p><hr><p>手动解决冲突后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5828e5a1-55a6-496c-a2f6-9b1e609e5eaa.jpg" alt></p><hr><p>冲突解决，但还没有接收时的代码树</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/69ea69db-7c60-424b-8a16-7eed94c30365.jpg" alt></p><hr><p>点击 Squash按钮后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9db23230-b878-4b45-acf0-7fc0f9c371a5.jpg" alt></p><hr><p>查看当前代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7d9e5cd9-21fe-4eff-9752-e8b9c2786ca1.jpg" alt></p><p><font color="red">master 再次回退</font></p><p>回到初始的状态：<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d43b9b20-2748-454c-85ba-ab06784a9b30.jpg" alt></p><p><strong>Rebase</strong>:</p><p>beijing  rebase 到 base后：<br>不改变特性分支，将 beijing分支的变更如实更新到 master分支上，不做合成。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f84fabeb-04ca-4b79-b384-3ee85c5447ec.jpg" alt></p><p>shanghai  rebase 到 base后：<br>会发生冲突，解决冲突后但还没有接收squash：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/babdf2f4-c1d6-475b-9f81-d33e8bbbfbf0.jpg" alt></p><p>此时 pull request 已经走到死胡同，不能再往下走了</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dc90bc8a-b9d6-4e46-99b9-46ff0b5d10cb.jpg" alt></p><p>此时 Github 已经无能为力，但团队还是坚持要用 rebase。<br>可以将 shanghai 回退到 s这个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av  &#x2F;&#x2F;确保本地分支在 s节点</span><br><span class="line">git push -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6a45a1fa-e5f2-4a3d-a427-beb97e84abb7.jpg" alt></p><p>我们应该回到ShangHai分支，让 ShangHai分支执行变基的操作，基于远端的master分支进行变基。</p><p><strong>繁琐处理：</strong><br>在本地做这件事，需要将远端的 master 拉取到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0dad0ce9-8fb5-49af-a819-02504d24859f.jpg" alt></p><p>切换到需要变基的分支，即 ShangHai分支，基于远端的 Master分支进行变基。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;master &#x2F;&#x2F;自然会报冲突 readme文件出了冲突</span><br><span class="line"></span><br><span class="line">vi readme &#x2F;&#x2F;解决冲突即可</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理，直到没有冲突</span><br><span class="line"></span><br><span class="line">git status &#x2F;&#x2F; 工作区是干净的即可</span><br><span class="line">gitk --all &#x2F;&#x2F; 查看分支树</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31e04eb9-1c49-4316-83be-475ed0fd6e80.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/4678ec2a-0cea-4d3d-8ff2-e2708c2d1ee0.jpg" alt></p><p>继续推送即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git push origin Shanghai &#x2F;&#x2F; 会报 非 fast-forwards</span><br><span class="line"></span><br><span class="line">同分支的本地往远端推送，必须是 fast-forwards才行</span><br><span class="line"></span><br><span class="line">除非加上 -f</span><br><span class="line"></span><br><span class="line">git push  -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9ad43201-005f-4c37-ae62-fca6815ba55e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/08d08193-5c71-429f-aeca-660996a4ebea.jpg" alt></p><p>此时，代码树发生了变化</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfde1fd2-0a28-4abe-9b15-9136dbb27095.jpg" alt></p><p>再次查看 pull request发现可以 Rebase<br>即 远端的 master分支 与 远端的 ShangHai分支处理 Fast-Forward状态，不会再有冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b46166ab-7e19-4488-aae2-a2f54768c735.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f03a16a-3dae-41f5-9247-5a348f33a90f.jpg" alt></p><hr><p>有两个头像，一个是源文件的作者，一个是该文件的提交者。<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/cf7e6f21-0886-46c1-a51a-fe2f04c70abf.jpg" alt></p><p><strong>特殊处理：</strong></p><p>Git官网：找到 Documentation —&gt;&gt; Pro Git book 选择 简体中文<br><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/df38e4ff-6c68-4d2b-bc30-46d62c978bb7.png" alt></p><p>因为经过繁琐处理已经没有冲突，需要将ShangHai版本恢复到 远端 s节点继续演示</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/95fc6d9d-5048-4e44-8358-518ccc9f6b49.jpg" alt></p><p>Master 分支也需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/965989da-0f55-4cfb-bc05-7aff3973a755.jpg" alt></p><p>开启 rerere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global rerere.enabled true</span><br><span class="line">git checkout ShangHai</span><br><span class="line">git merge master &#x2F;&#x2F;  只有看到Recorded resolution for ... 才算开始记录解决冲突的办法     当前报冲突，解决冲突</span><br><span class="line">vim readme</span><br><span class="line">git add .</span><br><span class="line">git commit -am &quot;temp&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/24000499-5018-466d-8553-0d3c12da0a50.jpg" alt></p><p>因为只是为了记录解决冲突的方法，temp 这个 commit并不需要，所以需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e0fa0fb5-c7cb-42c3-bcdb-7a4d7ec91854.jpg" alt></p><p>现在 ShangHai  等待着与 远端的 Master 做 rebase，并且使用 rerere<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8444c3f4-821d-4ea5-846e-2a784608b009.jpg" alt></p><p>基于 master(7425314) 做 rebase</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8a6e2f89-ecea-4176-ae48-843348aa2b7d.jpg" alt></p><p>虽然报了冲突，但进去 readme看后发现 冲突内容被自动解决了<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f1a0406-9d6b-4222-876d-afd6a0d9e767.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git rebase  --continue</span><br><span class="line">vi readme &#x2F;&#x2F;冲突也没有 根据提示 添加 readme</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status  &#x2F;&#x2F;一直到不再报冲突为止</span><br><span class="line"></span><br><span class="line">git log -n5  &#x2F;&#x2F; 查看commit是否如实更新上去</span><br></pre></td></tr></table></figure><h2 id="8-如何保证集成质量"><a href="#8-如何保证集成质量" class="headerlink" title="8.如何保证集成质量"></a>8.如何保证集成质量</h2><p>通过 settings 中的 各种保险设置进行控制</p><p>也可在 市场中搜索各种 插件 APP 进行集成管控自己的代码。</p><h2 id="9-产品如何发布到GitHub上"><a href="#9-产品如何发布到GitHub上" class="headerlink" title="9.产品如何发布到GitHub上"></a>9.产品如何发布到GitHub上</h2><p><strong>Release</strong><br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/83c9516e-1095-4441-adcb-fb43d32f54e9.png" alt></p><p>如果是以 travis为例，需要在 .travis.yml文件中编写deploy的各种配置<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/88dbd0f3-6076-4eb1-9195-d55b17dffd1d.jpg" alt></p><hr><p>api_key 不能暴露， 通过变量方式获取<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b822c8e-5eef-4bb5-a123-879c578f650a.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/434cac1a-1033-4a93-b1e4-2b15e43e3e99.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5a4f266e-313d-40fb-a626-d64e1f6b7996.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7cad2344-3d21-445e-a558-9cbe2cc12142.jpg" alt></p><p>name 是yml文件中的变量名称</p><p>value 在如下图中：在个人 setting 的 token中</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b568e180-66fc-4606-9fe2-891c81a305a1.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8042988e-13b1-4398-99ae-b54c5a8e7d97.jpg" alt></p><hr><p>pull request merge到主分支</p><p>经过 travis ci 各种审查后，点击 release即可看到<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6fde5cb5-4e6e-4894-8079-6426d91dd358.jpg" alt></p><p>即通过 travis ci 通过 配置 travis.yml文件 将 java 工程部署到GitHub的 release中，期间要配置Token。</p><h2 id="10-如何给项目添加详细的指导文档-Wiki"><a href="#10-如何给项目添加详细的指导文档-Wiki" class="headerlink" title="10.如何给项目添加详细的指导文档 (Wiki)"></a>10.如何给项目添加详细的指导文档 (Wiki)</h2><p><strong>GitHub提供了 Wiki 功能</strong></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0b05b38d-5d3a-49b4-a38e-82c28270a5a1.jpg" alt></p><p>挑选别的开源项目中 wiki写的比较好的 下载下来，推送到自己的项目中才能进行各种 edit。</p><p>此时远端的 wiki 中 会出现别人的 wiki<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7a33688d-e6b3-4177-9b88-0c9a405dbe47.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-创建团队项目&quot;&gt;&lt;a href=&quot;#1-创建团队项目&quot; class=&quot;headerlink&quot; title=&quot;1.创建团队项目&quot;&gt;&lt;/a&gt;1.创建团队项目&lt;/h2&gt;&lt;p&gt;先在settings中创建组织类型的托管。然后在组织中创建团队的仓库。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>6-GitHub的认识与使用</title>
    <link href="http://javassun.github.io/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://javassun.github.io/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2019-02-25T09:58:51.000Z</published>
    <updated>2020-04-14T06:11:21.335Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-GitHub为什么会火"><a href="#1-GitHub为什么会火" class="headerlink" title="1.GitHub为什么会火"></a>1.GitHub为什么会火</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/53d51f84-9a62-4dde-9be4-7cbb9d0b1dae.jpg" alt></p><a id="more"></a><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/fbc94ced-1d7f-4a8d-9efb-22dbc218846e.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/7dbd21e1-01d8-4279-b7dd-0b5735565315.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/68ad18d1-6b50-49fb-82cb-0c64ea04cd9d.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a0c7cf11-f98f-40e9-9a73-b965ec8584c5.jpg" alt></p><h2 id="2-GitHub都有哪些核心功能"><a href="#2-GitHub都有哪些核心功能" class="headerlink" title="2.GitHub都有哪些核心功能"></a>2.GitHub都有哪些核心功能</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/89cbfdee-4587-495e-82eb-983f400ed9cc.png" alt></p><hr><p><strong>CI/CD</strong>：持续集成Continuous Integration（CI）和持续交付Continuous Delivery（CD）</p><p><strong>安全开发</strong><br><strong>代码审查</strong><br><strong>应用程序</strong><br><strong>托管代码</strong><br><strong>项目管理</strong><br><strong>团队管理</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/3cb0ab88-815b-4ad4-9c5b-89f1b59abea5.png" alt></p><h2 id="3-怎么快速淘到感兴趣的开源项目"><a href="#3-怎么快速淘到感兴趣的开源项目" class="headerlink" title="3.怎么快速淘到感兴趣的开源项目"></a>3.怎么快速淘到感兴趣的开源项目</h2><p>通过搜索匹配<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4b02d18e-520c-411a-8f1b-3d38afb83285.png" alt></p><p>或者使用<strong>高级搜索</strong></p><p><strong>git 最好学习资料 in:readme stars:&gt;1000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a7f07365-78c6-4406-bc0e-a8badd887228.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8d66d247-f9d2-4b44-9809-f0ff9af00b91.png" alt></p><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/e0a543a9-3b11-4b7b-94e2-71cb628b8f7f.png" alt></p><p>如果不登录去搜索的话，code 后会跟着 ？ 提示必须登录后才能享受代码的功能</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/1511493f-8f4e-4be8-8bb2-e91d1313ea5c.png" alt></p><h2 id="4-怎样在GitHub上搭建个人博客"><a href="#4-怎样在GitHub上搭建个人博客" class="headerlink" title="4.怎样在GitHub上搭建个人博客"></a>4.怎样在GitHub上搭建个人博客</h2><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p>此处以 <a href="https://github.com/barryclark" target="_blank" rel="noopener">barryclark</a>/<strong><a href="https://github.com/barryclark/jekyll-now" target="_blank" rel="noopener">jekyll-now</a></strong> 为例进行搭建。</p><p>按照步骤</p><ol><li>fork 到自己的仓库中，然后修改仓库名字</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4e3677f9-8877-40b8-86bf-dfbf3e6e56c6.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/839c82a3-253a-436a-aa2c-2b8df57bc2c3.png" alt></p><ol start="2"><li>修改配置文件</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/42ba975b-f1b0-4736-ae7a-3dda0f2493ce.png" alt></p><p>根据需求自己做调整</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2d59fd09-1072-47de-bc65-8fd2e7b06287.png" alt></p><ol start="3"><li>修改_post文件</li></ol><p>可以直接修改 2014-3-3-Hello-World.md 文件<br>或者<br>Create new file 文件<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/0b11316b-70c3-40bc-91ad-6bf75f768c45.png" alt></p><ol start="4"><li>有效日期+标题 2018-12-24-HaoRan-First-Blob.md</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a8784c54-f7a4-42bf-a3e0-9499b47a336b.png" alt></p><p>5.域名在settings中查找</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/6ff2ad0f-c4c6-47da-85bd-4e5486d8b547.png" alt></p><p>6.个人Blob展示</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/71e8cffb-3861-4936-a53e-66ce6f73d2a4.png" alt></p><h2 id="5-开源项目怎么保证代码质量"><a href="#5-开源项目怎么保证代码质量" class="headerlink" title="5.开源项目怎么保证代码质量"></a>5.开源项目怎么保证代码质量</h2><p>进入GitHub主页，点击 pull request</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/5b9b398f-0281-48b8-a47e-fb6ec287203d.jpg" alt></p><p>被merge吸纳的是紫色的，被拒绝的是红色的</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4289a643-491e-4fd5-b8d0-462039459ff2.jpg" alt></p><p>可以看到，有代码审查，有智能监测，owner在做了一系列检查后，才决定是否将他人的request merge到 master上来。</p><h2 id="6-为何需要组织类型的仓库"><a href="#6-为何需要组织类型的仓库" class="headerlink" title="6.为何需要组织类型的仓库"></a>6.为何需要组织类型的仓库</h2><p>在个人 porfile中 会有组织这种类型的仓库。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8aa1d29e-38ec-447a-9442-a772f0d0ef97.jpg" alt></p><p>举一个例子：<br>现阶段，我可能在A公司工作，A公司有一些公共开源的项目在GitHub上托管。过段时间，又加入到B公司的开源项目中工作。根据组织的成员也在流动中，所以需要组织类型的仓库对成员进行管理。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/cf97a418-e69a-4362-aa8c-dd3232217ec2.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f55a9a52-345a-4102-bc92-04ef177994db.jpg" alt></p><p><strong>邀请成员</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f18431a3-248e-4591-b865-8adb5025ae98.jpg" alt></p><p><strong>Team</strong>可以对仓库进行精细化的管控</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2c3267ca-ec77-4685-a2a0-49e63e697928.jpg" alt></p><p>可以加入教师团队的人员</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/32809d24-79a6-47e3-8abe-dcafff4219d9.jpg" alt></p><p>可以给人员分配仓库不同的权限</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/142f6b99-9f3e-49e6-8dd1-fe543d886344.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-GitHub为什么会火&quot;&gt;&lt;a href=&quot;#1-GitHub为什么会火&quot; class=&quot;headerlink&quot; title=&quot;1.GitHub为什么会火&quot;&gt;&lt;/a&gt;1.GitHub为什么会火&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/53d51f84-9a62-4dde-9be4-7cbb9d0b1dae.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>5-Git集成使用禁忌</title>
    <link href="http://javassun.github.io/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/"/>
    <id>http://javassun.github.io/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/</id>
    <published>2019-02-15T11:57:21.000Z</published>
    <updated>2020-04-14T06:12:07.034Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-禁止向集成分支执行push-f-操作"><a href="#1-禁止向集成分支执行push-f-操作" class="headerlink" title="1.禁止向集成分支执行push -f 操作"></a>1.禁止向集成分支执行push -f 操作</h2><p><strong>git push -f：会强制推送，对团队造成危害（虽然远程仓库有特殊机制制止这种变更）</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --hard 回退到某个古老的ID号</span><br><span class="line">git push -f &#x2F;&#x2F;会销毁远端最新最近的提交，所以禁止执行这个命令</span><br></pre></td></tr></table></figure><h2 id="2-禁止向集成分支执行变更历史的操作"><a href="#2-禁止向集成分支执行变更历史的操作" class="headerlink" title="2.禁止向集成分支执行变更历史的操作"></a>2.禁止向集成分支执行变更历史的操作</h2><p>团队协同工作时，<strong>公共分支严禁拉取到本地做rebase变基活动的</strong>，公共分支是团队一起一天天积累下来的，只能往前走，不能做历史变更。</p><p><strong>集成分支不能被改变历史</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;1-禁止向集成分支执行push-f-操作&quot;&gt;&lt;a href=&quot;#1-禁止向集成分支执行push-f-操作&quot; class=&quot;headerlink&quot; title=&quot;1.禁止向集成分支执行push -f 操作&quot;&gt;&lt;/a&gt;1.禁止向集成分支执行push -f 操作&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;git push -f：会强制推送，对团队造成危害（虽然远程仓库有特殊机制制止这种变更）&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>4-Git多人单分支集成协作时的常见场景</title>
    <link href="http://javassun.github.io/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/"/>
    <id>http://javassun.github.io/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/</id>
    <published>2019-02-08T10:55:04.000Z</published>
    <updated>2020-04-14T06:12:34.054Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-不同人修改不同文件如何处理"><a href="#1-不同人修改不同文件如何处理" class="headerlink" title="1.不同人修改不同文件如何处理"></a>1.不同人修改不同文件如何处理</h2><p><strong>JavaSsun用户修改 readme文件</strong><br><strong>haoran用户修改index文件</strong><br><strong>远端仓库新建一个名字为 feature/add_git_commands的分支</strong></p><p>为了在单机模拟两个人做操作，需要从远端克隆一个 命名为 git_learning_02 以 JavaSsun为用户的仓库</p><a id="more"></a><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/462c8fe6-41e9-448d-811b-af9aea07d29f.png" alt></p><p>再变更email</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/64daaa82-8983-411c-914a-61cc63b451e5.png" alt></p><p>基于远端刚才新建的分支在本地新建一个分支，并切换到该分支上（二者联系起来）</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/cc5a524a-5f7e-4b81-8c97-b773ac2f3224.png" alt></p><p>JavaSsun在git_learning_02仓库中修改readme文件，commit后 推送到远端仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push   即可（为什么不用加分支名了呢，因为上面命令中本地分支与远端分支做了关联）</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/0c2fe061-aebc-4a6e-ad4e-e191f9c57912.png" alt></p><p>远端仓库也有了最新的变更</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/c8d976b1-c8ee-4e78-900b-d01fe34540d4.png" alt></p><p><strong>至此，JavaSsun开发人员修改完了readme，并提交到了远程仓库。</strong></p><p>切换到haoran所属的git_learning 仓库，查看后发现没有 feature/add_git_commands分支，需要拉取下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git fetch github</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/16f7fea5-27cc-43cc-b7cc-1ed31bc51048.png" alt></p><p>将本地新建分支并与远端的分支做关联（名字最好一致，并查看hash值后发现确实是一致的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;add_git_commands github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/fba96bf8-4ef8-4dfb-8edf-c0004c9c1b76.png" alt></p><p><font color="red">Hash值都是 27582a7</font></p><p>haoran用户修改index文件，commit完成。<br>JavaSsun用户又修改了readme文件，并且push到远程。<br>此时，haoran用户push自己的index文件到远端，会报错，如下图：</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/7286fc61-21d2-43b1-884c-c86d466a2394.png" alt></p><p>如何解决呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch github  尝试拉取远端的最新变更</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/95006c82-d402-4b55-a1b4-a26869cad23d.png" alt></p><p>发现有一个是 ahead 1 , behind 1 即本地比远端多一个，远端也比本地多一个。</p><p><strong>如果团队不要求用线性树的模式的话，可以用merge 与远端的进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/86e9dc79-a8f3-4759-a9b1-5d7311f7b625.png" alt></p><p>查看readme文件，发现将JavaSsun用户提交的内容都合了进来。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/6e46ee55-4829-4bf3-b871-082e599fb039.png" alt></p><p>此时在使用 <strong>git push github</strong> 就不会报错</p><h2 id="2-不同人修改同文件不同区域如何处理"><a href="#2-不同人修改同文件不同区域如何处理" class="headerlink" title="2.不同人修改同文件不同区域如何处理"></a>2.不同人修改同文件不同区域如何处理</h2><p>开发之前都需要将自己的分支与远端做一次同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>haoran</strong>：  对index.html文件做了变更，并做了commit<br><strong>JavaSsun</strong>: 对index.html文件做了变更，并做了commit</p><p><strong>haoran</strong>用户将自己的变更推送到了远端。此时 JavaSsun用户并不知道远端发生了新变更，也想推送自己的变更，自然就被拒绝。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/ac9f49fa-3b5c-4606-be44-1157432c6d45.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/340a928c-76a7-45fd-b5c8-fd34a7fca38d.png" alt></p><p>出现比远端做一个commit，同时比远端少一个commit,做merge即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git merge origin&#x2F;feature&#x2F;add_git_commands(远端分支或者分支ID号)</span><br></pre></td></tr></table></figure><p>默认缺省即可，查看发现有了其他人添加的内容。</p><h2 id="3-不同人修改同文件同一区域如何处理"><a href="#3-不同人修改同文件同一区域如何处理" class="headerlink" title="3.不同人修改同文件同一区域如何处理"></a>3.不同人修改同文件同一区域如何处理</h2><p>工作区先进行同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>都对index.html文件的同一区域做了相同的变更，JavaSsun用户将自己的变更推送到了远端，haoran用户想推送自己的变更时被拒绝了。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/954bba88-adef-4176-9d20-f77bfcb8d8df.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果用 merge 直接与远端进行合并，又发现 Already up to date，但又push不上去。</span><br><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p>此时，需要用 git pull 命令,出现了冲突（需手动解决）<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/07f361a2-d594-4c27-84e9-ae0abfafec0e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/100853e3-cee0-4abe-8583-8575cde7c76e.png" alt></p><p><strong>&lt;&lt;&lt;&lt;&lt;HEAD 到 ===========是自己的变更</strong><br><strong>=========到&gt;&gt;&gt;&gt;&gt;&gt;&gt;是别人的变更</strong></p><p>留下双方都需要的变更<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/e869d140-31d9-4126-8225-bcbd683321fd.png" alt></p><p>使用 <strong>git status</strong> 出现提示信息<br><strong>git commit 保留二者的变更。 **<br>**git merge –abort 不想让这两个分支merge，恢复到merge之前的状态。</strong></p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/57b10dc7-595f-4c3f-a5cc-97f6922ab404.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push github 推送即可</span><br><span class="line"></span><br><span class="line">另一个人</span><br><span class="line">git pull  拉取远端最新的变更即可</span><br></pre></td></tr></table></figure><h2 id="4-同时变更了文件名和文件内容如何处理"><a href="#4-同时变更了文件名和文件内容如何处理" class="headerlink" title="4.同时变更了文件名和文件内容如何处理"></a>4.同时变更了文件名和文件内容如何处理</h2><p>A变更了文件名，B变更了文件内容，但还是按照原来的文件名推送。</p><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git mv index.html index.htm</span><br><span class="line">git status</span><br><span class="line">git commit -am &quot;Mv index.html to index.htm&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/08718508-fa10-4155-8729-c6735a141a07.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -am &quot;....&quot;</span><br><span class="line">git push  &#x2F;&#x2F;会报错</span><br><span class="line">git pull  &#x2F;&#x2F; 默认缺省值 :wq</span><br><span class="line">ll -al   &#x2F;&#x2F;文件名已经更改过来 index.htm</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/82033f41-57ba-40ec-b694-0002adfa4244.png" alt></p><h2 id="5-同一文件改成了不同的文件名如何处理"><a href="#5-同一文件改成了不同的文件名如何处理" class="headerlink" title="5.同一文件改成了不同的文件名如何处理"></a>5.同一文件改成了不同的文件名如何处理</h2><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index2.html</span><br><span class="line">git commit -am &quot;Mv index to index2&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/b2ff7258-bf35-4458-ad39-32d94e263c1b.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index1.html</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push &#x2F;&#x2F;报错</span><br><span class="line">git pull &#x2F;&#x2F;报冲突</span><br><span class="line">ll -al   &#x2F;&#x2F;发现出现两个文件</span><br><span class="line">diff index1.htm index2.htm  &#x2F;&#x2F;只是文件名不同，内容是一致的</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f685d46e-0796-4f75-9f98-67064df101dd.png" alt></p><p>查看状态，需要协作者一起协商文件名的选取</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/aaca27e6-94be-4348-b12a-72e295a477ef.png" alt></p><p>如果选择 index1.htm这个名字，需要按以下命令更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git rm index.htm index2.htm</span><br><span class="line">git add index1.htm</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f7faceed-f423-43e3-bbd6-9813f5e448a2.png" alt></p><p>远端的已经变成了index1.htm<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/33006191-16a2-4668-ba75-aba5a7837028.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-不同人修改不同文件如何处理&quot;&gt;&lt;a href=&quot;#1-不同人修改不同文件如何处理&quot; class=&quot;headerlink&quot; title=&quot;1.不同人修改不同文件如何处理&quot;&gt;&lt;/a&gt;1.不同人修改不同文件如何处理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;JavaSsun用户修改 readme文件&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;haoran用户修改index文件&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;远端仓库新建一个名字为 feature/add_git_commands的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了在单机模拟两个人做操作，需要从远端克隆一个 命名为 git_learning_02 以 JavaSsun为用户的仓库&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>3-Git与GitHub简单同步</title>
    <link href="http://javassun.github.io/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/"/>
    <id>http://javassun.github.io/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/</id>
    <published>2019-01-20T11:52:53.000Z</published>
    <updated>2020-04-14T06:13:02.145Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-注册一个GitHub账号"><a href="#1-注册一个GitHub账号" class="headerlink" title="1.注册一个GitHub账号"></a>1.注册一个GitHub账号</h2><p>略<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/3f130bd8-80ca-4c71-973a-0c3bd9146ea3.png" alt></p><a id="more"></a><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/2f0d55c7-f1f5-463a-9c1d-503aea9d7070.png" alt></p><p>将公钥粘贴到GitHub上来，方便推送。</p><h2 id="2-配置公私钥"><a href="#2-配置公私钥" class="headerlink" title="2.配置公私钥"></a>2.配置公私钥</h2><p><strong>查看是否之前有过公私钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ll -al</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/27b6c3ca-54d0-4f78-9fd0-d4efc9cc81b9.png" alt></p><p><strong>如果没有配置过，是不会出现 id_rsa 与 id_rsa.pub这两个文件的</strong></p><p><strong>生成公私钥命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;2642487764@qq.com&quot;</span><br><span class="line">一路回车即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/79ea4449-83f0-4a0c-9920-d8ff5cf7902b.jpg" alt></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/b21dc469-dfff-40c2-abfd-c661b11de310.png" alt></p><p>复制到GitHub的账户上即可、<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a35abfab-8c9d-4e94-a132-f502155abb62.png" alt></p><p><strong>好处</strong>：ssh协议做push活动时不需要再输入用户名密码，可以智能识别，允许自己往对应的GitHub账户上推送内容。</p><h2 id="3-GitHub上创建个人仓库"><a href="#3-GitHub上创建个人仓库" class="headerlink" title="3.GitHub上创建个人仓库"></a>3.GitHub上创建个人仓库</h2><p><strong>MIT License 可以直接拿过来用</strong></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/c7414606-ca57-4231-be64-3d36af153932.png" alt></p><p>点开会拥有 MIT lecense标识<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/07a92364-782e-48a4-8d2f-c0744488765b.png" alt></p><h2 id="4-本地仓库同步到GitHub"><a href="#4-本地仓库同步到GitHub" class="headerlink" title="4.本地仓库同步到GitHub"></a>4.本地仓库同步到GitHub</h2><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a9b74e0a-dc0e-4a35-9b3d-0de613b6569b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add github git@github.com:JavaSsun&#x2F;git_learning.git</span><br><span class="line"></span><br><span class="line">添加远程站点 并更名为  github</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/adf9277a-96d2-4318-a877-134fd63b77cb.png" alt></p><p><strong>有了上述github后 即可与远端建立联系</strong></p><p>因为 远端有了 License文件 ，在本地直接push的时候会报错，提示push前需要把远端的先pull下来。</p><p><strong>没有pull之前的版本树</strong><br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/617d8530-f5e2-447f-b4b9-a9976b5a926f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github master  拉取远端 master上的文件到本地，仅仅是拉取，没有与本地分支做merge</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6d78b45d-b26e-4c80-9596-9268d916ce74.png" alt></p><p>此时 远端的 LICENSE已经被fetch下来</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d21ef24-88fc-48de-a48d-ff36c39e4efa.png" alt></p><p>将本地master与远端master进行merge，但是会报错<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/4eff67a2-224d-4ed5-ac26-b46ca787549f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge -h  查找帮助</span><br><span class="line">git merge --allow-unrelated-histories github&#x2F;master</span><br><span class="line">在交互界面使用默认缺省值即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/8efd7ace-e75e-4fcb-8fb6-95d762d59e44.png" alt></p><p>查看merge后的当前树（发现有两个父亲，rebase则是线性的，只有一个）</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d37e621-8bac-43f7-b421-33b8974df6f5.png" alt></p><p>此时再将本地push到远方，不会再报错</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6b3b24b8-517f-417d-b87d-c04e67347a95.png" alt></p><p>查看当前树</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a48de224-c5cd-428b-a7c0-66acd18e58bb.png" alt></p><p>查看远端仓库</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/da932435-ce0a-4a69-ab63-161987e1bb6d.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-注册一个GitHub账号&quot;&gt;&lt;a href=&quot;#1-注册一个GitHub账号&quot; class=&quot;headerlink&quot; title=&quot;1.注册一个GitHub账号&quot;&gt;&lt;/a&gt;1.注册一个GitHub账号&lt;/h2&gt;&lt;p&gt;略&lt;br&gt;&lt;img src=&quot;/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/3f130bd8-80ca-4c71-973a-0c3bd9146ea3.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>2-Git常用场景</title>
    <link href="http://javassun.github.io/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://javassun.github.io/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2019-01-18T11:05:19.000Z</published>
    <updated>2020-04-14T06:13:32.898Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-删除无用分支"><a href="#1-删除无用分支" class="headerlink" title="1.删除无用分支"></a>1.删除无用分支</h2><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cbe35443-f8b1-43e6-a798-b0828a836ef3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name             &#x2F;&#x2F; 删除分支(会有提示是否确认删除)</span><br><span class="line">git branch -D branch_name             &#x2F;&#x2F; 删除分支（确认删除情况下）</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-修改本地最新commit的messagee"><a href="#2-修改本地最新commit的messagee" class="headerlink" title="2.修改本地最新commit的messagee"></a>2.修改本地最新commit的messagee</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend               &#x2F;&#x2F;可以对最新的commit的message做变更</span><br></pre></td></tr></table></figure><h2 id="3-修改本地老旧commit的message"><a href="#3-修改本地老旧commit的message" class="headerlink" title="3.修改本地老旧commit的message"></a>3.修改本地老旧commit的message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  待修改commit的父ID号        &#x2F;&#x2F; -i交互式</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/caa4ac95-c0c9-491e-b4df-26f9c7faf1ba.png" alt><br>将第一个 pick 改为 reword / r 然后保存,会再次进入交互界面。</p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/8c965b60-3093-4927-b588-f07df7b8ef5d.png" alt></p><p>修改变更的信息后保存，查看信息。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/61baa9ed-06a6-4f23-b99a-442093cfbe82.png" alt></p><h2 id="4-连续多个本地commit整理成1个"><a href="#4-连续多个本地commit整理成1个" class="headerlink" title="4.连续多个本地commit整理成1个"></a>4.连续多个本地commit整理成1个</h2><p>将中间两个合并成一个commit<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f95841b5-9286-4c80-a1b9-2db49e5b147d.png" alt></p><p>此时，应该基准是中间两个的父ID号，即 7f7e472c30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c30</span><br></pre></td></tr></table></figure><p>选用 squash 或者 s 进行合并<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/e7eec623-3f36-4ca8-b02d-8f36a2f92b0d.png" alt></p><p>添加合并信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f2c191d1-ebab-4b52-b01b-fa120ae984a1.png" alt></p><p>git log –graph            //查看日志<br><strong>会对整理后的commit生成一个新的ID号</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/032b9093-e06b-4dbe-80c4-dd35b5ab5300.png" alt></p><h2 id="4-多个本地-间隔commit整理成1个"><a href="#4-多个本地-间隔commit整理成1个" class="headerlink" title="4.多个本地 间隔commit整理成1个"></a>4.多个本地 间隔commit整理成1个</h2><p><strong>将最新的一个与第一个合成一个commit</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/b9d3b699-43ee-4d12-b475-94be40a3bac9.png" alt></p><p>因为最早的一个没有父亲，所以直接使用rebase变更命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/5db8b72f-677d-4a87-acf5-ecad61863d6d.png" alt></p><p>添加   pick 7f7e471c 命令      //最古老的那一个    <strong>合并上限</strong><br>将        s 96764b86 添加到上面命令的下一行  //    <strong>合并下限</strong><br>删除   pick 96764b8  命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue   &#x2F;&#x2F;继续  使用这个继续操作</span><br><span class="line">git rebase --abort      &#x2F;&#x2F;舍弃</span><br></pre></td></tr></table></figure><p>添加变更信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/59279101-2af0-414e-9235-7ad4bdab712d.png" alt></p><p>合并成功，生成新的commit ID号<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/3b7309ee-3845-4d28-9106-cff524594bd5.png" alt></p><p>此时出现两个（树）根 可以看情况删除非master所在的根<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/6e3b571f-984d-4c1a-be95-15d2c6d66dbf.png" alt></p><h2 id="5-比较暂存区与HEAD所含文件的差异"><a href="#5-比较暂存区与HEAD所含文件的差异" class="headerlink" title="5.比较暂存区与HEAD所含文件的差异"></a>5.比较暂存区与HEAD所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变更内容后使用 git add 添加到暂存区</span><br><span class="line">git status</span><br><span class="line">git diff --cached            &#x2F;&#x2F;查看暂存区与HEAD所指向文件的具体变化</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/832bbece-3ea4-4ef6-a4d2-ff94c99a10b0.png" alt></p><h2 id="6-比较暂存区与工作区所含文件的差异"><a href="#6-比较暂存区与工作区所含文件的差异" class="headerlink" title="6.比较暂存区与工作区所含文件的差异"></a>6.比较暂存区与工作区所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff                    &#x2F;&#x2F;默认查看工作区与暂存区所有文件的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name      &#x2F;&#x2F;查看指定文件在工作区与暂存区的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name1 file_name2  file_nameN</span><br></pre></td></tr></table></figure><h2 id="7-将暂存区恢复成HEAD所处状态-变暂存区用-reset"><a href="#7-将暂存区恢复成HEAD所处状态-变暂存区用-reset" class="headerlink" title="7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)"></a>7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区有了新的优化方案。此前暂存区的内容不想保留，想回溯到之前的HEAD所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD                &#x2F;&#x2F;取消暂存区中的文件（文件由绿变红）</span><br><span class="line">git diff --cached             &#x2F;&#x2F;比较暂存区与HEAD 返回为空，即撤销成功</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/4da5296d-6b61-4e5e-92db-15f3430d4179.png" alt></p><h2 id="8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）"><a href="#8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）" class="headerlink" title="8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）"></a>8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区做了变化后，发现没有暂存区的好。<br>想舍弃工作区当前的更改，回溯到暂存区所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file_name   &#x2F;&#x2F; 舍弃工作区的变更，恢复为暂存区的内容</span><br><span class="line">git diff file_name          &#x2F;&#x2F; 没有返回信息，工作区与暂存区一致</span><br></pre></td></tr></table></figure><h2 id="9-取消暂存区部分文件的更改"><a href="#9-取消暂存区部分文件的更改" class="headerlink" title="9.取消暂存区部分文件的更改"></a>9.取消暂存区部分文件的更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- file_name1 file_name2</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/58261fc0-c409-42c7-9c92-9a22d67bc86a.png" alt></p><h2 id="10-消除最近的几次提交"><a href="#10-消除最近的几次提交" class="headerlink" title="10.消除最近的几次提交"></a>10.消除最近的几次提交</h2><p>恢复到提交的前几次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  ID                &#x2F;&#x2F;  回退到指定的commit的ID号</span><br></pre></td></tr></table></figure><h2 id="11-不同提交、分支的指定文件的差异化比较"><a href="#11-不同提交、分支的指定文件的差异化比较" class="headerlink" title="11.不同提交、分支的指定文件的差异化比较"></a>11.不同提交、分支的指定文件的差异化比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff branch_name1 branch_name2    &#x2F;&#x2F;比较两个分支的差异</span><br><span class="line">git diff branch_name1 branch_name2 -- file_name   &#x2F;&#x2F;比较指定文件在指定分支上的差异</span><br><span class="line"></span><br><span class="line">git diff 分支1对应的commit的ID号 分支2对应的commit的ID号   &#x2F;&#x2F;与上述一致</span><br></pre></td></tr></table></figure><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>常规做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm  指定文件名    &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git status       &#x2F;&#x2F;变红色，说明仅仅是删除了工作区中的，</span><br><span class="line">git rm 指定文件名 &#x2F;&#x2F;删除暂存区文件</span><br><span class="line">git status       &#x2F;&#x2F;变绿色，说明暂存区中文件被删除</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD  &#x2F;&#x2F;废除刚才所有变动</span><br></pre></td></tr></table></figure><p><strong>git 做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 指定文件名</span><br><span class="line">git status &#x2F;&#x2F; 变绿色</span><br></pre></td></tr></table></figure><h2 id="13-开发中临时添加紧急任务（stash）"><a href="#13-开发中临时添加紧急任务（stash）" class="headerlink" title="13.开发中临时添加紧急任务（stash）"></a>13.开发中临时添加紧急任务（stash）</h2><p>工作区与暂存区中的内容暂时还不能提交，但是当前又有一个更为紧急的任务需要完成时，可以把工作区与暂存区中的内容存放到另一个空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff       &#x2F;&#x2F; 工作区与暂存区是有差异的</span><br><span class="line">git stash      &#x2F;&#x2F; 将未commit的内容存放另一个空间</span><br><span class="line">git stash list &#x2F;&#x2F; 可以看到类似于存放在有ID号的堆栈中</span><br><span class="line">git status     &#x2F;&#x2F; 工作区与暂存区是干净的</span><br></pre></td></tr></table></figure><p><strong>此时可以处理紧急任务，add到暂存区，commit到仓库后，再回来继续当前开发，需要将之前存储在另一个空间的内容恢复出来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash apply &#x2F;&#x2F; 将内容弹出，但不删除空间中的内容，可反复使用</span><br><span class="line">git stash list  &#x2F;&#x2F; 依然存在</span><br><span class="line">git stash pop   &#x2F;&#x2F; 弹出且删除空间中的内容</span><br><span class="line">git stash list  &#x2F;&#x2F; 什么也没有</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/348f60ab-06f0-4957-8551-9c7dae0ef36c.png" alt></p><p><strong>处理完紧急任务后弹出内容</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/9578d032-8074-4f0c-b3d6-5d30c9bfd9bb.png" alt></p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cf033f3f-a3b8-4607-826a-f034b1aee126.png" alt></p><h2 id="14-指定不需要Git管理的文件"><a href="#14-指定不需要Git管理的文件" class="headerlink" title="14.指定不需要Git管理的文件"></a>14.指定不需要Git管理的文件</h2><p><strong>建立一个文件，指定文件名为 .gitignore</strong></p><p>在文件中添加需要Git版本忽略的文件即可。</p><p>可在GitHub上查看<br><a href="https://github.com/github-tools/github/blob/master/.gitignore" target="_blank" rel="noopener">https://github.com/github-tools/github/blob/master/.gitignore</a></p><h2 id="15-备份Git仓库到本地"><a href="#15-备份Git仓库到本地" class="headerlink" title="15.备份Git仓库到本地"></a>15.备份Git仓库到本地</h2><p>常用的传输协议<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/be6aa585-e6f5-4670-95d0-f34a4c1623d7.jpg" alt></p><p><strong>哑协议与智能协议</strong></p><p><strong>直观区别</strong>：哑协议传输进度不可见；智能协议传输可见。<br><strong>传输速度</strong>：智能协议比哑协议传输速度快。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/35a50a7b-3fbb-4413-9cec-692c4b2bdb72.jpg" alt></p><p><strong>哑协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git ya.git</span><br><span class="line">从本地另一个Git仓库中克隆一个文件到当前仓库</span><br><span class="line">--bare 是只克隆仓库中的内容，不可隆工作区中的内容</span><br><span class="line">将 .git 文件更名为 ya.git文件</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/ac7afc75-38b6-48e2-a671-8c6c719c2199.png" alt></p><p><strong>智能协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git zhineng.git</span><br><span class="line"></span><br><span class="line">前面添加    file:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/a1a209cd-6efb-40d7-9b5c-e090082711ed.png" alt></p><p><strong>本地推远端仓库（demo）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add zhineng file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;666-backup&#x2F;zhineng.git</span><br><span class="line">git brach -av</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;1-删除无用分支&quot;&gt;&lt;a href=&quot;#1-删除无用分支&quot; class=&quot;headerlink&quot; title=&quot;1.删除无用分支&quot;&gt;&lt;/a&gt;1.删除无用分支&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cbe35443-f8b1-43e6-a798-b0828a836ef3.png&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch -d branch_name             &amp;#x2F;&amp;#x2F; 删除分支(会有提示是否确认删除)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git branch -D branch_name             &amp;#x2F;&amp;#x2F; 删除分支（确认删除情况下）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>1-Git安装及简单操作</title>
    <link href="http://javassun.github.io/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
    <id>http://javassun.github.io/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</id>
    <published>2019-01-15T12:44:23.000Z</published>
    <updated>2020-04-14T06:08:55.968Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p>图片来源：极客时间，需个人购买教程。</p><h2 id="Git下载路径-https-git-scm-com"><a href="#Git下载路径-https-git-scm-com" class="headerlink" title="Git下载路径 https://git-scm.com/"></a>Git下载路径 <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></h2><h4 id="廖雪峰-Git文档"><a href="#廖雪峰-Git文档" class="headerlink" title="廖雪峰 Git文档"></a>廖雪峰 Git文档</h4><h2 id="https-www-liaoxuefeng-com-wiki-896043488029600"><a href="#https-www-liaoxuefeng-com-wiki-896043488029600" class="headerlink" title="https://www.liaoxuefeng.com/wiki/896043488029600"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version     &#x2F;&#x2F;可查看版本即安装成功</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-使用Git前的小配置"><a href="#1-使用Git前的小配置" class="headerlink" title="1.使用Git前的小配置"></a>1.使用Git前的小配置</h3><h4 id="配置User信息-（user-name-和-user-email）"><a href="#配置User信息-（user-name-和-user-email）" class="headerlink" title="配置User信息  （user.name 和 user.email）"></a>配置User信息  （user.name 和 user.email）</h4><p>方便代码变更时展示变更人信息 及 通知协作者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure><h4 id="config-作用域"><a href="#config-作用域" class="headerlink" title="config 作用域"></a><font color="red">config 作用域</font></h4><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6075a03d-a390-4546-ad59-1b2a2a5c1795.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br><span class="line">git config --local user.name</span><br><span class="line">git config --local user.email</span><br></pre></td></tr></table></figure><h3 id="2-建Git仓库"><a href="#2-建Git仓库" class="headerlink" title="2.建Git仓库"></a>2.建Git仓库</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/025b15b1-6dd2-4a50-9d4d-b152d763370d.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git add                 &#x2F;&#x2F; 添加文件到暂存区</span><br><span class="line">git commit -m &#39;变更内容&#39; &#x2F;&#x2F; 添加文件到Git仓库</span><br><span class="line">git status              &#x2F;&#x2F; 查看文件状态</span><br><span class="line">git log                 &#x2F;&#x2F; 查看提交日志</span><br><span class="line"></span><br><span class="line">git checkout branc_name &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b branch_name &#x2F;&#x2F;创建并切换新分支</span><br><span class="line"></span><br><span class="line">git commit -am &#39;变更信息&#39; &#x2F;&#x2F;直接推到仓库，跳过暂存区，不推荐使用</span><br></pre></td></tr></table></figure><h4 id="local-优先级高于-global，即全局设置的global会被某一个local仓库的信息给覆盖"><a href="#local-优先级高于-global，即全局设置的global会被某一个local仓库的信息给覆盖" class="headerlink" title=" local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖"></a><font color="red"> local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖</font></h4><h3 id="3-工作区与暂存区"><a href="#3-工作区与暂存区" class="headerlink" title="3.工作区与暂存区"></a>3.工作区与暂存区</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/0ea1afe7-4fd5-4f90-825e-d0f280c38dbb.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u            &#x2F;&#x2F; 可以将已修改的 Git所管理的文件 一起提到暂存区，如下所示</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9ff91e2a-397a-450e-b95c-5d266c60d2e3.jpg" alt></p><h3 id="4-Git-中的文件重命名"><a href="#4-Git-中的文件重命名" class="headerlink" title="4.Git 中的文件重命名"></a>4.Git 中的文件重命名</h3><p>常规步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv old_name  new_name       &#x2F;&#x2F; 重命名</span><br><span class="line">git add  new_name           &#x2F;&#x2F; 添加新文件进入暂存区</span><br><span class="line">git rm old_name             &#x2F;&#x2F; 删除暂存区中旧的文件</span><br><span class="line">git status                  &#x2F;&#x2F; Git智能的认为是文件重命名</span><br><span class="line">---  太繁琐  ---</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/cf8ae066-98f1-4e68-bbe9-7839f0e8fba7.png" alt></p><p><font color="red">Git方式重命名</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name  new_name  &#x2F;&#x2F; Git重命名文件   3合1</span><br><span class="line">git status                 &#x2F;&#x2F; 查看状态</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e6ad4c3-298d-4359-92df-fe65f2eb8ee5.png" alt></p><h3 id="5-git-log-查看版本演变历史"><a href="#5-git-log-查看版本演变历史" class="headerlink" title="5.git log 查看版本演变历史"></a>5.git log 查看版本演变历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git log                        &#x2F;&#x2F; 查看当前分支详细版本历史</span><br><span class="line"></span><br><span class="line">git log --oneline              &#x2F;&#x2F; 查看当前分支简略版本历史</span><br><span class="line"></span><br><span class="line">git log -n2                    &#x2F;&#x2F; 查看当前分支最近的两次版本提交记录</span><br><span class="line">git log -n2 --oneline          &#x2F;&#x2F; 组合使用</span><br><span class="line"></span><br><span class="line">git branch -a                  &#x2F;&#x2F; 查看有多少分支(简略)</span><br><span class="line">git branch -v                  &#x2F;&#x2F; 查看有多少分支(详细)</span><br><span class="line">git branch -av                 &#x2F;&#x2F; 常用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log                        &#x2F;&#x2F; 查看当前分支版本</span><br><span class="line"></span><br><span class="line">git log temp                   &#x2F;&#x2F; 查看指定分支temp的历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline temp         &#x2F;&#x2F; 查看指定分支temp的简略历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline --all temp   &#x2F;&#x2F; 此时 依然是查看所有分支的历史版本，temp不再起作用</span><br><span class="line"></span><br><span class="line">git log --all                  &#x2F;&#x2F; 查看所有分支版本历史</span><br><span class="line"></span><br><span class="line">git log --all --graph          &#x2F;&#x2F; 以图形化的方式查看所有分支（父子关系分支）关系</span><br></pre></td></tr></table></figure><p><font color="red">按需求组合：</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5db3e9f7-aabf-4ef3-9864-42aed7a2099e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all -n4 --graph         &#x2F;&#x2F; 查看简略ID</span><br><span class="line">git log --pretty&#x3D;oneline --all -n4 --graph  &#x2F;&#x2F; 查看详细ID</span><br></pre></td></tr></table></figure><p><strong>使用网页方式查看相关命令帮助</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help --web  log            &#x2F;&#x2F; 以网页方式查看log命令用法</span><br><span class="line">git help --web  commit         &#x2F;&#x2F; 以网页方式查看commit命令用法</span><br></pre></td></tr></table></figure><h3 id="6-gitk-通过图形界面工具查看版本演变历史"><a href="#6-gitk-通过图形界面工具查看版本演变历史" class="headerlink" title="6.gitk   通过图形界面工具查看版本演变历史"></a>6.gitk   通过图形界面工具查看版本演变历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br><span class="line"></span><br><span class="line">gitk --all</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ddf34b16-0714-4641-8483-02fffa3fcc0c.png" alt></p><h3 id="7-探索-git目录"><a href="#7-探索-git目录" class="headerlink" title="7.  探索.git目录"></a>7.  探索.git目录</h3><h5 id="HEAD文件"><a href="#HEAD文件" class="headerlink" title="HEAD文件"></a>HEAD文件</h5><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28fe4315-38cf-495f-8da8-0731f13553d7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat HEAD        &#x2F;&#x2F;查看HEAD文本内容 HEAD是一个引用，指向当前工作分支，指向的是refs文件夹下的heads文件夹下的某个分支的ID号</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/d99a688c-7472-48a0-a725-d089915e1249.png" alt></p><p><font color="red">切换回master分支后，HEAD内容发生变化</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/03ef6a79-099b-4929-be05-36bb21a766f4.png" alt></p><h5 id="config配置文件"><a href="#config配置文件" class="headerlink" title="config配置文件"></a>config配置文件</h5><p>对config作用域的user信息的修改直接保存到该文件中。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/98e5bb44-5de4-4ee8-8226-019330ad2950.png" alt></p><p>将user.name 由 local1 改为local2后，再次查看该文件发现已经更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list      &#x2F;&#x2F;列出本地所有可以看得信息</span><br><span class="line">git config --local user.nane   &#x2F;&#x2F;列出指定信息（如user.name）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c595b00-c8c0-47d9-a8aa-793465e69f43.png" alt></p><p><strong>再次修改回去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &#39;local1&#39;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6c514813-a599-410d-98f0-144f247436ab.png" alt></p><h5 id="refs文件夹"><a href="#refs文件夹" class="headerlink" title="refs文件夹"></a>refs文件夹</h5><p>heads: 分支，一个独立的开发空间，前后端各1个分支，互不影响，需要集成时，合并到一个共同的分支上。<br>tags: 标签/里程碑 标明一个版本等。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28046633-46c0-4af5-8ad1-36344f509e92.png" alt></p><p><strong>heads文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t ID号前几位        &#x2F;&#x2F;查看存放的对象是一个什么类型 （commit类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/e0e52020-8d55-44b6-8a0a-392604927f6c.png" alt></p><p><strong>tags文件夹</strong></p><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c392142-567a-466e-b72a-f7bff540600f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p ID号前几位         &#x2F;&#x2F; 查看内容（tag类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/76815d92-3063-4ae0-8e1e-9d260cf93fac.png" alt></p><h5 id="objects文件夹"><a href="#objects文件夹" class="headerlink" title="objects文件夹"></a>objects文件夹</h5><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6659db73-a48b-4935-b5fe-33b9af5f6978.png" alt></p><p><strong>查看98文件夹下存放的类型与内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看类型（tree类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/09cba8a4-0998-4c2b-a306-a57336988f2b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看内容</span><br><span class="line"></span><br><span class="line">blob 文本类型   再次查看blob ID号对应的内容是文本信息</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a2cd87bf-3284-4f0f-ad62-b512505b0199.png" alt></p><p>内容是文本里的内容信息</p><p><font color="red">核心类型：</font><br><strong>TREE  / COMMIT  /  BLOB</strong></p><h3 id="8-commit、tree、blob-三者关系"><a href="#8-commit、tree、blob-三者关系" class="headerlink" title="8.  commit、tree、blob 三者关系"></a>8.  commit、tree、blob 三者关系</h3><p>Git眼中，文件内容完全相同，就被认为是同一个对象。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c6b17719-a3a1-4b69-9edb-76ed250c6cef.jpg" alt><br>**<br>一个commit 对应一个 tree<br>blob 对应文本文件<br>tree 对应文件夹，文件夹下可能有tree或者blob<br>**<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ae5fb42a-36b4-4df1-bf33-9c3f29353970.png" alt></p><h3 id="8-tree的个数"><a href="#8-tree的个数" class="headerlink" title="8.  tree的个数"></a>8.  tree的个数</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c44300e9-0b7b-462a-b9d4-bc00140c4c3a.jpg" alt></p><p>查看某个目录下类型是文件的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .git&#x2F;objects -type f</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/96621697-d0f6-4774-8282-e08b68043fb7.png" alt></p><p>2个tree，1个commit，1个blob</p><h3 id="9-分离头指针时的注意事项（detached-HEAD）"><a href="#9-分离头指针时的注意事项（detached-HEAD）" class="headerlink" title="9.  分离头指针时的注意事项（detached HEAD）"></a>9.  分离头指针时的注意事项（detached HEAD）</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2ed04c46-8f7f-4bf7-b619-2df3653fb36b.png" alt></p><p>如果此时对某些文件做了修改，并提交到仓库后，切换分支时，会提示是否给当前没有依赖的变更创建新的分支，如果不创建，会丢失这次修改。<br>在Git看来，如果没有将某个commit与分支或者tag绑定，都会被清除<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5dc33929-8d2e-418e-96a5-1aea442dfbd6.png" alt></p><p>按照提示 git branch branch_name ID号 进行分支的挂钩，即可保留修改。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1b1a7c5a-850a-4d0f-bc42-b388bf34e891.png" alt></p><p><strong>因此，分离头指针指的是 某个变更没有基于branch进行，在切换分支时，分离头指针下的commit会被Git当做垃圾清理掉。如果这些变更是重要的，要与某个分支绑定在一起。</strong></p><h3 id="9-HEAD-与-branch"><a href="#9-HEAD-与-branch" class="headerlink" title="9.  HEAD 与 branch"></a>9.  HEAD 与 branch</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/dcec9acc-64e3-4422-8b45-58ac5b9e8b40.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch_name      &#x2F;&#x2F;基于当前分支创建新分支</span><br><span class="line">git checkout -b new_branch_name old_branch_name   &#x2F;&#x2F;基于指定分支创建新分支</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/587b9e50-28f3-40ec-bd1c-8ae109102004.png" alt></p><p>此时 .git/HEAD 的引用也指向了新的分支<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e96d652-d2b3-45c8-84b0-a6e6aec3a29f.png" alt></p><p><strong>HEAD 既可以指向最后一次提交的分支，也可以不与任何分支挂钩（即处于分离头指针状态下），整个HEAD指向了某个 commit上。当做分支切换时，HEAD指向新分支</strong></p><p><font color="red">HEAD 指向分支，分支指向commit，或者HEAD直接指向commit</font>.</p><p><strong>比较两次commit的差异性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff 待比较ID1  待比较ID2     &#x2F;&#x2F; ID1与ID2的提交比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD^1             &#x2F;&#x2F; 当前HEAD所指向的commit与他的父亲（上一次）比较</span><br><span class="line">git diff HEAD HEAD^1^1           &#x2F;&#x2F; 当前HEAD所指向的commit与他的爷爷（上两次）比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD~n             &#x2F;&#x2F; 当前HEAD所指向的commit与 上n次 比较</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;图片来源：极客时间，需个人购买教程。&lt;/p&gt;
&lt;h2 id=&quot;Git下载路径-https-git-scm-com&quot;&gt;&lt;a href=&quot;#Git下载路径-https-git-scm-com&quot; class=&quot;headerlink&quot; title=&quot;Git下载路径 https://git-scm.com/&quot;&gt;&lt;/a&gt;Git下载路径 &lt;a href=&quot;https://git-scm.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://git-scm.com/&lt;/a&gt;&lt;/h2&gt;&lt;h4 id=&quot;廖雪峰-Git文档&quot;&gt;&lt;a href=&quot;#廖雪峰-Git文档&quot; class=&quot;headerlink&quot; title=&quot;廖雪峰 Git文档&quot;&gt;&lt;/a&gt;廖雪峰 Git文档&lt;/h4&gt;&lt;h2 id=&quot;https-www-liaoxuefeng-com-wiki-896043488029600&quot;&gt;&lt;a href=&quot;#https-www-liaoxuefeng-com-wiki-896043488029600&quot; class=&quot;headerlink&quot; title=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.liaoxuefeng.com/wiki/896043488029600&lt;/a&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git --version     &amp;#x2F;&amp;#x2F;可查看版本即安装成功&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="http://JavaSsun.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>TextRank基本了解</title>
    <link href="http://javassun.github.io/2018/09/01/TextRank/"/>
    <id>http://javassun.github.io/2018/09/01/TextRank/</id>
    <published>2018-09-01T02:40:48.000Z</published>
    <updated>2020-04-14T04:45:37.392Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一-TextRank算法介绍"><a href="#一-TextRank算法介绍" class="headerlink" title="一. TextRank算法介绍"></a>一. TextRank算法介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法相对来说，是一种很简单的算法。算法的流程类似于Kleinberg的HITS算法，<font color="red">Google</font>的PageRank算法，不得不说GooglePageRank算法的出现引发了搜索引擎的一次变革。PageRank算法成功运用到互联网上来评估网页的重要性，当用户搜索时，返回与搜索问题相关又有质量的网页。TextRank算法可以说借鉴了PageRank算法的思想，也非常成功的运用到文章的引文提取，关键词提取上。当然一个单纯的算法来提取关键词，可能效果并不如意，可以结合其他算法，比如TF-IDF来筛选有力表达主题/文章中心思想的词语。</p><a id="more"></a><h1 id="二-TextRank算法解析"><a href="#二-TextRank算法解析" class="headerlink" title="二. TextRank算法解析"></a>二. TextRank算法解析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法对文章关键词进行提取的过程，实际就是迭代计算一个由文章中的词语构建的有向有权图G=(V,E) 。其中集合V(图中的节点)有文章中的词语构成，中文我们可以利用ansj_seg进行分词筛选特定词性的词。集合E(图中的边)由文章中的词在特定的滑动窗口下组成。E是一个VxV的子集。图中任意两节点Vi,Vj之间的权重为Wij，而对于一个节点Vi，In(Vi)表示图中指向该节点的其他节点集合，入度。而Out(Vi)为节点Vi指向的其他节点的集合。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于TextRank算法每次迭代是Vi节点的得分的计算公式为：<img src="/2018/09/01/TextRank/6d3a90f9-54f5-411b-bf3d-5e119062f76e.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;其中d是一个阻尼系数，其值在0到1之间。代表从图中一节点指向其他任意一节点的概率, 一般取值为 0.85。上述的公式，表示当前节点Vi的值为所有指向Vi的节点Vj给予的值的和。就相当于，我现在手上有1个苹果，如果我收集了我朋友给我的苹果，我将有多少个苹果的问题。假如我有两个朋友，他们会给我一些苹果，而我现在拥有的苹果数量就是他们给我的苹果数量的和。朋友A有3个苹果，但是同样他有3个朋友，而且需要给苹果给他的朋友，所以只能给我3/3＝1个苹果。朋友B有6个苹果，他有3个朋友，那么他给我6/3=2个苹果。那我现在手头将有1+1+3=5个苹果。实际中还要乘阻尼系数。TextRank算法就是这样迭代计算每个节点的值，而算法停止可以采用指定的迭代次数或者图中节点的值跟上次结果值的误差是否小于一个制定的极限值，一般取值为：0.0001。</p><h1 id="三-TextRank算法文本关键词提取"><a href="#三-TextRank算法文本关键词提取" class="headerlink" title="三. TextRank算法文本关键词提取"></a>三. TextRank算法文本关键词提取</h1><p>主要步骤：</p><ol><li>利用分词工具对文本进行分词</li><li>指定滑动窗口大小</li><li>滑动窗口经过文本词组，构建有向有权图。</li><li>迭代计算有向有权图，直到收敛。</li></ol><p>注意：在构建有向有权图时候，只筛选特定词性的词作为节点，比如名词，动词，形容词等，同时删除停用词。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol><li><p>一个文本，对其进行分词后，词组组成一个集合：<br>T = [S1,S2,S3,S1,S5,S6,S7,S8,S9]</p></li><li><p>指定滑动窗口大小为3</p></li><li><p>窗口里面的词组构建图，每次都是以窗口头结点为主节点。如下图所示：</p></li></ol><p>A：窗口第一次经过的词组，那么组成的边有:(S1,S2),(S2,S1),(S1,S3),(S3,S1)<br><img src="/2018/09/01/TextRank/e78a6e11-0507-4e6e-a289-a6bd1d4365b2.jpg" alt><br>B：窗口第二次经过的词组,组成的边有：(S2,S3),(S3,S1),(S2,S1),(S1,S2)。遇到重叠的边，则权重加1.<br><img src="/2018/09/01/TextRank/59840975-e639-4ab7-970b-171816be466e.jpg" alt><br>C：构建图完成之后，按照textRank算法的执行步骤，迭代计算，直到收敛。</p><p>D：最后对节点的权重排序输出。</p><h1 id="四-TextRank算法Scala代码实现"><a href="#四-TextRank算法Scala代码实现" class="headerlink" title="四. TextRank算法Scala代码实现"></a>四. TextRank算法Scala代码实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法的实现，这里采用scala，分词工具采用ansj_seg，这里scala代码实现的TextRank算法，只实现关键词的提取，没有实现句子提取，后续再补充。代码略。<br>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">object TextRankTest&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val tr &#x3D; new TextRank</span><br><span class="line">    tr.setStopword(Config.STOP_WORDS_FILE)&#x2F;&#x2F;停用词</span><br><span class="line">    val text &#x3D; &quot;机器学习是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。&quot;</span><br><span class="line">    val tags &#x3D; tr.textrank(sentence &#x3D; text,topK &#x3D; 10, allowPOS &#x3D; List(&quot;ns&quot;, &quot;vn&quot;, &quot;n&quot;, &quot;nr&quot;, &quot;nt&quot;, &quot;mama&quot;))</span><br><span class="line">    tags.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(算法,n,1.0)</span><br><span class="line">(学科,n,0.963356)</span><br><span class="line">(理论,n,0.934734)</span><br><span class="line">(分析,vn,0.85816)</span><br><span class="line">(机器学习,n,0.723762)</span><br><span class="line">(数据,n,0.615997)</span><br><span class="line">(规律,n,0.537537)</span><br><span class="line">(设计,vn,0.474728)</span><br><span class="line">(概率论,n,0.466409)</span><br><span class="line">(复杂度,n,0.442039)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h1 id=&quot;一-TextRank算法介绍&quot;&gt;&lt;a href=&quot;#一-TextRank算法介绍&quot; class=&quot;headerlink&quot; title=&quot;一. TextRank算法介绍&quot;&gt;&lt;/a&gt;一. TextRank算法介绍&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;TextRank算法相对来说，是一种很简单的算法。算法的流程类似于Kleinberg的HITS算法，&lt;font color=&quot;red&quot;&gt;Google&lt;/font&gt;的PageRank算法，不得不说GooglePageRank算法的出现引发了搜索引擎的一次变革。PageRank算法成功运用到互联网上来评估网页的重要性，当用户搜索时，返回与搜索问题相关又有质量的网页。TextRank算法可以说借鉴了PageRank算法的思想，也非常成功的运用到文章的引文提取，关键词提取上。当然一个单纯的算法来提取关键词，可能效果并不如意，可以结合其他算法，比如TF-IDF来筛选有力表达主题/文章中心思想的词语。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://JavaSsun.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>(5)Hexo踩坑_主题优化</title>
    <link href="http://javassun.github.io/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <id>http://javassun.github.io/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</id>
    <published>2018-08-21T09:15:09.000Z</published>
    <updated>2020-04-14T05:18:46.974Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="0-字体乱码问题"><a href="#0-字体乱码问题" class="headerlink" title="0 字体乱码问题"></a>0 字体乱码问题</h2><p>Windows 上新建的文件一般都是 <strong>gb2312或iso-8859-1</strong>，这样windows下的文件传递到Linux可能会出乱码问题</p><p>用 Git进去文件使用命令查看文件是否是<strong>utf-8</strong> 格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i word.ejs</span><br><span class="line">word.ejs: text&#x2F;html; charset&#x3D;iso-8859-1(或是其他)</span><br></pre></td></tr></table></figure><p><strong>第一种</strong><br>最简单的办法就是  vim  word.ejs</p><a id="more"></a><p>设置 set fileencoding=utf-8，强制保存，此时中文会乱码，再次输入即可</p><p><strong>第二种</strong></p><p>找一个 是 utf-8文件的 直接粘贴到需要位置，改名删除内容，写上自己的内容即可。</p><h2 id="1-图片无法加载"><a href="#1-图片无法加载" class="headerlink" title="1 图片无法加载"></a>1 图片无法加载</h2><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><p>效果如下图：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/83b0faba-efa5-477e-b4bf-be002402fb8b.jpg" alt></p><h2 id="2-点击所有文章-缺失模块"><a href="#2-点击所有文章-缺失模块" class="headerlink" title="2 点击所有文章 缺失模块"></a>2 点击所有文章 缺失模块</h2><p>缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br>npm i hexo-generator-json-content –save</p><p>3、在根目录_config.yml里添加配置：直接粘贴复制即可。（自己手打可能出错）</p><pre q-show="jsonFail" style="box-sizing: border-box; overflow: auto; white-space: pre-wrap; overflow-wrap: break-word; font-family: monospace, monospace; font-size: 12px;">  jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</pre><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9266a57c-8ba0-4ea9-831d-5d868b6de1de.jpg" alt></p><h2 id="3-个人头像及网站图标"><a href="#3-个人头像及网站图标" class="headerlink" title="3 个人头像及网站图标"></a>3 个人头像及网站图标</h2><h3 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h3><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。</p><h2 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h2><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/avatar.png</code>，设置则为<code>avatar: /assets/avatar.png</code>。（图标同理）</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f3f4cf22-244b-4dc6-9ec6-80772d70eeb5.jpg" alt></p><h2 id="4-文章摘要"><a href="#4-文章摘要" class="headerlink" title="4 文章摘要"></a>4 文章摘要</h2><p>目前主要是两种方式在首页显示文章摘要而不是全文</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1 "></a>方法1 <!--more--></h3><p>ps: 之前最好不要有空格</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/EBX_29_24AY7O_5DK_7EUZCSA2LR1BN.png" alt></p><h3 id="方法2-description-in-Front-matter"><a href="#方法2-description-in-Front-matter" class="headerlink" title="方法2 description in Front-matter"></a>方法2 description in Front-matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2015-12-03 00:00:00</span><br><span class="line">description: &quot;Welcome to Hexo! This is your very first post.&quot;</span><br><span class="line">---</span><br><span class="line">&lt;Contents&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>description</code> 添加的摘要只能为纯文本</p><p><code>description</code> 中的内容加引号，可以避免一些程序错误，例如当内容里包含英文冒号时。</p><h2 id="5-主菜单"><a href="#5-主菜单" class="headerlink" title="5 主菜单"></a>5 主菜单</h2><p>按下面格式添加侧边栏，菜单前的<font color="red">#</font>表示隐藏该条目<font color="red">themes/yilia/_config.yml</font>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按需求更改</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  所有文章: &#x2F;archives&#x2F;</span><br><span class="line">  #随笔: &#x2F;tags&#x2F;随笔</span><br><span class="line">  标签云: &#x2F;tags&#x2F;</span><br><span class="line">  关于我: &#x2F;about&#x2F;</span><br></pre></td></tr></table></figure><h2 id="6-标签云"><a href="#6-标签云" class="headerlink" title="6 标签云"></a>6 标签云</h2><p>使用 Hexo 命令新建一个tags的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/60e3c4cd-8d7d-43ab-8d6d-70d12b414979.png" alt></p><p>该页面标题可以在 /hexo/source/tags/index.md 中修改</p><p>同一片文章设置多个分类后的问题 <a href="https://github.com/MOxFIVE/hexo-theme-yelee/issues/4" target="_blank" rel="noopener">issue#4</a></p><h2 id="7-关于我"><a href="#7-关于我" class="headerlink" title="7 关于我"></a>7 关于我</h2><p>使用 Hexo 命令新建一个名为 <code>about</code> 的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>该页面内容在文件 <code>\hexo\source\about\index.md</code> 中修改</p><h2 id="8-本地搜索"><a href="#8-本地搜索" class="headerlink" title="8 本地搜索"></a>8 本地搜索</h2><p>使用搜索需先安装对应插件，用于生成索引数据</p><p>插件主页: <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置插件启用为true 到根目录下的_config.yml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line"> on: true</span><br><span class="line"> onload: false</span><br></pre></td></tr></table></figure><p><strong>onload: true：</strong> 索引数据<strong>search.xml</strong>随页面一起加载（效率优先）<br><strong>onload：false：</strong> 当激活搜索框时在下载索引数据（按需加载）</p><h2 id="9-社交图标"><a href="#9-社交图标" class="headerlink" title="9 社交图标"></a>9 社交图标</h2><p>去掉前面的 # 再填写链接即可</p><p><font color="red">themes/yilia/_config.yml</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line"> Email: &quot;haoransunlin@163.com&quot;</span><br><span class="line"> #新浪微博: &quot;sina weibo&quot;</span><br><span class="line"> GitHub: ...</span><br><span class="line"> #RSS: &quot;&#x2F;aotm.xml&quot;</span><br></pre></td></tr></table></figure><p>设置 Email 时保留 <code>mailto:</code> 可考虑加密邮件地址 <a href="http://ctrlq.org/encode/" target="_blank" rel="noopener">http://ctrlq.org/encode/</a></p><p>使用 RSS 需先安装对应插件 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><h2 id="10-网站运行时间-暂时没有配置"><a href="#10-网站运行时间-暂时没有配置" class="headerlink" title="10 网站运行时间(暂时没有配置)"></a>10 网站运行时间(暂时没有配置)</h2><h3 id="1-修改-themes-yilia-config-yml-添加如下内容"><a href="#1-修改-themes-yilia-config-yml-添加如下内容" class="headerlink" title="1 修改 \themes\yilia_config.yml 添加如下内容"></a>1 修改 \themes\yilia_config.yml 添加如下内容</h3><p>网站运行时间，格式形如：“本站已安全运行 50 天 12 小时 13 分 41 秒”<br>Runing Time<br>running_time:<br> enable: true<br> create_time: ‘07/25/2019 12:00:00’ #此处修改你的建站时间或者网站上线时间</p><h3 id="2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容："><a href="#2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容：" class="headerlink" title="2 修改\themes\yilia\layout\_partial\footer.ejs，在&lt;/footer&gt;上面添加如下内容："></a>2 修改<code>\themes\yilia\layout\_partial\footer.ejs</code>，在<code>&lt;/footer&gt;</code>上面添加如下内容：</h3><!--《添加网站运行时间  <br/>--><p>&lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time){ %&gt;<br>    <span id="timeDate">载入天数…</span><span id="times">载入时分秒…</span><br>    <script><br>    var now = new Date();<br>    function createtime() {<br>        //此处修改你的建站时间或者网站上线时间<br>        var create_time = '<%- theme.running_time.create_time %>';<br>        now.setTime(now.getTime() + 250);<br>        days = (now - grt) / 1000 / 60 / 60 / 24;<br>        dnum = Math.floor(days);<br>        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);<br>        hnum = Math.floor(hours);<br>        if (String(hnum).length == 1) {<br>            hnum = "0" + hnum;<br>        }<br>        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);<br>        mnum = Math.floor(minutes);<br>        if (String(mnum).length == 1) {<br>            mnum = "0" + mnum;<br>        }<br>        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);<br>        snum = Math.round(seconds);<br>        if (String(snum).length == 1) {<br>            snum = "0" + snum;<br>        }<br>        document.getElementById("timeDate").innerHTML = " | 本站已安全运行 " + dnum + " 天 ";<br>        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";<br>    }<br>    setInterval("createtime()", 250);<br>    </script><br>&lt;% } %&gt;</p><!-- 添加网站运行时间》--><h2 id="11-背景图片"><a href="#11-背景图片" class="headerlink" title="11 背景图片"></a>11 背景图片</h2><p>*<em>推荐大小：700 x 1200 *</em></p><h3 id="1-找到-themes-lilia-目录下的-config-yml-修改配置如下："><a href="#1-找到-themes-lilia-目录下的-config-yml-修改配置如下：" class="headerlink" title="1 找到 themes\lilia\目录下的 _config.yml,修改配置如下："></a>1 找到 themes\lilia\目录下的 _config.yml,修改配置如下：</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/2488f7cb-b9a9-4f5e-b191-8b9fd0200767.png" alt></p><h3 id="2-将选好的背景图片放入-themes-yilia-source-assets-目录下"><a href="#2-将选好的背景图片放入-themes-yilia-source-assets-目录下" class="headerlink" title="2 将选好的背景图片放入 themes\yilia\source\assets 目录下"></a>2 将选好的背景图片放入 themes\yilia\source\assets 目录下</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/a9d8f38d-868e-48ba-8299-1f2dd027adaa.jpg" alt></p><h3 id="3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）"><a href="#3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）" class="headerlink" title="3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）"></a>3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）</h3><p><strong>ctrl + f 搜索：.left-col{ 、.left-col .overlay{ 、#mobile-nav .overlay</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/aeda14f1-204f-4735-a71a-b5df19eb9bc4.png" alt></p><p>里面添加 <strong>background-image:url(“图片地址”)即可</strong></p><p>字体颜色需要自己根据背景图片来调配</p><p>搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.left-col #header a&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header a:hover&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header .header-subtitle&#123;</span><br></pre></td></tr></table></figure><h3 id="4-打开-yilia-layout-partial-left-col-ejs"><a href="#4-打开-yilia-layout-partial-left-col-ejs" class="headerlink" title="4 打开 yilia\layout_partial\left-col,ejs"></a>4 打开 yilia\layout_partial\left-col,ejs</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9c9a363b-d5e2-4785-b13d-5b4e4945b8ce.png" alt></p><p>重新部署即可看到效果</p><h2 id="12-文章目录"><a href="#12-文章目录" class="headerlink" title="12 文章目录"></a>12 文章目录</h2><h3 id="1-添加-CSS-样式"><a href="#1-添加-CSS-样式" class="headerlink" title="1 添加 CSS 样式"></a>1 添加 CSS 样式</h3><p>打开 <code>themes\yilia\source</code> 下的 <code>main.234bc0.css</code> 文件，直接在后面添加如下代码：</p><p>/<em>新添加的</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#container .show-toc-btn,#container .toc-article&#123;display:block&#125;</span><br><span class="line">.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http:&#x2F;&#x2F;7xtawy.com1.z0.glb.clouddn.com&#x2F;show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;</span><br><span class="line">.toc-article li ol, .toc-article li ul &#123;</span><br><span class="line">    margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.toc-article ol, .toc-article ul &#123;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-修改-article-ejs-文件"><a href="#2-修改-article-ejs-文件" class="headerlink" title="2 修改 article.ejs 文件"></a>2 修改 article.ejs 文件</h3><p>打开 <code>themes\yilia\layout\_partial</code> 文件夹下的 <code>article.ejs</code> 文件, 在 <code>&lt;/header&gt; &lt;% } %&gt;</code> 下面加入如下内容（注意位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目录内容 --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;show-toc-btn&quot; id&#x3D;&quot;show-toc-btn&quot; onclick&#x3D;&quot;showToc();&quot; style&#x3D;&quot;display:none&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-bg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-text&quot;&gt;文章导航&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;toc-article&quot; class&#x3D;&quot;toc-article&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;toc-close&quot; class&#x3D;&quot;toc-close&quot; title&#x3D;&quot;隐藏导航&quot; onclick&#x3D;&quot;showBtn();&quot;&gt;×&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;toc-title&quot;&gt;文章目录&lt;&#x2F;strong&gt;</span><br><span class="line">           &lt;%- toc(post.content) %&gt;</span><br><span class="line">         &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function showToc()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    function showBtn()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">&lt;!-- 目录内容结束 --&gt;</span><br></pre></td></tr></table></figure><p>想要温江显示目录，在每篇文章开头加入：toc: true 即可。</p><h2 id="13-版权"><a href="#13-版权" class="headerlink" title="13 版权"></a>13 版权</h2><p>待定</p><h2 id="14-友情链接"><a href="#14-友情链接" class="headerlink" title="14 友情链接"></a>14 友情链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 编辑友链</span><br><span class="line">friends:</span><br><span class="line">  Hexo: https:&#x2F;&#x2F;hexo.io</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;pages.github.com&#x2F;</span><br><span class="line">  MOxFIVE: http:&#x2F;&#x2F;moxfive.xyz&#x2F;</span><br><span class="line"></span><br><span class="line">## 关闭友链</span><br><span class="line">friends: false</span><br></pre></td></tr></table></figure><h2 id="15-关于我"><a href="#15-关于我" class="headerlink" title="15 关于我"></a>15 关于我</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启“关于我”。</span><br><span class="line">aboutme: 专注于前端</span><br><span class="line"></span><br><span class="line"># 关闭“关于我”</span><br><span class="line">aboutme: false</span><br></pre></td></tr></table></figure><h2 id="16-评论"><a href="#16-评论" class="headerlink" title="16 评论"></a>16 评论</h2><p><strong>GitHub OAuth授权：Settings/Developer settings/OAuth Apps</strong></p><p><a href="https://github.com/settings/applications/1265561" target="_blank" rel="noopener">https://github.com/settings/applications/1265561</a></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0_3_C@_7EZ_609_5DF_4_7E1_240_24S0L5.png" alt></p><h3 id="在layout-partial-post目录下新增gitalk-ejs文件"><a href="#在layout-partial-post目录下新增gitalk-ejs文件" class="headerlink" title="在layout/_partial/post目录下新增gitalk.ejs文件"></a>在<code>layout/_partial/post</code>目录下新增<code>gitalk.ejs</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot; style&#x3D;&quot;padding: 0px 30px 0px 30px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">if(&lt;%&#x3D;theme.gitalk.enable%&gt;)&#123;</span><br><span class="line"> var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line"> clientID: &#39;&lt;%&#x3D;theme.gitalk.ClientID%&gt;&#39;,</span><br><span class="line"> clientSecret: &#39;&lt;%&#x3D;theme.gitalk.ClientSecret%&gt;&#39;,</span><br><span class="line"> repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line"> owner: &#39;&lt;%&#x3D;theme.gitalk.githubID%&gt;&#39;,</span><br><span class="line"> admin: [&#39;&lt;%&#x3D;theme.gitalk.adminUser%&gt;&#39;],</span><br><span class="line"> id: &#39;&lt;%&#x3D; page.date %&gt;&#39;,</span><br><span class="line"> distractionFreeMode: &#39;&lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="修改source-src-css-目录下comment-scss文件"><a href="#修改source-src-css-目录下comment-scss文件" class="headerlink" title="修改source-src/css/目录下comment.scss文件"></a>修改<code>source-src/css</code>/目录下<code>comment.scss</code>文件</h3><p>注意第一行最后添加了 #gitalk-container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container &#123;</span><br><span class="line"> padding: 0 30px !important;</span><br><span class="line"> min-height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#SOHUCS &#123;</span><br><span class="line"> #SOHU_MAIN .module-cmt-list .block-cont-gw &#123;</span><br><span class="line"> border-bottom: 1px dashed #c8c8c8 !important;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码："><a href="#在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码：" class="headerlink" title="在layout/_partial目录下的article.ejs文件内新增gitalk相关的配置代码："></a>在<code>layout/_partial</code>目录下的<code>article.ejs</code>文件内新增<code>gitalk</code>相关的配置代码：</h3><p>在最后一行 &lt;% } %&gt; 前加入，如下图所示<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9f43f555-78c6-44fa-a465-3b55891297fd.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable)&#123; %&gt;</span><br><span class="line"> &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line"> key: post.slug,</span><br><span class="line"> title: post.title,</span><br><span class="line"> url: config.url+url_for(post.path)</span><br><span class="line"> &#125;) %&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="最后在yilia主题配置文件中新增gitalk相关的配置："><a href="#最后在yilia主题配置文件中新增gitalk相关的配置：" class="headerlink" title="最后在yilia主题配置文件中新增gitalk相关的配置："></a>最后在<code>yilia</code>主题配置文件中新增<code>gitalk</code>相关的配置：</h3><p>属性名要与 配置文件中保持一致 ,如：<br>theme.gitalk.client_id  要与配置文件中 client_id 这几个字母一致<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/63179418-0e08-4864-bc85-b444e6067360.png" alt></p><p><strong>githubID：是自己的GitHub账户名称，如我的是JavaSsun</strong><br><strong>repo：是新建的评论仓库名称</strong><br><strong>adminuser:是自己的账户名称JavaSsun</strong></p><h3 id="更新一下即可。"><a href="#更新一下即可。" class="headerlink" title="更新一下即可。"></a>更新一下即可。</h3><p>基本完成，现在解决常见问题：</p><h2 id="17-文章字数及统计阅读时长-注意乱码"><a href="#17-文章字数及统计阅读时长-注意乱码" class="headerlink" title="17 文章字数及统计阅读时长(注意乱码)"></a>17 文章字数及统计阅读时长(注意乱码)</h2><h3 id="1-安装-hexo-wordcount"><a href="#1-安装-hexo-wordcount" class="headerlink" title="1 安装 hexo-wordcount"></a>1 安装 hexo-wordcount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h3 id="2-文件配置"><a href="#2-文件配置" class="headerlink" title="2 文件配置"></a>2 文件配置</h3><p>在theme\yilia\layout_partial\post下创建word.ejs文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top:10px;&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &amp;nbsp; | &amp;nbsp;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后在 themes/yilia/layout/_partial/article.ejs中添加(在 /header 之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;article-inner&quot;&gt;</span><br><span class="line">    &lt;% if (post.link || post.title)&#123; %&gt;</span><br><span class="line">      &lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class="line">        &lt;% if (!post.noDate)&#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">        &lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">        &lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">        &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">          &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">        &lt;!-- 添加完成 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      &lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure><h3 id="3-开启功能"><a href="#3-开启功能" class="headerlink" title="3 开启功能"></a>3 开启功能</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e0da8fad-4be8-436b-9491-b943d26853f1.png" alt></p><p>效果如图所示：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0c5c293d-95ac-47c3-a2cc-b3a589682a23.png" alt></p><h2 id="18-添加背景音乐"><a href="#18-添加背景音乐" class="headerlink" title="18 添加背景音乐"></a>18 添加背景音乐</h2><h3 id="1-打开网易云音乐首页，然后搜索要添加的背景音乐"><a href="#1-打开网易云音乐首页，然后搜索要添加的背景音乐" class="headerlink" title="1 打开网易云音乐首页，然后搜索要添加的背景音乐"></a>1 打开网易云音乐首页，然后搜索要添加的背景音乐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/65d6c7e8-80bf-45c9-8092-a46d177d5dfa.jpg" alt></p><h3 id="2-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#2-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="2 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>2 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/19e4d9b9-e95b-4313-947f-5f0fc33bea71.png" alt></p><h3 id="3-复制外链播放器的代码"><a href="#3-复制外链播放器的代码" class="headerlink" title="3 复制外链播放器的代码"></a>3 复制外链播放器的代码</h3><p>打开 /yilia/layout/_partia/left-col.ejs 文件 <strong>nav标签中添加代码</strong><br>注：放在<code>&lt;nav&gt;</code>和<code>&lt;/nav&gt;</code>之内</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9dd56bf0-40f8-46ae-acb7-764d7074be59.png" alt><br>[========]</p><h2 id="19-鼠标点击桃心效果"><a href="#19-鼠标点击桃心效果" class="headerlink" title="19 鼠标点击桃心效果"></a>19 鼠标点击桃心效果</h2><p>在 themes/yilia/source文件夹下，建立resources文件夹，再新建click.js文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">! function(e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e &#x3D; 0; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick &#x3D; function(e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText &#x3D; e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d &#x3D; [];</span><br><span class="line">    e.requestAnimationFrame &#x3D; function() &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure><p>然后在themes/yilia/layout/_partial文件夹下的after-footer.ejs中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&lt;%&#x3D;config.root%&gt;.&#x2F;resources&#x2F;click.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/68ee37c3-7cb5-49b0-9d82-d670cf2bf98c.png" alt></p><p>重新部署即可</p><h2 id="20-添加网站运行时间"><a href="#20-添加网站运行时间" class="headerlink" title="20 添加网站运行时间"></a>20 添加网站运行时间</h2><h2 id="21-Hexo博客添加-helper-live2d动态模型插件"><a href="#21-Hexo博客添加-helper-live2d动态模型插件" class="headerlink" title="21 Hexo博客添加 helper-live2d动态模型插件"></a>21 Hexo博客添加 helper-live2d动态模型插件</h2><h3 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h3><ul><li>yilia主题</li><li>插件地址 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener" title="hexo-helper-live2d">hexo-helper-live2d</a></li><li><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></li></ul><h3 id="1-安装模块"><a href="#1-安装模块" class="headerlink" title="1 安装模块"></a>1 安装模块</h3><p>在hexo根目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h3 id="2-下载模型"><a href="#2-下载模型" class="headerlink" title="2 下载模型"></a>2 下载模型</h3><p>作者各种模型包展示 ➡️ <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener" title=" hexo live2d插件 2.0 !">hexo live2d插件 2.0 !</a></p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haru/02</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code> 黑猫</li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code> 白猫</li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>使用<code>npm install {packagename}</code>安装模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install live2d-widget-model-hibiki</span><br></pre></td></tr></table></figure><h3 id="3-详细配置"><a href="#3-详细配置" class="headerlink" title="3 详细配置"></a>3 详细配置</h3><p>在Hexo的 <code>_config.yml</code> 文件中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  #enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hibiki</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure><p>hexo g | hexo s即可</p><h2 id="22-Hexo添加访问量统计"><a href="#22-Hexo添加访问量统计" class="headerlink" title="22 Hexo添加访问量统计"></a>22 Hexo添加访问量统计</h2><ul><li>主题 yilia</li><li>访问统计量使用 <strong><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener" title="不蒜子">不蒜子</a></strong></li></ul><h3 id="1-配置是否开启不蒜子访问量统计功能"><a href="#1-配置是否开启不蒜子访问量统计功能" class="headerlink" title="1 配置是否开启不蒜子访问量统计功能"></a>1 配置是否开启不蒜子访问量统计功能</h3><p>在 <strong>themes/yilia/_config.yml</strong> 添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启访问量统计功能（不蒜子）</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="2-引入不蒜子并添加站点访问量"><a href="#2-引入不蒜子并添加站点访问量" class="headerlink" title="2 引入不蒜子并添加站点访问量"></a>2 引入不蒜子并添加站点访问量</h3><p>在<code>themes/yilia/layout/_partial/footer.ejs</code>末尾添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/760ffbaf-8a71-415e-8869-74c555cddcf8.png" alt></p><h3 id="3-添加文章访问量"><a href="#3-添加文章访问量" class="headerlink" title="3 添加文章访问量"></a>3 添加文章访问量</h3><p>在<code>themes/yilia/layout/_partial/post/date.ejs</code>开头添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/daf13bfc-f651-4963-99bd-3cec83a0b71a.png" alt></p><meta charset="utf-8"><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>两种方法选择一种使用即可，都使用可能会出现无法显示的问题</p></li><li><p>使用<code>hexo s</code>部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用<code>localhost:4000</code>进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p></li></ul><h2 id="23-RSS"><a href="#23-RSS" class="headerlink" title="23 RSS"></a>23 RSS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/fafa6df3-68ca-4b15-aaa9-b8ebb2ea0dec.png" alt></p><h2 id="24-Hexo设置-标签-分类-归档"><a href="#24-Hexo设置-标签-分类-归档" class="headerlink" title="24 Hexo设置 标签 分类 归档"></a>24 Hexo设置 标签 分类 归档</h2><p>举例：</p><h3 id="1添加-分类页面"><a href="#1添加-分类页面" class="headerlink" title="1添加 分类页面"></a>1添加 分类页面</h3><p>使用：<code>hexo new page categories</code> 新建一个 分类 页面。</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/50a49785-9652-4252-af8d-f67fbc85784c.png" alt></p><p>添加 type: “categories”<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/ac3196b3-f7f0-4483-8f0b-581b673c3e04.png" alt></p><p>tags类似：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/db61e102-242e-404a-8f6e-9026770bcf82.png" alt></p><p>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/24627704-f7a0-4686-9c87-bd3ecc9d433e.png" alt></p><h2 id="25-Hexo博客优化之文章置顶-置顶标签"><a href="#25-Hexo博客优化之文章置顶-置顶标签" class="headerlink" title="25 Hexo博客优化之文章置顶+置顶标签"></a>25 Hexo博客优化之文章置顶+置顶标签</h2><h3 id="1-博文置顶"><a href="#1-博文置顶" class="headerlink" title="1 博文置顶"></a>1 博文置顶</h3><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index  --save </span><br><span class="line">$ npm install hexo-generator-index-pin-top  --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：<br>注意有 <strong>空格</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/062b9442-ca03-4376-b1c2-52287944889b.png" alt></p><h3 id="2-配置置顶标准"><a href="#2-配置置顶标准" class="headerlink" title="2 配置置顶标准"></a>2 配置置顶标准</h3><p>打开：/themes/*/layout（/_macro）/post.ejs<br>直接在最前面加入以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.top) &#123; %&gt;</span><br><span class="line"> &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line"> &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line"> &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="3-配置文章"><a href="#3-配置文章" class="headerlink" title="3 配置文章"></a>3 配置文章</h3><p>然后在需要置顶的文章的Front-matter中加上top选项即可<br>top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> title: (5)Hexo踩坑_主题优化</span><br><span class="line"> date: 2018-08-21 17:15:09</span><br><span class="line"> tags: Hexo-yilia</span><br><span class="line"> categories: Hexo</span><br><span class="line"> top: 5</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><h3 id="4-优先级配置"><a href="#4-优先级配置" class="headerlink" title="4 优先级配置"></a>4 优先级配置</h3><p>修改根目录配置文件/_config.yml,top值-1标示根据top值倒序（正序设置为1即可），同样date也是根据创建日期倒序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line"> path: &#39;&#39;</span><br><span class="line"> per_page: 10</span><br><span class="line"> order_by:</span><br><span class="line"> top: -1</span><br><span class="line"> date: -1</span><br></pre></td></tr></table></figure><h3 id="5-设置置顶标志"><a href="#5-设置置顶标志" class="headerlink" title="5 设置置顶标志"></a>5 设置置顶标志</h3><p>暂时用默认的</p><h2 id="26-去掉配置文件中的-more"><a href="#26-去掉配置文件中的-more" class="headerlink" title="26 去掉配置文件中的 more"></a>26 去掉配置文件中的 more</h2><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/957764e6-d0ac-4b0c-8cc2-4b05f6327872.png" alt></p><h2 id="27-在左侧显示总文章数"><a href="#27-在左侧显示总文章数" class="headerlink" title="27 在左侧显示总文章数"></a>27 在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class&#x3D;&quot;header-menu&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line"> &lt;% for (var i in theme.menu)&#123; %&gt;</span><br><span class="line"> &lt;li&gt;&lt;a href&#x3D;&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%&#x3D; i %&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;%&#125;%&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav style&#x3D;&quot;color: #7FFFD4;&quot;&gt;总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;0-字体乱码问题&quot;&gt;&lt;a href=&quot;#0-字体乱码问题&quot; class=&quot;headerlink&quot; title=&quot;0 字体乱码问题&quot;&gt;&lt;/a&gt;0 字体乱码问题&lt;/h2&gt;&lt;p&gt;Windows 上新建的文件一般都是 &lt;strong&gt;gb2312或iso-8859-1&lt;/strong&gt;，这样windows下的文件传递到Linux可能会出乱码问题&lt;/p&gt;
&lt;p&gt;用 Git进去文件使用命令查看文件是否是&lt;strong&gt;utf-8&lt;/strong&gt; 格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;file -i word.ejs&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;word.ejs: text&amp;#x2F;html; charset&amp;#x3D;iso-8859-1(或是其他)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;第一种&lt;/strong&gt;&lt;br&gt;最简单的办法就是  vim  word.ejs&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://JavaSsun.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo-yilia" scheme="http://JavaSsun.github.io/tags/Hexo-yilia/"/>
    
  </entry>
  
  <entry>
    <title>(4)Hexo撰写文章</title>
    <link href="http://javassun.github.io/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
    <id>http://javassun.github.io/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/</id>
    <published>2018-08-19T03:07:37.000Z</published>
    <updated>2020-04-14T05:20:25.490Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><img src="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/60bbee39-dccc-48d2-9fb5-149a40253315.png" alt></p><a id="more"></a><h3 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h3><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 <code>title</code> 为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <strong>source/_post</strong> 文件夹下创建一个文件，命名为：<strong>title.md</strong></p><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h3 id="二、编写文章（基于Markdown）"><a href="#二、编写文章（基于Markdown）" class="headerlink" title="二、编写文章（基于Markdown）"></a>二、编写文章（基于Markdown）</h3><h4 id="1-Markdown基本语法略"><a href="#1-Markdown基本语法略" class="headerlink" title="1 Markdown基本语法略"></a>1 <strong>Markdown基本语法略</strong></h4><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2 说明："></a>2 <strong>说明：</strong></h4><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><h4 id="3-高级设置"><a href="#3-高级设置" class="headerlink" title="3 高级设置"></a>3 高级设置</h4><p><strong>1 模板设置</strong></p><p>当我们使用命令 <strong>hexo new “title”</strong> 创建文章时，Hexo 会根据 <strong>/scaffolds/post.md</strong> 对新文章进行初始化</p><p>换言之，<strong>/scaffolds/post.md</strong> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories</span><br></pre></td></tr></table></figure><p><strong>2 头部设置</strong></p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置<strong>文章标题</strong>、<strong>发布日期</strong>等基础信息外，还可以为文章<strong>添加标签</strong>、<strong>分类</strong>等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><font color="red"><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</font></p><p><strong>3 首页显示</strong></p><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，<strong>表示只会显示标志前面的内容</strong></p><h3 id="三、部署发布"><a href="#三、部署发布" class="headerlink" title="三、部署发布"></a>三、部署发布</h3><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h3 id="四、Hexo一篇文章多个categories"><a href="#四、Hexo一篇文章多个categories" class="headerlink" title="四、Hexo一篇文章多个categories"></a>四、Hexo一篇文章多个categories</h3><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写一篇 《Servlet笔记》，我既想将它放在 <strong>Java</strong> 这个分类中，又想将它放入 <strong>Servlet</strong> 这个分类。</p><p>  按照官方的解释，<code>categories</code> 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h4 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h4><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Java</span><br><span class="line">  - Servlet</span><br></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [Java, Servlet]</span><br></pre></td></tr></table></figure><h4 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h4><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java]</span><br><span class="line">  -[Servlet]</span><br></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。</p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java, Servlet]</span><br><span class="line">  -[Programming]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net/wsmrzx/article/details/81477926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wsmrzx/article/details/81477926&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/60bbee39-dccc-48d2-9fb5-149a40253315.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://JavaSsun.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo-yilia" scheme="http://JavaSsun.github.io/tags/Hexo-yilia/"/>
    
  </entry>
  
  <entry>
    <title>(3)Hexo常用命令详解</title>
    <link href="http://javassun.github.io/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2018-08-19T01:03:39.000Z</published>
    <updated>2020-04-14T05:21:22.710Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><strong>Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</strong><br><strong>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</strong><br><strong>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</strong><br><strong>不同的主题会有不同的主题配置文件，由主题作者所提供</strong>.</p><a id="more"></a><h3 id="1、hexo-init"><a href="#1、hexo-init" class="headerlink" title="1、hexo init"></a>1、hexo init</h3><p><strong>hexo init</strong> 命令用于初始化本地文件夹为网站的根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><ul><li><strong>folder</strong> 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录</li></ul><h3 id="2、hexo-new"><a href="#2、hexo-new" class="headerlink" title="2、hexo new"></a>2、hexo new</h3><p><strong>hexo new</strong> 命令用于新建文章，一般可以简写为<strong>hexo n</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>layout</strong> 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</p></li><li><p><strong>title</strong> 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</p></li></ul><h3 id="3、hexo-generate"><a href="#3、hexo-generate" class="headerlink" title="3、hexo generate"></a>3、hexo generate</h3><p><strong>hexo generate</strong> 命令用于生成静态文件，一般可以简写为 hexo g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong> 选项，指定生成后部署，与 <strong>hexo d -g</strong> 等价</li></ul><p>详细信息请参考：<a href="https://hexo.io/docs/generating" target="_blank" rel="noopener">https://hexo.io/docs/generating</a></p><h3 id="4、hexo-server"><a href="#4、hexo-server" class="headerlink" title="4、hexo server"></a>4、hexo server</h3><p><strong>hexo server</strong> 命令用于启动本地服务器，一般可以简写为 <strong>hexo s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><ul><li><p>-p 选项，指定服务器端口，默认为 4000</p></li><li><p>-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</p></li><li><p>-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p></li></ul><p>说明 ：运行服务器前需要安装 hexo-server 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">https://hexo.io/docs/server.html</a></p><h3 id="5、hexo-deploy"><a href="#5、hexo-deploy" class="headerlink" title="5、hexo deploy"></a>5、hexo deploy</h3><p><strong>hexo deploy</strong> 命令用于部署网站，一般可以简写为 hexo d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><ul><li><strong>-g</strong> 选项，指定生成后部署，与 hexo g -d 等价</li></ul><p>说明 ：部署前需要修改 _config.yml 配置文件，下面以 git 为例进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: &lt;repository url&gt;</span><br><span class="line">    branch:    master</span><br><span class="line">    message: 自定义提交消息，默认为Site updated: &#123;&#123; now(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><h3 id="6、hexo-clean"><a href="#6、hexo-clean" class="headerlink" title="6、hexo clean"></a>6、hexo clean</h3><p><strong>hexo clean</strong> 命令用于清理缓存文件，是一个比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>网站显示异常时可尝试此操作</p><h3 id="7、Option"><a href="#7、Option" class="headerlink" title="7、Option"></a>7、Option</h3><p><strong>（1）hexo –safe</strong></p><p><strong>hexo –safe</strong> 表示安全模式，用于禁用加载插件和脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>安装新插件时遇到问题可尝试此操作</p><p><strong>（2）hexo –debug</strong></p><p><strong>hexo –debug</strong> 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p><strong>（3）hexo –silent</strong></p><p><strong>hexo –silent</strong> 表示静默模式，用于静默输出到终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net/wsmrzx/article/details/81477926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wsmrzx/article/details/81477926&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;不同的主题会有不同的主题配置文件，由主题作者所提供&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://JavaSsun.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo-yilia" scheme="http://JavaSsun.github.io/tags/Hexo-yilia/"/>
    
  </entry>
  
  <entry>
    <title>(2)Hexo配置文件详解</title>
    <link href="http://javassun.github.io/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</id>
    <published>2018-08-17T04:56:53.000Z</published>
    <updated>2020-04-14T03:25:41.938Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p>Hexo 是一款极为优秀的博客框架，使用 Hexo 搭建一个个人博客后，还需要编写位于站点根目录下的 <code>_config.yml</code> 文件来满足定制化的需求。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:&#x2F;&#x2F;elfwalk.github.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line">#发布设置</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;elfwalk&#x2F;elfwalk.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1d62242a-d3b1-417a-bf11-e69e000b36f1.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/c95a5140-a299-4492-9006-3827168ab8e9.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/6ef267ec-cfd0-411b-891a-15de0966c39b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/92065ad3-a506-4066-8ccf-0dc4f6804458.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/97fd8861-b2b9-48a8-8c6a-545d0f31b2d0.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/7fdb3429-0dd3-4363-bf04-c03636d1702b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/d3ea4182-f75f-4576-904c-71883facc176.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/cb23844c-160e-47e9-97d3-753d06414ab8.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/801539a4-704b-4a63-b4f3-b824a474f7cd.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 &lt;a href=&quot;https://blog.csdn.net/wsmrzx/article/details/81477926&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wsmrzx/article/details/81477926&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hexo 是一款极为优秀的博客框架，使用 Hexo 搭建一个个人博客后，还需要编写位于站点根目录下的 &lt;code&gt;_config.yml&lt;/code&gt; 文件来满足定制化的需求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://JavaSsun.github.io/categories/Hexo/"/>
    
    
      <category term="Hexo-yilia" scheme="http://JavaSsun.github.io/tags/Hexo-yilia/"/>
    
  </entry>
  
</feed>
