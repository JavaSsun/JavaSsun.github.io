<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haoran&#39;s blog</title>
  
  <subtitle>Talk is cheap. Show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javassun.github.io/"/>
  <updated>2020-05-06T06:33:23.548Z</updated>
  <id>http://javassun.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ详解</title>
    <link href="http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-25T12:22:31.000Z</published>
    <updated>2020-05-06T06:33:23.548Z</updated>
    
    <content type="html"><![CDATA[<p>转载<a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/RabbitMQ01.png" alt></p><ul><li>左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。</li><li>中间即是 RabbitMQ，其中包括了 交换机 和 队列。</li><li>右侧 C 代表 消费者，也就是从 RabbitMQ 拿消息的程序。</li></ul><p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机，交换机，队列，和绑定。</p><ul><li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li><li>交换机：<em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li><li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系</li></ul><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout</p><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置 header attribute 参数类型的交换机</li><li>Fanout：转发消息到所有绑定队列</li></ul><p><strong>Direct Exchange</strong></p><p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/rabbitMq_direct.png" alt></p><p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p><p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p><p><strong>Topic Exchange</strong></p><p>Topic Exchange 转发消息主要是根据通配符。_ 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p><p>在这种交换机模式下：</p><ul><li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li><li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li></ul><p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br></pre></td></tr></table></figure><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p><ul><li><code>*</code>表示一个词.</li><li><code>#</code>表示零个或多个词.</li></ul><p><strong>Headers Exchange</strong></p><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><p><strong>Fanout Exchange</strong></p><p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，_会把消息发给绑定给它的全部队列_，如果配置了 routing_key 会被忽略。</p><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了<code>spring-boot-starter-amqp</code> 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 <code>spring-boot-starter-amqp</code> 的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;Spring-boot-rabbitmq</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.0.86</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue Queue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><p>rabbitTemplate 是 Spring Boot 提供的默认实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component</span><br><span class="line">public class HelloSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context &#x3D; &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;hello&quot;)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver  : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，发送者和接收者的 queue name 必须一致，不然不能接收</p></blockquote><h3 id="多对多使用"><a href="#多对多使用" class="headerlink" title="多对多使用"></a>多对多使用</h3><p>一个发送者，N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p><p><strong>一对多发送</strong></p><p>对上面的代码进行了小改造，接收端注册了两个 Receiver,Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void oneToMany() throws Exception &#123;</span><br><span class="line">    for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 12</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 14</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 13</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 15</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 16</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 18</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 17</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 19</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br></pre></td></tr></table></figure><p>根据返回结果得到以下结论</p><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><p><strong>多对多发送</strong></p><p>复制了一份发送者，加入标记，在一百个循环中相互交替发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void manyToMany() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            neoSender.send(i);</span><br><span class="line">            neoSender2.send(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 25</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 25</span><br></pre></td></tr></table></figure><blockquote><p>结论：和一对多一样，接收端仍然会均匀接收到消息</p></blockquote><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p><strong>对象的支持</strong></p><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送者</span><br><span class="line">public void send(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Sender object: &quot; + user.toString());</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;object&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收者</span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Receiver object : &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sender object: User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Receiver object : User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>Topic Exchange</strong></p><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列</p><p>首先对 topic 规则配置，这里使用两个队列来测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    final static String message &#x3D; &quot;topic.message&quot;;</span><br><span class="line">    final static String messages &#x3D; &quot;topic.messages&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;exchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am message 1&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.message&quot;, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am messages 2&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.messages&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息</p><p><strong>Fanout Exchange</strong></p><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>Fanout 相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FanoutRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue AMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue BMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue CMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue AMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, fanout msg &quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver A  : hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg</span><br></pre></td></tr></table></figure><p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zouyesheng.com/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p><p><a href="https://github.com/401Studio/WeekLearn/issues/2" target="_blank" rel="noopener">RabbitMQ：Spring 集成 RabbitMQ 与其概念，消息持久化，ACK机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载&lt;a href=&quot;http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。&lt;/p&gt;
&lt;h2 id=&quot;RabbitMQ-介绍&quot;&gt;&lt;a href=&quot;#RabbitMQ-介绍&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 介绍&quot;&gt;&lt;/a&gt;RabbitMQ 介绍&lt;/h2&gt;&lt;p&gt;RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;p&gt;AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;p&gt;RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://JavaSsun.github.io/categories/MQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://JavaSsun.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot面试</title>
    <link href="http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/"/>
    <id>http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-19T11:18:33.000Z</published>
    <updated>2020-05-06T06:33:16.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：</p><p>问：你觉得 Spring Boot 最大的优势是什么呢？</p><p>答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。</p><p>答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？</p><p>问：Spring Boot Starter 的工作原理是什么？</p><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li><p>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</p></li><li><p>② 根据 spring.factories 配置加载 AutoConfigure 类</p></li><li><p>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</p></li></ul><p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p><a id="more"></a><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p><p>第三部：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>是不是很爽？</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p><h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p><p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p><p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p><h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p><h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p><p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p><p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p><h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p><p>一般前端的解决方案有：</p><ul><li><p>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</p></li><li><p>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</p></li></ul><p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p><p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p><p>第一，配置 CorsFilter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置上述的一段代码。第二种方式稍微简单一些。</p><p>第二，在启动类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p><p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p><h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>用一组不太合理的包含关系来表达它们之间的关系。</p><p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：&lt;/p&gt;
&lt;p&gt;问：你觉得 Spring Boot 最大的优势是什么呢？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;/p&gt;
&lt;p&gt;问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。&lt;/p&gt;
&lt;p&gt;答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？&lt;/p&gt;
&lt;p&gt;问：Spring Boot Starter 的工作原理是什么？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 在启动的时候会干这几件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;② 根据 spring.factories 配置加载 AutoConfigure 类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="面试" scheme="http://JavaSsun.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-08T04:43:25.000Z</published>
    <updated>2020-04-16T16:17:20.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。<br>疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>速度更块</li><li>代码更少（Lambda表达式）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li></ul><p><font color="red">核心为：Lambda表达式与Stream API</font></p><a id="more"></a><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-为什么使用Lambda表达式"><a href="#1-为什么使用Lambda表达式" class="headerlink" title="1. 为什么使用Lambda表达式"></a>1. 为什么使用Lambda表达式</h3><p><strong>Lambda</strong>是一个<font color="red">匿名函数</font>，我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>（将代码像数据一样传递）。可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，使Java语言的表达更加凝练。</p><ul><li>从匿名类到 Lambda 的转换</li></ul><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匿名内部类</span><br><span class="line">Runnable r1 &#x3D; new Runnable()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">         System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原来使用匿名内部类作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(String o1,String o2)&#123;</span><br><span class="line">        return Integer.compare(o1.length,o2.length());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts2 &#x3D; new TreeSet&lt;&gt;(</span><br><span class="line">     (o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>匿名内部类</strong></font>：冗余的语法。导致了“Height Problem”（只有一行在工作）</p><h3 id="2-Lambda表达式语法"><a href="#2-Lambda表达式语法" class="headerlink" title="2. Lambda表达式语法"></a>2. Lambda表达式语法</h3><p>Lambda 表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “<font color="red"> -&gt; </font>“，该操作符被称为 Lambda操作符 或 箭头操作符。它将Lambda分为两个部分：</p><p><strong>左侧：</strong>指定了 Lambda 表达式需要的所有参数<br><strong>右侧：</strong>指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式一：无参，无返回值，Lambda只需一条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lambda需要一个参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun &#x3D; (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式三：Lambda只需要一个参数时，参数的小括号可省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consummer&lt;String&gt; fun &#x3D; args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lambda需要两个参数，并且有返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt;&#123;</span><br><span class="line">      System.out.println(&quot;实现函数接口方法&quot;);</span><br><span class="line">      return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：当Lambda体只有一条语句时，return与大括号可以省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：Long数据类型可以省略，可由编译器推断，即“类型推断”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (Long x,Long y) -&gt; &#123;</span><br><span class="line">         System.out.println(&quot;实现函数接口方法&quot;)；</span><br><span class="line">         x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong>是<font color="red"><strong>匿名内函数</strong></font>：提供了轻量级的语法。解决了匿名内部类带来的“高度”问题。</p><p>语法：<strong>参数列表</strong> <strong>-&gt;</strong> <strong>函数体</strong>三部分组成。<br>函数体：表达式、语句块。<br><font color="red"><strong>表达式</strong></font>：表达式会被执行然后返回执行结果。<br><font color="red"><strong>语句块</strong></font>：语句块中的语句会被依次执行，就像方法中的语句一样</p><ol><li>return语句会把控制权交给匿名函数的调用者</li><li>break和continue只能在循环中使用。</li><li>如果函数体有返回值。那么函数体内部的每一条路径都要有。</li></ol><p>表达式函数体适合小型<strong>Lambda</strong>表达式。消除了return关键字。简洁。</p><p><font color="red">新包</font>：<strong>java.util.function:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收 T对象 返回boolean</span><br><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收 T对象 不返回任何值</span><br><span class="line">Consumer&lt;T&gt; void accept(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收 T对象 返回R对象</span><br><span class="line">Function(T,R) R apply(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供 T对象（工厂T）</span><br><span class="line">Supplier&lt;T&gt; T get()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一元：接收T 返回T</span><br><span class="line">UnaryOperator&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二元：接收两个T 返回T</span><br><span class="line">BinaryOperator&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些 Lambda表达式简单例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int x,int y)-&gt;x+y; &#x2F;&#x2F;接收 x y 返回 x与y的和</span><br><span class="line">()-&gt;45;       &#x2F;&#x2F; 不接受参数 返回45</span><br><span class="line">(String s)-&gt;&#123;System.out.println(s);&#125; &#x2F;&#x2F;接收一个字符串，并把它打印在控制台</span><br></pre></td></tr></table></figure><h3 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h3><p>Lambda表达式无需指定类型，程序依然可以编译，因为 javac 根据程序上下文，在后台推断出了参数类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。即所谓的“类型推断”。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="1-什么是函数式接口"><a href="#1-什么是函数式接口" class="headerlink" title="1. 什么是函数式接口"></a>1. 什么是函数式接口</h3><ul><li><p>只包含了一个抽象方法的接口，称为<strong>函数式接口</strong></p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在任意函数式接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li></ul><h3 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2. 自定义函数式接口"></a>2. 自定义函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyNumber&#123;</span><br><span class="line">   public double getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式接口中使用泛型：</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">   public T getValue(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作为参数传递 Lambda 表达式</span><br><span class="line">public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123;</span><br><span class="line">        return mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       String newStr &#x3D; toUpperString(</span><br><span class="line">       (str) -&gt; str.toUpperCase(), &quot;abcdef&quot;);</span><br><span class="line">       System.out.println(newStr);</span><br></pre></td></tr></table></figure><p><font color="red">作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br></font></p><h3 id="3-Java内治四大核心函数式接口"><a href="#3-Java内治四大核心函数式接口" class="headerlink" title="3. Java内治四大核心函数式接口"></a>3. Java内治四大核心函数式接口</h3><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/97801292-5716-4519-9bff-9f8f08aed48b.png" alt></p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/743ea2bc-aeda-44e0-b691-31c354b94f47.png" alt></p><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况：</p><ul><li><p><strong>对象::实例方法</strong></p></li><li><p><strong>类::静态方法</strong></p></li><li><p><strong>类::实例方法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(x);</span><br><span class="line">等同于</span><br><span class="line">System.out::println;</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D; (x,y) -&gt; Math.pow(x,y);</span><br><span class="line">等同于</span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D;Math::pow;</span><br><span class="line"></span><br><span class="line">compare((x,y) -&gt;x.equals(y), &quot;abcdef&quot; , &quot;abcdef&quot;);</span><br><span class="line">等同于</span><br><span class="line">compare(String::equals,&quot;abc&quot;,&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p><strong>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</strong></p><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><p><strong>格式： ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，与构造器参数 列表要与接口中抽象方法的参数列表一致！</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; (n) -&gt; new MyClass(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; MyClass::new;</span><br></pre></td></tr></table></figure><h3 id="3-数字引用"><a href="#3-数字引用" class="headerlink" title="3. 数字引用"></a>3. 数字引用</h3><p><strong>格式： type[] :: new</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun &#x3D; (n) -&gt; new Integer(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; Integer[]::new;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><h3 id="1-了解Stream"><a href="#1-了解Stream" class="headerlink" title="1. 了解Stream"></a>1. 了解Stream</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一 个则是 <strong>Stream API(java.util.stream.*)</strong>。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>*<em>流(Stream)是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>*</em><br><font color="red">“集合讲的是数据，流讲的是计算！”</font></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="2-Stream三步骤"><a href="#2-Stream三步骤" class="headerlink" title="2. Stream三步骤"></a>2. Stream三步骤</h3><ul><li><p><strong>创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p></li><li><p><strong>中间操作</strong><br>一个中间操作链，对数据源的数据进行处理 </p></li><li><p><strong>终端操作</strong><br>一个终止操作，执行中间操作链，并产生结果<br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/37346492-7531-44b8-a2bf-681c14b381ec.jpg" alt></p></li></ul><h3 id="3-创建Stream"><a href="#3-创建Stream" class="headerlink" title="3. 创建Stream"></a>3. 创建Stream</h3><h4 id="1-Collection-创建流"><a href="#1-Collection-创建流" class="headerlink" title="1. Collection 创建流"></a>1. Collection 创建流</h4><ul><li><p>default Stream<E> stream() : 返回一个顺序流</E></p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p></li></ul><h4 id="2-数组-创建流（Arrays的静态方法stream-创建）"><a href="#2-数组-创建流（Arrays的静态方法stream-创建）" class="headerlink" title="2. 数组 创建流（Arrays的静态方法stream()创建）"></a>2. 数组 创建流（Arrays的静态方法stream()创建）</h4><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li></ul><p><strong>重载形式，能够处理对应基本类型的数组</strong></p><ul><li><p>public static IntStream stream(int[] array)</p></li><li><p>public static LongStream stream(long[] array)</p></li><li><p>public static DoubleStream stream(double[] array)</p></li></ul><h4 id="3-由值创建流"><a href="#3-由值创建流" class="headerlink" title="3. 由值创建流"></a>3. 由值创建流</h4><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li></ul><h4 id="4-由函数创建流：创建无限流"><a href="#4-由函数创建流：创建无限流" class="headerlink" title="4. 由函数创建流：创建无限流"></a>4. 由函数创建流：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>迭代</li></ul><p>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</T></T></T></p><ul><li>生成</li></ul><p>public static<T> Stream<T> generate(Supplier<T> s)</T></T></T></p><h3 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4. Stream 的中间操作"></a>4. Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><p><strong>筛选与切片</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/853fb496-9885-4191-b20d-1d5c8508def5.png" alt></p><p><strong>映射</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/feb89458-0a81-42a9-9aa4-33b20b5991bf.png" alt></p><p><strong>排序</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3a69b800-08f9-4bca-ab2d-51e3f3446635.png" alt></p><h3 id="5-Stream-的终止操作"><a href="#5-Stream-的终止操作" class="headerlink" title="5. Stream 的终止操作"></a>5. Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的 值，例如：List、Integer，甚至是 void 。</p><p><strong>查找与匹配</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1cd0233f-598b-4537-8998-5e5fa24aada0.png" alt><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/bae6b149-cc4f-4f84-aec0-e27bf8afe015.png" alt></p><p><strong>归约</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/037bfd49-78ed-468b-aa65-4ad0242e490b.png" alt></p><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</p><p><strong>收集</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2cccbffb-7df8-4a65-8153-537071e75bd7.png" alt></p><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><h3 id="6-并行流与串行流"><a href="#6-并行流与串行流" class="headerlink" title="6. 并行流与串行流"></a>6. 并行流与串行流</h3><p><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p><h3 id="7-了解-Fork-Join-框架"><a href="#7-了解-Fork-Join-框架" class="headerlink" title="7. 了解 Fork/Join 框架"></a>7. 了解 Fork/Join 框架</h3><p><strong>Fork/Join 框架</strong>:就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/84eaed9b-717b-47f9-9f0a-f5fde05f7472.jpg" alt></p><h3 id="8-Fork-Join-框架与传统线程池的区别"><a href="#8-Fork-Join-框架与传统线程池的区别" class="headerlink" title="8. Fork/Join 框架与传统线程池的区别"></a>8. Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的<br>处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因<br>无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果<br>某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子<br>问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程<br>的等待时间,提高了性能.</p><h2 id="5-新时间日期API"><a href="#5-新时间日期API" class="headerlink" title="5. 新时间日期API"></a>5. 新时间日期API</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实 例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1d49dcda-eb3d-4eb7-aa3c-889e5607867f.png" alt></p><p><strong>Instant 时间戳</strong></p><ul><li>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算</li></ul><p><strong>Duration 和 Period</strong></p><ul><li><p>Duration:用于计算两个“时间”间隔</p></li><li><p>Period:用于计算两个“日期”间隔</p></li><li><p>日期的操纵</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获 取例如：将日期调整到“下个周日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法提供了大量的常 用 TemporalAdjuster 的实现。</p></li></ul><p>例如获取下个周日：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday &#x3D; LocalDate.now().with(</span><br><span class="line">   TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析与格式化</strong></p><p>java.time.format.DateTimeFormatter 类：该类提供了三种 格式化方法：</p><ul><li><p>预定义的标准格式</p></li><li><p>语言环境相关的格式</p></li><li><p>自定义的格式</p></li></ul><p><strong>时区的处理</strong></p><ul><li>Java8 中加入了对时区的支持，带时区的时间为分别为：</li></ul><p>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><p>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><p><strong>与传统日期处理的转换</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/0b30f162-415f-4a9c-a650-ba13116ff20b.png" alt></p><h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6. 接口中的默认方法与静态方法"></a>6. 接口中的默认方法与静态方法</h2><h3 id="1-接口中的默认方法"><a href="#1-接口中的默认方法" class="headerlink" title="1. 接口中的默认方法"></a>1. 接口中的默认方法</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">  T func(int a);</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>接口默认方法的”类优先”原则 *</em></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyFunc&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Named&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello java8&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass implements MyFunc,Named&#123;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">        return Named.super.getName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口中的静态方法"><a href="#2-接口中的静态方法" class="headerlink" title="2. 接口中的静态方法"></a>2. 接口中的静态方法</h3><p>Java8 中，接口中允许添加静态方法</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">  public Integer myFun();</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show()&#123;</span><br><span class="line">     System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-其他新特性"><a href="#7-其他新特性" class="headerlink" title="7. 其他新特性"></a>7. 其他新特性</h2><p><strong>Optional 类</strong></p><p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p><p><strong>常用方法：</strong><br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值<br>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t<br>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</p><p><strong>重复注解与类型注解</strong></p><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations&#123;</span><br><span class="line">   MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation&#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyAnnotation(&quot;Hello&quot;)</span><br><span class="line">@MyAnnotation(&quot;World&quot;)</span><br><span class="line">public void show(@MyAnnotation(&quot;abc&quot;) String str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 交易员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class Trader &#123;</span><br><span class="line">     private String name;</span><br><span class="line">     private String city;</span><br><span class="line">     public Trader(String name, String city) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getter setter方法省略</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">     private Trader trader;</span><br><span class="line">     private int year;</span><br><span class="line">     private int value;</span><br><span class="line">     public Transaction(Trader trader, int year, int value) &#123;</span><br><span class="line">        this.trader &#x3D; trader;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PuttingIntoPractice &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Trader raoul &#x3D; new Trader(&quot;Raoul&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader mario &#x3D; new Trader(&quot;mario&quot;,&quot;Milan&quot;);</span><br><span class="line">        Trader alen &#x3D; new Trader(&quot;alen&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader brian &#x3D; new Trader(&quot;brian&quot;,&quot;Cambridge&quot;);</span><br><span class="line"></span><br><span class="line">  List&lt;Transaction&gt; transactions &#x3D; Arrays.asList(</span><br><span class="line">          new Transaction(brian,2011,300),</span><br><span class="line">          new Transaction(raoul,2012,1000),</span><br><span class="line">          new Transaction(raoul,2011,400),</span><br><span class="line">          new Transaction(mario,2012,710),</span><br><span class="line">          new Transaction(mario,2012,700),</span><br><span class="line">          new Transaction(alen,2012,950)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getYear() &#x3D;&#x3D; 2011)</span><br><span class="line">.sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (2) 交易员都在哪些不同的城市工作过？</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (3) 查找所有来自于剑桥的交易员，并按姓名排序。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (4) 返回所有交易员的姓名字符串，按字母顺序排序。</span><br><span class="line">  String traderStr &#x3D; transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">  System.out.println(traderStr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (5) 有没有交易员是在米兰工作的？</span><br><span class="line">  boolean miLanBased &#x3D; transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader()</span><br><span class="line">                        .getCity().equals(&quot;MiLan&quot;));</span><br><span class="line">  System.out.println(miLanBased);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (6) 打印生活在剑桥的交易员的所有交易额。</span><br><span class="line">         transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (7) 所有交易中，最高的交易额是多少？</span><br><span class="line">  int highestValue &#x3D; transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(0,Integer::max);</span><br><span class="line">  System.out.println(highestValue);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Transaction::getValue).reversed())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (8) 找到交易额最小的交易。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">             .min(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">                .min(Comparator.comparing((Transaction t1)-&gt; t1.getValue()))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (9) 统计每个交易员的记录</span><br><span class="line">  transactions.stream()</span><br><span class="line">       .collect(Collectors.groupingBy(Transaction::getTrader))</span><br><span class="line">                .entrySet().stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (10) 找到单笔交易最高的交易员</span><br><span class="line">  transactions.stream()</span><br><span class="line">             .max(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(tran -&gt;&#123;</span><br><span class="line">                    System.out.println(tran.getTrader());</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习参考网络</p><h2 id="8-java8红黑树"><a href="#8-java8红黑树" class="headerlink" title="8. java8红黑树"></a>8. java8红黑树</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>回顾：HashSet是基于HashCode实现元素不重复的。当插入元素的哈希码相同时，会调用equals方法进行二次比较，如果相同，则新值替旧值。如果不同，则以链表的形式挂在当前元素所在的位置。</p><p>扩容因子：0.75</p><p>如果是1 ，则可能永远是只插入到两个位置，形成部分元素的长链表。每次都要在哈希码相同时进行equals比较（哈希碰撞）。降低性能。</p><p>如果是&lt;0.75,则可能浪费空间。</p><h3 id="数组-链表-红黑树-二叉树的一种"><a href="#数组-链表-红黑树-二叉树的一种" class="headerlink" title="数组-链表-红黑树(二叉树的一种)"></a>数组-链表-红黑树(二叉树的一种)</h3><p><strong>条件：当碰撞袁术个数&gt;8 &amp;&amp; 总容量&gt;64 将其转换为红黑树</strong></p><p><font color="red">碰撞元素个数</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK7是数组-&gt;链表</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK8是数组-链表</font>： 当转变为红黑树时，添加的效率变低。其他效率都高了。平衡二叉树（比当前值与节点值的大小）</p><p>扩容是：原来表会计算hashcode值进行元素的再次填充。</p><p>现在只需要找原来表的总长度+当前所在的位置，就是当前扩容后的位置。（不需要再次进行哈希计算）。</p><p><strong>ConcurrentHashMap：效率提高</strong></p><p>JDK7: ConcurrentLevel = 16<br>JDK8：CAS算法</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/7d750713-3d72-48e3-b512-d11dc1900f92.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。&lt;br&gt;疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;速度更块&lt;/li&gt;
&lt;li&gt;代码更少（Lambda表达式）&lt;/li&gt;
&lt;li&gt;强大的Stream API&lt;/li&gt;
&lt;li&gt;便于并行&lt;/li&gt;
&lt;li&gt;最大化减少空指针异常 Optional&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;核心为：Lambda表达式与Stream API&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Docker简单配置</title>
    <link href="http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</id>
    <published>2020-01-15T14:20:51.000Z</published>
    <updated>2020-05-06T06:33:32.647Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><a id="more"></a><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello Docker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DockerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>plugins 中添加 Docker 构建插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br><span class="line"></span><br><span class="line">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span><br><span class="line">systemctl  start docker.service</span><br><span class="line">systemctl  enable docker.service</span><br></pre></td></tr></table></figure><p>使用Docker 中国加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><p>配置环境变量 打开 <code>vim /etc/profile</code> 添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成之后，使其生效</p><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装MAVEN"><a href="#安装MAVEN" class="headerlink" title="安装MAVEN"></a>安装MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar vxf apache-maven-3.5.2-bin.tar.gz</span><br><span class="line">## 移动</span><br><span class="line">mv apache-maven-3.5.2 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#打包</span><br><span class="line">mvn package</span><br><span class="line">#启动</span><br><span class="line">java -jar target&#x2F;spring-boot-docker-1.0.jar</span><br></pre></td></tr></table></figure><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME &#x2F;tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line">Removing intermediate container 593ee5e1ea51</span><br><span class="line">Step 4 : ENTRYPOINT java -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar</span><br><span class="line"> ---&gt; Running in 85d558a10cd4</span><br><span class="line"> ---&gt; 7102f08b5e95</span><br><span class="line">Removing intermediate container 85d558a10cd4</span><br><span class="line">Successfully built 7102f08b5e95</span><br><span class="line">[INFO] Built springboot&#x2F;spring-boot-docker</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M&#x2F;182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot&#x2F;spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot&#x2F;spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot&#x2F;spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080&#x2F;tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。&lt;/p&gt;
&lt;p&gt;首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>25-Nginx变量原理-应用</title>
    <link href="http://javassun.github.io/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/"/>
    <id>http://javassun.github.io/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/</id>
    <published>2019-12-13T12:10:53.000Z</published>
    <updated>2020-05-14T11:53:59.342Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，<strong>变量是一个解耦工具</strong>。它同样可以在 openresty 中 lua 语言中大有用处。</p><a id="more"></a><h2 id="变量原理"><a href="#变量原理" class="headerlink" title="变量原理"></a>变量原理</h2><h3 id="变量的提供模块与使用模块"><a href="#变量的提供模块与使用模块" class="headerlink" title="变量的提供模块与使用模块"></a>变量的提供模块与使用模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d4564092-81ea-4d1e-a6e6-55b113cd6724.jpg" alt></p><p><strong>流程：</strong></p><p><font color="red">提供变量名的模块</font></p><p>Nginx启动后，发现当前是一个HTTP模块。它其中有一个 <strong>preconfiguration回调方法</strong>，如 realip模块的 realip变量等等。它定义的是一对值，即<strong>变量名</strong>和<strong>解析出当前变量名的方法</strong>。如给出输入（如http请求头部中的名称），输出就是对应的值。此处<strong>定义规则</strong>。</p><p><font color="red">使用变量名的模块</font></p><p>通过变量名完成解耦。</p><p><strong>两个模块各自专注于自己的职责</strong></p><h3 id="变量的特性"><a href="#变量的特性" class="headerlink" title="变量的特性"></a>变量的特性</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/16c0d0ee-eea1-4e84-b72f-0d99716a1a82.jpg" alt></p><h3 id="存放变量的哈希表"><a href="#存放变量的哈希表" class="headerlink" title="存放变量的哈希表"></a>存放变量的哈希表</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a51c5b96-8f90-4db7-8a3c-5be8fc35c05b.jpg" alt></p><h2 id="HTTP框架提供的请求有关变量"><a href="#HTTP框架提供的请求有关变量" class="headerlink" title="HTTP框架提供的请求有关变量"></a>HTTP框架提供的请求有关变量</h2><p>除许多HTTP模块会提供变量外，Nginx的HTTP框架也提供了大量的变量，这些变量不需要编译、引入新的HTTP模块，而且框架提供的变量往往反映了用户发来的请求时被Nginx处理的流程与细节。因此，熟悉Nginx框架提供的每一个变量的用法是非常有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf配置文件中</span><br><span class="line"></span><br><span class="line">vim var.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/780053e8-ebbd-4515-a257-109fdd50ba0f.jpg" alt><br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8dd34c5-839c-4201-a384-06a439b4a88f.jpg" alt></p><p>为了演示有些变量在不同的阶段时不同的，添加了日志文件。return中，将相关联的变量以一行显示，以逗号分隔。冒号前是变量名，冒号后是变量值。</p><p>做一次访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B7.PNG" alt></p><h3 id="HTTP框架提供的变量"><a href="#HTTP框架提供的变量" class="headerlink" title="HTTP框架提供的变量"></a>HTTP框架提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/535214ab-1e4a-40d3-a006-333711c9259c.jpg" alt></p><h3 id="HTTP请求有关变量"><a href="#HTTP请求有关变量" class="headerlink" title="HTTP请求有关变量"></a>HTTP请求有关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7b486912-8cd7-47a3-89c7-48843fd52723.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c9fdf904-3f7d-416a-b4be-e49b2f4a33c4.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e2070844-a852-4cf3-978b-4b27ba67365b.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8abd28c-0ef9-4070-98f4-914b88414852.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a43e65e2-6f41-47f0-8f3e-a62e9dc13303.jpg" alt></p><h2 id="HTTP框架提供的其他变量"><a href="#HTTP框架提供的其他变量" class="headerlink" title="HTTP框架提供的其他变量"></a>HTTP框架提供的其他变量</h2><h3 id="TCP连接有关的变量"><a href="#TCP连接有关的变量" class="headerlink" title="TCP连接有关的变量"></a>TCP连接有关的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d920d0da-2705-45e4-92d3-7591b589a20f.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/962047ba-83c2-416d-87a1-8a5b26102403.jpg" alt></p><h3 id="Nginx处理请求过程中产生的变量"><a href="#Nginx处理请求过程中产生的变量" class="headerlink" title="Nginx处理请求过程中产生的变量"></a>Nginx处理请求过程中产生的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e25f6442-1682-4d3e-acf1-8fe712fc7601.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/b7821b26-bd21-4930-b315-96c7b4f4a582.jpg" alt></p><h3 id="发送HTTP响应时相关变量"><a href="#发送HTTP响应时相关变量" class="headerlink" title="发送HTTP响应时相关变量"></a>发送HTTP响应时相关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589440450988.PNG" alt></p><h3 id="Nginx系统变量"><a href="#Nginx系统变量" class="headerlink" title="Nginx系统变量"></a>Nginx系统变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/14088861-0f90-4cba-ba31-ee728fc9ea81.jpg" alt></p><h2 id="变量防盗链"><a href="#变量防盗链" class="headerlink" title="变量防盗链"></a>变量防盗链</h2><h3 id="简单有效的防盗链手段：referer模块"><a href="#简单有效的防盗链手段：referer模块" class="headerlink" title="简单有效的防盗链手段：referer模块"></a>简单有效的防盗链手段：referer模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52fc1d8f-49eb-4f0a-9260-cde0e218ccd5.jpg" alt></p><h3 id="referer模块的指令"><a href="#referer模块的指令" class="headerlink" title="referer模块的指令"></a>referer模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a01e89ed-9426-420a-98b8-c9255c31d197.jpg" alt></p><h3 id="valid-referers-指令"><a href="#valid-referers-指令" class="headerlink" title="valid_referers 指令"></a>valid_referers 指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e54ac723-8063-4e30-92fc-ae1e90441ddd.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6deb74a6-c5ac-4d39-b36c-32af38a57191.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim referer.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/746f4c69-3700-40f1-b5c1-b2ed3c4b9c5c.jpg" alt></p><p>将带测验8个请求放入 testurl中</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8449207d-4d7c-4da3-b7a8-e161e01c19b2.jpg" alt></p><p><strong>第一个：403 没有匹配上</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d12d9d27-044e-4f2a-9bd1-ca85d432b590.jpg" alt></p><p><strong>第二个：valid,匹配上了 *.taohui.pub</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5d42d29d-4018-41ac-84e6-1005638b2f3e.jpg" alt></p><p><strong>第三个：valid，以内没有referer，匹配上了blocked</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/af7b6ab0-34a0-4a1d-a4f5-df816de7855f.jpg" alt></p><p><strong>第四个：valid，匹配上了 none</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c1f5564a-ef69-45d9-af0e-7a0c27306f77.jpg" alt></p><p><strong>第五个：403 没有匹配上<a href="http://www.taohui.tech" target="_blank" rel="noopener">www.taohui.tech</a></strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a7a7df59-3678-49ca-a876-6c2f54f8d166.jpg" alt></p><p><strong>第六个：valid，匹配上了 server_name</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7f671a43-86f3-47e5-99b2-8ec29753c44b.jpg" alt></p><p><strong>第七个：403 没有配置与baidu有关的</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/f3f2d117-77c7-4e6e-b9dd-7664cdcd4f80.jpg" alt></p><p><strong>第八个：匹配上了正则表达式</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a15fd9ff-cf2e-4ce8-ac7f-94b6d6db4886.jpg" alt></p><h2 id="为复杂业务生成新的变量：map模块"><a href="#为复杂业务生成新的变量：map模块" class="headerlink" title="为复杂业务生成新的变量：map模块"></a>为复杂业务生成新的变量：map模块</h2><p>很多时候，直接使用某些变量的值做逻辑判断是比较困难的，而Map模块提供了可根据1个或多个变量组合成的值结果做判断，进而生成新的变量。再判断新的变量值做逻辑判断。</p><h3 id="通过映射新变量提供更多的可能性：map模块"><a href="#通过映射新变量提供更多的可能性：map模块" class="headerlink" title="通过映射新变量提供更多的可能性：map模块"></a>通过映射新变量提供更多的可能性：map模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/85a00cd6-ef9c-4b74-9843-d3add7d242c5.jpg" alt></p><h3 id="map模块的指令"><a href="#map模块的指令" class="headerlink" title="map模块的指令"></a>map模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/dd78cd48-64fa-4fad-ac21-41d2f7184f58.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/65abe6b5-434d-4b47-bc9f-ac482844cf51.jpg" alt></p><p><strong>问题：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/028fd1ec-f458-4ec8-a901-cc4ce08d150a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589442692006.PNG" alt></p><p>将待检测url放入 testurl，方便拷贝访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/50eed808-e466-43c3-af8f-b744b4f33625.jpg" alt></p><p>访问 map.taohui.org.cn ，匹配上了 泛域名正则、前缀、后缀。而前缀最优先，所以返回 2:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6e049513-0650-42b2-a1e7-ccca35715a47.jpg" alt></p><p>访问 map.tao123.org.cn，只有正则表达式匹配上 1:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8f07ad7f-d832-45bd-b698-5fa0567236e4.jpg" alt></p><p>访问 map.taohui.tech， 完全匹配 与  后缀匹配 都行，但是完全匹配优先级最高，所以 3:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/bf57c2ab-44d3-4e0c-a1c6-af7883535d12.jpg" alt></p><h2 id="通过变量指定少量用户实现AB测试：split-clients模块"><a href="#通过变量指定少量用户实现AB测试：split-clients模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_clients模块"></a>通过变量指定少量用户实现AB测试：split_clients模块</h2><p>该模块可以根据变量的值按照百分比方式生成新的变量。</p><h3 id="AB测试：split-clients模块"><a href="#AB测试：split-clients模块" class="headerlink" title="AB测试：split_clients模块"></a>AB测试：split_clients模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443194182.PNG" alt></p><h3 id="split-clients-模块指令"><a href="#split-clients-模块指令" class="headerlink" title="split_clients 模块指令"></a>split_clients 模块指令</h3><p><strong>AB测试：产品推出的功能不太确定用户是否接受，所以推出多个类似功能，让某一个百分比用户去尝试某一类功能，看大家的反馈来决定最终使用哪一个功能的版本。关键：确保按照某一定的百分比决定用户的行为。</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/3b3fc65c-30fd-47b3-82cd-83d467f82da1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5f8c251c-a7e5-4e44-a908-c1bfe51b26b9.jpg" alt></p><p>上述问题是已经超过100%了。此时重启会发现，重启失败。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/485b6f96-2886-43a2-a5bf-4f413c9856d4.jpg" alt></p><p>将 40% 注释掉。再次访问，server-location中额 $variant 取自 split_clients 中的配置项。而他又取决于$(http_testcli)经算法改造后的值，看这个值落在那个区域，就返回后面对应的值。</p><p><strong>testcli: xxx</strong>，xxx值随便填写，<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443935577.PNG" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589444022423.PNG" alt></p><h2 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h2><p>可根据子网掩码来生成新变量。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/208fe8ff-79ac-4ae0-9568-9b650664ea54.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a751238f-27ba-4fae-b8ae-a7b5c5e6980e.jpg" alt></p><p><strong>geo模块示例</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9b9883bc-c88a-48d8-9017-54b3afbb84bd.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9a632337-6e6d-48c1-b019-c3f9b08daf6a.jpg" alt></p><p>访问<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589449028238.PNG" alt></p><h2 id="使用变量获得用户的地理位置：geoip模块"><a href="#使用变量获得用户的地理位置：geoip模块" class="headerlink" title="使用变量获得用户的地理位置：geoip模块"></a>使用变量获得用户的地理位置：geoip模块</h2><p>可以根据IP地址库自动的计算出IP地址找到相应的地理位置。</p><h3 id="基于MaxMind数据库从客户端地址获取变量：geoip模块"><a href="#基于MaxMind数据库从客户端地址获取变量：geoip模块" class="headerlink" title="基于MaxMind数据库从客户端地址获取变量：geoip模块"></a>基于MaxMind数据库从客户端地址获取变量：geoip模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589450542232.PNG" alt></p><h3 id="geoip-country指令提供的变量"><a href="#geoip-country指令提供的变量" class="headerlink" title="geoip_country指令提供的变量"></a>geoip_country指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/557efae0-fbc2-4a0f-be6f-cf302b8ba368.jpg" alt></p><h3 id="geoip-city指令提供的变量"><a href="#geoip-city指令提供的变量" class="headerlink" title="geoip_city指令提供的变量"></a>geoip_city指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52203507-2fba-4aa3-9a1c-f52fbf4903ff.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/212dbcb2-ddaa-4b31-b1a6-3e78e9f4f2ad.jpg" alt></p><p><a href="https://dev.maxmind.com/geoip/legacy/downloadable/" target="_blank" rel="noopener">MaxMind</a>网址，因为Nginx使用C语言，所以选中C语言的GitHub，进行下载。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7930ddd0-47f0-4e0e-b982-c81bca70c522.png" alt></p><p><a href="https://github.com/maxmind/geoip-api-c" target="_blank" rel="noopener">Github下载zip文件</a></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6793d729-e928-47a5-b427-3920b0c71f28.png" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d07ee523-b404-4c4b-ab54-24c96cbb361f.jpg" alt></p><p>编译进nginx后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e6863285-196c-4e7d-af76-e8df4f44fb06.jpg" alt></p><p>在 <a href="http://www.goubanjia.com/" target="_blank" rel="noopener">http://www.goubanjia.com/</a>选择一些IP来做测试。</p><p>广东IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453163330.PNG" alt></p><p>纽约IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453218372.PNG" alt></p><h2 id="对客户端使用keepalive提升连接效率"><a href="#对客户端使用keepalive提升连接效率" class="headerlink" title="对客户端使用keepalive提升连接效率"></a>对客户端使用keepalive提升连接效率</h2><p>此处是 HTTP协议中的Keepalive，不是TCP协议中的Keepalive</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/86c74fbd-439f-434f-b50c-8e9f25123974.jpg" alt></p><p><strong>语法：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/2205cb77-407c-4672-8c3d-682654a9a5a4.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，&lt;strong&gt;变量是一个解耦工具&lt;/strong&gt;。它同样可以在 openresty 中 lua 语言中大有用处。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>24-详解HTTP过滤模块</title>
    <link href="http://javassun.github.io/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/</id>
    <published>2019-12-12T11:10:53.000Z</published>
    <updated>2020-05-14T11:51:57.407Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文介绍了HTTP模块的11个阶段，在<strong>content</strong>阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到<strong>HTTP过滤模块</strong>，因此，它是处于 <strong>Log</strong>阶段之前，<strong>content</strong>阶段之后去介入请求的处理。</p><a id="more"></a><h2 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h2><h3 id="HTTP过滤模块位置"><a href="#HTTP过滤模块位置" class="headerlink" title="HTTP过滤模块位置"></a>HTTP过滤模块位置</h3><p>image_filter resize 长 宽；（此处图片略有问题）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B7.PNG" alt></p><p><strong>content阶段的 static模块生成响应内容后，到达 header过滤模块的 image_filter，再到 gzip压缩，二者不可翻转。</strong></p><h3 id="返回响应-加工响应内容"><a href="#返回响应-加工响应内容" class="headerlink" title="返回响应-加工响应内容"></a>返回响应-加工响应内容</h3><p>查看 Nginx_module.c数组中内容，也是如下图一样，由下往上看，先被下面的过滤模块处理，在推送到上方的过滤模块。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B71589376248179.PNG" alt></p><h2 id="用过滤模块更改响应中的字符串-sub模块"><a href="#用过滤模块更改响应中的字符串-sub模块" class="headerlink" title="用过滤模块更改响应中的字符串-sub模块"></a>用过滤模块更改响应中的字符串-sub模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/b3d6ce9b-3543-4171-8024-f6a6365fe8e0.jpg" alt></p><h3 id="sub模块指令"><a href="#sub模块指令" class="headerlink" title="sub模块指令"></a>sub模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/f13609e6-c454-4416-a81f-fd26a6238b3b.jpg" alt></p><ul><li><p><strong>sub_filter string replacement，将响应中的string换成replacement</strong></p></li><li><p><strong>sub_filter_last_modified：off,是否同时返回上次未修改过的旧内容（默认是不返回旧内容）</strong></p></li><li><p><strong>sub_filter_once：on  只修改 1次，如果改为off，则是扫描整个body内容，全文修改</strong></p></li><li><p><strong>sub_filter_types mimie-type，只针对 mimie-type类型的响应进行替换，默认是 text/html</strong></p></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim sub.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/be46d0e3-7da9-4c95-be47-dd161c2736a9.jpg" alt></p><p>首先，将配置全部注释，访问域名：端口，得到的是一个index.html欢迎页面。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/312e41fc-b9f1-4657-b13f-2874fbeee811.jpg" alt></p><p>看到 nginx.org 这个超链接中，显示的是<strong>nginx.org</strong>文字，将其替换掉。<strong>替换时忽略大小写</strong>。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/36a19f55-6752-4a68-8bd3-0440f6e09b1d.jpg" alt></p><p>再次访问，发现文字没有变，但是超链接已经变了。（因为开启了只替换一次的功能，所以只替换了超链接，没有替换文字）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/7770d995-813c-4a6c-a224-6c00a5517ff7.jpg" alt></p><p>同时响应头中没有返回<strong>last-modified</strong>有关的内容</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/76b8d1d8-ef27-4e57-b0a3-f1d3c16a70e0.jpg" alt></p><p>再次修改配置项，将 once 改为 off , last_modified 改为 on</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e45f5291-7c8c-4116-9ae0-1a107a67333a.jpg" alt></p><p>访问时会发现被替换掉，且有last-modified</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e5feba71-f287-4ba6-bf46-5dba4f3927c0.jpg" alt></p><h2 id="用过滤模块在http响应前后添加内容-addition模块"><a href="#用过滤模块在http响应前后添加内容-addition模块" class="headerlink" title="用过滤模块在http响应前后添加内容-addition模块"></a>用过滤模块在http响应前后添加内容-addition模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/6f8bae7e-41c0-474a-93d1-a1804c570499.jpg" alt></p><h3 id="addition模块指令"><a href="#addition模块指令" class="headerlink" title="addition模块指令"></a>addition模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/20fa76fe-2f13-4024-a514-4061c47c44b2.jpg" alt></p><p>add_before|after_body uri：添加的URI是<strong>子请求</strong>，让Nginx去访问这个URI，将响应内容添加到body前后。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim addition.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/2cced630-36cc-417e-a563-40c1d92ebb95.jpg" alt></p><p>先访问一个存在的文件 a.txt</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/85d9e2c2-7f2d-4919-baf2-59a045663850.jpg" alt></p><p>修改 addition.conf ，将3个注释解开，再次访问</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/41aacb64-baf1-4429-a122-0cae9ba421c1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上文介绍了HTTP模块的11个阶段，在&lt;strong&gt;content&lt;/strong&gt;阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到&lt;strong&gt;HTTP过滤模块&lt;/strong&gt;，因此，它是处于 &lt;strong&gt;Log&lt;/strong&gt;阶段之前，&lt;strong&gt;content&lt;/strong&gt;阶段之后去介入请求的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>23-详解HTTP请求的11个阶段</title>
    <link href="http://javassun.github.io/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://javassun.github.io/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/</id>
    <published>2019-12-11T11:10:53.000Z</published>
    <updated>2020-05-14T11:49:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除<strong>HTTP过滤模块</strong> 和 <strong>只提供变量的Nginx模块</strong>之外，所有的HTTP模块必须从Nginx定义好的<strong>11</strong>个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？</p><h2 id="HTTP请求处理时的11个阶段"><a href="#HTTP请求处理时的11个阶段" class="headerlink" title="HTTP请求处理时的11个阶段"></a>HTTP请求处理时的11个阶段</h2><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG" alt></p><a id="more"></a><ul><li><p><strong>post_read</strong>：read到Header内容，刚读完HTTP头部，没有做任何加工之前的原始数据。涉及到 <font color="red"><strong>realip模块</strong></font>。</p></li><li><p><strong>server_rewrite、rewrite</strong>：涉及到<strong>rewrite模块</strong>.</p></li><li><p><strong>find_config</strong>：Nginx框架会做，其实是在做location的匹配。</p></li><li><p><strong>post_rewrite</strong>：即 rewrite之后，需要做的一些工作</p></li></ul><p><strong>Access有关的三个模块</strong>：确认访问权限的。（能不能访问）</p><ul><li><p><strong>preaccess</strong>：在access之前做一些处理。</p></li><li><p><strong>access</strong>：auth_basic（用户名密码），access（访问IP），auth_request(第三方授权等)</p></li><li><p><strong>post_access</strong>：在access之后做一些处理。</p></li></ul><p><strong>content有关的</strong></p><ul><li><p><strong>precontent</strong>：在处理content之前做一些处理。</p></li><li><p><strong>content</strong>：诸如一些方向代理等都是在这个阶段生效的。</p></li><li><p><strong>log</strong>：打印access日志的</p></li></ul><p><strong>所有的请求都是由上到下一个阶段一个阶段按序执行。</strong>在debug时可以清楚地看到。</p><h2 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h2><p>当一个HTTP请求进入到Nginx这11个阶段时，由于每一个阶段都可能有0-n个HTTP模块，如果某一个模块不再把HTTP请求向下传递，那么后面的模块是不会执行的。同一阶段中的多个模块，也不是每个模块都有机会执行到的，可能会有前面的模块把请求直接传递给下一个阶段的模块去处理。下面看一看HTTP模块顺序以及他们的处理流程。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2009d91-a832-44c0-bb11-cdb5ac1dd40c.jpg" alt></p><p><strong>每一个蓝色的模块都属于某一个阶段，这些模块是有序的</strong>。</p><p><strong>char *ngx_module_name[]</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe4091aa-9ac8-4596-895b-ed7041e5b2f5.jpg" alt></p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>顺序如何确定呢？可以去看 ngx_modules.c，即configure执行时，会用 with添加模块，这些都会出现在 ngx_module_name[]数组中，这些模块出现的顺序非常关键。</p><p>如 <strong>limit_req</strong> 与 <strong>limit_conn</strong>，二者同属于<strong>preaccess阶段</strong>，在数组中则是 limit_conn 先出现，limit_req后出现，但是对应于请求的处理时它们是相反的。<strong>一个HTTP请求，会先被 limit_req处理，再被limit_conn处理</strong>，假设这两个同时生效去阻止一个请求时，假设这两个返回值也不同，limit_req返回值是没有机会得到执行的，他已经先于limit_conn将请求结果返回给用户。</p><p><strong>灰色的是Nginx框架执行的，其他的第三方HTTP模块没有机会在此运行。</strong></p><h3 id="非顺序处理"><a href="#非顺序处理" class="headerlink" title="非顺序处理"></a>非顺序处理</h3><p>有些则是不会顺序执行的。如 access阶段，当某一个access模块满足，可以直接跳到 try_files模块。当content阶段index模块执行时有时会直接跳到log模块执行。</p><h2 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h2><p>它可以发现用户的真实IP地址，为后续模块的限速、限流等等功能提供了前提。</p><h3 id="如何拿到真实的用户IP地址？"><a href="#如何拿到真实的用户IP地址？" class="headerlink" title="如何拿到真实的用户IP地址？"></a>如何拿到真实的用户IP地址？</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/17157206-ab2d-457a-8e29-331609170ff3.jpg" alt></p><p>TCP连接有一个四元组，根据一条连接的Source_IP就能够判断出用户的IP地址了，但是网络中存在许多反向代理，这又导致反向代理后与上游服务器又建立了一个新的TCP连接。因此上游服务器想通过TCP中的Source_IP获取用户原始IP地址，是不可能的。</p><p><strong>举例：</strong></p><p>在家里上网时，家里的路由器可能分配了一个<strong>内网IP 192.168.0.x</strong>，当通过运营商（电信可能给分配了一个<strong>公网的IP：115.204.33.1</strong>）去访问某一个网站时，先命中到它的<strong>CDN</strong>，这个网站使用CDN加速（如图片等），这个CDN如果还没有把我所访问的资源缓存时，它可能要去<strong>回源</strong>，又建立了一条新的连接，回源过程中可能进入到一个<strong>反向代理</strong>中（如服务器买在阿里云，可能会用<strong>阿里云的SLB</strong>），这个SLB又会去建立一个新的连接，到我购买的服务器的<strong>Nginx</strong>，因此，Nginx如果仅通过拿地址的话，只能拿到<strong>反向代理的IP地址（2.2.2.2）</strong>，反向代理之前的<strong>CDN的地址是1.1.1.1</strong>，其实我们要拿到的是用户的<strong>公网地址115.204.33.1.</strong>， 如果要做限速、并发连接控制，肯定是基于这个公网IP进行的。</p><p><strong>现在拿到的remote_addr是2.2.2.2，想要的是115.204.33.1，如何做到呢？</strong></p><p>通过 <strong>2</strong>、<strong>3</strong>即可做到。</p><ul><li><p><strong>HTTP头部中有 X-Forwarded-For用来传递IP，如CDN的IP地址是1.1.1.1，他又建立了一个新的到反向代理的连接，这个方向代理服务器收到的Header中，可能会存在 X-Forwarded-for 与 X-Real-IP，这个是CDN添加的。</strong></p></li><li><p><strong>X-Forwarded-For 与 X-Real-IP不同，X-Real-IP永远都是一个用户真实IP地址，而X-Forwarded-For则是累加的。如上图中反向代理到Nginx的连接中，加上了CDN的IP地址</strong></p></li></ul><h3 id="拿到用户真实IP地址如何使用？"><a href="#拿到用户真实IP地址如何使用？" class="headerlink" title="拿到用户真实IP地址如何使用？"></a>拿到用户真实IP地址如何使用？</h3><p>基于变量来解耦使用。根据我们在realip模块中配置的指令，<strong>realip模块</strong>会把从 <strong>X-Forwarded-For、X-Real-IP</strong>中获取到的用户真实IP地址去覆盖 binary_remote_addr、remote_addr这两个变量的值。而这两个变量原来指向的是直接与Nginx连接的客户端地址。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1be2a418-5fc1-4400-9f52-4351644d8728.jpg" alt></p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/45c34dc4-a550-45ac-90bb-451c4f10798e.jpg" alt></p><h3 id="realip模块的指令"><a href="#realip模块的指令" class="headerlink" title="realip模块的指令"></a>realip模块的指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/41eb8af6-6c20-4df5-a634-a0034257f583.jpg" alt></p><p>real_ip_recursive：环回地址，默认是关闭的，当它打开时，他会将X-Forwarded-For中，最后的那个地址如果是和客户端地址相同，就会赔pass掉，去取上一个地址。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要自己添加realip.con配置，并且include到nginx.conf中</span><br><span class="line">vim realip.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589215977643.PNG" alt></p><p>此处的server_name 用的是 realip_.taohui.tech;<br>因为当前所在的机器是 116.62.160.193，所以这个测试是不会跨服务器的，本机访问，所以将本机设置为可信地址（set_real_ip_from 116.62.160.193;）没有用它的默认配置（ real_ip_header X-Real-IP;），而是重新作了配置（real_ip_header X-Forwarded-For;）环回地址用了默认 off ，对于这样的请求，返回 remote_addr 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#39;X-Forwarded-For: 1.1.1.1,116.62.160.193&#39; realip taohui.tech</span><br><span class="line"></span><br><span class="line">-H 可以对我的请求中添加一个Header，Header中放了两个IP，一个是1.1.1.1（模拟上一个对端地址），另一个是116.62.160.193；</span><br></pre></td></tr></table></figure><p>返回的 116.62.160.193</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e52cfd9f-d514-40f6-9aca-2f0226969883.jpg" alt></p><p>如果开启了环回地址 即为 on，Nginx做一次 realod，再次访问，因为我们最后一个地址是本机地址，出发了环回地址被pass掉，发现变为上一个对端地址 1.1.1.1</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/789f10ab-1a2c-4646-b6c1-0d7d5f73f356.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 post_read阶段中的realip模块，因为它处于的阶段，可以拿到没有加工过的X-Forwarded-For或X-Real-IP中的用户地址，因为后续的很多模块会去修改 X-Forwarded-For中头部的值。</p><h2 id="rewrite阶段：rewrite模块"><a href="#rewrite阶段：rewrite模块" class="headerlink" title="rewrite阶段：rewrite模块"></a>rewrite阶段：rewrite模块</h2><p><strong>rewrite模块</strong>中的<strong>return指令</strong>会在 server_rewrite 与 rewrite阶段都会生效，生效后，后续的HTTP模块的其他阶段是没有机会得到执行的。</p><h3 id="rewrite模块：return指令"><a href="#rewrite模块：return指令" class="headerlink" title="rewrite模块：return指令"></a>rewrite模块：return指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/62d86676-c710-43e4-b52a-bdd1f59ee2c9.jpg" alt></p><p>444 表示Nginx立即关闭连接，不再向客户端返回任何内容。</p><h3 id="rewrite模块：return指令与error-page指令"><a href="#rewrite模块：return指令与error-page指令" class="headerlink" title="rewrite模块：return指令与error_page指令"></a>rewrite模块：return指令与error_page指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ffdd9a3d-294a-4148-9b6b-4b51b00f7f55.jpg" alt></p><h3 id="return示例"><a href="#return示例" class="headerlink" title="return示例"></a>return示例</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5c75f1a9-fe7a-4e37-9720-d5bafda5d1cd.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建return.conf，并include进nginx.conf</span><br><span class="line">vim return.conf</span><br></pre></td></tr></table></figure><p>root html/  即我们访问 location 下的某个资源时，会去html下去找资源是否存在。如果文件没有找到，会生成一个404错误码，正常会这样返回，但这里注释掉，并且定义了一个 error_page 404 /403.html；即当看到404时给他重新定向到 403.html页面。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589217726606.PNG" alt></p><p>访问时故意找一个不存在的资源</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02ea6d8e-a71b-460e-a4a5-c67390fd926f.jpg" alt></p><p>此时，解开 return 404 的注释，再次访问， error_page是没有机会得到执行的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/36b9a97b-5f89-4733-8205-b6c0f14fdd27.jpg" alt></p><p>再如：在server中加入了一个 return 405;</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/09fad081-c6bd-4e98-b361-d231b97374d4.jpg" alt></p><p>此时会执行谁呢？ 在11个阶段中不难发现， server配置项中的return 是在 server_rewrite中的，location中的return是在 rewrite中的，肯定是 server_rewrite中的return先执行，而 location中的return是没有机会执行的。<strong>即肯定返回405</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/482f0981-162a-44e1-b2a6-7c71e67a86d7.jpg" alt></p><h3 id="rewrite模块：rewrite指令重写URL"><a href="#rewrite模块：rewrite指令重写URL" class="headerlink" title="rewrite模块：rewrite指令重写URL"></a>rewrite模块：rewrite指令重写URL</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/42d90672-258b-43f1-bfca-758460fbbaa2.jpg" alt></p><h4 id="rewrite指令示例（一）"><a href="#rewrite指令示例（一）" class="headerlink" title="rewrite指令示例（一）"></a>rewrite指令示例（一）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/118bb95d-6343-4197-a1f1-3e588ba5d3b4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/40344274-ece7-4745-8cbc-1495bbe764f5.jpg" alt></p><p>首先访问 first/3.txt</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6b709829-c696-4633-a415-a1f23c883a66.jpg" alt></p><p>在second中间 break注释放开，会有什么不一样呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d8c0525e-65d8-4b72-b88c-2699d513bf92.jpg" alt></p><h4 id="rewrite指令示例（二）"><a href="#rewrite指令示例（二）" class="headerlink" title="rewrite指令示例（二）"></a>rewrite指令示例（二）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0d88d297-907e-452a-9348-28f6bb1db4a8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd30f763-825d-4e63-a7d6-bc80aba824e9.jpg" alt></p><p>访问第一个，因为指定了 permanent（永久重定向），返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3717eeea-bc58-4d62-96f1-4c7c6e2c0b4a.jpg" alt></p><p>访问第二个，因为指令了 redirect（临时重定向），返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d719b0-ea6b-4891-93cb-32dcea315dfb.jpg" alt></p><p>访问第三个，因为什么都没有指定，但前面又有一个 http、https等，会返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f37d3915-6a05-4f68-af33-1c418890ad66.jpg" alt></p><p>访问第四个，虽然前面有 http、https，但最后指定了 permanent，会返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d55a475a-8a3f-43b6-b002-60a63daee590.jpg" alt></p><p><strong>rewrite_log指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8e0d3f73-8412-402c-b627-4a4c47dae229.jpg" alt></p><p>默认是不会开启的，需要显示开启，打开后，刚刚访问过的所有重定向的URL都会在指定的 <strong>logs/rewrite_error.log</strong>中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim rewrite_error.log</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8216df9e-65f7-40d8-b14d-81f473e58d38.jpg" alt></p><h3 id="rewrite模块：if指令-条件判断"><a href="#rewrite模块：if指令-条件判断" class="headerlink" title="rewrite模块：if指令-条件判断"></a>rewrite模块：if指令-条件判断</h3><p><strong>if指令</strong>可以让我们判断请求中的变量的值是否满足某个条件，再去决定由哪一个配置块执行，再根据这些配置块调用相应的模块去解析请求。（逻辑判断）</p><h4 id="rewrite模块的if指令"><a href="#rewrite模块的if指令" class="headerlink" title="rewrite模块的if指令"></a>rewrite模块的if指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/437f5e32-4633-43cd-a275-e96edcd4a1fc.jpg" alt></p><h4 id="if指令的条件表达式"><a href="#if指令的条件表达式" class="headerlink" title="if指令的条件表达式"></a>if指令的条件表达式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fdb72d21-a525-4781-b8aa-671d915b59f6.jpg" alt></p><p><strong>简单示例</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/25e97781-e9a3-4b33-af77-19c7189b6aa5.jpg" alt></p><h2 id="find-config阶段"><a href="#find-config阶段" class="headerlink" title="find_config阶段"></a>find_config阶段</h2><p>当我们在server块下的rewrite系列指令执行完毕后，开始根据用户请求中的URL去location中对应的URL正则表达式进行匹配。这一步【匹配完成后，就确定了由哪一个location对这个请求进行处理。</p><h3 id="处理请求的-location-指令块"><a href="#处理请求的-location-指令块" class="headerlink" title="处理请求的 location 指令块"></a>处理请求的 location 指令块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/96b8444c-2c2d-44f7-a224-24b101a157ca.jpg" alt></p><p><strong>merge_slashes</strong>可以去合并URL里的斜杠，两个斜杠在一起时，默认打开该配置项，会合并成一个。只有当URL中用到<strong>base64编码</strong>等等规则时，才需要关闭。</p><h4 id="location匹配规则：仅匹配URI，忽略参数"><a href="#location匹配规则：仅匹配URI，忽略参数" class="headerlink" title="location匹配规则：仅匹配URI，忽略参数"></a>location匹配规则：仅匹配URI，忽略参数</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bc97e48a-b6da-45b3-9a94-ccdb4dfdeb4d.jpg" alt></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/46154d9b-cde7-44aa-8011-b571869ddf18.jpg" alt></p><h4 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/db8723bd-dfe2-4cca-a421-fa5e85e6eec4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim locations.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/afea573c-c8c2-46f9-9964-81a5dfe637a0.jpg" alt></p><p>访问Test1,精确匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f8816478-51ce-4992-bf10-57198fc681c7.jpg" alt></p><p>访问Test1/,虽然有多个匹配，但是前缀字符串中遵循<strong>最长匹配</strong>的规则，所以匹配到了 Test1/，并且匹配上后，禁止后续正则表达式的匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe863375-e5e2-45b7-9d29-5c59ddc3b0d2.jpg" alt></p><p>访问/Test1/Test2 ，/Test1/Test2 与 <del>* /Test1/(\w+)$ 都匹配上了，但由于没有使用 ^</del>禁止正则表达式匹配，所以匹配的是带有正则表达式的最长匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c4e6b72-6e3a-4789-beec-aad6474d0f44.jpg" alt></p><p>访问/Test1/Test2/ ，因为正则没有匹配上，所以使用最长字符串匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/937460a9-1add-4e3d-a739-ef415bb617c0.jpg" alt></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 location的匹配规则，对于URI的请求，到底是由哪一个location下的指令去执行，就十分了然了，同时也知道了当location数量非常多时，怎样通过 <strong>禁止正则表达式匹配</strong>、<strong>使用=精确匹配</strong>等等方式对非常频繁发起的请求来减少它们做location匹配的次数。</p><h2 id="preaccess阶段"><a href="#preaccess阶段" class="headerlink" title="preaccess阶段"></a>preaccess阶段</h2><h3 id="对连接做限制的limit-conn模块"><a href="#对连接做限制的limit-conn模块" class="headerlink" title="对连接做限制的limit_conn模块"></a>对连接做限制的limit_conn模块</h3><p><strong>问题：如何限制每个客户端的并发连接数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/c2bbb690-8f6f-4a6b-a5e9-ef85c44d74b9.jpg" alt></p><h4 id="limit-conn指令"><a href="#limit-conn指令" class="headerlink" title="limit_conn指令"></a>limit_conn指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7fcdbe6a-773f-4720-9636-475b1fa1f457.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0126152a-bb75-4b70-bac7-0030bdb75d55.jpg" alt></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;3r&#x2F;s</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        limit_rate 50;</span><br><span class="line">        limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;1 nodelay;</span><br><span class="line">        #limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/636ff2ff-a1c4-408a-9b79-9dfa88be33f8.jpg" alt></p><p>上述配置文件定义了一个 <strong>10M</strong> 的共享内存，共享内存中使用 binary_remote_addr，这是一个二进制格式的IP地址（IPV4协议下只有4个字节,效率较高）。</p><p>定义了向用户返回的错误码是500（默认是503）</p><p>将 log_level调成了 warn（默认是error）</p><p>limit_conn_addr 1; 即限制了并发连接数为1（只为演示效果，当有两个客户端同时访问时，就会返回500）</p><p>limit_rate 50; 为了更好的演示，又加上了该配置项，即限制向用户返回的速度，每秒钟只返回50个字节，比较容易出现限制并发连接的场景。</p><p>在一个shell中访问，回复速度非常慢</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b53e8635-ea6e-477f-baf7-d7e9a41130ae.jpg" alt></p><p>在另一个shell中也访问，会回复500错误码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8032adb7-ee5f-4213-b7e5-6d37ba578735.jpg" alt></p><p>在 myerror.log中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d9f8cbfc-d250-42a1-b59a-542a21ee2700.jpg" alt></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>当Nginx作为资源服务器为用户提供服务时，限制用户能够同时发起的并发连接数，是一个很常用的功能。Nginx默认编辑进去的 ngx_http_limit_conn_module模块提供了这样的功能。<strong>设计好Key是关键</strong>。</p><h3 id="对请求做限制的limit-req模块"><a href="#对请求做限制的limit-req模块" class="headerlink" title="对请求做限制的limit_req模块"></a>对请求做限制的limit_req模块</h3><p><strong>问题：如何限制每个客户端的每秒处理请求数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f310270f-af32-456f-a8bc-10f9d88052ea.jpg" alt></p><h4 id="leaky-bucket算法"><a href="#leaky-bucket算法" class="headerlink" title="leaky bucket算法"></a>leaky bucket算法</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a55435d0-d50f-48e1-92e6-48e569f84fe6.jpg" alt></p><p>对于突发性流量，前两秒12Mbps，总共24M，2-7s没有流量，7-10为2Mbps，共6M，前10秒总共30M。</p><p>使用了该算法后，可以限制为3Mbps,前10秒总共 30M。</p><p>可以比喻为一个水龙头，向盆里流动的是突发性流量，而盆向下流的则是恒速流量。</p><ul><li><p><strong>当盆burst满的时候，立刻向用户返回503错误码</strong>。</p></li><li><p><strong>当盆burst没有满的时候，但向下速率已经达到最大化的时，水滴就会存在盆里，即用户的响应会变慢，请求并不会被拒绝</strong>。</p></li></ul><h4 id="limit-req指令"><a href="#limit-req指令" class="headerlink" title="limit_req指令"></a>limit_req指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/39b5d9e6-fc0a-486b-9ba3-417d57dc2ae0.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bafe56ec-ff77-4371-b9de-7bf7dbb7a0f8.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab666467-5387-42cf-b454-0b3ddf8c26b4.jpg" alt></p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;2r&#x2F;m</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        #limit_rate 50;</span><br><span class="line">        #limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;3 nodelay;</span><br><span class="line">        limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有加 burst 与 nodelay时，结果会是怎样？同时注释掉 limit_rate 这样可以快速返回内容。<strong>每分钟两条</strong></p><p><strong>curl limit.haoran.tech</strong> ，看到结果</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7db81b53-d952-41df-aa52-23651ef9a701.jpg" alt></p><p>再次访问</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/034093e0-7e6e-4aa0-8022-e4d36bbb5818.jpg" alt></p><p>将  burst的注释解开会是什么样的呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f129ccd-e03c-45ef-a3de-27ab1087cea7.jpg" alt></p><p>访问3次都可以看到结果，访问第4次时，会有503错误码。</p><p>现在将限制连接与限制请求同时打开。看下效果。返回500（限制连接生效），返回503（限制请求生效），</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/80d4681d-1e8d-410e-9491-4dc792b7e05d.jpg" alt></p><p>每分钟只能处理2个请求，所以第3次访问时，<strong>limit_req生效</strong>，但其实 第二次访问时 <strong>limit_conn</strong>同样生效了。返回的还是503，而不是500，这是因为 limit_req模块是在limit_conn模块之前生效的，limit_req已经向用户拒绝了，limit_conn就没有机会得到执行了。<br><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1eba94b3-b698-40f9-9d67-3243174af439.jpg" alt></p><h2 id="access阶段"><a href="#access阶段" class="headerlink" title="access阶段"></a>access阶段</h2><h3 id="对IP做限制的-access-模块"><a href="#对IP做限制的-access-模块" class="headerlink" title="对IP做限制的 access 模块"></a>对IP做限制的 access 模块</h3><p><strong>access模块</strong> 可以控制那些IP可以访问某些URL，那些不可以访问。</p><p><strong>问题：如何限制那些IP地址的访问权限？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/832769b6-fcc5-4fa5-9da7-4c17ec221d47.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/066c8482-4e64-46a6-b6a6-4ff35b0056e2.jpg" alt></p><h3 id="对用户名-密码做限制的-auth-basic-模块"><a href="#对用户名-密码做限制的-auth-basic-模块" class="headerlink" title="对用户名-密码做限制的 auth_ basic 模块"></a>对用户名-密码做限制的 auth_ basic 模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/609f0ee1-f934-4a18-be91-114657084c86.jpg" alt></p><p><strong>auth_basic模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/98ca71bc-ed6b-4332-910d-a6d02f593c64.jpg" alt></p><p><strong>生成密码文件</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d1d3a69a-f867-448b-a035-8a86dfc57870.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br><span class="line"></span><br><span class="line">htpasswd -c file -b user pass</span><br><span class="line"></span><br><span class="line">-c 指定生成的文件，-b 指定用户名密码</span><br><span class="line"></span><br><span class="line">假设现在已经生成了 auth.pass文件</span><br><span class="line"></span><br><span class="line">vim auth.pass</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4f016d91-a721-4522-a1fb-80cd531197ce.jpg" alt></p><p>上述密码文件中的密码做了一个简单的base64编码。</p><p>在 nginx.conf配置文件中指定有关配置</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/895f11ef-d463-4cd3-ac87-55a76b65174e.jpg" alt></p><p>浏览器访问 access.taohui.tech；会发现需要输入用户名-密码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d41f3894-95a1-4f95-b711-327495299542.jpg" alt></p><p>当我们提供一个非常简单的页面时，如go-access，想对他做一个安全保护，auth_basic是一个不错的做法。</p><h3 id="使用第三方做权限控制的-auth-request-模块"><a href="#使用第三方做权限控制的-auth-request-模块" class="headerlink" title="使用第三方做权限控制的 auth_request 模块"></a>使用第三方做权限控制的 auth_request 模块</h3><p>在生产环境中，往往会有一个动态Web服务器或者相应的一些应用服务器，它们提供更复杂的用户名-密码权限验证，这个时候可以通过访问Nginx的资源池先将这个请求传递给应用服务器上，根据应用服务器返回的结果再判断这个请求资源能不能继续执行，那么Nginx的access阶段有一个模块为 auth_request模块，他就可以完成这样的功能。</p><p><strong>统一的用户权限验证系统</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7af33897-413a-4e91-ace2-ec13a7099185.jpg" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6a69a3f-c156-4852-9303-e6f37b8e8210.jpg" alt></p><p>当访问 / 时 通过 auth_request 生成子请求,会去访问这个URL test_auth，而这个URL通过 proxy_pass反向代理到本机的另一个Nginx服务器（监听端口为8090），他提供的URL为 auth_upstream。成功后，因为有一个默认的配置 root html/(即使注释了也会正常显示html下的 index页面)，如果被拒绝，就会返回 8090 这台机器的错误码。</p><p>8090这台nginx的内容如下（成功的时候）：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7ec46de9-417b-4c2e-9538-92900bc23395.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/cacc2da6-43af-49a1-a0c2-5c875a1c29eb.jpg" alt></p><p>将上游的返回值改为403：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b3662788-1074-492f-9d3c-5c370f409aec.jpg" alt></p><p>禁用缓存后，再次访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e887c996-2eb0-47f2-a0e6-d7c049bc7c2b.jpg" alt></p><h3 id="access阶段的-satisfy-指令"><a href="#access阶段的-satisfy-指令" class="headerlink" title="access阶段的 satisfy 指令"></a>access阶段的 satisfy 指令</h3><p>前面提到了 access 阶段的3个模块，那这三个模块任意一个模块拒绝了用户的请求，用户请求就无法执行了呢？其实并不是这样的，那他们是否严格的按照顺序往下执行呢？同样不是这样的。</p><p>因为 Nginx的HTTP框架中提供了一个 <strong>satisfy指令</strong>，允许我们改变模块的执行顺序。</p><p><strong>限制所有access阶段模块的 satisfy指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9e0e322a-b59c-477b-8787-131df574d6ca.jpg" alt></p><p>即一个 access模块，有三种处理结果：</p><ul><li><p><strong>忽略，即没有任何配置，直接跳到下一个access模块</strong></p></li><li><p><strong>放行（allow），先判断satisfy开关，如果配置为 all（表示必须所有的access模块都同意放行这个请求才可以通过），所以继续执行下一个access模块；如果配置为 any（即不用再去考虑后续的access模块是否同意，直接跳到下一个 post_access阶段执行）</strong></p></li><li><p><strong>拒绝（deny），同样判断satisfy开关，如果配置为 all（直接拒绝请求），不再向下执行。如果是 any，虽然当前这个模块拒绝了，但也会后续模块会同意放行，所以继续执行下一个access模块</strong></p></li></ul><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/11fb6c5d-da39-4d6e-afeb-47fc345a904e.jpg" alt></p><ul><li><p><strong>1：肯定不会生效，因为return指令的生效期是 server_rewrite 与 rewrite阶段，二者都领先于 access，access是没有机会得到执行的。</strong></p></li><li><p><strong>2：肯定有影响，即如果 access阶段已经拒绝了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li><li><p><strong>3：可以访问到，配置了 satisfy any</strong></p></li><li><p><strong>4：提到之前，仍然可以访问，因为模块间的顺序ok就行了，配置指令间的顺序无关紧要</strong></p></li><li><p><strong>5：将 deny all 改为 allow all，没有机会输入，因为配置的 satisfy all，任意的模块同意就可以了，allow all是 access模块的，它先于auth_basic模块执行的，它已经同意了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li></ul><h2 id="precontent阶段"><a href="#precontent阶段" class="headerlink" title="precontent阶段"></a>precontent阶段</h2><h3 id="按序访问资源的-try-files-模块"><a href="#按序访问资源的-try-files-模块" class="headerlink" title="按序访问资源的 try_files 模块"></a>按序访问资源的 try_files 模块</h3><p><strong>对于反向代理的场景十分有用，Nginx先尝试去获取磁盘上的文件内容，如果没有再反向代理到上游服务。</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/728821e7-c28a-470a-8c79-2cc85b353fd3.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim tryfiles.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3eb1c77a-1125-49b9-ac41-bb1c00ee2057.jpg" alt></p><p>访问 /first，如果系统在维护的话可能会有一个 /system/maintenance.html文件，如果这个文件找不到的话，我们就去找 uri（即 html下first有没有），同样没有，$uri/index.html、$uri.html同样都没有，这时使用了 @lasturl 符号 去访问 另一个 location @lasturl。在这个location中返回 200的状态码。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/93bb2a64-19b6-4c1c-9e5a-ae4127d27779.jpg" alt></p><p>访问 /second，一样与一个去尝试，所有文件都找不到时，返回404.</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e14e4c54-713c-4f5d-afe3-826434d572c8.jpg" alt></p><h3 id="实时拷贝流量-mirror-模块"><a href="#实时拷贝流量-mirror-模块" class="headerlink" title="实时拷贝流量 mirror 模块"></a>实时拷贝流量 mirror 模块</h3><p>mirror模块可以帮我们创造一份镜像流量，如生产环境中处理一些请求，这些请求可能需要把他们同步的拷贝一份到我的测试、开发环境中做处理。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8611ad8c-6413-4e49-8c81-14d5dcc9d7bb.jpg" alt></p><p>即当请求到了Nginx后，可以生成一个子请求，这个子请求可以通过反向代理去访问我们的其他环境（测试环境等），对其他环境返回值不作处理。</p><p><strong>举例</strong></p><p>需要一个上游服务器</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8262d188-51e4-42cf-9020-9d191d34a19a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim mirror.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/dfe18329-89d0-4458-b28a-2415d5d86bde.jpg" alt></p><p>收到一个请求时，会拷贝一份流量到 mirror 中去，/mirror收到后，会指定 internal（内部），将其方向代理到本机的10020端口上去。</p><p>访问8001</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5602b6ce-74a5-4899-895c-8a0996c08303.jpg" alt></p><p>实时查看日志</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd01d90d-8679-434b-90d7-76bcdd1da763.jpg" alt></p><p>再去看上游Nginx(10020)的日志，是否收到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8fb49605-4b51-43a3-93b5-482835b2f6f5.jpg" alt></p><h2 id="content阶段"><a href="#content阶段" class="headerlink" title="content阶段"></a>content阶段</h2><h3 id="static模块-root-和-alias-指令"><a href="#static模块-root-和-alias-指令" class="headerlink" title="static模块 root 和 alias 指令"></a>static模块 root 和 alias 指令</h3><p>content阶段中 static模块  默认是在Nginx框架中的，是没有办法做移除的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b281027a-aae7-4dfe-88bc-ac86be3b0a78.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/85228787-c832-42d3-abcc-d1c9a88e6bf8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8ecfd588-3241-470e-87bb-05787d28f3c5.jpg" alt></p><p><font color="red">直接访问 root/，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0c140f6a-cbcd-47c6-9d3b-709a76fee58e.jpg" alt></p><p>查看日志，在 html后又加上了刚刚 location中的root，因为有个 反斜杠，所有有添加了 index.html，这个文件其实是不存在的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b653fc8e-67c4-41b4-8a47-8ab73f3bb163.jpg" alt></p><p><font color="red">直接访问 root/1.txt，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a47c5ad2-58ce-400b-9310-0c10ef8caff9.jpg" alt></p><p>查看日志，它其实是在 html/first/1.txt 后面又添加了 /root/1.txt，即 html/first/1.txt/root/1.txt</p><p><font color="red">直接访问 curl static.taohui.tech/alias/   ,他匹配到了 location /alias  会去访问 html下的index.html，所以应该访问首页</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e81ffef0-5e33-44d9-b9fc-87cdc23a59f0.jpg" alt></p><p><font color="red">直接访问 curl static.taohui.tech/alias/1.txt  ，不会添加完整路径，文件存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c61806a-68d3-412a-bdae-c38891d6fe4e.jpg" alt></p><h3 id="static模块-3个变量"><a href="#static模块-3个变量" class="headerlink" title="static模块 3个变量"></a>static模块 3个变量</h3><p><strong>生成待访问文件的三个相关变量</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363559193.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ef33b509-ef3c-4791-9a89-de3d330cd1f9.jpg" alt></p><p>realpath 实际上是一个软链接，他指向了 first目录下，这个目录下有一个1.txt文件</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2fc334d9-4140-4ae2-b475-c8c70453c88e.jpg" alt></p><p>在下图中可看到，返回3个路径，第一个是完整路径，后两个都是1.txt所在的目录，只不过 document_root 没有做软链接的替换，还是根据配置项拼接出来的，而 realpath_root 已经将 realpath 替换为真实 first目录。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363849390.PNG" alt></p><h3 id="static模块提供的其他功能"><a href="#static模块提供的其他功能" class="headerlink" title="static模块提供的其他功能"></a>static模块提供的其他功能</h3><h4 id="静态文件返回时的-content-type"><a href="#静态文件返回时的-content-type" class="headerlink" title="静态文件返回时的 content-type"></a>静态文件返回时的 content-type</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fcc5c202-7370-4c46-9781-5c3013c3ac45.jpg" alt></p><p>当我们去读磁盘上的文件时，根据文件的扩展名做一次映射。<strong>types指令</strong>就是做这个事情的，为了加速，需要将 content-type  与 扩展名 做一次映射放入 Hash 表中。</p><p><strong>default_type</strong>是在没有文件名时用来告诉用户这个content-type究竟怎样解析</p><h4 id="未找到文件时的错误日志"><a href="#未找到文件时的错误日志" class="headerlink" title="未找到文件时的错误日志"></a>未找到文件时的错误日志</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/73be5c25-2a92-49df-9fa6-4e5a2f18d0e1.jpg" alt></p><h3 id="static模块对url不以斜杠结尾却访问目录的做法"><a href="#static模块对url不以斜杠结尾却访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾却访问目录的做法"></a>static模块对url不以斜杠结尾却访问目录的做法</h3><p>很多人使用 static 模块的  root/alias 指令将Nginx当做静态资源服务器时，很可能会发现，当我们去访问一个目录，但是在url结尾没有加上斜杠时，实际上Nginx会返回一个301的重定向，那么对于重定向中的内容，Nginx提供了3种不同的指令，去控制location这样的行为。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d79721a2-30b5-45d1-bc5f-5a23376cb8f0.jpg" alt></p><p><strong>重定向跳转的域名</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5be98a60-9879-424b-af00-20da33bd9ac6.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim dirredirect.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0f59cecd-1d65-4878-a2fc-ed552e9a8ced.jpg" alt></p><p>在 server_name 中配置了两个域名，第一个是主域名。将 absolute_redireect off 开启（默认是on），root指向 html/ 下有一个 first文件夹。</p><p>先来访问 first文件夹，没有加反斜杠，此时应该获得一个301重定向</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f469702-82cb-4d21-9e94-87b8d4cbbbb2.jpg" alt></p><p>将 absolute_redirect off 注释掉。再次访问，发现 在 <strong>Location</strong>中将域名都添加了进去。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f4c52dee-e694-456e-a032-3adf3c6cb7cc.jpg" alt></p><p>如果头部有一个 <strong>Host: aaa</strong>，那么就会将它替换掉掉Location中的localhost。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3be924e8-441e-49aa-b014-0639d6707a30.jpg" alt></p><p>将 dirredirect.conf配置文件中的 <strong>server_name_in_redirect on</strong>开启后，再去访问，会发现Location中以主域名来绑定。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ea6acb6d-f387-4f79-b80e-04aaa22ace11.jpg" alt></p><h3 id="index-与-autoindex模块"><a href="#index-与-autoindex模块" class="headerlink" title="index 与 autoindex模块"></a>index 与 autoindex模块</h3><p>在前面已经演示过，autoindex会以目录形式显示服务器上的资源。但有时在搭建的时候，会没有看到目录结构，看到的是一个文件的内容，这是因为** index 模块** 先于 <strong>autoindex 模块</strong>产生作用。</p><h4 id="对访问-时的处理：content阶段的index模块"><a href="#对访问-时的处理：content阶段的index模块" class="headerlink" title="对访问/时的处理：content阶段的index模块"></a>对访问/时的处理：content阶段的index模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/03f6d0ed-8176-4fa7-9d84-94e0b6ba03d1.jpg" alt></p><h4 id="显示目录内容：content阶段的autoindex模块"><a href="#显示目录内容：content阶段的autoindex模块" class="headerlink" title="显示目录内容：content阶段的autoindex模块"></a>显示目录内容：content阶段的autoindex模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab7fdd2b-3bc0-411f-a706-72de6fa40001.jpg" alt></p><p><strong>autoindex 模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4a0c0058-8c44-4e61-bf74-a4a1031a99fe.jpg" alt></p><p>autoindex_exact_size on|off ：当默认打开的格式（向用户返回的是html格式时才有效）是显式相对的路径。<strong>绝对路径：</strong>以<strong>字节</strong>来显示。<strong>相对路径：</strong>以<strong>K、M</strong>显示。</p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim autoindex.conf</span><br></pre></td></tr></table></figure><p>监听了1个8080端口，以server_name指定的域名进行访问，默认没有修改index a.html（注释掉了）。当访问 / 时，会去找 index.html，在 alias指定的html下是有这个文件。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bf6a5afc-224c-4ace-bb0d-9980a58ef6d6.jpg" alt></p><p>去访问 autoindex.taohui.tech:8080，得到的是index.html内容</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/35ca0dd5-1174-4d4c-8ab4-f29a4e95c157.jpg" alt></p><p>因为 index 模块是没有办法从  Nginx中移除的，所以可以去修改 index指向的文件，将它指向一个不存在的 a.html文件（即将 index a.html 注释解开）</p><p>再次访问autoindex.taohui.tech:8080，是JSON格式返回这个目录</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d928ea5f-1314-45f7-8c2b-2bfa98a9379b.jpg" alt></p><p>同理，将 autoindex_format json 改为 html</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2f0517d-faa7-47bd-9d91-aaa32607b218.jpg" alt></p><p>reload后，再次访问，因为是以相对路径，所以可以显示到K。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a18c6759-3aae-41de-8cdf-f7b93d5e3473.jpg" alt></p><h3 id="content阶段中有Alibaba提供的concat模块"><a href="#content阶段中有Alibaba提供的concat模块" class="headerlink" title="content阶段中有Alibaba提供的concat模块"></a>content阶段中有Alibaba提供的concat模块</h3><p>concat模块可在一次请求中返回多个文件的内容，这对在Web页面中访问多个小文件来提升性能十分有用。（需要下载并且在 .configure 时编译进Nginx）</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/68e622ae-6d7a-42c3-9890-3cb801bc37d8.jpg" alt></p><p><strong>concat模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9d3beaf0-7b29-4534-81e5-7649b057033b.jpg" alt></p><ul><li><p><strong>concat 开启或者关闭</strong></p></li><li><p><strong>concat_delimiter：String，如果服务器返回多个文件，通过指定的String分隔符进行分割</strong></p></li><li><p><strong>concat_types: MIME types，对那些文件的类型做合并</strong></p></li><li><p><strong>concat_unique：对某一种文件类型进行合并，还是对多个文件类型进行合并</strong></p></li><li><p><strong>concat_ignore_file_error：如果某个文件出现错误，是忽略它，返回其他文件的内容</strong></p></li><li><p><strong>concat_max_files：最多合并多少个文件，默认为10</strong></p></li></ul><p><strong>看一下淘宝网的做法</strong></p><p>可以看到他的大部分请求，都使用了 <strong>??</strong>，后面添加了多个文件，后面用逗号隔开。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02e8a5f0-565f-4068-92ac-01046a0008ab.jpg" alt></p><p>在响应中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/14b5a5c5-325f-42ae-8156-591e00c25231.png" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim concat.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d44649-a349-4292-b964-44f983a5e1b3.jpg" alt></p><p>在 concat.conf配置文件中，首先打开了这个功能，最多20个文件，类型是 text/plain，以 <strong>三个分号</strong>来分隔多个文件。</p><p>现在来访问，他回去 html/concat 路径下找 1.txt 与 2.txt，这两个文件是存在的，内容如下：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e9612a1d-ca16-462c-a9e5-eaba187d31d5.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d3025d36-8921-429f-81f4-f5eefb3dd611.jpg" alt></p><h2 id="Log阶段（记录请求访问日志的log模块）"><a href="#Log阶段（记录请求访问日志的log模块）" class="headerlink" title="Log阶段（记录请求访问日志的log模块）"></a>Log阶段（记录请求访问日志的log模块）</h2><h3 id="http-log模块"><a href="#http-log模块" class="headerlink" title="http_log模块"></a>http_log模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a7c1944c-6b8c-4a7e-9155-dd3a886d2584.jpg" alt></p><h4 id="access-日志格式"><a href="#access-日志格式" class="headerlink" title="access 日志格式"></a>access 日志格式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2b74ec9f-c476-4e23-8162-da5fe03379b0.jpg" alt></p><h4 id="配置日志文件路径"><a href="#配置日志文件路径" class="headerlink" title="配置日志文件路径"></a>配置日志文件路径</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2806838-8e42-4e9f-992b-b9357b7a2820.jpg" alt></p><h4 id="对日志文件名包含变量时的优化"><a href="#对日志文件名包含变量时的优化" class="headerlink" title="对日志文件名包含变量时的优化"></a>对日志文件名包含变量时的优化</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589375413620.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;除&lt;strong&gt;HTTP过滤模块&lt;/strong&gt; 和 &lt;strong&gt;只提供变量的Nginx模块&lt;/strong&gt;之外，所有的HTTP模块必须从Nginx定义好的&lt;strong&gt;11&lt;/strong&gt;个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？&lt;/p&gt;
&lt;h2 id=&quot;HTTP请求处理时的11个阶段&quot;&gt;&lt;a href=&quot;#HTTP请求处理时的11个阶段&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求处理时的11个阶段&quot;&gt;&lt;/a&gt;HTTP请求处理时的11个阶段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>22-如何找到处理请求的Server指令块</title>
    <link href="http://javassun.github.io/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/</id>
    <published>2019-12-10T12:10:53.000Z</published>
    <updated>2020-05-14T11:47:19.401Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个<strong>server块</strong>处理，因此，要先介绍一个配置指令 <strong>server_name</strong>，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。</p><a id="more"></a><h2 id="Server-name-指令"><a href="#Server-name-指令" class="headerlink" title="Server_name 指令"></a>Server_name 指令</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/df26bdab-3bfd-42ee-86f7-638175ac5b63.jpg" alt></p><p><strong>简单演示：</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/afcba697-6524-4d0a-b0de-26c81a9e6f51.jpg" alt><br><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/9fb82a75-fe58-4cbb-b484-6e81b8ce6784.png" alt></p><p>主域名当前不会生效，curl 域名 -I  （-I 显示头部），访问second开头的域名，返回second开头的域名</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/28d97c9d-1dff-48c5-8da5-7ffe4c7bce25.jpg" alt></p><p>如果先返回是是主域名，就要将 off 改为 on，主域名开始生效。访问second开始的域名，发挥primary开头的主域名。</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/b8921fa4-75db-4574-a213-1614397578e8.jpg" alt></p><p><strong>server_name指令其他用法</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/7150b181-f5f1-4210-8132-47aad432be28.jpg" alt></p><h2 id="Server匹配顺序"><a href="#Server匹配顺序" class="headerlink" title="Server匹配顺序"></a>Server匹配顺序</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/eb693887-6efd-474d-be89-0322bb142a96.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了当Nginx框架取到了Host头部值时，就可以用这个值与我们<strong>Server</strong>块下的<strong>Server_name</strong>指令进行匹配，然后利用其中定义的规则进行解析处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个&lt;strong&gt;server块&lt;/strong&gt;处理，因此，要先介绍一个配置指令 &lt;strong&gt;server_name&lt;/strong&gt;，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>21-Nginx中的正则表达式</title>
    <link href="http://javassun.github.io/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://javassun.github.io/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-12-09T15:34:53.000Z</published>
    <updated>2020-05-14T11:45:23.188Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到<strong>正则表达式</strong>，它可以让我们匹配到的功能更为强大。</p><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/0e4b9acc-6d13-4199-8470-93df39ce4d0b.jpg" alt></p><p><strong>举例：</strong><br><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7fb63cc5-8759-486f-8d6d-c533584d10e1.jpg" alt></p><p><strong>工具：pcretest</strong></p><p>输入模式，输入待校验数据，查看匹配结果，可验证正则书写是否正确。</p><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7b9755d2-be5c-4b01-b2c2-1c91929f9831.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到&lt;strong&gt;正则表达式&lt;/strong&gt;，它可以让我们匹配到的功能更为强大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>20-处理HTTP请求头部流程</title>
    <link href="http://javassun.github.io/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://javassun.github.io/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-09T11:34:53.000Z</published>
    <updated>2020-05-14T11:42:43.774Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 <strong>HTTP Line</strong>，如方法、URL等，再去接收到所有的<strong>Header</strong>，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。</p><a id="more"></a><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/6db1c81d-6992-4757-bdda-4bd8ea201a0c.jpg" alt></p><p>大致分为3个层次：<strong>操作系统内核</strong>、<strong>事件模块</strong>、<strong>HTTP模块</strong>，流程大致如下：</p><ul><li><p><strong>操作系统内核：3次握手，当用户发来SYN时，内核会回复一个SYN+ACK表示已确认，当客户端再发来ACK时，标明连接已成功建立，Nginx有很多Worker进程，都监听了80、443端口，操作系统会依据它的负载均衡算法，选中某一个Worker进程</strong></p></li><li><p><strong>被选中的Worker进程会通过 epoll_wait方法去返回刚刚建立好连接的句柄，拿到句柄后，这其实是一个读事件（读到了一个ACK报文），根据读事件，找到监听的80、443端口，可以调用accept方法，分配连接内存池，默认为 connection_pool_size 512字节</strong></p></li><li><p><strong>所有的HTTP模块开始从事件模块中接入请求，HTTP模块在启动时会定义一个ngx_http_init_connection回调方法，通过 epoll_ctl将读事件加入其中，同时设置超时定时器（client_header_timeout:60s）</strong></p></li><li><p><strong>当用户真的把一个HTTP请求（get、post）发来时，其实是DATA，在TCP层（内核层），会回复一个ACK，同时事件模块的epoll_wait又拿到这个请求，回调方法是 ngx_http_wait_request_handler，需要将内核中的DATA读到Nginx的用户态中，需要分配内存，从连接内存池分配1k(client_header_buffer_size),并不是越大越好，因为只要用户有1个字节发过来，就要为他分配1k大小内存，但是如果用户发来的DATA（URL、Header）超过1K了呢？</strong></p></li></ul><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/301c6d75-7166-4bd4-b44f-9e1e8470fae6.jpg" alt></p><h3 id="接收URI"><a href="#接收URI" class="headerlink" title="接收URI"></a>接收URI</h3><p>刚刚分配完1K后，已经收到了 小于等于1K的请求内容。</p><ul><li><p><strong>分配请求内存池：</strong>处理请求与处理连接不同，处理连接只需要将它收到Nginx内存中就OK了，但处理请求时，去做大量的上下文分析，分析它的HTTP协议、Header，因此要分配一个<strong>请求内存池</strong>，默认 request_pool_size:4k，基本上是<strong>connection_pool_size</strong>的8倍，因为请求的上下文涉及到业务，通常4K是一个比价合适的大小（如果分配过小，请求内存池需要不断地扩充，分配内存的次数变多时，肯定会影响性能），要不要改这个4K要根据业务来决定。</p></li><li><p><strong>状态机解析请求行：</strong>解析请求的行， /r /n之前的 方法名、URL、协议。解析过程中可能会发现URL特别大，超过了刚刚分配的1K内存。</p></li><li><p><strong>分配大内存：</strong>主要是来解决大URL的问题，分多大的呢？<strong>large_client_header_buffers:4 8k</strong>，分配的并不是32K 这么大的内存，而是先分配一个8K的内存，将刚刚1K内存中内容拷贝到这个8K内存中来，还剩7K的内存，用剩下的7K再去接收URL，然后用状态机去继续解析URL，如果发现7K都没有解析完，再次分配第二个8K，即一共分配了16K，最多分配32K。</p></li><li><p><strong>解析完成时，就可以标识URI</strong>，类似于超链接，Nginx用指针指向这个URI。</p></li></ul><h3 id="接收Header"><a href="#接收Header" class="headerlink" title="接收Header"></a>接收Header</h3><p>HTTP请求中的Header可能会非常长，如有Cookie、Host等字段。</p><ul><li><p><strong>状态机解析Header</strong>,Header非常有可能超过1K,又需要分配大内存。</p></li><li><p><strong>分配大内存</strong>与左边接收URI是共用的，如左边已用了2个8K，此处最多只能在分配2个8k。</p></li><li><p><strong>标识header</strong></p></li><li><p><strong>移除超时定时器</strong>，是在收到完整的Header后，才可移除。</p></li><li><p><strong>开始11个阶段的HTTP请求处理</strong></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上都是Nginx框架处理的，11个流程是HTTP模块处理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 &lt;strong&gt;HTTP Line&lt;/strong&gt;，如方法、URL等，再去接收到所有的&lt;strong&gt;Header&lt;/strong&gt;，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>19-Nginx中Listen指令用法</title>
    <link href="http://javassun.github.io/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/</id>
    <published>2019-12-08T12:34:53.000Z</published>
    <updated>2020-05-14T11:40:33.422Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一个请求进入Nginx开始处理之前，都首先需要<strong>监听端口</strong>，以使得Nginx与客户端建立起<strong>TCP连接</strong>，监听端口的指令为<strong>listen</strong>指令，它是放在<strong>server</strong>配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。</p><a id="more"></a><h2 id="Listen-指令"><a href="#Listen-指令" class="headerlink" title="Listen 指令"></a>Listen 指令</h2><p><img src="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/729d148b-a54e-49ff-a745-fd79853e3e8f.jpg" alt></p><ul><li><p><strong>lisent address[:port]</strong></p></li><li><p><strong>listen port</strong></p></li><li><p><strong>listen unix:path 只用于本机通讯</strong></p></li><li><p><strong>listen 127.0.0.1; 此处默认使用 80端口</strong></p></li></ul><p>详细的Listen用法在后续文章实践时再提及。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每一个请求进入Nginx开始处理之前，都首先需要&lt;strong&gt;监听端口&lt;/strong&gt;，以使得Nginx与客户端建立起&lt;strong&gt;TCP连接&lt;/strong&gt;，监听端口的指令为&lt;strong&gt;listen&lt;/strong&gt;指令，它是放在&lt;strong&gt;server&lt;/strong&gt;配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>18-Nginx冲突的配置指令以谁为准</title>
    <link href="http://javassun.github.io/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/"/>
    <id>http://javassun.github.io/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/</id>
    <published>2019-12-08T10:34:53.000Z</published>
    <updated>2020-05-14T11:38:28.549Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正式开始学习<strong>HTTP模块</strong>之前，先要谈一谈指令的<strong>嵌套结构</strong>，每一个HTTP模块出现的指令，可能出现的<strong>Context(上下文)</strong>，既可以在<strong>location</strong>中，也可以在<strong>server</strong>中，或是<strong>http</strong>中，当一个指令出现在多个<strong>配置块</strong>中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的<strong>第三方模块</strong>可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？</p><a id="more"></a><h2 id="典型的配置块嵌套"><a href="#典型的配置块嵌套" class="headerlink" title="典型的配置块嵌套"></a>典型的配置块嵌套</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/2d6e5c41-6a8b-4259-bf26-934c752a9249.jpg" alt></p><p>http–server–location 是<strong>HTTP框架来定义</strong>，处理一个请求时，先按照请求中的<strong>域名：如 host</strong>找到对应的<strong>server</strong>,再根据<strong>URL</strong>找到对应的<strong>location</strong>，根据location下具体的指令来处理请求。</p><h2 id="指令的-Context"><a href="#指令的-Context" class="headerlink" title="指令的 Context"></a>指令的 Context</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1b48fc0d-3015-4f35-b87c-6d2eb15f8be8.jpg" alt></p><ul><li><strong>log_format</strong>出现的上下文Context是在<strong>http</strong>中的，如果把它放在<strong>server</strong>、<strong>location</strong>时，启动nginx检查配置文件语法时，会失败，无法启动。</li><li><strong>access_log</strong> 同理。</li></ul><h2 id="指令的合并"><a href="#指令的合并" class="headerlink" title="指令的合并"></a>指令的合并</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/7edbb2e6-b36d-4b34-959d-7db4f481fd9b.jpg" alt></p><h2 id="存储值的指令继承规则：向上覆盖"><a href="#存储值的指令继承规则：向上覆盖" class="headerlink" title="存储值的指令继承规则：向上覆盖"></a>存储值的指令继承规则：向上覆盖</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/82868d03-da97-48c9-af03-557cf3a81ead.jpg" alt></p><ul><li><p><strong>listen指令只能出现在server上下文中</strong></p></li><li><p><strong>alias指令虽然可以出现在 http、server、location中，但是在上述图示中只在location中出现</strong></p></li><li><p><strong>server下的root /home/geek/nginx/html;而其他location中没有定义root，同样可以使用父配置块定义的root，如最下方的root。这是一个通用配置规则，只要该指令允许在子配置块中生效</strong></p></li><li><p><strong>在 location /test 下重新定义了一个 root /home/geek/nginx/test; 或者 access_log 也重新定义了，此时直接使用子配置覆盖父配置</strong></p></li></ul><h2 id="HTTP模块合并配置的实现"><a href="#HTTP模块合并配置的实现" class="headerlink" title="HTTP模块合并配置的实现"></a>HTTP模块合并配置的实现</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/d052eae4-743b-4529-90ba-69e184b87f48.jpg" alt></p><p>举一个例子 <strong>ngx_http_referer_module</strong>防盗链模块，它们都有一个结构体是 <strong>ngx_module_t</strong>，相当于说明书。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/5c0f1a1b-ac60-4725-92e0-cc4f19839d32.jpg" alt></p><p>该模块提供的配置指令，都在 *<em>ngx_command_t &nbsp; &nbsp;ngx_http_referer_commands[] *</em>中提及。<br><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/658fa363-3808-499a-b04d-f78aa16ec8e1.jpg" alt></p><p>如 <strong>valid|referers</strong> 指令可以出现在 server、location下，可以携带1MORE（1个或多个）参数。</p><p>所有指令解析完要做合并，可以看 <strong>ngx_http_module_t</strong> 结构体。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1afde405-4fb7-4e72-963f-45ce63bfe249.jpg" alt></p><p>它定义了 8个回调方法，重点看 <strong>ngx_http_referer_merge_conf</strong>，以上指令都是在location下生效的，所以需要 http、server向location合并。</p><p><strong>合并规则</strong></p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/aa4e4b16-319b-434f-9a0b-dc098312b979.jpg" alt></p><p>parent：父指令<br>child： 子指令</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了HTTP模块指令合并规则，为下面正式学习HTTP每一个模块提供了技术帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正式开始学习&lt;strong&gt;HTTP模块&lt;/strong&gt;之前，先要谈一谈指令的&lt;strong&gt;嵌套结构&lt;/strong&gt;，每一个HTTP模块出现的指令，可能出现的&lt;strong&gt;Context(上下文)&lt;/strong&gt;，既可以在&lt;strong&gt;location&lt;/strong&gt;中，也可以在&lt;strong&gt;server&lt;/strong&gt;中，或是&lt;strong&gt;http&lt;/strong&gt;中，当一个指令出现在多个&lt;strong&gt;配置块&lt;/strong&gt;中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的&lt;strong&gt;第三方模块&lt;/strong&gt;可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>17-Nginx动态模块</title>
    <link href="http://javassun.github.io/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/</id>
    <published>2019-12-07T10:34:53.000Z</published>
    <updated>2020-05-14T11:36:27.663Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>动态模块</strong>可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。</p><h2 id="动态模块-减少编译环节"><a href="#动态模块-减少编译环节" class="headerlink" title="动态模块-减少编译环节"></a>动态模块-减少编译环节</h2><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg" alt></p><a id="more"></a><p>左上图 是没有使用动态模块的编译方式及结果。</p><p>左下图 是使用了动态模块的编译及结果（生成了<strong>指定模块的动态库</strong>）。</p><p><font color="red">动态库</font>与<font color="red">静态库</font>区别：静态库会将所有的源代码编译进最终的二进制可执行文件中；动态库在Nginx二进制可执行文件中只保留了<strong>调用它的地址</strong>，在需要用到动态库的功能时，由<strong>Nginx的二进制可执行文件（Nginx Executable）</strong>去调用这个动态库，再去完成对应的功能。好处：当我们仅仅需要修改某一个模块、升级某个模块的功能时（特别是当Nginx编译了大量的第三方模块），重新编译这个动态库，而不用替换二进制可执行文件，编译出新的动态库后，只需要替换出旧的动态库，让 Nginx reload即可使用新的模块功能。</p><p><strong>具体步骤：上右图6步骤</strong></p><p>工作流程：</p><ul><li><p><strong>Configure加入动态模块</strong>：只有<strong>部分模块</strong>可以以动态模块的身份编译</p></li><li><p><strong>执行make，编译出 binary</strong></p></li><li><p><strong>启动时会去读 ngx_modules[] 数组，在模块数组中会发现使用了某个动态模块</strong></p></li><li><p><strong>在nginx.conf中需要加入一个配置项 load_modules，这个配置项指明了这个动态模块所在的路径</strong></p></li><li><p><strong>接下来就可以在Nginx进程中打开动态库并上面的模块加入模块数组中</strong>。</p></li><li><p><strong>基于模块数组再进行初始化过程</strong>。</p></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>查看可以增加哪些动态模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br><span class="line"></span><br><span class="line">后面带有 dynamic 关键字的即为可以动态模块身份编译的</span><br><span class="line">--with-xx-xx-module&#x3D;dynamic</span><br></pre></td></tr></table></figure><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/13afd584-3542-46c9-ad01-e852d8644ff3.png" alt></p><p>以<strong>–with-http-image_filter_module=dynamic</strong> 为例来进行演示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">如果出现 下列信息</span><br><span class="line">.&#x2F;configure: error: the HTTP image filter module requires the GD library.</span><br><span class="line">You can either do not enable the module or install the libraries.</span><br><span class="line"></span><br><span class="line">按照下面这个命令安装依赖库</span><br><span class="line">yum install gd-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次运行编译</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们打开了 8080端口，把一些文件放在了test文件下</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/03066fd1-e17b-4cda-b8fe-90713600cc0d.png" alt></p><p>在test文件夹下，我们存放了一张图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/1786e7f3-3033-4e31-9792-d402fec8b880.png" alt></p><p>用浏览器访问该图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e63ab0bf-c704-4dc9-bc3a-583f3f3f7126.jpg" alt></p><p><strong>而上述动态模块的功能则是可以实时的把图片压缩成更小的图片</strong></p><p>安装好的目录中多了一个 <strong>modules</strong>目录，在这个目录中多出了一个动态库，Linux中所有的动态库是以 .so结尾，静态库是以 .a 结尾的。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/5f9d8e7e-ed30-48db-9bf1-8800ecef0f50.png" alt></p><p>打开nginx配置文件，调用 load_module 这个配置项，将相对路径放在此处。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e1e82aa5-e27d-4576-b1b6-adf007925733.png" alt></p><p>同时将图片放缩</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/328f5eca-3b8c-4fe5-8995-a16cc8f6c49a.png" alt></p><p>图片没有放缩，是因为浏览器缓存了这张图片，按F12，禁用缓存，再次刷新就可以了。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/a836cbf8-ddc3-412e-bc6a-43ef0000240a.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;动态模块&lt;/strong&gt;可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。&lt;/p&gt;
&lt;h2 id=&quot;动态模块-减少编译环节&quot;&gt;&lt;a href=&quot;#动态模块-减少编译环节&quot; class=&quot;headerlink&quot; title=&quot;动态模块-减少编译环节&quot;&gt;&lt;/a&gt;动态模块-减少编译环节&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>16-Nginx容器</title>
    <link href="http://javassun.github.io/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/"/>
    <id>http://javassun.github.io/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/</id>
    <published>2019-12-06T12:13:29.000Z</published>
    <updated>2020-05-14T11:34:25.855Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。</p><h2 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h2><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg" alt></p><a id="more"></a><h3 id="Nginx哈希表"><a href="#Nginx哈希表" class="headerlink" title="Nginx哈希表"></a>Nginx哈希表</h3><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/deb747db-853d-49bc-98b9-34edffd68808.jpg" alt></p><h4 id="哈希表配置"><a href="#哈希表配置" class="headerlink" title="哈希表配置"></a>哈希表配置</h4><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/42459f32-e90c-4688-a0b9-aad76a907fd1.jpg" alt></p><p>与常见的哈希表不同的是：</p><ul><li><strong>应用场景不同</strong>。用于<strong>静态不变的内容</strong>，即在运行过程中，哈希表通常不会出现插入、删除等操作，Nginx刚启动时就基本确定这个Hash表中一共有多少个元素。因此使用Hash表这种数据结构的模块通常会暴露出 <strong>max_size</strong> 与 <strong>bucket size</strong>。max size仅仅控制了最大的哈希表 bucket的个数，而不是实际上 bucket的个数，它的意义在于限制最大化使用内存。</li></ul><p>如上图所示，所有使用哈希表的模块有一些特点。stream/http中所有的变量使用了哈希表，因为变量在模块编译进去的时候就已经定义清楚了。还有 map、反向代理等。反向代理中需要对在配置文件中定义好的Header做哈希来提升它的访问性能。哈希表在访问的时候是一个O(1)的复杂度。</p><p>哈希表中有一个称之为 <strong>Bucket size</strong>，在这个里面会有一些默认值，这些默认值在Nginx的配置文档中说会使CPU Cache len 对齐到这样一个值。这实际上影响了怎样去配置 Bucket size，现在的主流CPU会有 L1、L2、L3缓存，它在取主存（内存）上的数据时，并不是按照所想像的那样，按照64位、32位去取。现在主流CPU去主存，一次取得的字节数是就是 CPU Cache len 。如现在是 64 字节。</p><p>为什么Hash表要向64字节对齐呢？</p><p>假设每一个Hash表的 Bucket是59字节，如果紧密排列在一起，取第一个Hash表元素，仅需要访问一次，还多取了一个自己。取第二个时，要访问主存两次，包括第一个64字节中的最后一个字节以及第二个单元中的58个字节。为了避免取两次的问题，Nginx在它的代码中自动向上对齐。在配置Bucket size时，要注意两个问题。</p><ul><li><p><strong>1 如果配置的不是CPU Cache Len，如配置了70字节，他就会向上分配，每个元素分配128字节。</strong></p></li><li><p><strong>2 如果有可能，尽量不要超过64字节，以减少CPU访问每个Hash表的次数。</strong></p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>哈希表专注于为<strong>静态不变</strong>的内容服务。</li><li>Hash表的 Bucket size 需要考虑CPU Cache Len 对齐问题。</li></ol><h3 id="Nginx红黑树"><a href="#Nginx红黑树" class="headerlink" title="Nginx红黑树"></a>Nginx红黑树</h3><p>Nginx多个Worker进程间做进程间通讯时，经常在共享内存上使用红黑树来管理对象，实际上，在Nginx内存中也会大量使用红黑树。</p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/fc01b91e-4a3c-42a7-b2e8-37b11db20474.jpg" alt></p><p><strong>特点：n为节点数</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/88f836f9-ea9e-4adf-9bae-fe33c6d0d709.jpg" alt></p><p><strong>红黑树的使用模块</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/9388a073-697f-4253-b903-2d36628116b2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。&lt;/p&gt;
&lt;h2 id=&quot;Nginx容器&quot;&gt;&lt;a href=&quot;#Nginx容器&quot; class=&quot;headerlink&quot; title=&quot;Nginx容器&quot;&gt;&lt;/a&gt;Nginx容器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>15-Worker集成协同工作的关键</title>
    <link href="http://javassun.github.io/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/"/>
    <id>http://javassun.github.io/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/</id>
    <published>2019-12-06T10:13:29.000Z</published>
    <updated>2020-05-14T11:32:00.720Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。</p><h2 id="Nginx进程间通讯方式"><a href="#Nginx进程间通讯方式" class="headerlink" title="Nginx进程间通讯方式"></a>Nginx进程间通讯方式</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg" alt></p><a id="more"></a><ul><li><p><strong>信号</strong>：前文也提及过。</p></li><li><p><strong>共享内存</strong>：数据同步。所谓的共享内存也就是我们打开了一个内存空间，如10M，那么一整块0-10M内存，多个Worker之间可以同时访问它，包括读取、写入等操作。为了使用好这样一块共享内存，就会引出另外两个问题。</p></li></ul><blockquote><p><strong>第一个就是锁</strong>，多个Worker进程同时操作一块内存，一定会出现竞争关系，不得不加锁。早期是基于<strong>信号量</strong>的锁，信号量是Linux中比较久远的一种进程同步方式，会导致进程进入休眠状态，即发生了主动切换。而现在大都使用的是<strong>自旋锁</strong>，当锁的条件没有满足，会一直请求。如：这块内存被Worker1使用，Worker2需要去获取锁时，只要Worker1没有释放锁，Worker2会一直在不停地去请求这把锁。<strong>自旋锁</strong>要求所有的Nginx模块必须快速的使用共享内存，即快速取锁，快速释放锁。一旦出现有的第三方模块不遵守这样的规则，就可能导致死锁。</p></blockquote><blockquote><p>一整块共享内存通常是给许多对象同时使用的，如果在模块中手动的去编写、分配内存给到不同的对象，是非常繁琐的，此时引入了<strong>Slab内存管理器</strong>。</p></blockquote><h2 id="共享内存：跨worker进程通讯"><a href="#共享内存：跨worker进程通讯" class="headerlink" title="共享内存：跨worker进程通讯"></a>共享内存：跨worker进程通讯</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/456d7c90-48ea-4f21-9f96-6563bb043d8d.jpg" alt></p><p><strong>红黑树</strong> ：限速、流控场景。（插入、删除快）。</p><p><strong>单链表</strong>：将共享元素串起来。</p><p><strong>Ngx_http_lua_api</strong>：Openresty核心模块</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/685b875f-0c66-4a51-96b0-b1b4dd0626d0.jpg" alt></p><h2 id="共享内存工具-Slab管理器"><a href="#共享内存工具-Slab管理器" class="headerlink" title="共享内存工具-Slab管理器"></a>共享内存工具-Slab管理器</h2><p>上文谈到Nginx不同的Worker进程间需要共享信息时，只能通过共享内存。共享内存上可以使用链表、红黑树这样的数据结构，但每一个红黑树上有许多节点，每一个节点都需要分配内存去存放。怎样把一整块共享内存切割成小块给红黑树上的每个节点使用呢？</p><h3 id="Slab内存管理"><a href="#Slab内存管理" class="headerlink" title="Slab内存管理"></a>Slab内存管理</h3><p>详见 <strong>408 操作系统、计算机组成原理-内存管理与分配</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/edd2057b-fbb7-4724-a215-48c2d898ed15.jpg" alt></p><p><a href="http://tengine.taobao.org/document/ngx_slab_stat.html" target="_blank" rel="noopener">Tengine-Slab</a></p><p><strong>Tengine上 ngx_sla_stat:统计Slab使用状态</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/28245628-4a49-4dd0-a117-a51e6a8568ba.jpg" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/601995b6-b99a-4324-b88e-14106a22871c.png" alt></p><p>会发现没有Github地址，即没有作为一个独立模块发布出来，所以只能点击<strong>Download</strong>下载整个Tengine项目。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0f3a65a0-3276-4dd7-b396-7ea3c5338bdb.png" alt></p><p>解压后，发现tengine中多出一个modules目录，进去查看</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/eed3a379-a7f8-4379-9982-16f2b6dcc0f5.png" alt></p><p>在最后发现 <strong>ngx_slab_stat</strong>模块。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/79bcae21-d7f4-4314-ae50-33d8b9762854.png" alt></p><p>这是一个标准的第三方模块。.c文件是它的说明书。config帮助他编译进目标nginx中。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>现在回到<strong>Openresty</strong>中，让Openresty编译时将<strong>Tengine的Slab_Stat模块</strong>编译进去，然后使用Openrety下的 <strong>share_dict</strong>去分配共享内存，再用<strong>slab_state</strong>查看共享内存的使用情况。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/262f2390-9a34-4537-bf05-74dad3bb3775.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --add-module&#x3D;..&#x2F;tengine-2.3.2&#x2F;modules&#x2F;ngx_slab_stat&#x2F;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0cf928f7-a528-4746-8894-5c1d923feab3.png" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/5b4305a1-3c01-4a02-a48b-2253016dc8de.png" alt></p><p><strong>set、get、slab_stat 得到信息</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/a8f4040f-2d4e-4b38-8d11-d882abc30425.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。&lt;/p&gt;
&lt;h2 id=&quot;Nginx进程间通讯方式&quot;&gt;&lt;a href=&quot;#Nginx进程间通讯方式&quot; class=&quot;headerlink&quot; title=&quot;Nginx进程间通讯方式&quot;&gt;&lt;/a&gt;Nginx进程间通讯方式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>14-Nginx连接池处理网络请求-内存池对性能的影响</title>
    <link href="http://javassun.github.io/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://javassun.github.io/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</id>
    <published>2019-12-05T10:13:29.000Z</published>
    <updated>2020-05-14T11:29:48.736Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？</p><p>Nginx使用了<strong>连接池</strong>来增加它对资源的利用率。</p><h2 id="Nginx通过连接池处理网络请求"><a href="#Nginx通过连接池处理网络请求" class="headerlink" title="Nginx通过连接池处理网络请求"></a>Nginx通过连接池处理网络请求</h2><p><strong>连接池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg" alt></p><a id="more"></a><p>右边图中每一个Worker进程中都有一个独立的数据结构：<strong>ngx_cycle_t</strong>。其中有三个中重要的数据。</p><ul><li><strong>connection数组</strong>：即连接池，他指向的数组有多大呢？其实是有一个配置项可以查看的。512大小的数组。</li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/85000415-fd2a-4026-a7c7-58328179c6f3.jpg" alt></p><ul><li><strong>read_event数组</strong>：数组大小与上述配置一致。</li><li><strong>write_event数组</strong>：同上。</li></ul><p>三者通过序号对应，5号连接自然对应5号读写事件。</p><p><strong>核心数据结构</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c5ba5443-c176-4ef7-b010-486eebe81312.jpg" alt></p><p>一般是 235 + 96*2   （乘2是因为读写两个分配）。</p><p>rb_tree_node_t 红黑树中每个节点指向的 timer，标志读写事件是否超时。</p><p>定时器也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/59848113-bab2-42fa-ae47-d22a8a33595e.jpg" alt></p><p>ngx_queue_t 事件进队列。</p><p>右边的 <strong>off_t</strong> 可以理解为一个无符号的变量，即已经向客户端发送了多少字节。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/9c81e155-3996-4a06-9890-5d00a60de797.jpg" alt></p><p>这个也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/b0b1dcdf-5169-45e1-a438-1c24df64e78c.jpg" alt></p><p>在access.log中可以看到上述配置生效。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c86ece93-3a3a-444d-bcb7-ae03da2b5c3d.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是 ngx_connection_t 与 ngx_event的配置。即连接与事件是怎样对应在一起的。当我们需要配置高并发的nginx时，需要将connection的数目配置的足够大。每一个connection对应的两个event（读写）都会消耗一定的内存。Nginx结构体中的许多成员与内置变量是可以对应做配置的。</p><h2 id="Nginx内存池对性能的影响"><a href="#Nginx内存池对性能的影响" class="headerlink" title="Nginx内存池对性能的影响"></a>Nginx内存池对性能的影响</h2><p>如果开发过第三方模块，会发现虽然在写C语言代码，但我们不需要关心内存的释放。如果在配置一些比较罕见的Nginx使用场景，可能需要去修改Nginx在请求和连接上初始分配的内存池大小。Nginx官方通常推荐不需要修改有关配置。究竟要不要改呢？</p><p><strong>内存池运转方式</strong><br>在上面的 <font color="red">核心数据结构</font>中，发现ngx_connection_s结构体中有一个<strong>ngx_pool_t</strong> 结构。它对应着当前连接所使用的内存池，可以通过 connection_pool_size去定义。</p><p><strong>内存池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/3e50c6d2-f117-49df-bc57-79dc8df8c829.jpg" alt></p><ul><li><p><strong>连接内存池</strong>上只分配一次，只要连接不关闭，分配的内存永远不需要释放，只有当关闭连接时才会释放。</p></li><li><p><strong>请求内存池</strong>：每一个HTTP请求开始分配时并不知道分配多少合适，但对于HTTP1.1 通常分配 4k大小（URL、Header往往需要这么多）。如果没有内存池，可能需要频繁而小块的分配，可能会造成内存碎片过多这样的代价。</p></li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/759a1245-2d83-43a9-b133-553b16c11061.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/1e0b5619-0a02-44af-8fda-989c9671877e.jpg" alt></p><p>当分配的内存超过 256|521 这种预分配大小时，还是可以继续分配的，这里只是提前分配空间，为了减少分配次数。</p><p>请求内存池大小</p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/93e8541a-d8a5-4616-a1ab-2a9f576d8855.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/304ff837-d46a-4e4a-86c3-68d0c54dde1e.jpg" alt></p><p>对于连接而言，他所需要的空间很小，只需要帮助后面的请求读取最初的一部分字节就ok了，而对于请求而言，要保存大量的上下文信息（URL、Header）等。如果URL过大，可以考虑修改这个配置项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？&lt;/p&gt;
&lt;p&gt;Nginx使用了&lt;strong&gt;连接池&lt;/strong&gt;来增加它对资源的利用率。&lt;/p&gt;
&lt;h2 id=&quot;Nginx通过连接池处理网络请求&quot;&gt;&lt;a href=&quot;#Nginx通过连接池处理网络请求&quot; class=&quot;headerlink&quot; title=&quot;Nginx通过连接池处理网络请求&quot;&gt;&lt;/a&gt;Nginx通过连接池处理网络请求&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;连接池&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>13-Nginx模块</title>
    <link href="http://javassun.github.io/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/</id>
    <published>2019-12-04T13:13:29.000Z</published>
    <updated>2020-05-14T11:27:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx之所以有如此多的特性，是因为有大量的第三方开发者在为它开发模块。Nginx之所以有这么丰富的生态圈，是因为它的模块设计十分优良。如TCP协议一样，从上个世纪70年代设计至今，没有做过大的变动。Nginx同样如此，从2004年发布后，没有发生过大的变化。</p><a id="more"></a><h2 id="Nginx模块就是什么？"><a href="#Nginx模块就是什么？" class="headerlink" title="Nginx模块就是什么？"></a>Nginx模块就是什么？</h2><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/4e23e191-595e-4e1c-a473-b1d92c0732e8.jpg" alt></p><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx开源文档</a>，如 gzip模块文档中，会有它的用法以及内置变量等。<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">Nginx-gzip</a></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f286212a-ebdb-4f32-899d-7d0c6b2173e2.png" alt></p><p>有的第三方模块没有详细说明，可到 安装模块中查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;nginx&#x2F;nginx-1.16.0</span><br><span class="line"></span><br><span class="line">.&#x2F;configure</span><br><span class="line"></span><br><span class="line">之后会生成 objs文件夹</span><br><span class="line"></span><br><span class="line">cd objs</span><br><span class="line">vim ngx_module.c</span><br><span class="line"></span><br><span class="line">其中是ngx_modules数组，都是被加载进ngx中的模块</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/cf1f0e17-1b30-4c69-9839-ee34e6908b47.png" alt></p><p>如 gzip模块已经被加载进来，每一个模块在 *<em>/usr/local/geek/nginx/nginx-1.16.0/src/http/modules<br>*</em>中都会有对应的 .c文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http_gzip_filter_module.c</span><br></pre></td></tr></table></figure><p>在每一个源文件中，都会由 ngx_command_t 这样一个唯一的结构体。</p><p>该结构体是一个数组，其中的元素是它所支持的指令名，参数名、参数类型等等参考文档。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/8925c799-45a5-4fc5-a28c-4d947eaf2c5a.png" alt></p><p><strong>Nginx模块</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/92a824bb-768f-4e0a-94d0-127e5091f5e4.jpg" alt></p><h2 id="Nginx模块的分类"><a href="#Nginx模块的分类" class="headerlink" title="Nginx模块的分类"></a>Nginx模块的分类</h2><p>针对不同的应用场景，Nginx会细分为不同的子模块。在特定的复杂的应用场景下，这些子模块会增加许多新的特性和功能。</p><p><strong>Nginx模块分类</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/10ed37f5-43f0-43dd-a089-416575abc55b.jpg" alt></p><p><strong>/usr/local/geek/nginx/nginx-1.16.0/src目录下</strong></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/fcfe9d98-d06e-44e7-a821-85cfc3d17eef.png" alt></p><p><strong>core目录</strong>：仅仅是Nginx的核心框架代码，并不是Nginx的 Core Module。</p><p><strong>event、http、mail、stream</strong>则是对应的子类型模块。</p><p>以最复杂的<strong>http</strong>为例</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/6003a348-cd71-423c-b7e7-ed9cf983e0f1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http.c</span><br><span class="line"></span><br><span class="line">&#x2F;ngx_module_t </span><br><span class="line">可以看到类型type是 ngx_core_module</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f23c4bbb-17b5-470e-b0ab-e81187cd3ee0.png" alt></p><p>官方提供的都是在上述目录下，非官方提供的在 modules目录下。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/7f92c21d-6a1b-4770-874e-672773ea4d9b.png" alt></p><p>上述模块大概分为 3 类：</p><p>处理请求、生成响应 + 响应过滤 + 与上游服务器交互（负载均衡等工作）</p><p>响应过滤的名称有<strong>filter</strong>关键字。</p><p>与上游服务器交互的有<strong>upstream</strong>关键字。</p><p>其它模块都是生成响应或为生成响应而工作的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx之所以有如此多的特性，是因为有大量的第三方开发者在为它开发模块。Nginx之所以有这么丰富的生态圈，是因为它的模块设计十分优良。如TCP协议一样，从上个世纪70年代设计至今，没有做过大的变动。Nginx同样如此，从2004年发布后，没有发生过大的变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>12-网络收发与Nginx事件模型</title>
    <link href="http://javassun.github.io/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://javassun.github.io/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-12-03T12:13:29.000Z</published>
    <updated>2020-05-14T11:27:36.110Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个<strong>事件驱动</strong>的框架。事件主要指的是<strong>网络事件</strong>。Nginx每个连接会自然对应两个网络事件，<strong>读事件</strong> 与 <strong>写事件</strong>。因此，我们在深入了解Nginx的各种原理以及它在极端场景下的各种错误处理时，必须首先理解什么是网络事件。</p><a id="more"></a><h2 id="网络收发"><a href="#网络收发" class="headerlink" title="网络收发"></a>网络收发</h2><p><strong>网络传输</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/bd0ed4ad-9ab4-4f02-b787-cd11c0157c85.jpg" alt></p><p><strong>TCP流与报文</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/7f4caf3e-3802-450c-958a-7cce48864829.jpg" alt></p><p><strong>TCP协议与非阻塞接口</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/04d4fa8e-bcb4-42d2-bd74-5901fab6af91.jpg" alt></p><h2 id="Nginx网络事件实例演示"><a href="#Nginx网络事件实例演示" class="headerlink" title="Nginx网络事件实例演示"></a>Nginx网络事件实例演示</h2><p>访问 116.62.160.193:8080 这是一个之前搭建的Nginx-Web静态资源服务器.</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/e446f920-ae60-4cc9-9698-02daad34ba0f.jpg" alt></p><p>同时要安装 Wireshark网络抓包器。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/ba356c5e-97af-4987-9957-452919556294.jpg" alt></p><p>TCP三次握手时会发送 <strong>SYN、SYN+ACK、ACK包</strong></p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/1442eeeb-7de3-4a6e-a140-b30a86df688d.jpg" alt></p><p><strong>TCP</strong>层主要是做进程与进程间的通讯，本地打开1875端口，远程是8080端口</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/597d3231-48b6-4424-8a89-a25bfad8fbe2.jpg" alt></p><p><strong>IP层</strong>主要解决机器之间互相找到的问题。本地IP是 192.168.74.142，远端Nginx所在IP是 116.62.160.193</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/78f77e0d-0a29-479f-b894-5d946f30d640.jpg" alt></p><h2 id="Nginx事件驱动模型"><a href="#Nginx事件驱动模型" class="headerlink" title="Nginx事件驱动模型"></a>Nginx事件驱动模型</h2><p>在了解了网络事件以及事件分发、收集器后，再来学习Nginx是如何处理事件的。</p><p><strong>Nginx事件循环</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/875ec507-3b0b-462b-891e-6045caf65664.jpg" alt></p><p>流程：<br>当Nginx刚刚启动时，处于 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态，即我们打开了80、443端口后，等待新的事件进来（如新的客户端连上了Nginx,向我们发起了连接）。这一步对应着 epoll中的 epoll_wait方法。Nginx是处于<strong>Sleep</strong>进程状态。</p><p>当操作系统收到了一个建立连接的TCP握手报文并处理完成后，操作系统就会通知epoll_wait阻塞方法，告之可以往下走了（找操作系统要事件），并且唤醒我们的Nginx-Worker进程。</p><p>Kernel 即操作系统内核会将事件放入到事件队列中。从事件队列中，Nginx可以获取到要处理事件，如 建立连接、TCP请求报文等。取出来后就会处理对应的事件，进入 <strong>PROCESS THE EVENTS QUEUE CIRCLE</strong>，即右边的图。</p><p>队列不为空，就将事件取出来进行处理。在处理事件的过程中可能会生成一些新的事件（如：新连接建立，要设置一个超时时间，超时时间后，浏览器不向我发送新的请求，我就关闭它。又比如：当收完完整的HTTP请求后，可以进行HTTP响应了，这个响应是需要我可以向操作系统的写缓存区中把响应写进来的，要求操作系统尽快把这样一段写的内容发回给浏览器，即期待一个写事件等等）。</p><p>所有的事件处理完成后，又会返回到 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态。</p><p><strong>知道上述流程的好处：</strong><br>一些第三方模块可能会做大量的CPU运算，此类计算任务会导致我处理一个事件的时间非常长，在上述流程图中会导致后续队列中的大量事件长时间得不到处理。从而引发恶性循环，他们的超时时间可能到了，CPU都消耗到处理连接不正常的断开。</p><p>有些第三方模块长时间的消耗大量CPU进行计算任务，这是Nginx不能容忍的。gzip等模块不会一次使用大量的CPU，而是分段使用。</p><h2 id="epoll的优势及原理"><a href="#epoll的优势及原理" class="headerlink" title="epoll的优势及原理"></a>epoll的优势及原理</h2><p>上面讨论到了Nginx事件分发机制，最关键的就是Nginx怎样快速的从操作系统的Kernel中获取到等待处理的事件。这一步经历了很长时间的解决。当下Nginx主要是使用epoll网络事件收集器模型。</p><p><strong>各个模型性能对比</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/b1948077-bc41-410e-ad9a-78281102880f.jpg" alt></p><p><strong>epoll</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/9ee0a593-037f-4c48-b96a-6e1583f5bd92.jpg" alt></p><h2 id="Nginx请求切换场景使用epoll带来的争议"><a href="#Nginx请求切换场景使用epoll带来的争议" class="headerlink" title="Nginx请求切换场景使用epoll带来的争议"></a>Nginx请求切换场景使用epoll带来的争议</h2><p><strong>请求切换</strong></p><p>传统服务依赖OS，处理大量连接时很困难。<br>Nginx用户态即可完成切换。除非Nginx-Worker时间片到了（5ms-800ms），才会依赖OS切换，因此往往将Nginx-Worker优先级加到最高（-19），操作系统分配的时间片往往是最大的。这样能比较好的在用户态完成进程切换，使得CPU少做无用功。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/f88e575b-fd29-4890-90ad-9a1e9a33f41c.jpg" alt></p><h2 id="同步-amp-异步-阻塞-amp-非阻塞之间的区别"><a href="#同步-amp-异步-阻塞-amp-非阻塞之间的区别" class="headerlink" title="同步&amp;异步 阻塞&amp;非阻塞之间的区别"></a>同步&amp;异步 阻塞&amp;非阻塞之间的区别</h2><p>同步是两个对象之间的关系，而阻塞是一个对象的状态。</p><p>阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</p><p><strong>阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/52aa1fc5-cf86-4aff-9cb5-aa70a6c11518.jpg" alt></p><p><strong>非阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/4f1b1ce6-f00d-4303-83f4-c54520ef08e2.jpg" alt></p><p><strong>非阻塞调用下的同步与异步</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/03334dfa-1e2a-4510-955a-08cd8528e1c8.jpg" alt></p><p><strong>四种组合方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步阻塞方式： </span><br><span class="line">发送方发送请求之后一直等待响应。 </span><br><span class="line">接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步非阻塞方式： </span><br><span class="line">发送方发送请求之后，一直等待响应。</span><br><span class="line">接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。 </span><br><span class="line">但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步阻塞方式：</span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。</span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步非阻塞方式： </span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。 </span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 </span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是一个&lt;strong&gt;事件驱动&lt;/strong&gt;的框架。事件主要指的是&lt;strong&gt;网络事件&lt;/strong&gt;。Nginx每个连接会自然对应两个网络事件，&lt;strong&gt;读事件&lt;/strong&gt; 与 &lt;strong&gt;写事件&lt;/strong&gt;。因此，我们在深入了解Nginx的各种原理以及它在极端场景下的各种错误处理时，必须首先理解什么是网络事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>11-Nginx架构_相关流程</title>
    <link href="http://javassun.github.io/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"/>
    <id>http://javassun.github.io/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-02T11:13:29.000Z</published>
    <updated>2020-05-14T11:59:46.247Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>为什么要讨论Nginx的架构技术呢？</strong></p><p>因为Nginx运行在企业内网的最外层-边缘节点，它处理的流量是其他应用服务器的几个数量级。任何一种问题在不同的场景下解决方式不尽相同。因此，Nginx处理问题时的难度会被放大，我们有必要熟知:</p><p><font color="red">为什么Nginx采用<strong>Master-Worker</strong>这样一种架构模型</font><br><font color="red">为什么Worker进程的数量要与CPU的核数相匹配</font><br><font color="red">在多个Worker之间共享数据时，为什么在TLS或者限流、限速场景下的共享方式是有所不同的。</font></p><p>这些都需要我们对Nginx架构有一个清晰的了解。</p><a id="more"></a><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/bd9bd159-e718-4206-9d7e-1e9a460c9bcb.jpg" alt></p><p>网络大致有三种流量 Web、Email、TCP 。</p><p>三种状态机：处理Tcp/Ip的第四层状态机、HTTP应用层状态机、mail邮件状态机。为什么需要状态机呢？因为Nginx中是使用 <strong>非阻塞的事件驱动处理引擎</strong>来工作的，即<strong>Epoll</strong>，当使用异步时，通常需要用状态机将请求正确的识别处理。</p><h2 id="Nginx进程结构"><a href="#Nginx进程结构" class="headerlink" title="Nginx进程结构"></a>Nginx进程结构</h2><h3 id="1-单进程结构"><a href="#1-单进程结构" class="headerlink" title="1 单进程结构"></a>1 单进程结构</h3><p>不适用于生产环境，只适合做开发、调试。<br>生产环境要保持Nginx足够健壮，同时发挥Nginx可利用多核的特性。</p><p><font color="red">默认配置都是打开多进程Nginx</font></p><h3 id="2-多进程结构"><a href="#2-多进程结构" class="headerlink" title="2 多进程结构"></a>2 多进程结构</h3><p><strong>为什么是多进程而不是多线程呢？</strong></p><p>Nginx要保证它的高可用性、高可靠性。当Nginx使用多线程结构时，因为线程间是共享同一个地址空间的，当某一个第三方模块引发了地址空间的越界时，会导致整个nginx进程挂掉。多进程结构则不会出现上述问题。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/d2ec02bd-fac8-40f1-9343-b1f7a8d4aa25.jpg" alt></p><p>Nginx在做进程设计时，同样遵循了高可用、高可靠原则。</p><p><strong>在Master进程中</strong>，通常第三方模块是不会在这里加入自己的功能代码的。<br>虽然Nginx在设计时，允许第三方模块在Master进程中，添加自己独有的自定义的一些方法，但是第三方模块通常不会这么做。</p><p><strong>Master进程</strong>是被设计用来做 <strong>Worker进程</strong>的管理的。</p><p><strong>Worker进程</strong>是真正处理请求的，而Master进程是负责监控每个Worker进程是否正常工作、需不需要重新载入配置文件、热部署等。</p><p><strong>缓存</strong>是在多个Worker进程间共享，而且还要被 <strong>Cache Manager/loader进程</strong>使用。</p><p><strong>Cache Manager/loader进程</strong>是为反向代理时后端发过来的动态请求做缓存负责的。Manager负责缓存的管理。 Loader负责缓存的载入。</p><p>实际上每一个请求处理时用到的缓存还是由Worker进程响应的。</p><p>进程间的通讯都是使用共享内存解决。</p><p><strong>为什么worker进程很多呢？</strong></p><p>Nginx采用事件驱动模型后，希望每一个Worker进程从头到尾占有一颗CPU，因此，通常不仅要把Worker进程数量与服务器上的CPU核数一致，还要把每一个Worker进程与它对应的CPU绑定在一起。可以更好地使用每颗CPU核上对应的CPU缓存来减少缓存失效的命中率。</p><h3 id="3-多进程结构实例演示"><a href="#3-多进程结构实例演示" class="headerlink" title="3 多进程结构实例演示"></a>3 多进程结构实例演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进入 openstry的安装目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx</span><br><span class="line"></span><br><span class="line">vim config&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">修改 从1 到2（此处只为演示）</span><br><span class="line">worker_process 2</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line">sbin&#x2F;nginx -c config&#x2F;nginx.conf</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h4 id="1-首次查看"><a href="#1-首次查看" class="headerlink" title="1 首次查看"></a>1 首次查看</h4><p>第一次：1个master(12906) + 2个worker(父进程是12906，即master进程)</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9ccf4f35-8fe8-4f1d-b7a7-fa4181171712.png" alt></p><p>现在使用 -s reload 会将之前的 worker + cache进程 优雅的退出，重载新的配置项，新起新的 worker 与  cache进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbin&#x2F;nginx -s reload</span><br><span class="line"></span><br><span class="line">worker 进程号与上述已经不同，证明是新起的worker进程，同时他们的父进程ID 依然是 12906</span><br></pre></td></tr></table></figure><h4 id="2-reload后查看"><a href="#2-reload后查看" class="headerlink" title="2 reload后查看"></a>2 reload后查看</h4><p>第二次：master不变，worker 新起<br><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/7bc1fe02-d57d-4ea4-87b5-476b8721fd82.png" alt></p><h4 id="3-发送hup信号查看"><a href="#3-发送hup信号查看" class="headerlink" title="3 发送hup信号查看"></a>3 发送hup信号查看</h4><p>第三次： reload 与 hup的作用相同,现在向 12906的 master进程发送 hup信号，结果依然相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGHUP 12906</span><br></pre></td></tr></table></figure><p>master进程依然没有变，worker进程是新起的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/fe405a29-14c4-4e24-acd4-27bd1e762a4b.png" alt></p><h4 id="4-quit、stop信号查看"><a href="#4-quit、stop信号查看" class="headerlink" title="4 quit、stop信号查看"></a>4 quit、stop信号查看</h4><p>第四次：向一个 worker进程发送 quit信号，该worker进程再退出的同时，会自动的向他的父进程 12906 发送一个CHLD退出信号，master进程收到信号后，会新起一个worker进程，维持worker进程的进程结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigterm 退出信号</span><br><span class="line"></span><br><span class="line">kill -SIGTERM 13041</span><br></pre></td></tr></table></figure><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/0d2af2bd-d80e-4343-a21e-fba21550e359.png" alt></p><p>因此，<strong>命令行中的需多子命令，就是向Master进程发送信号而已。</strong></p><h3 id="4-进程模型"><a href="#4-进程模型" class="headerlink" title="4 进程模型"></a>4 进程模型</h3><p><strong>进程</strong></p><p>master、worker、cache manager、cache loader</p><p><strong>通讯方式</strong></p><p>信号：TERM、INT、QUIT、HUP、USR1、USR2、WINCH</p><p>共享内存：slab内存管理、互斥锁</p><h3 id="5-信号管理Nginx父子进程"><a href="#5-信号管理Nginx父子进程" class="headerlink" title="5 信号管理Nginx父子进程"></a>5 信号管理Nginx父子进程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/442e24b0-cc0b-48df-ab6a-169534de3cfd.jpg" alt></p><p><strong>Master进程</strong></p><ul><li><p><strong>CHLD</strong>：当worker进程因为某些bug而停止工作时，它在退出时会向Master进程发送 CHLD信号，Master进程可以立刻通过 CHLD信号发现问题，重新拉起一个Worker进程。</p></li><li><p><strong>TERM，INT</strong>：立刻停止Nginx进程</p></li><li><p><strong>QUIT</strong>：优雅的停止Nginx进程</p></li><li><p><strong>HUP</strong>：重载配置文件</p></li><li><p><strong>USR1</strong>：重新打开日志文件，做日志文件的切割</p></li></ul><p>以上可以直接在 Nginx命令行 + 特定命令 向Master进程发送。</p><p>下面两个 只能通过 Linux中的  kill + 命令发送给Master进程，即先找到 Master的 PID，对 PID 发送信号。</p><ul><li><p><strong>USR2</strong>：热部署时使用</p></li><li><p><strong>WINCH</strong>：热部署时使用</p></li></ul><p><strong>Worker进程</strong></p><p>通常是不会直接对Worker进程发送相应的信号的，应该将信号发送给Master进程，由Master进程管控Worker进程。</p><p><strong>Nginx命令行</strong></p><p>当启动Nginx后，Nginx会将它的 PID 记录到 Nginx安装目录的 logs文件夹下的 Nginx.pid文件中，记录了 Master进程的PID，再次执行 nginx -s 时，Nginx命令行会读取 Nginx.pid，向Master进程所在的PID同样的去发送对应的信号。</p><p><font color="red">综上，命令行与发送信号本质是一致的</font></p><h2 id="reload重载配置文件流程"><a href="#reload重载配置文件流程" class="headerlink" title="reload重载配置文件流程"></a>reload重载配置文件流程</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当我们更改了 <strong>nginx.conf</strong> 配置文件后，再次启动时都会执行 <strong>-s reload</strong> 命令。</p><p><strong>好处：</strong>Nginx不停止服务，始终在处理新的请求，同时把Nginx的配置文件平滑的从旧的 nginx.conf 更新为新的 nginx.conf。</p><p>有时在执行完后，发现Nginx的 <strong>Worker进程</strong>变多了，这是因为老的 配置所运行的 Nginx-Worker进程长时间没有退出，当使用 stream做4层反向代理时可能会更多。</p><h3 id="reload流程"><a href="#reload流程" class="headerlink" title="reload流程"></a>reload流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b0a2b9a6-281b-4474-b39b-b7ca834ffa2f.jpg" alt></p><p>第3步：因为所有的子进程会继承父进程已经打开的端口。</p><p>第4-5步：是为了平滑过渡，先创建新的，在慢慢关闭老的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9b6e6e8a-d5f8-46ef-a03c-48344fe5c7ad.jpg" alt></p><p>当有些绿色的 老 worker进程因为一些bug，长时间不退出时，也只会影响已存在的连接，不会影响新的连接。如何处理这些异常存活的worker进程呢</p><p>Nginx新的版本中，提供了一个配置项，称为 worker shutdown timeout<br>，即超时时间；Master进程在启动 黄色的 新的 Worker进程时，会为老的绿色的Worker进程加上一个 定时器，超时后，将依然存在的老的Worker进程强制退出掉。</p><h2 id="热升级完整过程"><a href="#热升级完整过程" class="headerlink" title="热升级完整过程"></a>热升级完整过程</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在Nginx不停止服务的情况下，做版本的更新。但也会遇到新的问题，如：</p><ul><li><p>老的Worker进程一直退不掉。</p></li><li><p>新的Worker进程起来后出现了问题，考虑回滚等。</p></li><li><p>使用了新的Nginx.conf配置文件后，发现好多功能出现了错误，只能回滚等。</p></li></ul><h3 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/43851d55-23fc-4e2e-876d-4d13226725f8.jpg" alt></p><p><strong>第一步</strong>：<br>将旧的 binary文件替换为新的 binary文件。之所以只替换binary文件，是因为在大部分场景下，我们新编译的Nginx文件所指定的配置选项（配置文件的目录在哪里，logs文件所在的目录在哪里），必须保持和老的Nginx是一致的，否则无法使用 nginx.conf文件。替换时要注意备份，同时，新版本的Linux中，要求覆盖一个正在使用的文件时，需要这样写命令<strong>cp -f</strong></p><p><strong>第二步</strong>：<br>向老的Master进程发送 USR2信号。此时我们是没有办法通过Nginx命令行直接用 <strong>nginx -s</strong>这个信号来处理，这是因为Nginx到目前为止还没有持这样的信号。</p><p><strong>第三步</strong>：<br>老的Master进程为了给新的Master让路，修改自己的pid文件名，以方便新的Master进程创建自己的PID文件。</p><p><strong>第四步</strong>：<br>新的Master进程起来后，会出现新老Master、老的Worker同时存在的情况。新的Master会去拉起新的Worker进程。</p><p><strong>第五步</strong>：</p><p>通过查看 .oldbin 或者 ps -ef|grep nginx 查看老的Master进程号，以便向他发送WINCH信号。老的Master会优雅关闭老Worker进程。热升级已经完成。<strong>但是老的Master进程会一直存在，方便回滚</strong>。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b1685e4b-8e80-4a2a-baa2-b9f977363671.jpg" alt></p><p>新的Master进程是 老的Master进程的子进程。新的使用了新的binary来载入的。新老并存时，老的会在处理完请求后，关闭自己监听的端口，优雅的退出。完成后，就只剩下新的Master+Worker进程。</p><h2 id="优雅关闭Worker进程"><a href="#优雅关闭Worker进程" class="headerlink" title="优雅关闭Worker进程"></a>优雅关闭Worker进程</h2><p><strong>nginx - stop</strong> : 立即停止Nginx。<br><strong>nginx - quit</strong> : 优雅关闭Nginx。<br>在上面的热部署、reload时都是优雅的停止Nginx，那他的过程如何呢？</p><p>优雅的关闭：即Nginx的worker进程可以识别出当前的连接没有正在处理请求，此时再次关闭它。能不能做到这一点呢？</p><p>对于有些请求，Nginx是做不到的。如：</p><ul><li><p>Nginx代理 <strong>Web Socket</strong>协议时，在Web Socket通讯的 Frame帧中，Nginx是不解析这个帧的是没有办法识别的。</p></li><li><p>Nginx做TCP、UDP层的反向代理时，是没有办法识别一个请求需要经历多少报文才算是结束。</p></li></ul><p>对于<font color="red"> <strong>HTTP</strong></font>请求是可以识别的。因此，优雅的关闭，主要针对HTTP请求。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/f4bde9ab-dc0d-4741-baa5-25d0fffe95c9.jpg" alt></p><p><strong>第一步</strong>：<br>设置完定时器后，会加一个标志位，表示现在进入优雅的关闭流程了。</p><p><strong>第二步</strong>：<br>保证所在的Worker进程不会再去处理新的连接。</p><p><strong>第三步</strong>：<br>查看Nginx的连接池，Nginx为了保证对资源的充分利用，经常会保持一些空闲连接不断开。此时会关闭所有的空闲连接。</p><p><strong>第四步</strong>：<br>用时可能会超过第一步 worker_shutdonw_timeout设置的时间。一旦超时，即使请求还没有处理完，依然会强制关闭连接。优雅的关闭只完成一半，有一部分是立即停止。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为什么要讨论Nginx的架构技术呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为Nginx运行在企业内网的最外层-边缘节点，它处理的流量是其他应用服务器的几个数量级。任何一种问题在不同的场景下解决方式不尽相同。因此，Nginx处理问题时的难度会被放大，我们有必要熟知:&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;为什么Nginx采用&lt;strong&gt;Master-Worker&lt;/strong&gt;这样一种架构模型&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;red&quot;&gt;为什么Worker进程的数量要与CPU的核数相匹配&lt;/font&gt;&lt;br&gt;&lt;font color=&quot;red&quot;&gt;在多个Worker之间共享数据时，为什么在TLS或者限流、限速场景下的共享方式是有所不同的。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这些都需要我们对Nginx架构有一个清晰的了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-28T10:30:10.000Z</published>
    <updated>2020-04-16T10:05:57.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)</p><p>从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。 <a id="more"></a>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说， 假设你插入的键的顺序为 1、2、3、4，后来再次插入 2，迭代时的顺序还是 1、2、 3、4，而不会因为后来插入的 2 变成 1、3、4、2。（但其实我们可以改变它的规则， 使它变成 1、3、4、2）</p><p>LinkedHashMap 的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希 表部分继承了 HashMap，拥有了 HashMap 那一套高效的操作，所以我们要看的就是 LinkedHashMap 中链表的部分，了解它是如何来维护有序性的。</p><p>LinkedHashMap 的大致实现如下图所示，当然链表和哈希表中相同的键值对都是指 向同一个对象，这里把它们分开来画只是为了呈现出比较清晰的结构。</p><p><img src="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/123e5c16-da83-4e2b-99ca-ac014847a73a.jpg" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>在看属性之前，我们先来看一下 LinkedHashMap 的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; imple ments Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>从上面的声明中，我们可以看见 LinkedHashMap 是继承自 HashMap 的，所以它已 经从 HashMap 那里继承了与哈希表相关的操作了，那么在 LinkedHashMap 中，它 可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedHashMap 的链表节点继承了 HashMap 的节点，而且每个节点都包含</span><br><span class="line">了前指针和后指针，所以这里可以看出它是一个双向链表</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尾指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认为 false。当为 true 时，表示链表中键值对的顺序与每个键的插入顺</span><br><span class="line">序一致，也就是说重复插入键，也会更新顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单来说，为 false 时，就是上面所指的 1、2、3、4 的情况；为 true 时，</span><br><span class="line">就是 1、3、4、2 的情况</span><br><span class="line"></span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><p>如果仔细看过 HashMap 源码的话，会发现 HashMap 中有如下三个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果没有注意到注释的解释的话，可能会很奇怪为什么会有三个空方法，而且 有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点 之后，进行一些处理，它们在 LinkedHashMap 都有各自的实现。LinkedHashMap 正 是通过重写这三个方法来保证链表的插入、删除的有序性。</p><h2 id="1-afterNodeAccess方法"><a href="#1-afterNodeAccess方法" class="headerlink" title="1 afterNodeAccess方法"></a>1 afterNodeAccess方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    &#x2F;&#x2F;当 accessOrder 的值为 true，且 e 不是尾节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思简洁明了，就是把当前节点 e 移至链表的尾部。因为使用的是双向 链表，所以在尾部插入可以以 O（1）的时间复杂度来完成。并且只有当accessOrder<br>设置为 true 时，才会执行这个操作。在 HashMap 的 putVal 方法中，就调用了这个 方法。</p><h2 id="2-afterNodeInsertion方法"><a href="#2-afterNodeInsertion方法" class="headerlink" title="2 afterNodeInsertion方法"></a>2 afterNodeInsertion方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remov e eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntr y(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterNodeInsertion 方法是在哈希表中插入了一个新节点时调用的，它会把链表的头 节点删除掉，删除的方式是通过调用 HashMap 的 removeNode 方法。想一想，通过 afterNodeInsertion 方法和 afterNodeAccess 方法，是不是就可以简单的实现一个基于 最近最少使用（LRU）的淘汰策略了？当然，我们还要重写 removeEldestEntry 方法， 因为它默认返回的是 false。</p><h2 id="3-afterNodeRemoval方法"><a href="#3-afterNodeRemoval方法" class="headerlink" title="3 afterNodeRemoval方法"></a>3 afterNodeRemoval方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.aft er;</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当 HashMap 删除一个键值对时调用的，它会把在 HashMap 中删除的那 个键值对一并从链表中删除，保证了哈希表和链表的一致性。 </p><h2 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4 get方法"></a>4 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，LinkedHashMap 的 get 方法就是这么简单，因为它调用的是 HashMap 的 getNode 方法来获取结果的。并且，如果你把 accessOrder 设置为 true，那么在获取到值之后，还会调用 afterNodeAccess 方法。这样是不是就能保证一个 LRU 的算法了.</p><h2 id="5-put和remove方法"><a href="#5-put和remove方法" class="headerlink" title="5 put和remove方法"></a>5 put和remove方法</h2><p>在 LinkedHashMap 的源码中没有找到 put 方法，这就说明了它并没有重写 put 方 法，所以我们调用的 put 方法其实是 HashMap 的 put 方法。因为 HashMap 的 put 方 法中调用了 afterNodeAccess 方法和 afterNodeInsertion 方法，已经足够保证链表的有 序性了，所以它也就没有重写 put 方法了。remove 方法也是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;源码中的一段注释，提取关键信息&lt;br&gt;Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)&lt;/p&gt;
&lt;p&gt;从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
