<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haoran&#39;s blog</title>
  
  <subtitle>Talk is cheap. Show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javassun.github.io/"/>
  <updated>2020-05-06T06:33:23.548Z</updated>
  <id>http://javassun.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ详解</title>
    <link href="http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-25T12:22:31.000Z</published>
    <updated>2020-05-06T06:33:23.548Z</updated>
    
    <content type="html"><![CDATA[<p>转载<a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/RabbitMQ01.png" alt></p><ul><li>左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。</li><li>中间即是 RabbitMQ，其中包括了 交换机 和 队列。</li><li>右侧 C 代表 消费者，也就是从 RabbitMQ 拿消息的程序。</li></ul><p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机，交换机，队列，和绑定。</p><ul><li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li><li>交换机：<em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li><li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系</li></ul><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout</p><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置 header attribute 参数类型的交换机</li><li>Fanout：转发消息到所有绑定队列</li></ul><p><strong>Direct Exchange</strong></p><p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/rabbitMq_direct.png" alt></p><p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p><p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p><p><strong>Topic Exchange</strong></p><p>Topic Exchange 转发消息主要是根据通配符。_ 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p><p>在这种交换机模式下：</p><ul><li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li><li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li></ul><p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br></pre></td></tr></table></figure><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p><ul><li><code>*</code>表示一个词.</li><li><code>#</code>表示零个或多个词.</li></ul><p><strong>Headers Exchange</strong></p><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><p><strong>Fanout Exchange</strong></p><p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，_会把消息发给绑定给它的全部队列_，如果配置了 routing_key 会被忽略。</p><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了<code>spring-boot-starter-amqp</code> 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 <code>spring-boot-starter-amqp</code> 的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;Spring-boot-rabbitmq</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.0.86</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue Queue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><p>rabbitTemplate 是 Spring Boot 提供的默认实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component</span><br><span class="line">public class HelloSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context &#x3D; &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;hello&quot;)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver  : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，发送者和接收者的 queue name 必须一致，不然不能接收</p></blockquote><h3 id="多对多使用"><a href="#多对多使用" class="headerlink" title="多对多使用"></a>多对多使用</h3><p>一个发送者，N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p><p><strong>一对多发送</strong></p><p>对上面的代码进行了小改造，接收端注册了两个 Receiver,Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void oneToMany() throws Exception &#123;</span><br><span class="line">    for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 12</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 14</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 13</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 15</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 16</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 18</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 17</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 19</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br></pre></td></tr></table></figure><p>根据返回结果得到以下结论</p><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><p><strong>多对多发送</strong></p><p>复制了一份发送者，加入标记，在一百个循环中相互交替发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void manyToMany() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            neoSender.send(i);</span><br><span class="line">            neoSender2.send(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 25</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 25</span><br></pre></td></tr></table></figure><blockquote><p>结论：和一对多一样，接收端仍然会均匀接收到消息</p></blockquote><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p><strong>对象的支持</strong></p><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送者</span><br><span class="line">public void send(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Sender object: &quot; + user.toString());</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;object&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收者</span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Receiver object : &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sender object: User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Receiver object : User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>Topic Exchange</strong></p><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列</p><p>首先对 topic 规则配置，这里使用两个队列来测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    final static String message &#x3D; &quot;topic.message&quot;;</span><br><span class="line">    final static String messages &#x3D; &quot;topic.messages&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;exchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am message 1&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.message&quot;, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am messages 2&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.messages&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息</p><p><strong>Fanout Exchange</strong></p><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>Fanout 相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FanoutRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue AMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue BMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue CMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue AMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, fanout msg &quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver A  : hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg</span><br></pre></td></tr></table></figure><p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zouyesheng.com/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p><p><a href="https://github.com/401Studio/WeekLearn/issues/2" target="_blank" rel="noopener">RabbitMQ：Spring 集成 RabbitMQ 与其概念，消息持久化，ACK机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载&lt;a href=&quot;http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。&lt;/p&gt;
&lt;h2 id=&quot;RabbitMQ-介绍&quot;&gt;&lt;a href=&quot;#RabbitMQ-介绍&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 介绍&quot;&gt;&lt;/a&gt;RabbitMQ 介绍&lt;/h2&gt;&lt;p&gt;RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;p&gt;AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;p&gt;RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://JavaSsun.github.io/categories/MQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://JavaSsun.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot面试</title>
    <link href="http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/"/>
    <id>http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-19T11:18:33.000Z</published>
    <updated>2020-05-06T06:33:16.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：</p><p>问：你觉得 Spring Boot 最大的优势是什么呢？</p><p>答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。</p><p>答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？</p><p>问：Spring Boot Starter 的工作原理是什么？</p><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li><p>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</p></li><li><p>② 根据 spring.factories 配置加载 AutoConfigure 类</p></li><li><p>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</p></li></ul><p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p><a id="more"></a><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p><p>第三部：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>是不是很爽？</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p><h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p><p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p><p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p><h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p><h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p><p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p><p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p><h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p><p>一般前端的解决方案有：</p><ul><li><p>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</p></li><li><p>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</p></li></ul><p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p><p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p><p>第一，配置 CorsFilter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置上述的一段代码。第二种方式稍微简单一些。</p><p>第二，在启动类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p><p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p><h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>用一组不太合理的包含关系来表达它们之间的关系。</p><p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：&lt;/p&gt;
&lt;p&gt;问：你觉得 Spring Boot 最大的优势是什么呢？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;/p&gt;
&lt;p&gt;问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。&lt;/p&gt;
&lt;p&gt;答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？&lt;/p&gt;
&lt;p&gt;问：Spring Boot Starter 的工作原理是什么？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 在启动的时候会干这几件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;② 根据 spring.factories 配置加载 AutoConfigure 类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="面试" scheme="http://JavaSsun.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-08T04:43:25.000Z</published>
    <updated>2020-04-16T16:17:20.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。<br>疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>速度更块</li><li>代码更少（Lambda表达式）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li></ul><p><font color="red">核心为：Lambda表达式与Stream API</font></p><a id="more"></a><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-为什么使用Lambda表达式"><a href="#1-为什么使用Lambda表达式" class="headerlink" title="1. 为什么使用Lambda表达式"></a>1. 为什么使用Lambda表达式</h3><p><strong>Lambda</strong>是一个<font color="red">匿名函数</font>，我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>（将代码像数据一样传递）。可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，使Java语言的表达更加凝练。</p><ul><li>从匿名类到 Lambda 的转换</li></ul><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匿名内部类</span><br><span class="line">Runnable r1 &#x3D; new Runnable()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">         System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原来使用匿名内部类作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(String o1,String o2)&#123;</span><br><span class="line">        return Integer.compare(o1.length,o2.length());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts2 &#x3D; new TreeSet&lt;&gt;(</span><br><span class="line">     (o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>匿名内部类</strong></font>：冗余的语法。导致了“Height Problem”（只有一行在工作）</p><h3 id="2-Lambda表达式语法"><a href="#2-Lambda表达式语法" class="headerlink" title="2. Lambda表达式语法"></a>2. Lambda表达式语法</h3><p>Lambda 表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “<font color="red"> -&gt; </font>“，该操作符被称为 Lambda操作符 或 箭头操作符。它将Lambda分为两个部分：</p><p><strong>左侧：</strong>指定了 Lambda 表达式需要的所有参数<br><strong>右侧：</strong>指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式一：无参，无返回值，Lambda只需一条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lambda需要一个参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun &#x3D; (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式三：Lambda只需要一个参数时，参数的小括号可省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consummer&lt;String&gt; fun &#x3D; args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lambda需要两个参数，并且有返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt;&#123;</span><br><span class="line">      System.out.println(&quot;实现函数接口方法&quot;);</span><br><span class="line">      return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：当Lambda体只有一条语句时，return与大括号可以省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：Long数据类型可以省略，可由编译器推断，即“类型推断”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (Long x,Long y) -&gt; &#123;</span><br><span class="line">         System.out.println(&quot;实现函数接口方法&quot;)；</span><br><span class="line">         x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong>是<font color="red"><strong>匿名内函数</strong></font>：提供了轻量级的语法。解决了匿名内部类带来的“高度”问题。</p><p>语法：<strong>参数列表</strong> <strong>-&gt;</strong> <strong>函数体</strong>三部分组成。<br>函数体：表达式、语句块。<br><font color="red"><strong>表达式</strong></font>：表达式会被执行然后返回执行结果。<br><font color="red"><strong>语句块</strong></font>：语句块中的语句会被依次执行，就像方法中的语句一样</p><ol><li>return语句会把控制权交给匿名函数的调用者</li><li>break和continue只能在循环中使用。</li><li>如果函数体有返回值。那么函数体内部的每一条路径都要有。</li></ol><p>表达式函数体适合小型<strong>Lambda</strong>表达式。消除了return关键字。简洁。</p><p><font color="red">新包</font>：<strong>java.util.function:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收 T对象 返回boolean</span><br><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收 T对象 不返回任何值</span><br><span class="line">Consumer&lt;T&gt; void accept(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收 T对象 返回R对象</span><br><span class="line">Function(T,R) R apply(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供 T对象（工厂T）</span><br><span class="line">Supplier&lt;T&gt; T get()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一元：接收T 返回T</span><br><span class="line">UnaryOperator&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二元：接收两个T 返回T</span><br><span class="line">BinaryOperator&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些 Lambda表达式简单例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int x,int y)-&gt;x+y; &#x2F;&#x2F;接收 x y 返回 x与y的和</span><br><span class="line">()-&gt;45;       &#x2F;&#x2F; 不接受参数 返回45</span><br><span class="line">(String s)-&gt;&#123;System.out.println(s);&#125; &#x2F;&#x2F;接收一个字符串，并把它打印在控制台</span><br></pre></td></tr></table></figure><h3 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h3><p>Lambda表达式无需指定类型，程序依然可以编译，因为 javac 根据程序上下文，在后台推断出了参数类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。即所谓的“类型推断”。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="1-什么是函数式接口"><a href="#1-什么是函数式接口" class="headerlink" title="1. 什么是函数式接口"></a>1. 什么是函数式接口</h3><ul><li><p>只包含了一个抽象方法的接口，称为<strong>函数式接口</strong></p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在任意函数式接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li></ul><h3 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2. 自定义函数式接口"></a>2. 自定义函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyNumber&#123;</span><br><span class="line">   public double getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式接口中使用泛型：</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">   public T getValue(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作为参数传递 Lambda 表达式</span><br><span class="line">public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123;</span><br><span class="line">        return mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       String newStr &#x3D; toUpperString(</span><br><span class="line">       (str) -&gt; str.toUpperCase(), &quot;abcdef&quot;);</span><br><span class="line">       System.out.println(newStr);</span><br></pre></td></tr></table></figure><p><font color="red">作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br></font></p><h3 id="3-Java内治四大核心函数式接口"><a href="#3-Java内治四大核心函数式接口" class="headerlink" title="3. Java内治四大核心函数式接口"></a>3. Java内治四大核心函数式接口</h3><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/97801292-5716-4519-9bff-9f8f08aed48b.png" alt></p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/743ea2bc-aeda-44e0-b691-31c354b94f47.png" alt></p><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况：</p><ul><li><p><strong>对象::实例方法</strong></p></li><li><p><strong>类::静态方法</strong></p></li><li><p><strong>类::实例方法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(x);</span><br><span class="line">等同于</span><br><span class="line">System.out::println;</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D; (x,y) -&gt; Math.pow(x,y);</span><br><span class="line">等同于</span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D;Math::pow;</span><br><span class="line"></span><br><span class="line">compare((x,y) -&gt;x.equals(y), &quot;abcdef&quot; , &quot;abcdef&quot;);</span><br><span class="line">等同于</span><br><span class="line">compare(String::equals,&quot;abc&quot;,&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p><strong>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</strong></p><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><p><strong>格式： ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，与构造器参数 列表要与接口中抽象方法的参数列表一致！</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; (n) -&gt; new MyClass(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; MyClass::new;</span><br></pre></td></tr></table></figure><h3 id="3-数字引用"><a href="#3-数字引用" class="headerlink" title="3. 数字引用"></a>3. 数字引用</h3><p><strong>格式： type[] :: new</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun &#x3D; (n) -&gt; new Integer(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; Integer[]::new;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><h3 id="1-了解Stream"><a href="#1-了解Stream" class="headerlink" title="1. 了解Stream"></a>1. 了解Stream</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一 个则是 <strong>Stream API(java.util.stream.*)</strong>。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>*<em>流(Stream)是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>*</em><br><font color="red">“集合讲的是数据，流讲的是计算！”</font></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="2-Stream三步骤"><a href="#2-Stream三步骤" class="headerlink" title="2. Stream三步骤"></a>2. Stream三步骤</h3><ul><li><p><strong>创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p></li><li><p><strong>中间操作</strong><br>一个中间操作链，对数据源的数据进行处理 </p></li><li><p><strong>终端操作</strong><br>一个终止操作，执行中间操作链，并产生结果<br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/37346492-7531-44b8-a2bf-681c14b381ec.jpg" alt></p></li></ul><h3 id="3-创建Stream"><a href="#3-创建Stream" class="headerlink" title="3. 创建Stream"></a>3. 创建Stream</h3><h4 id="1-Collection-创建流"><a href="#1-Collection-创建流" class="headerlink" title="1. Collection 创建流"></a>1. Collection 创建流</h4><ul><li><p>default Stream<E> stream() : 返回一个顺序流</E></p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p></li></ul><h4 id="2-数组-创建流（Arrays的静态方法stream-创建）"><a href="#2-数组-创建流（Arrays的静态方法stream-创建）" class="headerlink" title="2. 数组 创建流（Arrays的静态方法stream()创建）"></a>2. 数组 创建流（Arrays的静态方法stream()创建）</h4><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li></ul><p><strong>重载形式，能够处理对应基本类型的数组</strong></p><ul><li><p>public static IntStream stream(int[] array)</p></li><li><p>public static LongStream stream(long[] array)</p></li><li><p>public static DoubleStream stream(double[] array)</p></li></ul><h4 id="3-由值创建流"><a href="#3-由值创建流" class="headerlink" title="3. 由值创建流"></a>3. 由值创建流</h4><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li></ul><h4 id="4-由函数创建流：创建无限流"><a href="#4-由函数创建流：创建无限流" class="headerlink" title="4. 由函数创建流：创建无限流"></a>4. 由函数创建流：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>迭代</li></ul><p>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</T></T></T></p><ul><li>生成</li></ul><p>public static<T> Stream<T> generate(Supplier<T> s)</T></T></T></p><h3 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4. Stream 的中间操作"></a>4. Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><p><strong>筛选与切片</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/853fb496-9885-4191-b20d-1d5c8508def5.png" alt></p><p><strong>映射</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/feb89458-0a81-42a9-9aa4-33b20b5991bf.png" alt></p><p><strong>排序</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3a69b800-08f9-4bca-ab2d-51e3f3446635.png" alt></p><h3 id="5-Stream-的终止操作"><a href="#5-Stream-的终止操作" class="headerlink" title="5. Stream 的终止操作"></a>5. Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的 值，例如：List、Integer，甚至是 void 。</p><p><strong>查找与匹配</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1cd0233f-598b-4537-8998-5e5fa24aada0.png" alt><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/bae6b149-cc4f-4f84-aec0-e27bf8afe015.png" alt></p><p><strong>归约</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/037bfd49-78ed-468b-aa65-4ad0242e490b.png" alt></p><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</p><p><strong>收集</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2cccbffb-7df8-4a65-8153-537071e75bd7.png" alt></p><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><h3 id="6-并行流与串行流"><a href="#6-并行流与串行流" class="headerlink" title="6. 并行流与串行流"></a>6. 并行流与串行流</h3><p><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p><h3 id="7-了解-Fork-Join-框架"><a href="#7-了解-Fork-Join-框架" class="headerlink" title="7. 了解 Fork/Join 框架"></a>7. 了解 Fork/Join 框架</h3><p><strong>Fork/Join 框架</strong>:就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/84eaed9b-717b-47f9-9f0a-f5fde05f7472.jpg" alt></p><h3 id="8-Fork-Join-框架与传统线程池的区别"><a href="#8-Fork-Join-框架与传统线程池的区别" class="headerlink" title="8. Fork/Join 框架与传统线程池的区别"></a>8. Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的<br>处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因<br>无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果<br>某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子<br>问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程<br>的等待时间,提高了性能.</p><h2 id="5-新时间日期API"><a href="#5-新时间日期API" class="headerlink" title="5. 新时间日期API"></a>5. 新时间日期API</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实 例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1d49dcda-eb3d-4eb7-aa3c-889e5607867f.png" alt></p><p><strong>Instant 时间戳</strong></p><ul><li>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算</li></ul><p><strong>Duration 和 Period</strong></p><ul><li><p>Duration:用于计算两个“时间”间隔</p></li><li><p>Period:用于计算两个“日期”间隔</p></li><li><p>日期的操纵</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获 取例如：将日期调整到“下个周日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法提供了大量的常 用 TemporalAdjuster 的实现。</p></li></ul><p>例如获取下个周日：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday &#x3D; LocalDate.now().with(</span><br><span class="line">   TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析与格式化</strong></p><p>java.time.format.DateTimeFormatter 类：该类提供了三种 格式化方法：</p><ul><li><p>预定义的标准格式</p></li><li><p>语言环境相关的格式</p></li><li><p>自定义的格式</p></li></ul><p><strong>时区的处理</strong></p><ul><li>Java8 中加入了对时区的支持，带时区的时间为分别为：</li></ul><p>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><p>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><p><strong>与传统日期处理的转换</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/0b30f162-415f-4a9c-a650-ba13116ff20b.png" alt></p><h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6. 接口中的默认方法与静态方法"></a>6. 接口中的默认方法与静态方法</h2><h3 id="1-接口中的默认方法"><a href="#1-接口中的默认方法" class="headerlink" title="1. 接口中的默认方法"></a>1. 接口中的默认方法</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">  T func(int a);</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>接口默认方法的”类优先”原则 *</em></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyFunc&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Named&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello java8&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass implements MyFunc,Named&#123;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">        return Named.super.getName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口中的静态方法"><a href="#2-接口中的静态方法" class="headerlink" title="2. 接口中的静态方法"></a>2. 接口中的静态方法</h3><p>Java8 中，接口中允许添加静态方法</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">  public Integer myFun();</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show()&#123;</span><br><span class="line">     System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-其他新特性"><a href="#7-其他新特性" class="headerlink" title="7. 其他新特性"></a>7. 其他新特性</h2><p><strong>Optional 类</strong></p><p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p><p><strong>常用方法：</strong><br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值<br>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t<br>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</p><p><strong>重复注解与类型注解</strong></p><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations&#123;</span><br><span class="line">   MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation&#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyAnnotation(&quot;Hello&quot;)</span><br><span class="line">@MyAnnotation(&quot;World&quot;)</span><br><span class="line">public void show(@MyAnnotation(&quot;abc&quot;) String str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 交易员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class Trader &#123;</span><br><span class="line">     private String name;</span><br><span class="line">     private String city;</span><br><span class="line">     public Trader(String name, String city) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getter setter方法省略</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">     private Trader trader;</span><br><span class="line">     private int year;</span><br><span class="line">     private int value;</span><br><span class="line">     public Transaction(Trader trader, int year, int value) &#123;</span><br><span class="line">        this.trader &#x3D; trader;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PuttingIntoPractice &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Trader raoul &#x3D; new Trader(&quot;Raoul&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader mario &#x3D; new Trader(&quot;mario&quot;,&quot;Milan&quot;);</span><br><span class="line">        Trader alen &#x3D; new Trader(&quot;alen&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader brian &#x3D; new Trader(&quot;brian&quot;,&quot;Cambridge&quot;);</span><br><span class="line"></span><br><span class="line">  List&lt;Transaction&gt; transactions &#x3D; Arrays.asList(</span><br><span class="line">          new Transaction(brian,2011,300),</span><br><span class="line">          new Transaction(raoul,2012,1000),</span><br><span class="line">          new Transaction(raoul,2011,400),</span><br><span class="line">          new Transaction(mario,2012,710),</span><br><span class="line">          new Transaction(mario,2012,700),</span><br><span class="line">          new Transaction(alen,2012,950)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getYear() &#x3D;&#x3D; 2011)</span><br><span class="line">.sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (2) 交易员都在哪些不同的城市工作过？</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (3) 查找所有来自于剑桥的交易员，并按姓名排序。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (4) 返回所有交易员的姓名字符串，按字母顺序排序。</span><br><span class="line">  String traderStr &#x3D; transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">  System.out.println(traderStr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (5) 有没有交易员是在米兰工作的？</span><br><span class="line">  boolean miLanBased &#x3D; transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader()</span><br><span class="line">                        .getCity().equals(&quot;MiLan&quot;));</span><br><span class="line">  System.out.println(miLanBased);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (6) 打印生活在剑桥的交易员的所有交易额。</span><br><span class="line">         transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (7) 所有交易中，最高的交易额是多少？</span><br><span class="line">  int highestValue &#x3D; transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(0,Integer::max);</span><br><span class="line">  System.out.println(highestValue);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Transaction::getValue).reversed())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (8) 找到交易额最小的交易。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">             .min(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">                .min(Comparator.comparing((Transaction t1)-&gt; t1.getValue()))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (9) 统计每个交易员的记录</span><br><span class="line">  transactions.stream()</span><br><span class="line">       .collect(Collectors.groupingBy(Transaction::getTrader))</span><br><span class="line">                .entrySet().stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (10) 找到单笔交易最高的交易员</span><br><span class="line">  transactions.stream()</span><br><span class="line">             .max(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(tran -&gt;&#123;</span><br><span class="line">                    System.out.println(tran.getTrader());</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习参考网络</p><h2 id="8-java8红黑树"><a href="#8-java8红黑树" class="headerlink" title="8. java8红黑树"></a>8. java8红黑树</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>回顾：HashSet是基于HashCode实现元素不重复的。当插入元素的哈希码相同时，会调用equals方法进行二次比较，如果相同，则新值替旧值。如果不同，则以链表的形式挂在当前元素所在的位置。</p><p>扩容因子：0.75</p><p>如果是1 ，则可能永远是只插入到两个位置，形成部分元素的长链表。每次都要在哈希码相同时进行equals比较（哈希碰撞）。降低性能。</p><p>如果是&lt;0.75,则可能浪费空间。</p><h3 id="数组-链表-红黑树-二叉树的一种"><a href="#数组-链表-红黑树-二叉树的一种" class="headerlink" title="数组-链表-红黑树(二叉树的一种)"></a>数组-链表-红黑树(二叉树的一种)</h3><p><strong>条件：当碰撞袁术个数&gt;8 &amp;&amp; 总容量&gt;64 将其转换为红黑树</strong></p><p><font color="red">碰撞元素个数</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK7是数组-&gt;链表</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK8是数组-链表</font>： 当转变为红黑树时，添加的效率变低。其他效率都高了。平衡二叉树（比当前值与节点值的大小）</p><p>扩容是：原来表会计算hashcode值进行元素的再次填充。</p><p>现在只需要找原来表的总长度+当前所在的位置，就是当前扩容后的位置。（不需要再次进行哈希计算）。</p><p><strong>ConcurrentHashMap：效率提高</strong></p><p>JDK7: ConcurrentLevel = 16<br>JDK8：CAS算法</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/7d750713-3d72-48e3-b512-d11dc1900f92.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。&lt;br&gt;疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;速度更块&lt;/li&gt;
&lt;li&gt;代码更少（Lambda表达式）&lt;/li&gt;
&lt;li&gt;强大的Stream API&lt;/li&gt;
&lt;li&gt;便于并行&lt;/li&gt;
&lt;li&gt;最大化减少空指针异常 Optional&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;核心为：Lambda表达式与Stream API&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Docker简单配置</title>
    <link href="http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</id>
    <published>2020-01-15T14:20:51.000Z</published>
    <updated>2020-05-06T06:33:32.647Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><a id="more"></a><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello Docker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DockerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>plugins 中添加 Docker 构建插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br><span class="line"></span><br><span class="line">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span><br><span class="line">systemctl  start docker.service</span><br><span class="line">systemctl  enable docker.service</span><br></pre></td></tr></table></figure><p>使用Docker 中国加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><p>配置环境变量 打开 <code>vim /etc/profile</code> 添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成之后，使其生效</p><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装MAVEN"><a href="#安装MAVEN" class="headerlink" title="安装MAVEN"></a>安装MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar vxf apache-maven-3.5.2-bin.tar.gz</span><br><span class="line">## 移动</span><br><span class="line">mv apache-maven-3.5.2 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#打包</span><br><span class="line">mvn package</span><br><span class="line">#启动</span><br><span class="line">java -jar target&#x2F;spring-boot-docker-1.0.jar</span><br></pre></td></tr></table></figure><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME &#x2F;tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line">Removing intermediate container 593ee5e1ea51</span><br><span class="line">Step 4 : ENTRYPOINT java -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar</span><br><span class="line"> ---&gt; Running in 85d558a10cd4</span><br><span class="line"> ---&gt; 7102f08b5e95</span><br><span class="line">Removing intermediate container 85d558a10cd4</span><br><span class="line">Successfully built 7102f08b5e95</span><br><span class="line">[INFO] Built springboot&#x2F;spring-boot-docker</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M&#x2F;182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot&#x2F;spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot&#x2F;spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot&#x2F;spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080&#x2F;tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。&lt;/p&gt;
&lt;p&gt;首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-28T10:30:10.000Z</published>
    <updated>2020-04-16T10:05:57.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)</p><p>从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。 <a id="more"></a>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说， 假设你插入的键的顺序为 1、2、3、4，后来再次插入 2，迭代时的顺序还是 1、2、 3、4，而不会因为后来插入的 2 变成 1、3、4、2。（但其实我们可以改变它的规则， 使它变成 1、3、4、2）</p><p>LinkedHashMap 的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希 表部分继承了 HashMap，拥有了 HashMap 那一套高效的操作，所以我们要看的就是 LinkedHashMap 中链表的部分，了解它是如何来维护有序性的。</p><p>LinkedHashMap 的大致实现如下图所示，当然链表和哈希表中相同的键值对都是指 向同一个对象，这里把它们分开来画只是为了呈现出比较清晰的结构。</p><p><img src="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/123e5c16-da83-4e2b-99ca-ac014847a73a.jpg" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>在看属性之前，我们先来看一下 LinkedHashMap 的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; imple ments Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>从上面的声明中，我们可以看见 LinkedHashMap 是继承自 HashMap 的，所以它已 经从 HashMap 那里继承了与哈希表相关的操作了，那么在 LinkedHashMap 中，它 可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedHashMap 的链表节点继承了 HashMap 的节点，而且每个节点都包含</span><br><span class="line">了前指针和后指针，所以这里可以看出它是一个双向链表</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尾指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认为 false。当为 true 时，表示链表中键值对的顺序与每个键的插入顺</span><br><span class="line">序一致，也就是说重复插入键，也会更新顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单来说，为 false 时，就是上面所指的 1、2、3、4 的情况；为 true 时，</span><br><span class="line">就是 1、3、4、2 的情况</span><br><span class="line"></span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><p>如果仔细看过 HashMap 源码的话，会发现 HashMap 中有如下三个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果没有注意到注释的解释的话，可能会很奇怪为什么会有三个空方法，而且 有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点 之后，进行一些处理，它们在 LinkedHashMap 都有各自的实现。LinkedHashMap 正 是通过重写这三个方法来保证链表的插入、删除的有序性。</p><h2 id="1-afterNodeAccess方法"><a href="#1-afterNodeAccess方法" class="headerlink" title="1 afterNodeAccess方法"></a>1 afterNodeAccess方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    &#x2F;&#x2F;当 accessOrder 的值为 true，且 e 不是尾节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思简洁明了，就是把当前节点 e 移至链表的尾部。因为使用的是双向 链表，所以在尾部插入可以以 O（1）的时间复杂度来完成。并且只有当accessOrder<br>设置为 true 时，才会执行这个操作。在 HashMap 的 putVal 方法中，就调用了这个 方法。</p><h2 id="2-afterNodeInsertion方法"><a href="#2-afterNodeInsertion方法" class="headerlink" title="2 afterNodeInsertion方法"></a>2 afterNodeInsertion方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remov e eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntr y(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterNodeInsertion 方法是在哈希表中插入了一个新节点时调用的，它会把链表的头 节点删除掉，删除的方式是通过调用 HashMap 的 removeNode 方法。想一想，通过 afterNodeInsertion 方法和 afterNodeAccess 方法，是不是就可以简单的实现一个基于 最近最少使用（LRU）的淘汰策略了？当然，我们还要重写 removeEldestEntry 方法， 因为它默认返回的是 false。</p><h2 id="3-afterNodeRemoval方法"><a href="#3-afterNodeRemoval方法" class="headerlink" title="3 afterNodeRemoval方法"></a>3 afterNodeRemoval方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.aft er;</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当 HashMap 删除一个键值对时调用的，它会把在 HashMap 中删除的那 个键值对一并从链表中删除，保证了哈希表和链表的一致性。 </p><h2 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4 get方法"></a>4 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，LinkedHashMap 的 get 方法就是这么简单，因为它调用的是 HashMap 的 getNode 方法来获取结果的。并且，如果你把 accessOrder 设置为 true，那么在获取到值之后，还会调用 afterNodeAccess 方法。这样是不是就能保证一个 LRU 的算法了.</p><h2 id="5-put和remove方法"><a href="#5-put和remove方法" class="headerlink" title="5 put和remove方法"></a>5 put和remove方法</h2><p>在 LinkedHashMap 的源码中没有找到 put 方法，这就说明了它并没有重写 put 方 法，所以我们调用的 put 方法其实是 HashMap 的 put 方法。因为 HashMap 的 put 方 法中调用了 afterNodeAccess 方法和 afterNodeInsertion 方法，已经足够保证链表的有 序性了，所以它也就没有重写 put 方法了。remove 方法也是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;源码中的一段注释，提取关键信息&lt;br&gt;Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)&lt;/p&gt;
&lt;p&gt;从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>HashTable实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-22T05:28:10.000Z</published>
    <updated>2020-04-16T10:05:42.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>Hashtable 可以说已经具有一定的历史了，现在也很少使用到 Hashtable 了，更多的是使 用 HashMap 或 ConcurrentHashMap。HashTable 是一个线程安全的哈希表，它通过使用 synchronized 关键字来对方法进行加锁，从而保证了线程安全。但这也导致了在单线程 环境中效率低下等问题。Hashtable 与 HashMap 不同，它不允许插入 null 值和 null 键。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>Hashtable 并没有像 HashMap 那样定义了很多的常量，而是直接写死在了方法里（看下 去就知道了），所以它的属性相比 HashMap 来说，可以获取的信息还是比较少的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">private transient Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录哈希表中键值对的个数</span><br><span class="line">private transient int count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩容的阈值</span><br><span class="line">private int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">private float loadFactor;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+l oadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">        initialCapacity &#x3D; 1;</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    table &#x3D; new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二话不说，上来先丢了三个构造函数。从构造函数中，我们可以获取到这些信息： Hashtable默认的初始化容量为11（与HashMap不同），负载因子默认为0.75（与HashMap 相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以 先推断出，Hashtable 使用的哈希函数跟 HashMap 是不一样的（事实也确实如此）。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;通过哈希函数，计算出 key 对应的桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F;遍历该桶的所有元素，寻找该 key</span><br><span class="line">    for (Entry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 HashMap 相比，Hashtable 的 get 方法非常简单。我们首先可以看见 get 方法使用了 synchronized 来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。 另外，我们还可以看见 HashTable 并没有像 HashMap 那样封装一个哈希函数，而是直接 把哈希函数写在了方法中。而哈希函数也是比较简单的，它仅对哈希表的长度进行了取模。</p><h2 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3 put方法"></a>3 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">    if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;计算桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    &#x2F;&#x2F;遍历桶中的元素，判断是否存在相同的 key</span><br><span class="line">    for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">        if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old &#x3D; entry.value;</span><br><span class="line">            entry.value &#x3D; value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不存在相同的 key，则把该 key 插入到桶中</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F;哈希表的键值对个数达到了阈值，则进行扩容</span><br><span class="line">    if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">        &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab &#x3D; table;</span><br><span class="line">        hash &#x3D; key.hashCode();</span><br><span class="line">        index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    &#x2F;&#x2F;把新节点插入桶中（头插法）</span><br><span class="line">    tab[index] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 方法一开始就表明了不能有 null 值，否则就会向你抛出一个空指针异常。Hashtable 的 put 方法也是使用 synchronized 来修饰。你可以发现，在 Hashtable 中，几乎所有的方 法都使用了 synchronized 来保证线程安全。</p><h2 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4 remove方法"></a>4 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(Entry&lt;K,V&gt; prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.nex t) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity &#x3D; table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;扩容扩为原来的两倍+1</span><br><span class="line">    int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    &#x2F;&#x2F;判断是否超过最大容量</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">            &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">            return;</span><br><span class="line">        newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap &#x3D; new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F;计算下一次 rehash 的阈值</span><br><span class="line">    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRA Y_SIZE + 1);</span><br><span class="line">    table &#x3D; newMap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;把旧哈希表的键值对重新哈希到新哈希表中去</span><br><span class="line">    for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old &#x3D; (Entry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">            old &#x3D; old.next;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next &#x3D; (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hashtable 的 rehash 方法相当于 HashMap 的 resize 方法。跟 HashMap 那种巧妙的 rehash 方式相比，Hashtable 的 rehash 过程需要对每个键值对都重新计算哈希值，而比起异或 和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;Hashtable 可以说已经具有一定的历史了，现在也很少使用到 Hashtable 了，更多的是使 用 HashMap 或 ConcurrentHashMap。HashTable 是一个线程安全的哈希表，它通过使用 synchronized 关键字来对方法进行加锁，从而保证了线程安全。但这也导致了在单线程 环境中效率低下等问题。Hashtable 与 HashMap 不同，它不允许插入 null 值和 null 键。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-20T12:05:10.000Z</published>
    <updated>2020-04-16T10:05:36.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>大致意思是：这个哈希表是基于 Map 接口的实现的，它允许 null 值和 null 键，它不是线程同步的，同时也不保证有序。</p><a id="more"></a><p>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.  An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p><p>大意：讲的是 Map 的这种实现方式为 get （取）和 put（存）带来了比较好的性能。但是如果涉及到大量的遍历操作的话，就 尽量不要把 capacity 设置得太高（或 load factor 设置得太低），否则会严重降低遍历的效率。</p><p>影响 HashMap 性能的两个重要参数：“initial capacity”（初始化容量）和”load factor“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对 个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash 操作来进行扩容。</p><p>HashMap 的大致结构如下图所示，其中哈希表是一个数组，我们经常把数组中的每 一个节点称为一个桶，哈希表中的每个节点都用来存储一个键值对。在插入元素时， 如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解 决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过 key 的<br>哈希值先定位到桶，再遍历桶上的所有键值对，找出 key 相等的键值对，从而来获 取 value。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0f32057b-e876-449b-99ec-fbcf3b3bbcce.png" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的初始容量为 16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最大的容量上限为 2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的负载因子为 0.75 </span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变成树型结构的临界值为 8</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;恢复链式结构的临界值为 6</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表中键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表被修改的次数</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span><br><span class="line">就会进行扩容操作</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采</span><br><span class="line">取扩容来尝试减少冲突</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure><p>Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个 节点都是 Node 类型。我们可以看到，Node 类中有 4 个属性，其中除了 key 和 value 之外，还有 hash 和 next 两个属性。hash 是用来存储 key 的哈希值的，next 是在构建链表时用来指向后继节点的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + valu e; &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(val ue); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三方法"><a href="#三方法" class="headerlink" title="三方法"></a>三方法</h1><h2 id="1-get方法"><a href="#1-get方法" class="headerlink" title="1 get方法"></a>1 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的</span><br><span class="line">实现</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;是否直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first n ode </span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; ke y.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F;判断是否有后续节点 </span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode (hash, key);</span><br><span class="line">                &#x2F;&#x2F;不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下： </p><ol><li>通过 hash 值获取该 key 映射到的桶。</li><li>桶上的 key 就是要查找的 key，则直接命中。</li><li>桶上的 key 不是要查找的 key，则查看后续节点：<br>（1）如果后续节点是树节点，通过调用树的方法查找该 key。<br>（2）如果后续节点是链式节点，则通过循环遍历链查找该 key。</li></ol><h2 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2 put方法"></a>2 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;put 方法的具体实现也是在 putVal 方法中，所以我们重点看下面的 putVal 方法</span><br><span class="line">   public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIf Absent,boolean evict) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">       &#x2F;&#x2F;如果哈希表为空，则先创建一个哈希表</span><br><span class="line">       if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">           n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">       &#x2F;&#x2F;如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span><br><span class="line">       if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">           tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">       else &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           &#x2F;&#x2F;如果桶上节点的 key 与当前 key 重复，那你就是我要找的节点了</span><br><span class="line">           if (p.hash &#x3D;&#x3D; hash &amp;&amp;((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equ als(k))))</span><br><span class="line">               e &#x3D; p;</span><br><span class="line">           &#x2F;&#x2F;如果是采用红黑树的方式处理冲突，则通过红黑树的 putTreeVal 方法去插入这个键值对</span><br><span class="line">           else if (p instanceof TreeNode)</span><br><span class="line">               e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">           &#x2F;&#x2F;否则就是传统的链式结构</span><br><span class="line">           else &#123;</span><br><span class="line">               &#x2F;&#x2F;采用循环遍历的方式，判断链中是否有重复的 key</span><br><span class="line">               for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                   &#x2F;&#x2F;到了链尾还没找到重复的 key，则说明 HashMap 没有包含该键</span><br><span class="line">                   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       &#x2F;&#x2F;创建一个新节点插入到尾部</span><br><span class="line">                       p.next &#x3D; newNode(hash, key, value, nul l);</span><br><span class="line"></span><br><span class="line">                       &#x2F;&#x2F;如果链的长度大于 TREEIFY_THRESHOLD 这个临界值，则把链变为红黑树</span><br><span class="line">                       if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   &#x2F;&#x2F;找到了重复的 key</span><br><span class="line">                   if (e.hash &#x3D;&#x3D; hash</span><br><span class="line">                       ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                       break;</span><br><span class="line">                   p &#x3D; e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span><br><span class="line">           if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">               V oldValue &#x3D; e.value;</span><br><span class="line">               if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               return oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       &#x2F;&#x2F;判断是否需要进行扩容</span><br><span class="line">       if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>put 方法比较复杂，实现步骤大致如下：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红 黑树。</li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果 size 大于阈值，则进行扩容。</li></ol><h2 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="3  remove方法"></a>3  remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove 方法的具体实现在 removeNode 方法中，所以我们重点看下面的 removeNode 方法</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, tru e)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object va lue,</span><br><span class="line">                           boolean matchValue, boolean movabl e) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    &#x2F;&#x2F;如果当前 key 映射到的桶不为空</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        &#x2F;&#x2F;如果桶上的节点就是要找的 key，则直接命中</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是以红黑树处理冲突，则构建一个树节点</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F;如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;比对找到的 key 的 value 跟要删除的是否匹配</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals (v)))) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过调用红黑树的方法来删除节点</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, t ab, movable);</span><br><span class="line">            &#x2F;&#x2F;使用链表的操作来删除节点</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Hash方法"><a href="#5-Hash方法" class="headerlink" title="5 Hash方法"></a>5 Hash方法</h2><p>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作， 计算的主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的 n 指的是哈希表的大小，hash 指的是 key 的哈希值，hash 是通过下面 这个方法计算出来的，采用了二次哈希的方式，其中 key 的 hashCode 方法是一个 native 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>这个 hash 方法先通过 key 的 hashCode 方法获取一个哈希值，再拿这个哈希值与它 的高 16 位的哈希值做一个异或操作来得到最后的哈希值，计算过程可以参考下图。 为啥要这样做呢？注释中是这样解释的：如果当 n 很小，假设为 64 的话，那么 n-1 即为 63（0x111111），这样的值跟 hashCode()直接做与操作，实际上只使用了哈希 值的后 6 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲 突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0dfe17b4-be06-48e2-90e1-0383e587a440.jpg" alt></p><p>正是因为与的这个操作，决定了 HashMap 的大小只能是 2 的幂次方，想一想，如果 不是2的幂次方，会发生什么事情？即使你在创建HashMap的时候指定了初始大小， HashMap 在构建的时候也会调用下面这个方法来调整大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_C APACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用看起来可能不是很直观，它的实际作用就是把 cap 变成第一个大于 等于 2 的幂次方的数。例如，16 还是 16，13 就会调整为 16，17 就会调整为 32。</p><h2 id="5-resize方法"><a href="#5-resize方法" class="headerlink" title="5 resize方法"></a>5 resize方法</h2><p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与 原来计算（n-1）&amp;hash 的结果相比，只是多了一个 bit 位，所以节点要么就在原来 的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为 32，那么应该拿 hash 跟 31（0x11111）做与操作；在扩容扩到 了 64 的容量之后，应该拿 hash 跟 63（0x111111）做与操作。新容量跟原来相比只 是多了一个 bit 位，假设原来的位置在 23，那么当新增的那个 bit 位的计算结果为 0 时，那么该节点还是在 23；相反，计算结果为 1 时，则该节点会被分配到 23+31 的 桶上。</p><p>正是因为这样巧妙的 rehash 方式，保证了 rehash 之后每个桶上的节点数必定小于等 于原来桶上的节点数，即保证了 rehash 之后不会出现更严重的冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;计算扩容后的大小</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量超过最大容量，则无法进行扩容</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没超过最大值则扩为原来的两倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp; &amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">     &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in t hreshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIA L_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)M AXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;新的 resize 阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F;创建新的哈希表</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;如果桶上只有一个键值对，则直接插入</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F;如果是通过红黑树来处理冲突的，则调用相关方法把树分</span><br><span class="line">离开</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                &#x2F;&#x2F;如果采用链式处理冲突 </span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    &#x2F;&#x2F;通过上面讲的方法来计算节点的新位置</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个需要注意的地方，有些文章指出当哈希表的桶占用超过阈值时就进行 扩容，这是不对的；实际上是当哈希表中的<strong>键值对个数超过阈值</strong>时，才进行扩容的.</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>通过红黑树的方式来处理哈希冲突是我第一次看见！学过哈希，学过红黑树，从来没有想过两个可以结合到一起这么用，或许这就是大佬吧！！！</p><p>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表 的效率降低至 O（n），而通过红黑树的方式，可以把效率改进至 O（logn）。相比 链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;源码中的一段注释，提取关键信息&lt;br&gt;Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.&lt;/p&gt;
&lt;p&gt;大致意思是：这个哈希表是基于 Map 接口的实现的，它允许 null 值和 null 键，它不是线程同步的，同时也不保证有序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis多数据源配置</title>
    <link href="http://javassun.github.io/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <id>http://javassun.github.io/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</id>
    <published>2019-11-17T13:26:57.000Z</published>
    <updated>2020-05-06T06:33:28.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多数据源，一般都来解决主从模式或者业务比较复杂需要连接不同的分库来支持业务。我们遇到的情况是后者，网上找了很多，大都是根据 Jpa 来做多数据源解决方案，要不就是老的 Spring 多数据源解决方案，还有的是利用 Aop 动态切换，过于复杂，当前已Mybatis Xml为例，简单配置。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Pom 包就不贴了比较简单该依赖的就依赖，主要是数据库这边的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location&#x3D;classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line"></span><br><span class="line">spring.datasource.test1.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test1?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test1.username&#x3D;root</span><br><span class="line">spring.datasource.test1.password&#x3D;root</span><br><span class="line">spring.datasource.test1.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.test2.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test2?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test2.username&#x3D;root</span><br><span class="line">spring.datasource.test2.password&#x3D;root</span><br><span class="line">spring.datasource.test2.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>一个 test1 库和一个 test2 库，其中 test1 位主库，在使用的过程中必须指定主库，不然会报错</p><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">public class DataSource1Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1DataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.test1&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource testDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis&#x2F;mapper&#x2F;test1&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1TransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的地方就是这块了，一层一层注入,首先创建 DataSource，然后创建 SqlSessionFactory 再创建事务，最后包装到 SqlSessionTemplate 中。其中需要指定分库的 mapper 文件地址，以及分库dao层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br></pre></td></tr></table></figure><p>这块的注解就是指明了扫描 dao 层，并且给 dao 层注入指定的 SqlSessionTemplate。所有<code>@Bean</code>都需要按照命名指定正确。</p><h2 id="dao-层和-xml层"><a href="#dao-层和-xml层" class="headerlink" title="dao 层和 xml层"></a>dao 层和 xml层</h2><p>dao 层和 xml 需要按照库来分在不同的目录，比如：test1 库 dao 层在 <code>com.neo.mapper.test1</code> 包下，test2 库在<code>com.neo.mapper.test2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    List&lt;UserEntity&gt; getAll();</span><br><span class="line">    UserEntity getOne(Long id);</span><br><span class="line">    void insert(UserEntity user);</span><br><span class="line">    void update(UserEntity user);</span><br><span class="line">    void delete(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.neo.mapper.test1.User1Mapper&quot; &gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;BIGINT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;userName&quot; property&#x3D;&quot;userName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;passWord&quot; property&#x3D;&quot;passWord&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;user_sex&quot; property&#x3D;&quot;userSex&quot; javaType&#x3D;&quot;com.neo.enums.UserSexEnum&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;nick_name&quot; property&#x3D;&quot;nickName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id&#x3D;&quot;Base_Column_List&quot; &gt;</span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    &lt;&#x2F;sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getAll&quot; resultMap&#x3D;&quot;BaseResultMap&quot;  &gt;</span><br><span class="line">       SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getOne&quot; parameterType&#x3D;&quot;java.lang.Long&quot; resultMap&#x3D;&quot;BaseResultMap&quot; &gt;</span><br><span class="line">        SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">     WHERE id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       INSERT INTO </span><br><span class="line">          users</span><br><span class="line">          (userName,passWord,user_sex) </span><br><span class="line">        VALUES</span><br><span class="line">          (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       UPDATE </span><br><span class="line">          users </span><br><span class="line">       SET </span><br><span class="line">        &lt;if test&#x3D;&quot;userName !&#x3D; null&quot;&gt;userName &#x3D; #&#123;userName&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;passWord !&#x3D; null&quot;&gt;passWord &#x3D; #&#123;passWord&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        nick_name &#x3D; #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">          id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id&#x3D;&quot;delete&quot; parameterType&#x3D;&quot;java.lang.Long&quot; &gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">           users </span><br><span class="line">       WHERE </span><br><span class="line">           id &#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试可以使用 SpringBootTest,也可以放到 Controller中，这里只贴 Controller 层的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User1Mapper user1Mapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User2Mapper user2Mapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUsers&quot;)</span><br><span class="line">    public List&lt;UserEntity&gt; getUsers() &#123;</span><br><span class="line">        List&lt;UserEntity&gt; users&#x3D;user1Mapper.getAll();</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">    public UserEntity getUser(Long id) &#123;</span><br><span class="line">        UserEntity user&#x3D;user2Mapper.getOne(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">    public void save(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;update&quot;)</span><br><span class="line">    public void update(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void delete(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">        user1Mapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;多数据源，一般都来解决主从模式或者业务比较复杂需要连接不同的分库来支持业务。我们遇到的情况是后者，网上找了很多，大都是根据 Jpa 来做多数据源解决方案，要不就是老的 Spring 多数据源解决方案，还有的是利用 Aop 动态切换，过于复杂，当前已Mybatis Xml为例，简单配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="http://JavaSsun.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis多数据源配置" scheme="http://JavaSsun.github.io/tags/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>LinkList实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-17T11:10:10.000Z</published>
    <updated>2020-04-16T10:05:32.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</p><p>All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</p><p>Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list</p><p>由上述注释中可以大概得知： LinkedList 是由一个双向链表来实现的，它允许插入所有元素，包括 null，同时，它是线程不同步的。</p><a id="more"></a><p>双向链表结构示意图：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/01a8426b-2594-400f-8475-71d402cb4550.png" alt><br>双向链表每个结点除了数据域之外，还有一个前指针和后指针，分别指向前驱结点 和后继结点（如果有前驱/后继的话）。另外，双向链表还有一个 first 指针，指向头 节点，和 last 指针，指向尾节点。</p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;链表的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向头节点的指针</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向尾节点的指针</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>LinkedList属性非常少，由上述三个属性基本可以知道他是怎么实现的。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h2><p>Node 是在 LinkedList 里定义的一个静态内部类，它表示链表每个节点的结构，包括一个数据域 item，一个后置指针 next，一个前置指针 prev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2 添加元素"></a>2 添加元素</h2><p>对于链表这种数据结构来说，添加元素的操作无非就是在表头/表尾插入元素，又或 者在指定位置插入元素。因为 LinkedList 有头指针和尾指针，所以在表头或表尾进 行插入元素只需要 O(1) 的时间，而在指定位置插入元素则需要先遍历一下链表， 所以复杂度为 O(n)。</p><p>在表头添加元素的过程如下：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/04a15498-61a8-41a2-933e-f1da8796db53.png" alt></p><p>当向表头插入一个节点时，很显然当前节点的前驱一定为 null，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节<br>点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点， 源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向 null，后继指针原来的头节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">    &#x2F;&#x2F;头指针指向新的头节点</span><br><span class="line">    first &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有头节点，则更新原来节点的前驱指针，否则更新尾指针</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在表尾添加元素跟在表头添加元素大同小异，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/241772bf-9089-4aa3-9636-5d5e59215f01.png" alt></p><p>当向表尾插入一个节点时，很显然当前节点的后继一定为 null，而前驱结点是 last 指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾 节点的后继指针，使它指向新的尾节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向尾节点，后继指向 null</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    &#x2F;&#x2F;尾指针指向新的尾节点</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有尾节点，则更新原来节点的后继指针，否则更新头指针</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在指定节点之前插入，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/ee88f767-33ee-4e11-ba24-bdfb1413ad86.png" alt></p><p>当向指定节点之前插入一个节点时，当前节点的后继为指定节点，而前驱结点为指 定节点的前驱节点。此外，还要修改前驱节点的后继为当前节点，以及后继节点的 前驱为当前节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;指定节点的前驱</span><br><span class="line">    final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱为指点节点的前驱，后继为指定的节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    &#x2F;&#x2F;更新指定节点的前驱为当前节点</span><br><span class="line">    succ.prev &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;更新前驱节点的后继</span><br><span class="line">    if (pred &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        pred.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3 删除元素"></a>3 删除元素</h2><p>删除操作与添加操作大同小异，例如删除指定节点的过程如下图所示，需要把当前 节点的前驱节点的后继修改为当前节点的后继，以及当前节点的后继结点的前驱修 改为当前节点的前驱</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/571734ca-b358-465a-8bba-0c785301a2c7.png" alt></p><p>删除头节点和尾节点跟删除指定节点非常类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头节点，返回表头元素的值</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next; &#x2F;&#x2F;头指针指向后一个节点</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;新头节点的前驱为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾节点，返回表尾元素的值</span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev; &#x2F;&#x2F;尾指针指向前一个节点</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null; &#x2F;&#x2F;新尾节点的后继为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定节点，返回指定元素的值 </span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next; &#x2F;&#x2F;当前节点的后继</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev; &#x2F;&#x2F;当前节点的前驱</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next; &#x2F;&#x2F;更新前驱节点的后继为当前节点的后继</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev; &#x2F;&#x2F;更新后继节点的前驱为当前节点的前驱</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取元素"><a href="#4-获取元素" class="headerlink" title="4 获取元素"></a>4 获取元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取表头元素</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取表尾元素 </span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据下标是否超过链表长度的一半，来选择从头部开始遍历还是从尾部</span><br><span class="line">开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-常用方法"><a href="#5-常用方法" class="headerlink" title="5 常用方法"></a>5 常用方法</h2><p>上述方法都不是 public 的，LinkedList 是在这些基础的方法进行操作的，下面就来看看可以调用的方法有哪些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头元素 </span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾元素</span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表头节点</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表尾节点</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;链表的大小</span><br><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表尾</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index); &#x2F;&#x2F;先检查是否越界</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;替换指定下标的值</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">    E oldVal &#x3D; x.item;</span><br><span class="line">    x.item &#x3D; element;</span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在指定位置插入节点</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定下标的节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空抛出异常</span><br><span class="line">public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，并删除表头节点，表头为空返回 null</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表头</span><br><span class="line">public void push(E e) &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表头元素</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>1、LinkedList 的底层结构是一个带头/尾指针的双向链表，可以快速的对头/尾节点 进行操作。</p><p>2、相比数组，链表的特点就是在指定位置插入和删除元素的效率较高，但是查找的 效率就不如数组那么高了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;源码中的一段注释，提取关键信息&lt;/p&gt;
&lt;p&gt;Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).&lt;/p&gt;
&lt;p&gt;All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.&lt;/p&gt;
&lt;p&gt;Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list&lt;/p&gt;
&lt;p&gt;由上述注释中可以大概得知： LinkedList 是由一个双向链表来实现的，它允许插入所有元素，包括 null，同时，它是线程不同步的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList实现原理_探险</title>
    <link href="http://javassun.github.io/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
    <id>http://javassun.github.io/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</id>
    <published>2019-11-16T09:58:10.000Z</published>
    <updated>2020-04-16T10:05:19.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p><p>由上文注释可以大概得知：ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认容量的大小</span><br><span class="line">private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空数组常量</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的空数组常量</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存放元素的数组，可以发现 ArrayList 的底层实现就是一个 Object数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组中包含的元素个数</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组的最大上限 </span><br><span class="line">private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALU E - 8;</span><br></pre></td></tr></table></figure><p>ArrayList 的属性非常少，就只有这些。其中最重要的莫过于 elementData 了，ArrayList 所有的方法都是建立在 elementData 之上。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity]; </span><br><span class="line">    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中可以看出，默认情况下，elementData 是一个大小为 0 的空数组，当我们指定了初始大小的时候，elementData 的初始大小就变成了我们所指定的初始大小了。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; size)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg (index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 ArrayList 是采用数组结构来存储的，所以它的 get 方法非常简单，先是判断一下有没有越界，之后就可以直接通过数组下标来获取元素了，所以 get 的时间复杂 度是 O(1)。</p><h2 id="3-add方法"><a href="#3-add方法" class="headerlink" title="3 add方法"></a>3 add方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    &#x2F;&#x2F;调用一个 native 的复制方法，把 index 位置开始的元素都往后挪一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, inde x + 1, size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacit y);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 的 add 方法也很好理解，在插入元素之前，它会先检查是否需要扩容，然 后再把元素添加到数组中最后一个元素的后面。在 ensureCapacityInternal 方法中， 可以看见，如果当 elementData 为空数组时，它会使用默认的大小去扩容。所以 说，通过无参构造方法来创建 ArrayList 时，它的大小其实是为 0 的，只有在使用到 的时候，才会通过 grow 方法去创建一个大小为 10 的数组。<br>第一个 add 方法的复杂度为 O(1)，虽然有时候会涉及到扩容的操作，但是扩容的次 数是非常少的，所以这一部分的时间可以忽略不计。如果使用的是带指定下标的 add 方法，则复杂度为 O(n)，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p><h2 id="4-set方法"><a href="#4-set方法" class="headerlink" title="4 set方法"></a>4 set方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 方法的作用是把下标为 index 的元素替换成 element，跟 get 非常类似，时间复杂度度为 O(1)。</p><h2 id="5-remove方法"><a href="#5-remove方法" class="headerlink" title="5 remove方法"></a>5 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(inderemove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。x);</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its wo rk</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。</p><h2 id="6-grow方法"><a href="#6-grow方法" class="headerlink" title="6 grow方法"></a>6 grow方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; minCapacity is usually close to size, so this is a wi n:</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 方法是在数组进行扩容的时候用到的，从中可以看见，ArrayList 每次扩容 都是扩 1.5 倍，然后调用 Arrays 类的 copyOf 方法，把元素重新拷贝到一个新的数组 中去。</p><h2 id="7-ize方法"><a href="#7-ize方法" class="headerlink" title="7 ize方法"></a>7 ize方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size 方法非常简单，它是直接返回 size 的值，也就是<strong>数组中元素的个数</strong>间 复杂度为 O(1)。这里要注意一下，返回的并不是数组的实际大小。</p><h2 id="8-indexOf-amp-lastIndexOf"><a href="#8-indexOf-amp-lastIndexOf" class="headerlink" title="8 indexOf &amp; lastIndexOf"></a>8 indexOf &amp; lastIndexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf 方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组 中每个元素的值来查找的，所以它的时间复杂度是 O(n)。</p><p>lastIndexOf 的原理跟 indexOf 一样，而它仅仅是从后往前找起罢了。</p><h1 id="四-Vector"><a href="#四-Vector" class="headerlink" title="四 Vector"></a>四 Vector</h1><p>很多方法都跟 ArrayList 一样，只是多加了个 synchronized 来保证线程安全,主要汇总二者不同点</p><p>Vector 比 ArrayList 多了一个属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩 capacityIncrement 个空间就 足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    this.capacityIncrement &#x3D; capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中，可以看出 Vector 的默认大小也是 10，而且它在初始化的时候就 已经创建了数组了，这点跟 ArrayList 不一样。再来看一下 grow 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 grow 方法中可以发现，newCapacity 默认情况下是两倍的 oldCapacity，而当 指定了 capacityIncrement 的值之后，newCapacity 变成了 oldCapacity+capacityIncrement。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h1><p>1、ArrayList 创建时的大小为 0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10</p><p>2、ArrayList 每次扩容都以当前数组大小的 1.5 倍去扩容。  3、Vector 创建时的默认大小为 10</p><p>4、Vector 每次扩容都以当前数组大小的 2 倍去扩容。当指定了 capacityIncrement 之 后，每次扩容仅在原先基础上增加 capacityIncrement 个单位空间。</p><p>5、ArrayList 和 Vector 的 add、get、size 方法的复杂度都为 O(1)，remove 方法的复 杂度为 O(n)。</p><p>6、ArrayList 是非线程安全的，Vector 是线程安全的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerlink&quot; title=&quot;一 概述&quot;&gt;&lt;/a&gt;一 概述&lt;/h1&gt;&lt;p&gt;深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。&lt;/p&gt;
&lt;p&gt;源码中的一段注释，提取关键信息&lt;/p&gt;
&lt;p&gt;Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)&lt;/p&gt;
&lt;p&gt;由上文注释可以大概得知：ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
      <category term="源码解析" scheme="http://JavaSsun.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>10-OpenResty用Lua语言实现简单服务</title>
    <link href="http://javassun.github.io/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/"/>
    <id>http://javassun.github.io/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/</id>
    <published>2019-11-12T13:40:55.000Z</published>
    <updated>2020-05-08T09:47:56.349Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/93c7612e-307f-4fe2-84c8-ac0e13a042e0.png" alt></p><a id="more"></a><p><a href="http://openresty.org/cn/" target="_blank" rel="noopener">Openresty官方站点</a></p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5f3c391e-6f44-44af-b4f9-f02244dda8b2.png" alt></p><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/f9783f7c-7a09-47ac-9971-b437c34d1a86.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.15.8.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf openresty-1.15.8.3.tar.gz </span><br><span class="line"></span><br><span class="line">cd openresty-1.15.8.3</span><br><span class="line"></span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h3 id="2-分析目录结构"><a href="#2-分析目录结构" class="headerlink" title="2 分析目录结构"></a>2 分析目录结构</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/7944541f-db36-4847-a046-9d2cea4a65e0.png" alt></p><p>看出与 nginx相比 少了很多东西，都在 bundle模块下，核心为 nginx-x模块。</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/560b6198-f80c-43f2-b7e1-a109ffcfcb95.png" alt></p><p>主要分为 两大模块<br><strong>nginx c代码模块</strong>，通常以 ngx打头。<br><strong>lua模块</strong>，使用 ngx c代码模块提供的功能。</p><p>编译时也主要是编译 <strong>C模块</strong></p><p>观看 openresty 的configure模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p>基本没有什么不同，只不过集合了更多的第三方模块。<br><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/2c32f29e-6114-4fec-beb4-1b663cdef9e3.jpg" alt></p><h3 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认, &#96;--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#96; 程序会被安装到&#x2F;usr&#x2F;local&#x2F;openresty目录。</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="4-添加lua代码"><a href="#4-添加lua代码" class="headerlink" title="4 添加lua代码"></a>4 添加lua代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">因为被安装到了这里，所以进入这个目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">添加如下内容</span><br><span class="line"></span><br><span class="line">location &#x2F;lua &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        content_by_lua</span><br><span class="line">           &#39;ngx.say(&quot;User-Agent: &quot;, ngx.req.get_headers()[&quot;User-Agent&quot;])&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -c conf&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>浏览器输入 192.168.121.100:80</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5a886d20-993f-4a00-b51b-492b6fdbe3a7.png" alt></p><p>浏览器输入 192.168.121.100:80/lua</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/3abd7c85-86d2-47bd-94aa-d58a42498346.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;简单应用&quot;&gt;&lt;a href=&quot;#简单应用&quot; class=&quot;headerlink&quot; title=&quot;简单应用&quot;&gt;&lt;/a&gt;简单应用&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/93c7612e-307f-4fe2-84c8-ac0e13a042e0.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
      <category term="Openresty" scheme="http://JavaSsun.github.io/categories/Nginx/Openresty/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
      <category term="Openresty" scheme="http://JavaSsun.github.io/tags/Openresty/"/>
    
  </entry>
  
  <entry>
    <title>9-SSL-Nginx</title>
    <link href="http://javassun.github.io/2019/11/11/9-SSL-Nginx/"/>
    <id>http://javassun.github.io/2019/11/11/9-SSL-Nginx/</id>
    <published>2019-11-11T11:40:32.000Z</published>
    <updated>2020-05-08T09:44:29.057Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络安全是当前非常受到关注的一个问题，大部分站点都是通过 <strong>HTTPS</strong> 来实现安全访问。如何将自己的站点改造成 <strong>HTTPS</strong> 站点呢？我们需要了解 <strong>SSL</strong> 协议。</p><h2 id="知识普及"><a href="#知识普及" class="headerlink" title="知识普及"></a>知识普及</h2><ul><li>TLS/SSL 发展历程<br><img src="/2019/11/11/9-SSL-Nginx/c97e2236-9c76-47a7-8101-c6a81360c5d0.jpg" alt><a id="more"></a></li><li>TLS安全密码套件解读</li></ul><p>抓包或者观察服务器端的配置时，可看到下图</p><p><img src="/2019/11/11/9-SSL-Nginx/b90659c2-af11-44dd-96c1-e06f39232949.jpg" alt></p><h3 id="概要介绍"><a href="#概要介绍" class="headerlink" title="概要介绍"></a>概要介绍</h3><p><strong>ECDHE</strong>: 密钥交换算法（此处是一个椭圆曲线加密算法），用来解决浏览器与服务器则那样独立生成相同的密钥，接下来会用此密钥加密数据。</p><p><strong>RSA</strong>: 身份验证算法。密钥交换过程中，需要验证各自身份。</p><p>数据加密、解密时要用到对称加密算法，即 <strong>AES_128_GCM</strong></p><p><strong>AES</strong>: 算法名称</p><p><strong>128</strong>：AES支持3种加密强度，此处使用 128</p><p><strong>GCM</strong>：AES有很多分组模式，GCM是较新的一种模式，可以提高多核CPU下加解密的性能。</p><p><strong>SHA256</strong>: 摘要算法，用来把不定长度的字符串生成一个固定长度的更短的摘要。</p><h4 id="对称加密-VS-非对称加密"><a href="#对称加密-VS-非对称加密" class="headerlink" title="对称加密 VS 非对称加密"></a>对称加密 VS 非对称加密</h4><h5 id="对称加密（同一把密钥）"><a href="#对称加密（同一把密钥）" class="headerlink" title="对称加密（同一把密钥）"></a>对称加密（同一把密钥）</h5><p><img src="/2019/11/11/9-SSL-Nginx/5e4ccaf3-a19e-418e-91a8-618eebf304d0.jpg" alt></p><p>使用相同的 密钥序列 进行 异或运算，第一次加密，再异或一次即解密。<br><img src="/2019/11/11/9-SSL-Nginx/4252405b-8e3e-4396-97aa-e0862c67a72f.jpg" alt></p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>同一份文档，用<strong>公钥</strong>加密的，只能用对应的<strong>私钥</strong>进行解密</p><p><img src="/2019/11/11/9-SSL-Nginx/3d318d9b-74f0-49b5-8ef1-53c5eb195619.jpg" alt></p><ul><li><p>文档加密</p></li><li><p>身份验证</p></li></ul><h4 id="SSL证书公信力的保证"><a href="#SSL证书公信力的保证" class="headerlink" title="SSL证书公信力的保证"></a>SSL证书公信力的保证</h4><p>爱丽丝 与 鲍勃 进行通信，但有个前提条件，爱丽丝就是爱丽丝，鲍勃就是鲍勃，这样一个新问题，在多方通讯过程中必须有一个公信机构，即 <strong>CA机构</strong></p><p><strong>CA是怎样颁发证书，使证书过期的呢?</strong></p><p><strong>PKI公钥基础设施</strong><br><img src="/2019/11/11/9-SSL-Nginx/f539cc97-f8b6-421f-80a3-47ee62687cfd.jpg" alt></p><p><font color="red">流程：</font></p><p>图中的<strong>CA</strong>即是一个公信机构，用来颁发证书的。</p><p>我们作为一个站点的维护者，就是一个 <strong>证书订阅人</strong>，首先我们要去申请一个证书，必要要登记（我是谁、我属于什么组织、我想做什么）</p><p>到了登记机构后，通过 <strong>CSR</strong> 发送给 <strong>CA</strong>，申请通过后。</p><p><strong>CA</strong>会生成一对公私钥，公钥保存在CA的证书链中，公私钥被证书订阅人拿到后。</p><p><strong>证书订阅人</strong> 会把拿到的公私钥部署到自己的 <strong>Web服务器</strong>，如 Nginx服务器等。</p><p>当 <strong>浏览器</strong>通过 第 1 步 访问我们的 HTTPS站点时，会去请求我们的证书，而Nginx这样的Web站点服务器 会将我们的 <strong>公钥证书</strong> 发给我们的浏览器。 浏览器需要去验证 我们颁发给他的证书是否 <strong>合法有效</strong></p><p>如果我们用 <strong>Let’s encrypt</strong> 会发现证书只有 90天的有效期。而用其他的SSL-CA可能会有1年的有效期。</p><p><strong>有效期如何体现</strong>： CA中心 会把过期的证书放到 <strong>CRL服务器</strong>中</p><p><strong>CRL服务器</strong>会把所有的过期证书形成一个很长很长的链条，性能极差。</p><p>所以又推出一个称为 <strong>OCSP响应程序</strong>，它可以就一个证书去查询是否过期。 因此 <strong>浏览器</strong>可以直接查询 <strong>OCSP响应程序</strong>，但 OCSP 性能依然不高。</p><p>因此，我们的 <strong>Nginx Web服务器</strong> 往往会有一个 <strong>OCSP开关</strong>，当打开时，会由 <strong>Nginx</strong> 主动地去<strong>OCSP</strong>查询, 这样，大量的客户端可以直接从 <strong>Nginx</strong> 服务器获取到证书是否有效。</p><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><p><img src="/2019/11/11/9-SSL-Nginx/9f804386-3565-4c92-8a82-ae32e6a9afaa.jpg" alt></p><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>浏览器对 DV OV EV 验证效果是一样的，唯一区别的 就是他的 证书链。</p><p><img src="/2019/11/11/9-SSL-Nginx/a6f3f984-33c9-46cc-a6e8-842e9849c9f5.jpg" alt></p><p>目前所有站点的 主证书都是有 3级结构。<strong>根证书、二级证书、主证书</strong>。</p><p>为什么形成这样的3级证书结构呢？</p><p>那是因为 根证书的 验证十分谨慎，像 Window 、 Android 等操作系统 每 1年以上才会去更新它的根证书库。所以，一个新的根证书库CA机构是很难快速加入到操作系统、浏览器认可的证书库中的。</p><p>大部分浏览器使用的是操作系统的根证书库，像Firefox可能会维护自己的根证书库。所以浏览器在验证我们的证书是否有效时，最主要是验证 根证书是否无过期，有效。</p><p>Nginx 服务器向 浏览器发送 两个证书（主证书、二级证书）即可。根证书是被操作系统、浏览器内置的，无需发送。</p><h4 id="SSL协议握手时Nginx的性能瓶颈"><a href="#SSL协议握手时Nginx的性能瓶颈" class="headerlink" title="SSL协议握手时Nginx的性能瓶颈"></a>SSL协议握手时Nginx的性能瓶颈</h4><h5 id="TLS通讯过程"><a href="#TLS通讯过程" class="headerlink" title="TLS通讯过程"></a>TLS通讯过程</h5><p><img src="/2019/11/11/9-SSL-Nginx/64515879-b4e9-46d9-85f0-49ad2d5f8b86.png" alt></p><p><font color="red">流程：</font></p><ul><li><p>1 Client Hello 浏览器发给服务器。因为我们的浏览器是非常多元化的。Chrome、IE、FireFox等。浏览器的版本也在不停的变更。不同的浏览器所支持的安全套件、加密算法是不同的。因此在第一步，主要是告诉服务器，我支持哪些算法。</p></li><li><p>2 Server Hello 如 Nginx会有一个自己知道自己可支持的加密算法列表，以及自己倾向于使用哪一个加密算法套件，Nginx会选择自己最喜欢的一个加密算法套件发送给客户端。如果想复用 Session，即 Nginx 打开了 Session Cache ，希望一天内断开了连接的客户端，不用再次协商密钥，在这一步可以直接复用之前的密钥。因此 这一步主要是发送 究竟我们选择哪一个安全套件</p></li><li><p>3 Server Certificates 会把自己的公钥证书发送给浏览器，公钥证书中是包含证书链的，所以浏览器可以找到自己的跟证书库，去验证证书是否有效。<strong>Check Certificate validity</strong></p></li><li><p>4 Server Hello Done 服务器会发送此消息，但如果之前协商的安全套件，如椭圆曲线算法，此时需要在 3 与 4 之间 将椭圆曲线的参数发送给客户端。以方便我们在 6 生成最终加密的密钥。</p></li><li><p>5 ClientKey Exchange Message 客户端也需要根据椭圆曲线的公共参数生成自己的私钥后，将公钥发送给服务器。此时，服务器也有了自己的私钥，将公钥发送给客户端。</p></li><li><p>6  Key generation 服务器可以根据自己的私钥和客户端的公钥共同生成双方加密的密钥， 客户端可以根据自己的私钥和服务器的公钥共同生成双方加密的密钥。这两个各自生成的密钥是相同的。这是由 非正式加密算法来保证的。</p></li><li><p>7 CipherSpec Exchange Finished 接下来就可以用生成的密钥进行数据加密与通讯了。</p></li></ul><p><strong>由上述过程可以看到，TLS通讯过程主要是做 交换密钥 + 加密数据</strong>，这两个最耗费性能。</p><h5 id="Nginx优化性能"><a href="#Nginx优化性能" class="headerlink" title="Nginx优化性能"></a>Nginx优化性能</h5><p>对于小文件。握手是主要影响他 QPS性能的主要指标</p><p><img src="/2019/11/11/9-SSL-Nginx/cc318a18-f172-4688-8496-aa81fbf22abc.jpg" alt></p><h5 id="Nginx数据加密性能"><a href="#Nginx数据加密性能" class="headerlink" title="Nginx数据加密性能"></a>Nginx数据加密性能</h5><p><img src="/2019/11/11/9-SSL-Nginx/b18c290e-fbd4-4cf5-8ffe-199e8b7ccdcf.jpg" alt></p><h5 id="Nginx综合性能"><a href="#Nginx综合性能" class="headerlink" title="Nginx综合性能"></a>Nginx综合性能</h5><p>当以小文件为主时，考虑优化Nginx非对称加密性能（椭圆曲线）。<br>当以大文件为主时，考虑优化Nginx非对称加密性能（AES）。<br><img src="/2019/11/11/9-SSL-Nginx/f926e156-3fa6-4969-9b6e-70b174299402.jpg" alt></p><h2 id="免费SSL实现HTTPS站点"><a href="#免费SSL实现HTTPS站点" class="headerlink" title="免费SSL实现HTTPS站点"></a>免费SSL实现HTTPS站点</h2><p><strong>前提：</strong></p><ol><li>拥有一个域名，且ICP备案。</li><li>在域名服务器创建一条A记录，指向云主机的公网IP地址。例如demo.mydomain.com指向xxx.xxx.xxx.xxx的IP地址。</li><li>要等到新创建的域名解析能在公网上被解析到。</li></ol><p><img src="/2019/11/11/9-SSL-Nginx/a12032d4-c88b-4387-aec6-9fd44a280024.jpg" alt></p><p>演示如何使用 <strong>Let’s encrypt</strong> 生成免费的DV证书，将网站改造为 https站点。</p><h3 id="1-http协议请求标识"><a href="#1-http协议请求标识" class="headerlink" title="1 http协议请求标识"></a>1 http协议请求标识</h3><p><img src="/2019/11/11/9-SSL-Nginx/df826605-29a0-4e52-a185-b581eb423338.jpg" alt><br>没有小锁，说明现在是一个 http请求。</p><h3 id="2-Nginx-conf配置"><a href="#2-Nginx-conf配置" class="headerlink" title="2 Nginx.conf配置"></a>2 Nginx.conf配置</h3><p><img src="/2019/11/11/9-SSL-Nginx/d19e0b8a-2dcf-49ed-bba7-ba4aff4eb8f6.jpg" alt></p><p>在<strong>server</strong>中，有一个 server_name，这个域名会被 <strong>Let’s encrypt</strong>脚本所使用，<strong>location</strong> 指向了一个具体的文件</p><h3 id="3-脚本安装与使用"><a href="#3-脚本安装与使用" class="headerlink" title="3 脚本安装与使用"></a>3 脚本安装与使用</h3><p><a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install python2-certbot-nginx</span><br><span class="line"></span><br><span class="line">不成功的话，下面方法可以考虑，但要慎用，因为要做全面更新</span><br><span class="line"></span><br><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum install python2-certbot-nginx</span><br></pre></td></tr></table></figure><p>该工具会提供一个命令  <strong>certbot</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx --nginx-server-root&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openrestry&#x2F;nginx&#x2F;conf&#x2F; -d geektime.taohui.pub</span><br></pre></td></tr></table></figure><p>–nginx 会为nginx的配置文件自动执行相应的修改，通常默认会去修改 /usr/local/nginx/conf/ 下的配置文件，但此处因为路径不同，所以使用</p><p>–nginx-server-port 单独指定nginx.conf所在路径。</p><p>-d 指定 申请证书的域名。</p><p><img src="/2019/11/11/9-SSL-Nginx/8e6b10a7-a712-4016-b9b9-47d352a53654.jpg" alt></p><p>首先会去获取一个证书，验证证书，投放证书到配置文件。<br>1：不做重定向。（此处选择1）<br>2：做重定向。</p><p>区别：当有了 https站点后，希望所有的http流量，明文显示的不安全流量都是用 301 、302重定向协议转到https站点。</p><p><strong>HTTPS站点标识</strong><br><img src="/2019/11/11/9-SSL-Nginx/75ac2b42-8b6c-4479-ab0c-8ca3953cd045.jpg" alt></p><p>此时查看 nginx.conf,增加了5行</p><p><img src="/2019/11/11/9-SSL-Nginx/4fa55fe8-ee24-4191-9cf2-6de0f40a54bf.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">监听443端口 使用ssl协议</span><br><span class="line"></span><br><span class="line">ssl_certificate 、 ssl_certificate_key 分别为公私钥证书部署到对应的路径中。</span><br><span class="line"></span><br><span class="line">include 通用参数加了进来</span><br><span class="line"></span><br><span class="line">ssl_dhparam:表示使用非对称加密时，使用怎样的参数，这些参数决定网络加密的强度</span><br></pre></td></tr></table></figure><p>看一下 <code>/etc/letsencrypt/options-ssl-nginx.conf</code></p><p><img src="/2019/11/11/9-SSL-Nginx/9217ebcd-3850-4766-b60a-2b12cb122f05.jpg" alt></p><p>ssl中最降低性能的就是握手，因此设置了一个 ssl_session_cache ，大小为1M。在 1440m（分钟）即1天 时间内可以复用之前的。</p><p>ssl_protocols: ssl支持哪些版本的协议。</p><p>ssl_perfer_server_ciphers on 表示nginx服务器使用那些协议与浏览器进行通讯。</p><p>ssl_ciphers 中的安全套件以 分号为分隔符。排在前面的会优先使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;网络安全是当前非常受到关注的一个问题，大部分站点都是通过 &lt;strong&gt;HTTPS&lt;/strong&gt; 来实现安全访问。如何将自己的站点改造成 &lt;strong&gt;HTTPS&lt;/strong&gt; 站点呢？我们需要了解 &lt;strong&gt;SSL&lt;/strong&gt; 协议。&lt;/p&gt;
&lt;h2 id=&quot;知识普及&quot;&gt;&lt;a href=&quot;#知识普及&quot; class=&quot;headerlink&quot; title=&quot;知识普及&quot;&gt;&lt;/a&gt;知识普及&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;TLS/SSL 发展历程&lt;br&gt;&lt;img src=&quot;/2019/11/11/9-SSL-Nginx/c97e2236-9c76-47a7-8101-c6a81360c5d0.jpg&quot; alt&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
      <category term="SSL" scheme="http://JavaSsun.github.io/categories/Nginx/SSL/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
      <category term="SSL" scheme="http://JavaSsun.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>8-Nginx配置文件简易解析</title>
    <link href="http://javassun.github.io/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/"/>
    <id>http://javassun.github.io/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/</id>
    <published>2019-11-10T10:03:05.000Z</published>
    <updated>2020-05-07T03:36:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png" alt></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#运行用户</span><br><span class="line">user nobody;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"></span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # nginx作为http服务器的时候</span><br><span class="line"># max_clients &#x3D; worker_processes * worker_connections</span><br><span class="line">    # nginx作为反向代理服务器的时候：</span><br><span class="line">#max_clients &#x3D; worker_processes * worker_connections &#x2F; 4  </span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6].&quot;;</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"></span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"></span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs&#x2F;nginx.access.log  main;</span><br><span class="line"></span><br><span class="line">        #默认请求</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^&#x2F;(images|javascript|js|css|flash|media|static)&#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ &#x2F;.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png&quot; alt&gt;)&lt;img src=&quot;/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png&quot; alt&gt;)&lt;img src=&quot;/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>7-Nginx安装详解</title>
    <link href="http://javassun.github.io/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</id>
    <published>2019-11-09T11:01:02.000Z</published>
    <updated>2020-05-06T12:28:27.683Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx是一款轻量级高性能的Web服务器/反向代理服务器，</p><p>并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，<br>中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><a id="more"></a><h1 id="1-新方法安装"><a href="#1-新方法安装" class="headerlink" title="1 新方法安装"></a>1 新方法安装</h1><p><strong>Nginx是C语言开发，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. gcc安装</span><br><span class="line">yum install gcc-c++</span><br><span class="line">2. PCRE pcre-devel安装</span><br><span class="line">PCRE（Perl Compatible Regular Expressions）是一个Perl库，包括perl兼容的正则表达式。Nginx的http模块使用pcre来解析正则表达式。所以需要在linux安装pcre库。pcre-devel是pcre开发的一个二次开发库，nginx也需要此命令。</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">3. zlib安装</span><br><span class="line">zlib库提供了很多种压缩和解压额方式，Nginx使用zlib对http包的内容进行gzip，所以需要</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">4. Open-SSL安装</span><br><span class="line">OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法，常用的密钥和证书封装管理功能以及SSL协议，并提供丰富的应用程序供测试或其他目的。</span><br><span class="line">Nginx不仅支持http协议，还支持https（在ssl协议上传输http）,所以需要安装OpenSSL库</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h1 id="2-老方法安装"><a href="#2-老方法安装" class="headerlink" title="2 老方法安装"></a>2 老方法安装</h1><ol><li><p>安装gcc</p><p> rpm -Uvh glibc-2.12-1.209.el6_9.2.x86_64.rpm glibc-common-2.12-1.209.el6_9.2.x86_64.rpm libgcc-4.4.7-18.el6_9.2.x86_64.rpm tzdata-2018e-3.el6.noarch.rpm </p><p> rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm cpp-4.4.7-18.el6_9.2.x86_64.rpm glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm     kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm libgomp-4.4.7-18.el6_9.2.x86_64.rpm mpfr-2.4.1-6.el6.x86_64.rpm ppl-0.10.2-11.el6.x86_64.rpm </p><p> rpm -ivh gcc-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装gcc-c++<br> rpm -Uvh libstdc++-4.4.7-18.el6_9.2.x86_64.rpm<br> rpm -ivh libstdc++-devel-4.4.7-18.el6_9.2.x86_64.rpm  gcc-c++-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装pcre<br> tar -zxvf pcre-8.40.tar.gz<br> cd pcre-8.40<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装zlib</p><p> tar -zxvf zlib-1.2.11.tar.gz<br> cd zlib-1.2.11<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装启动</p><p> ./configure –prefix=/usr/local/nginx  配置nginx 并且指定nginx的安装目录</p><p> make &amp;&amp; make install</p><p> cd /usr/local/nginx/sbin</p><p> netstat -ano | grep 80     //检查80端口是否占用</p><p> ./nginx -c /usr/local/nginx/conf/nginx.conf</p><p> 注意：</p><pre><code>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：ln -s /usr/local/lib/libpcre.so.1 /lib64/</code></pre></li></ol><hr><p>Nginx运行和控制<br>    /usr/local/nginx/sbin/nginx 命令</p><pre><code>nginx命令参数：不像许多其他软件系统，Nginx 仅有几个命令行参数，完全通过配置文件来配置。参数如下：-s reload | reopen | stop 进程相关（重新载入配置文件 | 重启Nginx | 停止Nginx）-c &lt;/path/to/config&gt; 为 Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。-v 显示 nginx 的版本。-V 显示 nginx 的版本，编译器版本和配置参数。</code></pre><hr><p>nginx负载均衡</p><p>1.常用的负载均衡策略<br>    a. 轮询（默认）<br>    每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>    upstream backserver {<br>        server 192.168.0.14;<br>        server 192.168.0.15;<br>    }<br>    b. 指定权重<br>    指定轮询几率（权重默认为1），weight和访问比率成正比，用于后端服务器性能不均的情况。<br>    upstream backserver {<br>        server 192.168.0.14 weight=10;<br>        server 192.168.0.15 weight=10;<br>    }<br>    c. IP绑定 ip_hash<br>    每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>    upstream backserver {<br>        ip_hash;<br>        server 192.168.0.14:88;<br>        server 192.168.0.15:80;<br>    }</p><ol start="2"><li><p>完整配置</p><p> #添加tomcat列表，真实应用服务器都放在这<br> upstream tomcat_pool {</p><pre><code>#server tomcat地址:端口号 weight表示权值，权值越大，被分配的几率越大;</code></pre><p>　　    server 192.168.0.223:8080 weight=4 max_fails=2 fail_timeout=30s;<br> 　　server 192.168.0.224:8080 weight=4 max_fails=2 fail_timeout=30s;<br> }</p><p> server{</p><pre><code>......</code></pre></li></ol><pre><code>    location / {        proxy_pass    http://tomcat_pool;    #转向tomcat处理    }    ......}</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Nginx是一款轻量级高性能的Web服务器/反向代理服务器，&lt;/p&gt;
&lt;p&gt;并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，&lt;br&gt;中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>6-GoAccess实现可视化并实时监控access日志</title>
    <link href="http://javassun.github.io/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/"/>
    <id>http://javassun.github.io/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</id>
    <published>2019-11-08T12:00:25.000Z</published>
    <updated>2020-05-07T05:33:58.691Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>access日志</strong> 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。使用 cat、awk、sed 等命令做一些简单的日志分析统计，这样分析结果不理想也不全面，方法也极不高效。</p><p><strong>GoAccess</strong> 这款工具以图形化的方式通过<strong>web socket</strong>协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。</p><a id="more"></a><h2 id="1-Nginx配置"><a href="#1-Nginx配置" class="headerlink" title="1 Nginx配置"></a>1 Nginx配置</h2><p>为了提高 GoAccess 分析准确度，需要配置 <code>nginx.conf</code> 的 log_format 项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_body&quot;&#39;;</span><br></pre></td></tr></table></figure><h2 id="2-安装GoAccess"><a href="#2-安装GoAccess" class="headerlink" title="2 安装GoAccess"></a>2 安装GoAccess</h2><p><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess</a> 是这个工具的站点。如图所示：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/629f3358-d5c5-4889-b24f-bc4e6a87c46b.png" alt></p><p>先看一下之前静态web资源服务器所产生的access log日志格式<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/9f36080a-71ba-4c59-82e8-226d730d87a1.png" alt></p><p>现在打开 GoAccess中的 <strong>Get started</strong>快速开始页面，依据文档下载安装。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/615f6899-491f-4f74-a245-feb5f3a9c0b3.png" alt></p><p>先下载依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y GeoIP-devel</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;maxmind&#x2F;geoip-api-c&#x2F;releases&#x2F;download&#x2F;v1.6.11&#x2F;GeoIP-1.6.11.tar.gz</span><br><span class="line">tar -zxvf GeoIP-1.16.11.tar.gz</span><br><span class="line">cd GeoIP-1.16.11</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;tar.goaccess.io&#x2F;goaccess-1.3.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.3.tar.gz</span><br><span class="line">cd goaccess-1.3&#x2F;</span><br><span class="line">.&#x2F;configure --enable-utf8 --enable-geoip&#x3D;legacy --with-openssl  &#x2F;&#x2F;此处出现错误如下 安装下面依赖后回来继续安装即可</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>出现错误：<br>configure: error: *** Missing development libraries for ncursesw</p><p>解决方法：<br>要使用–enable-utf8，你需要安装ncursesw，下面是安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun goaccess]# sudo yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>安装成功后：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/dae8664f-26c8-45d9-b7ae-957833eae1fa.png" alt></p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h2><p>安装完成后，默认将配置文件<code>goaccess.conf</code>放置于<code>/usr/local/etc</code>路径，为了统一管理，使用<code>mv /usr/local/etc/goaccess.conf /etc/</code>命令将其移动到<code>/etc</code>目录下。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/5a428874-2d04-42df-ad85-07cbbc719e50.png" alt></p><p>对配置文件做一些主要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;goaccess.conf</span><br><span class="line"></span><br><span class="line">time-format %H:%M:%S</span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br><span class="line">log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/2120efc0-f319-469d-a88e-8639b9f58a17.png" alt></p><p>其中，log-format 与 access.log 的 log_format 格式对应，每个参数以空格或者制表符分割。参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%t  匹配time-format格式的时间字段</span><br><span class="line">%d  匹配date-format格式的日期字段</span><br><span class="line">%h  host(客户端ip地址，包括ipv4和ipv6)</span><br><span class="line">%r  来自客户端的请求行</span><br><span class="line">%m  请求的方法</span><br><span class="line">%U  URL路径</span><br><span class="line">%H  请求协议</span><br><span class="line">%s  服务器响应的状态码</span><br><span class="line">%b  服务器返回的内容大小</span><br><span class="line">%R  HTTP请求头的referer字段</span><br><span class="line">%u  用户代理的HTTP请求报头</span><br><span class="line">%D  请求所花费的时间，单位微秒</span><br><span class="line">%T  请求所花费的时间，单位秒</span><br><span class="line">%^  忽略这一字段</span><br></pre></td></tr></table></figure><h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4 命令"></a>4 命令</h2><p>查看 GoAccess 命令参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -h</span><br><span class="line"># 常用参数</span><br><span class="line">-a --agent-list 启用由主机用户代理的列表。为了更快的解析，不启用该项</span><br><span class="line">-d --with-output-resolver 在HTML&#x2F;JSON输出中开启IP解析，会使用GeoIP来进行IP解析</span><br><span class="line">-f --log-file 需要分析的日志文件路径</span><br><span class="line">-p --config-file 配置文件路径</span><br><span class="line">-o --output 输出格式，支持html、json、csv</span><br><span class="line">-m --with-mouse 控制面板支持鼠标点击</span><br><span class="line">-q --no-query-string 忽略请求的参数部分</span><br><span class="line">--real-time-html 实时生成HTML报告</span><br><span class="line">--daemonize 守护进程模式，--real-time-html时使用</span><br></pre></td></tr></table></figure><h2 id="5-控制台模式"><a href="#5-控制台模式" class="headerlink" title="5 控制台模式"></a>5 控制台模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log -p &#x2F;etc&#x2F;goaccess.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/8378f7b8-273a-4740-8ceb-4d961484c9e7.png" alt></p><p>控制台下的操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F1 主帮助页面</span><br><span class="line">F5 重绘主窗口</span><br><span class="line">q 退出</span><br><span class="line">1-15 跳转到对应编号的模块位置 </span><br><span class="line">o 打开当前模块的详细视图</span><br><span class="line">j 当前模块向下滚动</span><br><span class="line">k 当前模块向上滚动</span><br><span class="line">s 对模块排序</span><br><span class="line">&#x2F; 在所有模块中搜索匹配</span><br><span class="line">n 查找下一个出现的位置</span><br><span class="line">g 移动到第一个模块顶部</span><br><span class="line">G 移动到最后一个模块底部</span><br></pre></td></tr></table></figure><h2 id="6-HTML模式"><a href="#6-HTML模式" class="headerlink" title="6 HTML模式"></a>6 HTML模式</h2><p>上游服务器（14）： /home/geek/nginx  其中的 nginx.conf 配置为 127.0.0.1:8080 即仅能本机访问。</p><p>代理服务器（16）： /usr/local/geek/openstry/nginx 其中 nginx.conf 配置了 upstream 来标明上游服务器的ip地址+端口号，同时也设置了相应的缓存，具体查看前几节文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html</span><br></pre></td></tr></table></figure><p>浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.121.100:80&#x2F;go-access.html 即可看到</span><br><span class="line"></span><br><span class="line">上述配置都是在上游nginx服务器中完成的</span><br><span class="line">此处是使用了代理服务器的80端口，由代理服务器替我们到上游服务器获取go-access.log 实时日志以html页面展示</span><br></pre></td></tr></table></figure><p>由下图可看到，确实是由 代理服务器替我们拿到的数据<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/1d80d359-8e05-421c-9637-e799599b0de8.png" alt></p><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><p>GoAccess 已经为我们考虑到这点了，它可以以 daemonize 模式运行，并提供创建实时 HTML 的功能，只需要在启动命令后追加<code>--real-time-html --daemonize</code>参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html --real-time-html --daemonize</span><br><span class="line"></span><br><span class="line"># 监听端口7890</span><br><span class="line">netstat -tunpl |grep &quot;goaccess&quot;</span><br><span class="line">tcp        0      0 0.0.0.0:7890            0.0.0.0:*               LISTEN      13212&#x2F;goaccess</span><br></pre></td></tr></table></figure><p>以守护进程启动 GoAccess 后，使用 Websocket 建立长连接，它默认监听 7890 端口，可以通过<code>--port</code>参数指定端口号。</p><blockquote><p>如果站点启用了 HTTPS, GoAccess 也需要使用 openssl，在配置文件<code>goaccess.conf</code>中配置<code>ssl-cert</code>和<code>ssl-key</code>项，并确保在安装过程中 configure 时已添加<code>--with-openssl</code>项来支持 openssl 。当使用 HTTPS 后 Websocket 通信时也应该使用 wss 协议，需要将<code>ws-url</code>项配置为<code>wss://www.domain.com</code>。</p></blockquote><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>在某些场景下，没有这样的实时性要求，可采用 crontab 机制实现定时更新 HTML 报表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 每天执行</span><br><span class="line"></span><br><span class="line">0 0 1 * * goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html 2&gt; &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;go-access.log</span><br></pre></td></tr></table></figure><p>当access 日志被切割后，怎么合理使用 GoAccess 分析日志，<code>--keep-db-files</code>这个功能倒是可以尝试，这样就可以只分析新生产的日志文件了。</p><h2 id="7-不足"><a href="#7-不足" class="headerlink" title="7 不足"></a>7 不足</h2><p>尽管 GoAccess 很强大，但是它无法制定自定义监控规则，无法满足对站点更细粒度更全面的监控需求。此时就要使用到 ELK日志平台来分析站点的访问情况和流量分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;access日志&lt;/strong&gt; 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。使用 cat、awk、sed 等命令做一些简单的日志分析统计，这样分析结果不理想也不全面，方法也极不高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GoAccess&lt;/strong&gt; 这款工具以图形化的方式通过&lt;strong&gt;web socket&lt;/strong&gt;协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
      <category term="Tools" scheme="http://JavaSsun.github.io/categories/Nginx/Tools/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/categories/Nginx/Tools/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
      <category term="Tools" scheme="http://JavaSsun.github.io/tags/Tools/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>5-Nginx搭建具备缓存功能的反向代理</title>
    <link href="http://javassun.github.io/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://javassun.github.io/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2019-11-05T11:55:57.000Z</published>
    <updated>2020-04-16T06:38:58.646Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经展示了<strong>Nginx</strong>如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-<strong>上游服务</strong>，再搭建一个Nginx服务，作为<strong>反向代理</strong>，演示当Nginx作为方向代理时，应该如何使用？</p><p>由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，</p><a id="more"></a><p>现在这个页面仍然是我们刚才搭建的静态资源服务器所展示的页面。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/df2a42be-0e03-4eba-b963-00566fe3011b.jpg" alt></p><p>我们需要将此Nginx服务器变更为<strong>上游服务器</strong>，而上游服务器通常对公网是不进行访问的。我们可以做一个非常简单的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim conf&#x2F;nginx.conf</span><br><span class="line">   server &#123;</span><br><span class="line">        listen      127.0.0.1:8080;</span><br><span class="line">       # server_name  localhost;</span><br><span class="line"></span><br><span class="line"># 在listen上加入IP地址：127.0.0.1:8080</span><br><span class="line">这表示只能本机的进程来访问我们打开的8080端口，</span><br><span class="line"></span><br><span class="line"># 此时我们需要先将原先的Nginx进程停掉</span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line"># 再重新打开Nginx，防止之前的端口仍然可以使用</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/ff657493-3010-44aa-8983-412cc49d08b0.png" alt></p><p>再次访问时，会发现无法访问了，因为Nginx拒绝了由浏览器发过去的请求连接。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/043e0d0a-61f5-4acc-8730-288adfb9ea29.png" alt></p><p>由此，Nginx静态资源服务器已经变成了一个上游服务器。</p><h1 id="1-开始搭建Nginx反向代理"><a href="#1-开始搭建Nginx反向代理" class="headerlink" title="1 开始搭建Nginx反向代理"></a>1 开始搭建Nginx反向代理</h1><p>之前的 <strong>Nginx</strong> 是1.14版本，而反向代理我们用openrestry的1.16版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun sbin]# .&#x2F;nginx -v</span><br><span class="line">nginx version: nginx&#x2F;1.14.2</span><br></pre></td></tr></table></figure><p>我们进入到openresty所在的nginx服务，修改其配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 在此处添加一个 upstream，即上游服务其中的一台server，它的访问地址是 127.0.0.1:8080</span><br><span class="line"># 如果我有很多上游服务，可以依次放在这里面。（命名为 local,此处可表示一批上游服务器）</span><br><span class="line">  #gzip  on;</span><br><span class="line">    upstream local&#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # 此处设置当前代理服务器的域名，由于没有，就算了</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            # proxy_set_header：因为有了一台反向代理，所以我们再去拿一些变量或者值的时  候，可能就会出错了，</span><br><span class="line">            # 比如：一个TCP连接，是有对端地址的，而有了方向代理后，我们的              反向代理与客户端是一个TCP连接，而反向代理与上游服务器又是另外一个TCP连接，因此，如果我们取 $remote_addr 这个远端地址的时候，在上游服务那里，取到的实际上师我反向代理服务器的地址，而如果我想拿浏览器的客户端地址，作为限制浏览器访问速度功能的一个依据时，其实是拿不到的。因此，proxy_set_header可以把一些值添加为新的header发送给上游服务器，</span><br><span class="line">            # 比如说 X-Real-IP 将它的值设置为我们从TCP连接中拿到的远端IP地址，Host同样道理，因为用户直接访问的域名，是在他的浏览器中输入的，即可由上游服务器处理此域名，也可由反向代理服务器处理此域名，这些所有的配置特性，都可在官网的 http_proxy_module模块中找到。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            # http_proxy_module提供了非常丰富的特性+内置变量，而最重要之一特性就是 proxy_cache。</span><br><span class="line">            # 因为当我们的Nginx作为方向代理时，通常只有动态的请求，即不同的用户访问同一个URL时，看到的内容是不同的，此时才会交由上游服务处理。</span><br><span class="line">            # 但是有一些内容可能是一段时间不会发生变化的。此时，为了减轻上游服务的压力，我们就会让Nginx将上游返回来的内容缓存一段时间，如缓存一天等。在一天之内，即使上游服务器对这个内容的响应发生了变化，也不管，只会去拿已缓存的内容向浏览器发出响应。</span><br><span class="line">            # 因为 Nginx的性能远远领先于上游服务器的性能，所以使用此特性后，对我们一些小的站点，会有非常大的性能提升。</span><br><span class="line">            #proxy_cache my_cache;</span><br><span class="line">            #proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            #proxy_cache_valid 200 304 302 1d;</span><br><span class="line">            # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2ab4b5f1-508b-47c5-af66-188ff2a9c828.png" alt></p><p>此时再去访问我们的代理服务器的IP地址，<strong>如果配置里域名，则用域名访问即可</strong>，因为监听的80端口，所以使用192.168.121.100:80/dangdang/book.html访问即可。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/14217284-3db6-4e6e-86ce-c6b7271843ef.jpg" alt></p><p>由下图可看出，我们的请求是由反向代理服务器发给我们的。其中的 <strong>server:nginx/1.16.0</strong>证明了它的身份。</p><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/06774664-cc31-4dbb-b5f5-bf44b60829d2.png" alt></p><h1 id="2-开始搭建Nginx缓存服务器"><a href="#2-开始搭建Nginx缓存服务器" class="headerlink" title="2 开始搭建Nginx缓存服务器"></a>2 开始搭建Nginx缓存服务器</h1><p>首先，我们需要<strong>proxy_cache_path</strong>来设置我们的缓存 文件写在那个目录下，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    proxy_cache_path &#x2F;tmp&#x2F;nginxcache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m max_size&#x3D;10g</span><br><span class="line">            inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            .....</span><br></pre></td></tr></table></figure><p>此处写在了 <code>/tmp/nginxcache</code>,以及这些文件的命名方式，这些文件的关键字是要放在共享内存中的，此处开了一个10m的共享内存，命名为my_cache，这些参数都在控制我们的缓存。</p><p>缓存如何使用呢？就是在我们需要做缓存的路径下添加<code>proxy_cache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       #server_name  haoraunsun.pub;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location &#x2F; &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">           proxy_set_header Host $host;</span><br><span class="line">           proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">           # 就在此处</span><br><span class="line">           # proxy_cache 后面跟的就是我们刚才开辟的共享内存</span><br><span class="line">           proxy_cache my_cache;</span><br><span class="line">           # 共享内存中的key设置的是 同一个url 访问时 对不同的用户可能展示的内容不一样。因此，用户这样一个变量就要放在共享内存中。</span><br><span class="line">           # 此处只是简单的放置了 host+资源+参数,这些作为一个整体的Key。</span><br><span class="line">           proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">           # 对于哪些响应不返回，这里做了一些简单处理。</span><br><span class="line">           proxy_cache_valid 200 304 302 1d;</span><br><span class="line">           </span><br><span class="line">           # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dbb3164a-c86b-45cd-97c4-4d0d228aeb3a.png" alt></p><p>加完这些参数后，需要重载配置文件，重新启用方向代理服务的配置。<br>再次直接访问站点，然后将上游服务停掉，看是否能获得同样的结果。</p><p>首先，我们再次访问，让其响应内容刷到缓存文件中。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/f116bae7-d1df-4716-9f3f-a5c461f0eb37.png" alt></p><p>查看进程<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/9733b5f7-3813-4f02-bf20-eda96a4c0ed0.png" alt></p><p>将上游服务停掉。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dfc0abce-1988-43f5-a4df-ae755de9af93.png" alt></p><p>再次访问，实际上读的是缓存系统中的内容作为响应返回给客户端。</p><p>此时，上游服务已经停掉了<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/a3d4faab-fcc5-4ce4-956f-7e75e52d8662.png" alt></p><p>再次访问<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/6f1b4d43-8144-49ac-8676-201d87902b4c.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前面已经展示了&lt;strong&gt;Nginx&lt;/strong&gt;如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-&lt;strong&gt;上游服务&lt;/strong&gt;，再搭建一个Nginx服务，作为&lt;strong&gt;反向代理&lt;/strong&gt;，演示当Nginx作为方向代理时，应该如何使用？&lt;/p&gt;
&lt;p&gt;由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>4-Nginx搭建静态资源Web服务器</title>
    <link href="http://javassun.github.io/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://javassun.github.io/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2019-11-01T10:53:57.000Z</published>
    <updated>2020-05-06T16:34:35.797Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font>`</p><h2 id="1-上传静态资源到Nginx目录中"><a href="#1-上传静态资源到Nginx目录中" class="headerlink" title="1 上传静态资源到Nginx目录中"></a>1 上传静态资源到Nginx目录中</h2><p>如这里新建了一个dlib目录，里面存放静态资源<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/534bed34-738b-47df-9819-997373f35987.png" alt></p><a id="more"></a><h2 id="2-修改-nginx-conf"><a href="#2-修改-nginx-conf" class="headerlink" title="2 修改 nginx.conf"></a>2 修改 nginx.conf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;  # 监听端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        # 现在的请求比较简单，所有的请求都去访问我们 dlib&#x2F; 目录下面的文件，所以此处建立一个location &#x2F;  这个 “斜杠”表示所有的请求，</span><br><span class="line">        # 然后要去指定 url的后缀 要与我文件目录下的后缀一一对应（文件名），此处有两种写法：1.route，有个问题，会将URL中的一些路径，带到我们的文件目录中来。所以通常使用  2 alias：即 Nginx安装目录中的 dlib目录下，后面的路径与我们的URL路径是一一对应的。</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">做完这些后，再去启动Nginx。</span><br><span class="line">.&#x2F;nginx -c ..&#x2F;conf&#x2F;nginx.conf 会发现找不到这个文件</span><br><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 即可</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/ec1f7e9f-05a4-41a8-9105-f636ec985a7b.jpg" alt></p><p><strong>192.168.121.100 为Nginx的服务器地址，8080是刚才配置的端口号，/dangdang/book.html是  dlib 目录下的 dangdang/book.html 。</strong></p><p><font color="red"><strong>但是此处有一个问题，打开访问页面的抓包查看</strong></font><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/324fabe1-d3b4-4f0a-aeae-5fbe99099406.jpg" alt></p><p>*<em>这里的book.html文件大小是3.0kB,与文件本身的大小是一致的。<font color="red">但是所有的文本文件是可以做 gzip 压缩的</font>，做完 gzip 压缩后，传递的字节数会大幅度减少，因此通常是 打开 gzip压缩功能。 *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 打开 gzip开关</span><br><span class="line">gzip  on;</span><br><span class="line"></span><br><span class="line"># 小于 1字节的内容就不再行压缩了（1是可以配置的，不带单位为字节，可带单位：5K 5M 5G）</span><br><span class="line">因为对于特表小的文本内容。在TCP一个报文中就可以全部发送出来。此时再进行压缩，去消耗CPU资源，意义不大，此处是为了显示 gzip压缩效果，将其设置为1。</span><br><span class="line">gzip_min_length  1;</span><br><span class="line"></span><br><span class="line"># 表示 gzip的压缩级别</span><br><span class="line">gzip_comp_level  2;</span><br><span class="line"></span><br><span class="line"># 表示针对列举的类型才进行gzip压缩。比如 已经做过压缩的文件是没有必要再做gzip压缩的（zip文件等）</span><br><span class="line">gzip_types  text&#x2F;plain application&#x2F;x-javascript test&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php  image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line"></span><br><span class="line">加好这些配置后 reload</span><br><span class="line">sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/81b273e2-ff17-4686-b7d4-9ff0c3a0e0d8.png" alt></p><p><strong>再次访问此文件：</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/63cef855-efb9-4663-8018-804306a4f37f.jpg" alt></p><p>此时传输的字节数只有1.6KB了，从响应头中也可看出使用了  gzip压缩。<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/d5decbbd-d47c-4472-a1ec-96b2d251f146.png" alt></p><p><strong>因此使用了 gzip 压缩后，整个静态资源 WEB服务，传输效率会提升很多。</strong></p><h2 id="3-Nginx常用功能"><a href="#3-Nginx常用功能" class="headerlink" title="3 Nginx常用功能"></a>3 Nginx常用功能</h2><h3 id="3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"><a href="#3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？" class="headerlink" title="3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"></a>3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？</h3><p><strong>Nginx 提供了 官方模块 <font color="red">auto_index_module</font>在官方网站<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a> 提供了使用说明</strong>。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on; # 加入此模块</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">执行 reload即可。</span><br><span class="line"></span><br><span class="line">192.168.121.100:8080&#x2F;</span><br><span class="line">192.168.121.100:8080&#x2F;dangdang&#x2F;</span><br><span class="line">即可看到如下页面，则成功。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/6e4bca87-3437-42e4-bef5-df5592e3e6df.png" alt></p><hr><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/69254aad-1999-4d64-ab86-4c5cae6cacb7.png" alt></p><p>这样会显示 指定层级下 所有的目录及文件。<strong>提供了共享静态资源的功能.</strong></p><h3 id="3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"><a href="#3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。" class="headerlink" title="3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"></a>3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。</h3><p>使用 set命令+内置变量即可达到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on;</span><br><span class="line">           set $limit_rate 1k;</span><br><span class="line">          # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">set $limit_rate 1k; # 限制Nginx向浏览器发送响应的一个速度。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/396f4ca5-45fe-4926-8719-e22866f50bc2.png" alt></p><p>limit_rate：在 Nginx官网中的 <strong>ngx_http_core_module中 提供了 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="noopener">Embedded Variables</a>，在这其中有一个内置的变量，$limit_rate ,来限制我们的访问速度</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/936fe133-af26-413a-beb9-8555e4b397ce.png" alt></p><p><strong>用法：set $limit_rate N； 是空间单位的；意义是：每秒传输 N 字节到浏览器中。<br>再去访问大页面，发现变得很慢了</strong>。</p><h3 id="3-3-记录access-log日志"><a href="#3-3-记录access-log日志" class="headerlink" title="3.3 记录access.log日志"></a>3.3 记录access.log日志</h3><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/2339d20c-675f-4197-a127-8dda272a9a06.png" alt></p><p><strong>nginx.conf 中的 log_format指令在定义日志的格式。</strong></p><p>这里的日志格式使用了许多变量，比如 $remote_addr<br>等等，具体见 00-Nginx访问日志详解。</p><p>这样的日志格式给他明明为 main , 因为我们可能对不同的域名下做不同格式的日志记录，或者对一些大文件，做反向代理等不同的用途时，记录不同日志格式。</p><p>配好 <strong>log_format</strong>之后，需要去设定 日志 记录在哪里</p><p><strong>access_log指令：决定日志记录在什么地方。access_log指令的位置决定了它所属的这样一类请求，会被记录到 当前指令所指定的路径中，采用 main这样的一种格式来记录。</strong></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxx;</span><br><span class="line">    acccess_log logs&#x2F;access.log main；</span><br><span class="line"># 这里access_log放在了 server下，即所有发送我这个域名或者请求端口的都会被记录到这个文件中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx内置的所有变量都可以被记录到 日志中。</p><p>官方内置变量在上面提过了</p><p>第三方模块变量，如 ngx_http_gzip_module 中的 内置变量 $gzip_ratio：记录了压缩级别</p><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/88b697fd-76d2-4960-8fe3-0567add181a7.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;`&lt;/p&gt;
&lt;h2 id=&quot;1-上传静态资源到Nginx目录中&quot;&gt;&lt;a href=&quot;#1-上传静态资源到Nginx目录中&quot; class=&quot;headerlink&quot; title=&quot;1 上传静态资源到Nginx目录中&quot;&gt;&lt;/a&gt;1 上传静态资源到Nginx目录中&lt;/h2&gt;&lt;p&gt;如这里新建了一个dlib目录，里面存放静态资源&lt;br&gt;&lt;img src=&quot;/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/534bed34-738b-47df-9819-997373f35987.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>3-Nginx命令行演示-重载-热部署-切割</title>
    <link href="http://javassun.github.io/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/"/>
    <id>http://javassun.github.io/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/</id>
    <published>2019-10-20T11:00:56.000Z</published>
    <updated>2020-04-16T06:38:20.806Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-检查80端口是否被占用"><a href="#1-检查80端口是否被占用" class="headerlink" title="1 检查80端口是否被占用"></a>1 检查80端口是否被占用</h1><p>yum install net-tools<br>netstat -ano | grep 80</p><h1 id="2-Nginx命令行"><a href="#2-Nginx命令行" class="headerlink" title="2 Nginx命令行"></a>2 Nginx命令行</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg" alt></p><a id="more"></a><h1 id="3-重载配置文件"><a href="#3-重载配置文件" class="headerlink" title="3 重载配置文件"></a>3 重载配置文件</h1><p>此时在 nginx的安装目录下执行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">将Nginx启动了起来。</span><br></pre></td></tr></table></figure><p><font color="red">注意：<br>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：<br>ln -s /usr/local/lib/libpcre.so.1 /lib64/</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">再次修改了 Nginx配置文件中的一些值</span><br><span class="line">[root@haoransun nginx]# vim conf&#x2F;nginx.conf</span><br><span class="line">如需要将 #tcp_nopush这个注释去掉。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/098162e9-ca47-4da3-a22c-b0e1de51a776.png" alt></p><ul><li><p><strong><font color="red">mac</font>：当修改完成后，保存退出后，可以直接执行 <font color="red"> ./nginx -s reload </font>指令。这样是在Nginx在不停止对客户服务的情况下，使用了 tcp_nopush这个新的配置项，</strong></p></li><li><p>**<font color="red">CentOS</font>：<br>cd sbin<br>[root@haoransun sbin]# ./nginx -s reload即可</p></li><li><p><strong>ps -ef | grep nginx 可以看到正在运行的Nginx</strong></p></li></ul><h1 id="4-热部署"><a href="#4-热部署" class="headerlink" title="4 热部署"></a>4 热部署</h1><p><strong>即对Nginx在不停机的情况下做版本升级</strong>。<br><font color="red">对现有的Nginx的运行目录中的二进制可执行文件做一次备份：<strong>因为我们更换的只是二进制文件，并不会对其他文件做更换。</strong></font><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/1069c513-57b6-4f14-bf86-e72dc898eacf.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx nginx.old</span><br></pre></td></tr></table></figure><p>先下载一个最新版本的Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line">tar -zxvf 此版本Nginx</span><br><span class="line">编译生成二进制可执行文件</span><br><span class="line">进入新版本Nginx目录中，</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx</span><br><span class="line"></span><br><span class="line">上述命令会在Nginx最新版本目录中生成objs中间文件。</span><br><span class="line">make</span><br><span class="line">上述命令会生成Makerfile文件</span><br><span class="line">make install</span><br><span class="line">上述命令会在 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx目录下生成最新版本Nginx的运行目录文件，里面包含了最新版本的Nginx二进制可执行文件</span><br></pre></td></tr></table></figure><p>将我们编译好的<strong>最新版本的二进制文件</strong>拷贝到旧版本的二进制那个可执行文件目录中，替换掉当前Nginx进程正在使用的旧版本二进制文件。<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/daf5c361-5f4f-42c3-a7b0-26c0f1339f06.png" alt><br><font color="red"><strong>复制成功后，看到新版本的Nginx二进制可执行文件的size与旧版本是不一样的。</strong></font></p><p>现在，需要给<strong>正在运行的Nginx的Master进程发送一个信号，告诉它，我们要进行热部署了，做一次版本升级</strong><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/c1c96e01-89b4-4df0-8302-d5594b0ab572.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 6655 ## master进程号</span><br><span class="line">ps -ef |grep nginx</span><br></pre></td></tr></table></figure><p>接下来会看到，<strong>Nginx Master进程会新起一个Nginx Master进程，新的Nginx Master进程使用了刚刚复制过来的最新的Nginx二级制文件，老的Worker也在运行，新的Master会生成新的Worker，它们会平滑的将所有的请求过渡到新的二进制文件所起的Nginx进程中，由此实现了平滑过度-热部署</strong>，如下所示：<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/086e0e3b-a68e-4e18-b5ca-2d2e14362e01.png" alt><br>我们看到，新老都存在，且新的Master进程父ID 为老的Master进程ID，由此看出新的是由老的新起的。</p><p>但是老的Master进程已经<strong>不再监听80或者443这样的Web端口</strong>，所以，新的连接，都会进入新的Nginx进程中。</p><p>这是，我们需要向老的Nginx进程发生一个信号，告诉它，优雅的关闭所有的 Worker进程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 6655 ## 老的Master 进程号</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/5a48e9e0-f3dc-410c-89d2-bc7de1124ecd.png" alt></p><p>老的Worker进程已经优雅的退出了，但是老的Master进程 6655 还存在，但是它手下已经没有Worker进程了，这说明了一件事情：所有的请求已经去全部切换到我们新升级好的Nginx中了。</p><p>./nginx -v :已经是最新的版本了</p><p><strong>如果升级过程完成后，没有任何问题，需要关闭老的master进程的话，使用以下命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill  -QUIT old_master_pid</span><br></pre></td></tr></table></figure><p><strong>但是 想要版本回退呢？只需要向老的Master进程 6655发送 reload 命令，让它重新拉起Worker进程，再把新的Master进程关掉。<font color="red"> 因此：老的Master进程是不会退出的，保留以允许我们做版本回退</font>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v   # 此时这里是新的nginx版本号</span><br><span class="line"></span><br><span class="line">mv nginx nginx-1.16.0 # 将新的nginx文件命名为它的版本号</span><br><span class="line"></span><br><span class="line">mv nginx.old nginx # 将老的nginx命名为nginx</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">kill -USR1 6728(新的nginx的master的id)</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;nginx -v # 已经是老版本的nginx了</span><br></pre></td></tr></table></figure><h1 id="5-切割日志文件"><a href="#5-切割日志文件" class="headerlink" title="5 切割日志文件"></a>5 切割日志文件</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/e7955fcb-062b-424e-8db2-3f4cf82ba1ad.png" alt></p><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/ce22072b-b74f-4910-a13b-bc1a2407f577.png" alt></p><p>可以看到，haoransun_access.log日志文件已经有接近16M了，假设它此时已经很大了，想要将当前日志备份到另外一个文件中，而当前Nginx仍然正常运行，该如何做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reopen即可</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/d7da2cf6-25f5-4fc5-b3bd-3618ecaea6a1.png" alt></p><p><strong>./nginx -s  reopen 命令即可做到，但是太麻烦了</strong></p><p><font color="red">具体的便捷做法参考000-Nginx访问日志配置及信息详解.。。。。</font></p><h2 id="5-1-日志切割-bash脚本demo"><a href="#5-1-日志切割-bash脚本demo" class="headerlink" title="5.1 日志切割 bash脚本demo"></a>5.1 日志切割 bash脚本demo</h2><p>往往会每一天或者每一周执行一次日志切割。</p><p>可以先写成一个<strong>bash脚本</strong>，在此脚本中，先将 haoransun.log复制一下，在执行 -s reopen命令。<br>最后将此脚本放在<strong>crontab</strong>中，比如：</p><p>在logs目录下新建 history文件夹：用于存放历史日志文件。</p><p><strong>在logs目录下新建rotate.sh脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Rotate the Nginx logs to prevent a single logfile from consuming too much disk space.</span><br><span class="line"># 此处 日志存放目录可以自定义，但一般存放在nginx相关的目录下</span><br><span class="line"># LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line"># CUR_LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs</span><br><span class="line">CUR_LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs</span><br><span class="line">YESTERDAY&#x3D;$(date -d &quot;yesterday&quot;+%Y-%m-%d )</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;haoransun_access.log $(LOGS_PATH)&#x2F;haoransun_access_$(YESTERDAY).log</span><br><span class="line"># 此处可以指定多个日志文件到指定目录下</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;error.log $(LOGS_PATH)&#x2F;error_$(YESTERDAY).log</span><br><span class="line">## 向 Nginx 主进程发送 USR1 信号 USR1 信号是重新打开日志文件</span><br><span class="line">kill -USR1 $(cat &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin)</span><br></pre></td></tr></table></figure><p><strong>查看当前周期任务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">crontab -e</span><br><span class="line">59 23 * * * root &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logx&#x2F;rotate.sh</span><br><span class="line">:wq</span><br><span class="line">再次 crontab -l 即可查看该脚本在每天的23点59分执行。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-检查80端口是否被占用&quot;&gt;&lt;a href=&quot;#1-检查80端口是否被占用&quot; class=&quot;headerlink&quot; title=&quot;1 检查80端口是否被占用&quot;&gt;&lt;/a&gt;1 检查80端口是否被占用&lt;/h1&gt;&lt;p&gt;yum install net-tools&lt;br&gt;netstat -ano | grep 80&lt;/p&gt;
&lt;h1 id=&quot;2-Nginx命令行&quot;&gt;&lt;a href=&quot;#2-Nginx命令行&quot; class=&quot;headerlink&quot; title=&quot;2 Nginx命令行&quot;&gt;&lt;/a&gt;2 Nginx命令行&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>2-Nginx配置语法</title>
    <link href="http://javassun.github.io/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</id>
    <published>2019-10-17T11:47:52.000Z</published>
    <updated>2020-05-06T13:04:55.291Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-Nginx-配置语法"><a href="#1-Nginx-配置语法" class="headerlink" title="1 Nginx 配置语法"></a>1 Nginx 配置语法</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg" alt></p><a id="more"></a><h1 id="2-Nginx配置参数：时间单位"><a href="#2-Nginx配置参数：时间单位" class="headerlink" title="2 Nginx配置参数：时间单位"></a>2 Nginx配置参数：时间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/4440df2c-e938-4f44-9a0e-2a9a1b44b32c.jpg" alt></p><h1 id="3-Nginx配置参数：空间单位"><a href="#3-Nginx配置参数：空间单位" class="headerlink" title="3 Nginx配置参数：空间单位"></a>3 Nginx配置参数：空间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/2a8c6624-55b3-4554-b84c-8c448dc319b6.jpg" alt></p><h1 id="4-Nginx-语法示例"><a href="#4-Nginx-语法示例" class="headerlink" title="4 Nginx 语法示例"></a>4 Nginx 语法示例</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7a40655-721d-4edb-b990-9d4ef7b60470.jpg" alt></p><ul><li><p><strong>http{} 就是一个指令块</strong></p></li><li><p><strong>include            mime.types; 这是一条指令</strong></p></li><li><p><strong>指令后 可以跟多个参数</strong></p></li><li><p><strong>指令间以;为分隔符，可以将多条指令放在一行</strong></p></li><li><p><strong>指令块可以有名字，如：upstream指令块 thwp,有些指令块是没有名字的，如： http、server等。<font color="red">有名与否是由提供这个指令块的Nginx 模块来决定的</font></strong></p></li><li><p><strong>3m:表示3分钟</strong></p></li><li><p><strong>limit_req_zone 10m 开启10MB大小的共享内存空间，给不同的Worker使用</strong></p></li></ul><hr><h1 id="5-http配置的指令块"><a href="#5-http配置的指令块" class="headerlink" title="5 http配置的指令块"></a>5 http配置的指令块</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7901424-0375-4abf-869b-7a62ddb552b8.jpg" alt></p><ul><li><p><strong>http模块有四个大的指令块：http、server、location、upstream</strong></p></li><li><p><strong>http{}：表示 大括号内的所有指令都是由<font color="red">http模块去解析、执行。一个非 http模块：stream等是没有办法被解析的</font>。</strong></p></li><li><p><strong>upstream：表示<font color="red">上游服务</font> ，当Nginx需要与Tomcat/DJango等企业内网的其他应用服务交互时，可以定义此 upstream.</strong></p></li><li><p><strong>server：对应一个组域名</strong></p></li><li><p><strong>location：一个URL表达式</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Nginx-配置语法&quot;&gt;&lt;a href=&quot;#1-Nginx-配置语法&quot; class=&quot;headerlink&quot; title=&quot;1 Nginx 配置语法&quot;&gt;&lt;/a&gt;1 Nginx 配置语法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>1-Nginx的前世今生</title>
    <link href="http://javassun.github.io/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://javassun.github.io/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2019-10-15T11:00:56.000Z</published>
    <updated>2020-05-08T09:21:55.454Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><a href="http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">章亦春文档</a></p><h1 id="1-Nginx的三个主要应用场景"><a href="#1-Nginx的三个主要应用场景" class="headerlink" title="1 Nginx的三个主要应用场景"></a>1 Nginx的三个主要应用场景</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg" alt></p><p><font color="red">流程解析：</font><br>一个<strong>Web</strong>请求从红色的线走下来后，会先经过<strong>Nginx</strong>,再到<strong>应用服务（Tomcat/Django）</strong>，再去访问<strong>Redis/MySQL</strong>这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有<strong>反向代理</strong>功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，<strong>反向代理</strong>必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于<strong>企业内网的边缘节点</strong>，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来<strong>在一段时间内不变的动态内容缓存到Nginx</strong>中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 <strong>缓存，加速我们的访问</strong>。（<strong>反向代理</strong>）</p><p>一些<strong>css/js/png</strong>等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（<strong>静态资源</strong>）</p><p>如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（<strong>API服务</strong>）</p><a id="more"></a><h1 id="2-Nginx出现的缘由"><a href="#2-Nginx出现的缘由" class="headerlink" title="2 Nginx出现的缘由"></a>2 Nginx出现的缘由</h1><h2 id="2-1-互联网的数据量急速增长"><a href="#2-1-互联网的数据量急速增长" class="headerlink" title="2.1 互联网的数据量急速增长"></a>2.1 互联网的数据量急速增长</h2><p>互联网的快速普及<br>全球化<br>物联网</p><h2 id="2-2-摩尔定律：性能提升"><a href="#2-2-摩尔定律：性能提升" class="headerlink" title="2.2 摩尔定律：性能提升"></a>2.2 摩尔定律：性能提升</h2><h2 id="2-3-低效的Apache-：一个连接对应一个进程"><a href="#2-3-低效的Apache-：一个连接对应一个进程" class="headerlink" title="2.3 低效的Apache ：一个连接对应一个进程"></a>2.3 低效的Apache ：一个连接对应一个进程</h2><p>当有百万个连接时，Apache并不会建造出百万个进程，就算生成了，进程间的切换会损耗极大的性能。而Nginx可以轻松应对百万级的连接。</p><h1 id="3-Nginx的优点"><a href="#3-Nginx的优点" class="headerlink" title="3 Nginx的优点"></a>3 Nginx的优点</h1><p>高并发、高性能<br><strong>高并发</strong>往往需要我们对每个连接所使用的内存尽量的少即可达到，具有高并发的同时又能达到<strong>高性能</strong>，需要非常好的设计。Nginx可以达到什么样的标准呢？如现在的主流服务器（32核，64G）可以轻松地达到数千万并发连接，如果是处理简单的静态资源请求，可以达到100W的RPS(REQUEST PER SECOND)<br>可扩展性好<br>主要体现在<strong>模块化设计</strong>，非常的稳定。使其的第三方模块-生态圈非常稳定、丰富。甚至是有Tengene（淘宝修改了Nginx的源源码，做了定制化开发）/OpenResty（Lua语言开发）这样的第三方插件在他们之上，又生成了一套生态圈。<br>高可靠性<br>Nginx可以在服务器上持续不间断的运行数年。对于Nginx这样的一个高并发、高性能的反向代理服务器而言，往往运行在企业内网的边缘节点上，此时，若企业想提供<strong>5个9</strong>或更高的服务时，Nginx的宕机可能1年就1s的时间间隙。<br>热部署<br>在不停止服务的情况下，升级Nginx,此功能<strong>非常重要</strong>，因为在Nginx上可能跑了数百万的并发连接。如果是普通服务，则直接kill掉进程再重启即可。但对于Nginx而言，kill掉Nginx进程，会导致操作系统为所有的已建立连接的客户端发送<strong>TCP中的reset复位包</strong>，然而很多客户端是没有办法，很好的处理复位请求的，<strong>在大并发场景下，一些偶然事件就会导致非常恶劣的结果，因此热部署极其重要</strong><br>BSD许可证<br>开源且可商用</p><h1 id="4-Nginx的组成"><a href="#4-Nginx的组成" class="headerlink" title="4 Nginx的组成"></a>4 Nginx的组成</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/e604a666-da3c-4a91-9866-53e81c4ff90f.jpg" alt></p><h2 id="4-1-Nginx二进制可执行文件"><a href="#4-1-Nginx二进制可执行文件" class="headerlink" title="4.1 Nginx二进制可执行文件"></a>4.1 Nginx二进制可执行文件</h2><p>由Nginx自身的官方模块+我们编译的第三方模块一起构建的文件，相当于汽车本身（有完整的系统，所有的功能都由它提供）</p><h2 id="4-2-Nginx-conf配置文件"><a href="#4-2-Nginx-conf配置文件" class="headerlink" title="4.2 Nginx.conf配置文件"></a>4.2 Nginx.conf配置文件</h2><p>相当于汽车的驾驶员。</p><h2 id="4-3-access-log访问日志"><a href="#4-3-access-log访问日志" class="headerlink" title="4.3 access.log访问日志"></a>4.3 access.log访问日志</h2><p>汽车经过所形成的GPS轨迹。</p><h2 id="4-4-error-log错误日志"><a href="#4-4-error-log错误日志" class="headerlink" title="4.4 error.log错误日志"></a>4.4 error.log错误日志</h2><p>黑匣子：定位问题。</p><h1 id="5-Nginx的版本（nginx-org-开源-nginx-com-商业）"><a href="#5-Nginx的版本（nginx-org-开源-nginx-com-商业）" class="headerlink" title="5 Nginx的版本（nginx.org:开源 nginx.com:商业）"></a>5 Nginx的版本（nginx.org:开源 nginx.com:商业）</h1><p>单数号：最新按本（新功能有待考验）<br>偶数号：稳定版本（一般选择此版本）<br>版本号-feature-bugfix-change<br>openresty.com openresty.org</p><h1 id="6-编译出适合自己的Nginx"><a href="#6-编译出适合自己的Nginx" class="headerlink" title="6 编译出适合自己的Nginx"></a>6 编译出适合自己的Nginx</h1><p>nginx.org网址 —–&gt; 选择download<br>在选中的版本上 —–&gt; 右键选择复制链接地址<br>在linux系统中  —–&gt; wget 下载地址即可<br><font color="red">ps:Nginx依赖一些第三方软件包，如gcc、gcc-c++、openssl、pcre、zlib,详细见0-Nginx安装过程</font></p><h1 id="7-目录解析"><a href="#7-目录解析" class="headerlink" title="7 目录解析"></a>7 目录解析</h1><p>解压压缩包： tar -zxvf nginx-xxx.tar.gz<br>进入解压源码包： cd nginx-xxx<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f08f5668-a4bd-4fe4-a790-c25c437b69e3.png" alt></p><p><strong>auto：</strong> 其中主要有四个子目录（cc:用于编译，lib库、os库对操作系统的判断，types），其他的文件是为了辅助<strong>config</strong>脚本执行时判定 当前的Nginx支持哪些模块、当前的操作系统有哪些特性供Nginx使用。</p><p><strong>CHANGES：</strong> Nginx每一个版本提供了哪些 Features、BugFix、Changes这三类特性。</p><p><strong>CHANGES.ru：</strong> 因为作者是 俄罗斯人，所以提供了一个俄罗斯语言的变更说明书。</p><p><strong>conf：</strong> 示例文件，将Nginx安装好后，为了方便运维去配置，会将此目录中的示例文件拷贝到安装目录。</p><p><strong>configure：</strong>这个脚本是用来生成中间文件、执行编译前的一个必备动作。</p><p><strong>contrib：</strong>提供了两个pl脚本和vim的工具，在没有使用vim工具时去打开nginx配置文件，会发现色彩没有什么变化（nginx语法没有在vim），此时，需要将contrib文件夹下的所有文件拷贝到我们自己的vim目录中，即：</p><p><strong>（mac:cp -r contrib/vim/* ~/.vim/ ）</strong></p><p>（ <font color="red">centos:自定义安装vim的话，使用 whereis vim查看vim的安装路径，vimfiles就在 /usr/share/vim/下<br>所以：cp -r contrib/vim/* /usr/share/vim/vimfiles/<br>此时再次打开nginx.conf文件，发现语法高亮显示</font>）<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/a11a6806-0bf0-4908-9f46-2dcb2b590271.png" alt></p><p><strong>html：</strong> 提供了两个标准的html文件。如图：<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ae1df995-18a4-4490-97e6-93aa397516f7.png" alt><br>一个是发现500错误的时候重定向到当前指定文件。<br>一个是默认的Nginx的欢迎页面。</p><p><strong>man：</strong>Nginx的帮助文件<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f5e50c6d-0b16-4494-9580-169a0fe8e3c3.png" alt></p><p><strong>src：</strong>Nginx的源代码。<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5d35e8e4-1b4c-482c-ad22-1b7af2a3d92f.png" alt>。即Nginx的框架都在这些源代码中。</p><h1 id="8开始编译"><a href="#8开始编译" class="headerlink" title="8开始编译"></a>8开始编译</h1><h2 id="8-1-编译前首先观察configure都支持哪些参数？"><a href="#8-1-编译前首先观察configure都支持哪些参数？" class="headerlink" title="8.1 编译前首先观察configure都支持哪些参数？"></a>8.1 编译前首先观察configure都支持哪些参数？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/b42567c1-87be-482a-86b1-b3779ec76e2c.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/727a8526-4163-4ed7-9c65-72dcaf6cf2ce.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/bdf16353-460a-49e4-9991-85b84e615d49.png" alt><br><strong>此处主要分为3大块参数内容</strong>：</p><ul><li><p>确定Nginx执行中会去找哪些目录下的文件作为它的辅助文件；如：使用动态模块，则 –modules-path=PATH 就会起作用；确定Nginx.log文件放在那里，则 –lock-path=PATH会起作用；然而，<font color="red">如果没有任何变动的话，只需要指定 –prefix=PATH即可,所有的其他的文件会在prefix目录下建立相应的文件夹</font>。</p></li><li><p>确定使用那些模块，而不使用那些模块。如 –with 与 –without, –with ：需要显示指定的时候，意味着Nginx默认是不会加载此模块的。 –without: 意味着默认会编译到Nginx中，如果加上了，则是显示取消编译的，移出默认的Nginx模块中。</p></li><li><p>确定Nginx编译时所需要的一些特殊参数。如 –with-cc=Path –with-cpp=Path 就是使用gcc编译时需要加一些什么样的优化参数；–with-debug 打印debug级别的日志，–with-pcre –with-zlib 这是需要加一些第三方的模块等等。</p></li></ul><h2 id="8-2-编译前的依赖包的安装"><a href="#8-2-编译前的依赖包的安装" class="headerlink" title="8.2 编译前的依赖包的安装"></a>8.2 编译前的依赖包的安装</h2><p>参看 附件 + 0篇内容，此处省略。。。。</p><h2 id="8-3-生成指定目录下的-Makefile，为下一步编译做准备"><a href="#8-3-生成指定目录下的-Makefile，为下一步编译做准备" class="headerlink" title="8.3 生成指定目录下的 Makefile，为下一步编译做准备"></a>8.3 生成指定目录下的 Makefile，为下一步编译做准备</h2><p>配置 Nginx的安装目录   /home/geek/nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标目录不存在，会自动创建</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx</span><br><span class="line">如果没有任何报错，则Nginx编译成功，如下图</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/30d9368f-43a9-4413-bef9-08f8311a1657.png" alt></p><p>在 ./configure 成功后，会生成一些中间文件，存储在 /objs 文件夹下。<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/14168daf-02ec-4203-812a-efc660721862.png" alt><br><strong>最重要的是会生成<font color="red"> ngx_modules.c：它决定了我们执行编译时有哪些模块，会被编译到Nginx中</font></strong>。</p><p><strong>所有被编译的模块都会列出来，最后形成一份 ngx_modules[] 数组</strong> <img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/20212437-7463-4e77-9fc2-de2c6a5b5700.png" alt></p><h2 id="8-4-编译"><a href="#8-4-编译" class="headerlink" title="8.4 编译"></a>8.4 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make</span><br><span class="line">编译完成后，如果没有错误，就可以看到生成了大量的中间文件，如下图，他们都在 objs文件夹下。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/afa43e4b-c314-4481-a329-a1515a83f24b.jpg" alt></p><h2 id="8-5-为什么要知道Nginx的目标文件是放在objs下呢？"><a href="#8-5-为什么要知道Nginx的目标文件是放在objs下呢？" class="headerlink" title="8.5 为什么要知道Nginx的目标文件是放在objs下呢？"></a>8.5 为什么要知道Nginx的目标文件是放在objs下呢？</h2><p>如果是做<font color="red">Nginx版本升级</font>，此时不能执行** make install** ，而是需要从这里将目标文件 Nginx<br>拷贝到安装目录中，</p><p>C语言编译时生成的所有重要文件，都会存放在 *<em>objs/src目录 *</em>中。</p><p>如果使用了动态模块，则动态模块编译生成的<strong>so</strong>动态文件，也会放在<strong>objs 目录</strong>中。</p><h1 id="9-安装（首次安装时，可以使用此命令）"><a href="#9-安装（首次安装时，可以使用此命令）" class="headerlink" title="9 安装（首次安装时，可以使用此命令）"></a>9 安装（首次安装时，可以使用此命令）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make install</span><br></pre></td></tr></table></figure><h1 id="10-安装目录下的目录解析"><a href="#10-安装目录下的目录解析" class="headerlink" title="10 安装目录下的目录解析"></a>10 安装目录下的目录解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# cd &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;</span><br><span class="line">ll</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 conf</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 html</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 logs</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 sbin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;br&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;章亦春文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Nginx的三个主要应用场景&quot;&gt;&lt;a href=&quot;#1-Nginx的三个主要应用场景&quot; class=&quot;headerlink&quot; title=&quot;1 Nginx的三个主要应用场景&quot;&gt;&lt;/a&gt;1 Nginx的三个主要应用场景&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;流程解析：&lt;/font&gt;&lt;br&gt;一个&lt;strong&gt;Web&lt;/strong&gt;请求从红色的线走下来后，会先经过&lt;strong&gt;Nginx&lt;/strong&gt;,再到&lt;strong&gt;应用服务（Tomcat/Django）&lt;/strong&gt;，再去访问&lt;strong&gt;Redis/MySQL&lt;/strong&gt;这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有&lt;strong&gt;反向代理&lt;/strong&gt;功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，&lt;strong&gt;反向代理&lt;/strong&gt;必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于&lt;strong&gt;企业内网的边缘节点&lt;/strong&gt;，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来&lt;strong&gt;在一段时间内不变的动态内容缓存到Nginx&lt;/strong&gt;中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 &lt;strong&gt;缓存，加速我们的访问&lt;/strong&gt;。（&lt;strong&gt;反向代理&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;一些&lt;strong&gt;css/js/png&lt;/strong&gt;等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（&lt;strong&gt;静态资源&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（&lt;strong&gt;API服务&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
</feed>
