<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>haoran&#39;s blog</title>
  
  <subtitle>Talk is cheap. Show me the code</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://javassun.github.io/"/>
  <updated>2020-05-18T07:46:30.881Z</updated>
  <id>http://javassun.github.io/</id>
  
  <author>
    <name>Allen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>8-如何设计一个消息队列</title>
    <link href="http://javassun.github.io/2020/04/11/8-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://javassun.github.io/2020/04/11/8-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2020-04-11T11:44:16.000Z</published>
    <updated>2020-05-18T07:46:30.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-面试官心里分析"><a href="#1-面试官心里分析" class="headerlink" title="1. 面试官心里分析"></a>1. 面试官心里分析</h2><p>如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路</p><p>其实聊到这个问题，一般面试官要考察两块：</p><ul><li><p>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个mq的架构原理</p></li><li><p>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来</p></li></ul><p>说实话，遇到类似此类问题，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，大多数人就是平时埋头用，从来不去思考背后的一些东西。类似的问题，如果让你来设计一个spring框架你会怎么做？如果让你来设计一个dubbo框架你会怎么做？如果让你来设计一个mybatis框架你会怎么做？</p><a id="more"></a><h2 id="2-面试题剖析"><a href="#2-面试题剖析" class="headerlink" title="2. 面试题剖析"></a>2. 面试题剖析</h2><p>其实回答这类问题，说白了，起码不求你看过那技术的源码，起码你大概知道那个技术的基本原理，核心组成部分，基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p><p>比如说这个消息队列系统，我们来从以下几个角度来考虑一下</p><h3 id="1-支持可伸缩性"><a href="#1-支持可伸缩性" class="headerlink" title="1 支持可伸缩性"></a>1 支持可伸缩性</h3><p>首先这个mq得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给topic增加partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p><h3 id="2-落地磁盘"><a href="#2-落地磁盘" class="headerlink" title="2 落地磁盘"></a>2 落地磁盘</h3><p>其次你得考虑一下这个mq的数据要不要落地磁盘吧？那肯定要了，落磁盘，才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是kafka的思路。</p><h3 id="3-可用性"><a href="#3-可用性" class="headerlink" title="3 可用性"></a>3 可用性</h3><p>其次你考虑一下你的mq的可用性啊？这个事儿，具体参考我们之前可用性那个环节讲解的kafka的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker挂了重新选举leader即可对外服务。</p><h3 id="4-支持数据0丢失"><a href="#4-支持数据0丢失" class="headerlink" title="4 支持数据0丢失"></a>4 支持数据0丢失</h3><p>能不能支持数据0丢失啊？可以的，参考我们之前说的那个kafka数据零丢失方案</p><p>其实一个mq肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一般而言，如果一个面试官水平还算不错，会沿着从浅入深的环节深入挖一个点。比如一些大牛面试官，其实按照这个思路可以一直问下去，除了这里的7个问题之外，甚至能挑着你熟悉的一个mq一直问到源码级别非常底层。还可能会结合项目来仔细问，可能会先让你给我详细说说你的业务细节，然后将你的业务跟这些mq的问题场景结合起来，看看你每个细节是怎么处理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-面试官心里分析&quot;&gt;&lt;a href=&quot;#1-面试官心里分析&quot; class=&quot;headerlink&quot; title=&quot;1. 面试官心里分析&quot;&gt;&lt;/a&gt;1. 面试官心里分析&lt;/h2&gt;&lt;p&gt;如果让你写一个消息队列，该如何进行架构设计啊？说一下你的思路&lt;/p&gt;
&lt;p&gt;其实聊到这个问题，一般面试官要考察两块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个mq的架构原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说实话，遇到类似此类问题，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，大多数人就是平时埋头用，从来不去思考背后的一些东西。类似的问题，如果让你来设计一个spring框架你会怎么做？如果让你来设计一个dubbo框架你会怎么做？如果让你来设计一个mybatis框架你会怎么做？&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://JavaSsun.github.io/categories/MQ/"/>
    
      <category term="面试" scheme="http://JavaSsun.github.io/categories/MQ/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/categories/MQ/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="面试" scheme="http://JavaSsun.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="MQ" scheme="http://JavaSsun.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ详解</title>
    <link href="http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
    <id>http://javassun.github.io/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-25T12:22:31.000Z</published>
    <updated>2020-05-06T06:33:23.548Z</updated>
    
    <content type="html"><![CDATA[<p>转载<a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/RabbitMQ01.png" alt></p><ul><li>左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。</li><li>中间即是 RabbitMQ，其中包括了 交换机 和 队列。</li><li>右侧 C 代表 消费者，也就是从 RabbitMQ 拿消息的程序。</li></ul><p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机，交换机，队列，和绑定。</p><ul><li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li><li>交换机：<em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li><li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系</li></ul><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout</p><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置 header attribute 参数类型的交换机</li><li>Fanout：转发消息到所有绑定队列</li></ul><p><strong>Direct Exchange</strong></p><p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/rabbitMq_direct.png" alt></p><p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p><p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p><p><strong>Topic Exchange</strong></p><p>Topic Exchange 转发消息主要是根据通配符。_ 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p><p>在这种交换机模式下：</p><ul><li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li><li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li></ul><p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br></pre></td></tr></table></figure><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p><ul><li><code>*</code>表示一个词.</li><li><code>#</code>表示零个或多个词.</li></ul><p><strong>Headers Exchange</strong></p><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><p><strong>Fanout Exchange</strong></p><p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，_会把消息发给绑定给它的全部队列_，如果配置了 routing_key 会被忽略。</p><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了<code>spring-boot-starter-amqp</code> 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 <code>spring-boot-starter-amqp</code> 的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;Spring-boot-rabbitmq</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.0.86</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue Queue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><p>rabbitTemplate 是 Spring Boot 提供的默认实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component</span><br><span class="line">public class HelloSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context &#x3D; &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;hello&quot;)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver  : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，发送者和接收者的 queue name 必须一致，不然不能接收</p></blockquote><h3 id="多对多使用"><a href="#多对多使用" class="headerlink" title="多对多使用"></a>多对多使用</h3><p>一个发送者，N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p><p><strong>一对多发送</strong></p><p>对上面的代码进行了小改造，接收端注册了两个 Receiver,Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void oneToMany() throws Exception &#123;</span><br><span class="line">    for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 12</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 14</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 13</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 15</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 16</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 18</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 17</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 19</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br></pre></td></tr></table></figure><p>根据返回结果得到以下结论</p><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><p><strong>多对多发送</strong></p><p>复制了一份发送者，加入标记，在一百个循环中相互交替发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void manyToMany() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            neoSender.send(i);</span><br><span class="line">            neoSender2.send(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 25</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 25</span><br></pre></td></tr></table></figure><blockquote><p>结论：和一对多一样，接收端仍然会均匀接收到消息</p></blockquote><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p><strong>对象的支持</strong></p><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送者</span><br><span class="line">public void send(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Sender object: &quot; + user.toString());</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;object&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收者</span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Receiver object : &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sender object: User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Receiver object : User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>Topic Exchange</strong></p><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列</p><p>首先对 topic 规则配置，这里使用两个队列来测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    final static String message &#x3D; &quot;topic.message&quot;;</span><br><span class="line">    final static String messages &#x3D; &quot;topic.messages&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;exchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am message 1&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.message&quot;, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am messages 2&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.messages&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息</p><p><strong>Fanout Exchange</strong></p><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>Fanout 相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FanoutRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue AMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue BMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue CMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue AMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, fanout msg &quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver A  : hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg</span><br></pre></td></tr></table></figure><p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zouyesheng.com/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p><p><a href="https://github.com/401Studio/WeekLearn/issues/2" target="_blank" rel="noopener">RabbitMQ：Spring 集成 RabbitMQ 与其概念，消息持久化，ACK机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载&lt;a href=&quot;http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。&lt;/p&gt;
&lt;h2 id=&quot;RabbitMQ-介绍&quot;&gt;&lt;a href=&quot;#RabbitMQ-介绍&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 介绍&quot;&gt;&lt;/a&gt;RabbitMQ 介绍&lt;/h2&gt;&lt;p&gt;RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。&lt;/p&gt;
&lt;p&gt;AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。&lt;/p&gt;
&lt;p&gt;RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MQ" scheme="http://JavaSsun.github.io/categories/MQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://JavaSsun.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot面试</title>
    <link href="http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/"/>
    <id>http://javassun.github.io/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-19T11:18:33.000Z</published>
    <updated>2020-05-06T06:33:16.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：</p><p>问：你觉得 Spring Boot 最大的优势是什么呢？</p><p>答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。</p><p>答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？</p><p>问：Spring Boot Starter 的工作原理是什么？</p><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li><p>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</p></li><li><p>② 根据 spring.factories 配置加载 AutoConfigure 类</p></li><li><p>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</p></li></ul><p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p><a id="more"></a><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p><p>第三部：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>是不是很爽？</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p><h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p><p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p><p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p><h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p><h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p><p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p><p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p><h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p><p>一般前端的解决方案有：</p><ul><li><p>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</p></li><li><p>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</p></li></ul><p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p><p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p><p>第一，配置 CorsFilter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置上述的一段代码。第二种方式稍微简单一些。</p><p>第二，在启动类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p><p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p><h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>用一组不太合理的包含关系来表达它们之间的关系。</p><p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：&lt;/p&gt;
&lt;p&gt;问：你觉得 Spring Boot 最大的优势是什么呢？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;/p&gt;
&lt;p&gt;问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。&lt;/p&gt;
&lt;p&gt;答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？&lt;/p&gt;
&lt;p&gt;问：Spring Boot Starter 的工作原理是什么？&lt;/p&gt;
&lt;p&gt;答：Spring Boot 在启动的时候会干这几件事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;② 根据 spring.factories 配置加载 AutoConfigure 类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="面试" scheme="http://JavaSsun.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ELK日志平台-中</title>
    <link href="http://javassun.github.io/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/"/>
    <id>http://javassun.github.io/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/</id>
    <published>2020-02-11T06:25:35.000Z</published>
    <updated>2020-05-17T04:06:28.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于初期系统日志量还在可控范围，选择 ELK+Beats 的方案，并未引入消息队列，后续根据需求可以对系统升级。由此，只需要在日志平台部署 Elasticsearch 和 Logstash 集群，同时在应用服务器部署 Filebeat即可。</p><p><strong>ELK版本务必保持一致，否则可能会出现 Kibana server is not ready yet的情况。</strong><br><font color="red"><strong>警告：</strong><br><strong>ELK 版本 7.4.X 以上需要 Java11 版本</strong><br><strong>ELK 版本 6.6.0 可以使用 Java8 版本</strong><br><strong>因此我们使用 6.6.0 版本</strong><br></font></p><a id="more"></a><h2 id="1-安装前准备"><a href="#1-安装前准备" class="headerlink" title="1 安装前准备"></a>1 安装前准备</h2><h3 id="JAVA环境"><a href="#JAVA环境" class="headerlink" title="JAVA环境"></a>JAVA环境</h3><p>ELK 需要 JAVA 8 以上的运行环境，若未安装则按如下步骤安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看是否安装</span><br><span class="line">rpm -qa | grep java</span><br><span class="line"># 批量卸载</span><br><span class="line">rpm -qa | grep java | xargs rpm -e --nodeps</span><br><span class="line">yum install -y java-1.8.0-openjdk*</span><br><span class="line">java -version</span><br><span class="line">openjdk version &quot;1.8.0_151&quot;</span><br></pre></td></tr></table></figure><p>在文件<code>/etc/profile</code>配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 指向安装目录，其中1.8.0.151需与版本号保持一致</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.151-1.b12.el6_9.x86_64</span><br><span class="line">PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH</span><br><span class="line">CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line">JAVACMD&#x3D;&#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">export JAVA_HOME JAVACMD CLASSPATH PATH</span><br></pre></td></tr></table></figure><p>执行<code>source /etc/profile</code>命令，使配置环境生效</p><h3 id="安装GPG-KEY"><a href="#安装GPG-KEY" class="headerlink" title="安装GPG-KEY"></a>安装GPG-KEY</h3><p>由于后续采用 yum 安装，所以需要下载并安装 GPG-KEY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch</span><br></pre></td></tr></table></figure><blockquote><p>yum 命令会安装最新的版本，若需安装较旧的版本，请先从 <a href="https://www.elastic.co/downloads/past-releases" target="_blank" rel="noopener">官方地址</a> 下载对应的旧版本 rpm 包，然后使用<code>rpm -ivh</code>命令安装。</p></blockquote><h2 id="2-Elasticsearch"><a href="#2-Elasticsearch" class="headerlink" title="2 Elasticsearch"></a>2 Elasticsearch</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>1 如果网速过慢，可以选择笔记附件下载。</p></li><li><p>2 通过 <a href="https://www.elastic.co/downloads/past-releases" target="_blank" rel="noopener">官方地址</a> 下载选择最新版本，然后解压：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-6.6.0.tar.gz</span><br><span class="line"></span><br><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch-6.6.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch-6.6.0 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">cd elasticsearch</span><br><span class="line">mkdir data &#x2F;&#x2F;存数据文件用</span><br><span class="line">mkdir logs &#x2F;&#x2F;存日志文件用 如果有就不用再次创建</span><br></pre></td></tr></table></figure><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/79c3dd35-de46-4154-8137-936d6c2d3f27.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">目录结构介绍：</span><br><span class="line">bin：可执行文件，运行es的命令</span><br><span class="line">config：配置文件目录</span><br><span class="line"> config&#x2F;elasticsearch.yml：ES启动基础配置</span><br><span class="line"> config&#x2F;jvm.options：ES启动时JVM配置</span><br><span class="line"> config&#x2F;log4j2.properties：ES日志输出配置文件</span><br><span class="line">lib：依赖的jar</span><br><span class="line">logs：日志文件夹</span><br><span class="line">modules：es模块</span><br><span class="line">plugins：可以自己开发的插件</span><br><span class="line">data：我们自己创建的，存放es存储文件</span><br></pre></td></tr></table></figure><p>由于 Elasticsearch 新版本不允许以 <strong>root</strong> 身份启动，因此先创建 elk 用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接以root用户启动 会报错</span><br><span class="line">bin&#x2F;elasticsearch</span><br></pre></td></tr></table></figure><p>所以需要创建用户并赋予es安装目录权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建一个esroot用户并设置初始密码</span><br><span class="line">useradd -c &quot;ES user&quot; -d &#x2F;home&#x2F;esroot esroot</span><br><span class="line">passwd esroot</span><br><span class="line"></span><br><span class="line">将es安装目录属主权威改为esroot用户</span><br><span class="line">chown -R esroot &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch</span><br><span class="line"></span><br><span class="line">切换用户到esroot</span><br><span class="line">su esroot</span><br><span class="line"></span><br><span class="line">.&#x2F;elasticsearch -d 重启即可</span><br></pre></td></tr></table></figure><p><strong>可能出现的错误：</strong></p><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/2a7d0653-0f1e-4125-9507-b91ad467c647.png" alt></p><ul><li>1 jvm 的 Xms / Xmx 设置不一致，将其设置一致即可</li></ul><p>启动前，需要修改配置文件<code>jvm.options</code>中 JVM 大小，否则可能会内存溢出，导致启动失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd elasticsearch</span><br><span class="line">vim config&#x2F;jvm.options</span><br><span class="line"># 根据实际情况修改</span><br><span class="line">-Xms128m</span><br><span class="line">-Xmx128m</span><br></pre></td></tr></table></figure><ul><li><p>2 要设置系统参数vm.max_map_count=262144<br>原话为：<br><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.elastic.co%2Fguide%2Fen%2Felasticsearch%2Freference%2Fcurrent%2Fdocker.html%23docker-cli-run-prod-mode" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker-cli-run-prod-mode</a><br>The vm.max_map_count kernel setting needs to be set to at least 262144 for production use. Depending on your platform:</p></li><li><p>Linux<br> The vm.max_map_count setting should be set permanently in /etc/sysctl.conf:<br> To apply the setting on a live system type: sysctl -w vm.max_map_count=262144</p></li></ul><blockquote><p>$ grep vm.max_map_count /etc/sysctl.conf</p></blockquote><blockquote><p> vm.max_map_count=262144</p></blockquote><p><strong>解决办法：</strong><br>切换为root用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看vm.max_map_count属性值，</span><br><span class="line"></span><br><span class="line">如果没有添加则在&#x2F;etc&#x2F;sysctl.conf文件添加vm.max_map_count &#x3D; 262144</span><br><span class="line">grep vm.max_map_count &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line">或者执行添加临时变量</span><br><span class="line">sysctl -w vm.max_map_count&#x3D;262144</span><br></pre></td></tr></table></figure><h2 id="简要配置"><a href="#简要配置" class="headerlink" title="简要配置"></a>简要配置</h2><p><strong>1-5为elasticsearch.yml配置，6为jvm.options配置</strong></p><ul><li><p>1 配置集群名称（默认备注是，并且默认只有一个集群名）<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/3147066a-cd7c-4896-b9a2-f2741bae7da3.png" alt></p></li><li><p>2 配置当前es节点名称（默认是被注释的，并且默认有一个节点名）<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/12abb2c6-24a1-4d71-861e-68f23ed81be7.png" alt></p></li><li><p>3 配置存储数据的目录路径（用逗号分隔多个位置）和日志文件路径<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/30f50069-f103-4501-8a96-9703411b1b3e.png" alt></p></li><li><p>4 绑定地址为特定IP地址（设置0.0.0.0可以让任何人访问到你的es），设置一个http请求端口<br>添加一行为 http.host: 0.0.0.0 即可。<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/6a74c5c3-69c9-417f-98b6-0ee9704a3cdb.png" alt></p></li><li><p>5 集群启动，参看同目录其他文章。</p></li><li><p>6 配置ES启动JVM参数<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/5bafb14b-cca0-42a9-babc-20803c96c263.png" alt></p></li></ul><p>CentOS7 设置开机启动服务，启动 Elasticsearch，其默认监听 9200 端口。\</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf</span><br><span class="line">添加如下内容：</span><br><span class="line">* soft nofile 65536 </span><br><span class="line">* hard nofile 131072 </span><br><span class="line">* soft nproc 2048 </span><br><span class="line">* hard nproc 4096</span><br></pre></td></tr></table></figure><p>在/etc/systemd/system目录下创建elasticsearch.service文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;elasticsearch</span><br><span class="line">[Service]</span><br><span class="line">User&#x3D;esroot</span><br><span class="line">LimitNOFILE&#x3D;100000</span><br><span class="line">LimitNPROC&#x3D;100000</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch&#x2F;bin&#x2F;elasticsearch</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>设置开机自启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable elasticsearch</span><br></pre></td></tr></table></figure><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/2c40d70f-16d8-4194-b9ed-368bb40aff2b.png" alt></p><p>最后，安装使用到的插件 可能需要用到 <strong>Java11版本</strong>，看情况安装下述插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch</span><br><span class="line"># ingest-geoip和ingest-user-agent分别为ip解析插件和agent解析插件</span><br><span class="line">bin&#x2F;elasticsearch-plugin install ingest-geoip</span><br><span class="line">bin&#x2F;elasticsearch-plugin install ingest-user-agent</span><br><span class="line"># 用户管理和monitor管理</span><br><span class="line">bin&#x2F;elasticsearch-plugin install x-pack</span><br></pre></td></tr></table></figure><blockquote><p>安装 x-pack 插件后，对 Elasticsearch 的操作都需要授权，默认用户名为 elastic，默认密码为 changeme。</p></blockquote><p>启动成功图：-d 以后台方式启动<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/7fb9cc65-9e32-4d2f-b36b-e79ff144381a.png" alt></p><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/36b45622-af07-4e53-ad1a-ffb4c6d2fcdc.png" alt></p><h3 id="问题及解决办法"><a href="#问题及解决办法" class="headerlink" title="问题及解决办法"></a>问题及解决办法</h3><h4 id="1-权限问题"><a href="#1-权限问题" class="headerlink" title="1 权限问题"></a>1 权限问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: Cannot open file logs&#x2F;gc.log due to Permission denied</span><br><span class="line"></span><br><span class="line">[esroot@haoransun elasticsearch]$ Exception in thread &quot;main&quot; org.elasticsearch.bootstrap.BootstrapException: java.nio.file.AccessDeniedException: &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.keystore</span><br></pre></td></tr></table></figure><p>解决方法：<br>因为第一次启动不小心用了root启动，导致用root生成了对应的文件。切换es账号之后，没有对应文件的权限导致，删除相关的东西即可。<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/05421b4d-63cb-4019-88e2-3d5b25fe1b01.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf elasticsearch.keystore gc.log.0.current</span><br></pre></td></tr></table></figure><h4 id="2-max-number-of-threads-1024"><a href="#2-max-number-of-threads-1024" class="headerlink" title="2 #### max number of threads [1024]"></a>2 #### max number of threads [1024]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RROR: [2] bootstrap checks failed</span><br><span class="line">[1]: max number of threads [1024] for user [es] is too low, increase to at least [4096]</span><br><span class="line">[2]: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</span><br></pre></td></tr></table></figure><p>解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br><span class="line"></span><br><span class="line">max user processes              (-u) 1024</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;90-nproc.conf </span><br><span class="line"></span><br><span class="line"># Default limit for number of user&#39;s processes to prevent</span><br><span class="line"># accidental fork bombs.</span><br><span class="line"># See rhbz #432903 for reasoning.</span><br><span class="line"></span><br><span class="line">* hard nproc 4096</span><br><span class="line">* soft nproc 4096</span><br><span class="line">*          soft    nproc     4096</span><br><span class="line">root       soft    nproc     unlimited</span><br></pre></td></tr></table></figure><h4 id="3-system-call-filters-failed-to-install-check-the-logs-and-fix-your-configuration-or-disable-system-call-filters-at-your-own-risk"><a href="#3-system-call-filters-failed-to-install-check-the-logs-and-fix-your-configuration-or-disable-system-call-filters-at-your-own-risk" class="headerlink" title="3 system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk"></a>3 system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk</h4><p>这是在因为Centos6不支持SecComp，而ES5.2.0默认bootstrap.system_call_filter为true进行检测，所以导致检测失败，失败后直接导致ES不能启动。</p><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在elasticsearch.yml中配置bootstrap.system_call_filter为false，注意要在Memory下面:</span><br><span class="line">bootstrap.memory_lock: false</span><br><span class="line">bootstrap.system_call_filter: false</span><br></pre></td></tr></table></figure><h4 id="4-日志级别报错"><a href="#4-日志级别报错" class="headerlink" title="4 日志级别报错"></a>4 日志级别报错</h4><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/761060a0-6483-4264-b1ec-b739a115edfb.png" alt></p><p>需要修改config配置里的log4j2.properties 文件, 将 logger.deprecation.level = warn 改为 error即可。</p><h4 id="5-main-ERROR-Unable-to-invoke-factory-method-in-class-org-apache-logging-log4j-core"><a href="#5-main-ERROR-Unable-to-invoke-factory-method-in-class-org-apache-logging-log4j-core" class="headerlink" title="5 # main ERROR Unable to invoke factory method in class org.apache.logging.log4j.core"></a>5 # main ERROR Unable to invoke factory method in class org.apache.logging.log4j.core</h4><p>原因：在安装elasticsearch时，新建的logs目录是用root用户建的，因此，logs下的文件是root用户权限，因此，将该权限改为非root用户即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R esroot logs&#x2F;</span><br><span class="line">chgrp -R esroot logs&#x2F;</span><br></pre></td></tr></table></figure><p>再次启动，不会报错。</p><h2 id="3-Kibana"><a href="#3-Kibana" class="headerlink" title="3 Kibana"></a>3 Kibana</h2><h3 id="下载kibana安装包"><a href="#下载kibana安装包" class="headerlink" title="下载kibana安装包"></a>下载kibana安装包</h3><p>如果网速过慢，可以选择笔记附件下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;kibana&#x2F;kibana-6.6.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="解压kibana安装包"><a href="#解压kibana安装包" class="headerlink" title="解压kibana安装包"></a>解压kibana安装包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">tar -zxvf kibana-6.6.0-linux-x86_64.tar.gz  -C &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;kibana-6.6.0-linux-x86_64 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;kibana</span><br></pre></td></tr></table></figure><h3 id="修改kibana配置，config目录下的kibana-yml"><a href="#修改kibana配置，config目录下的kibana-yml" class="headerlink" title="修改kibana配置，config目录下的kibana.yml"></a>修改kibana配置，config目录下的kibana.yml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;kibana&#x2F;config&#x2F;kibana.yml</span><br><span class="line"></span><br><span class="line"># 修改内容</span><br><span class="line">server.port: 5601</span><br><span class="line"></span><br><span class="line">server.host: &quot;内网地址或者是0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line">elasticsearch.url: &quot;http:&#x2F;&#x2F;ElasticSearch所在ip地址:9200&quot;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/daa6f970-9bf4-4e09-8fb3-3b31b51c8906.png" alt></p><p>安装常用插件，如 x-pack</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;kibana-plugin install x-pack</span><br></pre></td></tr></table></figure><blockquote><p>安装 x-pack 插件后，访问 Kibana 同样需要授权，且任何 Elasticsearch 的用户名和密码对都可被认证通过。</p></blockquote><h3 id="启动-kibana"><a href="#启动-kibana" class="headerlink" title="启动 kibana"></a>启动 kibana</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd bin </span><br><span class="line">nohup .&#x2F;kibana &amp;</span><br></pre></td></tr></table></figure><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ul><li><strong>1 网络不可访问</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;“type”:“error”,&quot;@timestamp&quot;:“2019-04-06T00:25:22Z”,“tags”:[“fatal”,“root”],“pid”:754,“level”:“fatal”,“error”:&#123;“message”:“listen EADDRNOTAVAIL localhost:5601”,“name”:“Error”,“stack”:&quot;Error: listen EADDRNOTAVAIL localhost:5601\n at Server.setupListenHandle [as _listen2] (net.js:1343:19)\n …</span><br></pre></td></tr></table></figure>解决方案：<br>由于server.host: 之前设置的是阿里云服务器的外网ip地址，所以启动kibana一直报错 将server.host改为”内网地址或者是0.0.0.0”即可</li></ul><ul><li><strong>2 Kibana 运行时 NodeJs 默认会最大分配 1G 内存，可以在启动时增加<code>max-old-space-size</code>参数，以限制其运行内存大小</strong></li></ul><p><strong>同理：kibana not ready yet</strong></p><p><strong>同理：kibana FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim bin&#x2F;kibana</span><br><span class="line"></span><br><span class="line"># 增加--max-old-space-size&#x3D;140参数</span><br><span class="line">NODE_ENV&#x3D;production exec &quot;$&#123;NODE&#125;&quot; $NODE_OPTIONS --max-old-space-size&#x3D;200 --no-warnings &quot;$&#123;DIR&#125;&#x2F;src&#x2F;cli&quot; $&#123;@&#125;</span><br></pre></td></tr></table></figure><h3 id="防护墙开放5601端口，并测试访问"><a href="#防护墙开放5601端口，并测试访问" class="headerlink" title="防护墙开放5601端口，并测试访问"></a>防护墙开放5601端口，并测试访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;5601&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><p>访问 <a href="http://192.168.121.100:5601/app/kibana" target="_blank" rel="noopener">http://192.168.121.100:5601/app/kibana</a> 即可<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/8cf66438-c28c-4fc6-bfa5-f6d3480629c8.png" alt></p><hr><h2 id="4-Logstash"><a href="#4-Logstash" class="headerlink" title="4 Logstash"></a>4 Logstash</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a><a href="https://www.elastic.co/guide/en/logstash/current/installing-logstash.html#_yum" target="_blank" rel="noopener">安装</a></h3><ul><li>方法1</li></ul><p>首先，在<code>/etc/yum.repos.d</code>目录下创建<code>logstash.repo</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[logstash-6.x] </span><br><span class="line">name&#x3D;Elastic repository for  6.x packages</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;packages&#x2F;6.x&#x2F;yum</span><br><span class="line">gpgcheck&#x3D;1 </span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;GPG-KEY-elasticsearch</span><br><span class="line">enabled&#x3D;1 </span><br><span class="line">autorefresh&#x3D;1 </span><br><span class="line">type&#x3D;rpm-md</span><br></pre></td></tr></table></figure><p>使用 yum 安装 Logstash，并测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装logstash 6.x</span><br><span class="line">$ yum install -y logstash</span><br><span class="line"># 默认安装路径&#x2F;usr&#x2F;share</span><br><span class="line">$ mkdir -p &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line">$ ln -s &#x2F;usr&#x2F;share&#x2F;logstash &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;logstash</span><br><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk&#x2F;logstash</span><br><span class="line"># 命令行测试</span><br><span class="line">$ bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span><br><span class="line"></span><br><span class="line">The stdin plugin is now waiting for input:</span><br><span class="line">elk</span><br><span class="line">2017-11-21T22:25:07.264Z fhb elk</span><br></pre></td></tr></table></figure><ul><li>方法2<br>按上述连接安装，如果网速过慢，可以使用笔记附件安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">tar -zxvf logstash-6.6.0.tar.gz -C &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">mv logstash-6.6.0 logstash</span><br><span class="line"></span><br><span class="line">cd logstash</span><br></pre></td></tr></table></figure><h3 id="安装插件-可能需要一些时间"><a href="#安装插件-可能需要一些时间" class="headerlink" title="安装插件(可能需要一些时间)"></a>安装插件(可能需要一些时间)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash-plugin install logstash-input-jdbc</span><br><span class="line"></span><br><span class="line">bin&#x2F;logstash-plugin install logstash-output-elasticsearch</span><br><span class="line"></span><br><span class="line">安装 x-pack 插件，基本状态信息的监控:</span><br><span class="line">bin&#x2F;logstash-plugin install x-pack</span><br></pre></td></tr></table></figure><p>修改 JVM 内存大小，防止出现内存溢出异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim config&#x2F;jvm.options</span><br><span class="line"># 根据实际情况修改</span><br><span class="line">-Xms150m</span><br><span class="line">-Xmx150m</span><br></pre></td></tr></table></figure><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果没有 logs文件夹，则自己创建</span><br><span class="line">mkdir logs</span><br></pre></td></tr></table></figure><p><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/402f2720-4ed0-43f6-b4ad-e14b50b65e9c.png" alt></p><h3 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span><br></pre></td></tr></table></figure><blockquote><p>-e 即允许从命令行指定配置</p></blockquote><p>启动成功后，输入 hello world，会有如下显示，则安装成功。<br><img src="/2020/02/11/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%AD/d7cd18ae-eff8-4a43-87a5-3290bd35259b.png" alt></p><h2 id="5-Filebeat"><a href="#5-Filebeat" class="headerlink" title="5 Filebeat"></a>5 Filebeat</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="[安装]"></a>[安装]</h3><ul><li><p>1 网速较慢，使用笔记附件安装</p></li><li><p>2 使用 wget 下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget  https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;beats&#x2F;filebeat&#x2F;filebeat-6.6.0-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure></li></ul><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">tar -zxvf filebeat-6.6.0-linux-x86_64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;geek&#x2F;elk</span><br><span class="line"></span><br><span class="line">mv filebeat-6.6.0-linux-x86_64 filebeat</span><br><span class="line"></span><br><span class="line">cd filebeat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于初期系统日志量还在可控范围，选择 ELK+Beats 的方案，并未引入消息队列，后续根据需求可以对系统升级。由此，只需要在日志平台部署 Elasticsearch 和 Logstash 集群，同时在应用服务器部署 Filebeat即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ELK版本务必保持一致，否则可能会出现 Kibana server is not ready yet的情况。&lt;/strong&gt;&lt;br&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;警告：&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;ELK 版本 7.4.X 以上需要 Java11 版本&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;ELK 版本 6.6.0 可以使用 Java8 版本&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;因此我们使用 6.6.0 版本&lt;/strong&gt;&lt;br&gt;&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ELK" scheme="http://JavaSsun.github.io/categories/ELK/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/categories/ELK/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/categories/ELK/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="ELK" scheme="http://JavaSsun.github.io/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>ELK日志平台-上</title>
    <link href="http://javassun.github.io/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/"/>
    <id>http://javassun.github.io/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/</id>
    <published>2020-02-10T02:30:57.000Z</published>
    <updated>2020-05-17T04:06:55.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在过往的单体应用时代，我们所有组件都部署到一台服务器中，那时日志管理平台的需求可能并没有那么强烈，我们只需要登录到一台服务器通过shell命令就可以很方便的查看系统日志，并快速定位问题。随着互联网的发展，互联网已经全面渗入到生活的各个领域，使用互联网的用户量也越来越多，单体应用已不能够支持庞大的用户的并发量，那么将单体应用进行拆分，通过水平扩展来支持庞大用户的使用迫在眉睫，微服务概念就是在类似这样的阶段诞生，在微服务盛行的互联网技术时代，单个应用被拆分为多个应用，每个应用集群部署进行负载均衡，那么如果某项业务发生系统错误，开发或运维人员还是以过往单体应用方式登录一台一台登录服务器查看日志来定位问题，这种解决线上问题的效率可想而知。日志管理平台的建设就显得极其重要。通过Logstash去收集每台服务器日志文件，然后按定义的正则模板过滤后传输到Kafka或redis，然后由另一个Logstash从KafKa或redis读取日志存储到elasticsearch中创建索引，最后通过Kibana展示给开发者或运维人员进行分析。这样大大提升了运维线上问题的效率。除此之外，还可以将收集的日志进行大数据分析，得到更有价值的数据给到高层进行决策。</p><p><strong>优点</strong></p><ul><li><p>ELK 提供的功能满足使用要求，并有较高的扩展性。</p></li><li><p>ELK 为一套开源项目，较低的维护成本。</p><a id="more"></a><h2 id="1-相关概念"><a href="#1-相关概念" class="headerlink" title="1 相关概念"></a>1 相关概念</h2><p>ELK 指的是一套解决方案，是 <a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a>、<a href="https://www.elastic.co/cn/products/logstash" target="_blank" rel="noopener">Logstash</a> 和 <a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="noopener">Kibana</a> 三种软件产品的首字母缩写，<a href="https://www.elastic.co/cn/products/beats" target="_blank" rel="noopener">Beats</a> 是 ELK 协议栈的新成员。</p></li><li><p>E：代表 Elasticsearch，负责日志的存储和检索；</p></li><li><p>L：代表 Logstash，负责日志的收集、过滤和格式化；</p></li><li><p>K：代表 Kibana，负责日志数据的可视化；</p></li><li><p>Beats：是一类轻量级数据采集器；</p></li></ul><p>其中，目前 Beats 家族根据功能划分，主要包括 4 种：</p><ul><li>Filebeat：负责收集文件数据；</li><li>Packetbeat：负责收集网络流量数据；</li><li>Metricbeat：负责收集系统级的 CPU 使用率、内存、文件系统、磁盘 IO 和网络 IO 统计数据；</li><li>Winlogbeat：负责收集 Windows 事件日志数据;</li></ul><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/a68a642c-bc33-4ba2-bc23-92ea182d89a4.png" alt></p><p>在我们将要搭建的集中式日志平台系统中，就使用了 Filebeat 作为日志文件收集工具，Filebeat 可以很方便地收集 Nginx、Mysql、Redis、Syslog 等应用的日志文件。</p><h2 id="2-日志平台架构"><a href="#2-日志平台架构" class="headerlink" title="2 日志平台架构"></a>2 日志平台架构</h2><p>ELK 集中日志平台也是经过一次次演变，它的大概收集过程如下：</p><p>1 部署在应用服务器上的数据采集器，近实时收集日志数据推送到日志过滤节点的 Logstash</p><p>2 Logstash 再推送格式化的日志数据到 Elasticsearch 存储</p><p>3 Kibana 通过 Elasticsearch 集中检索日志并可视化</p><h3 id="ES-Logstash-Kibana"><a href="#ES-Logstash-Kibana" class="headerlink" title="ES + Logstash + Kibana"></a>ES + Logstash + Kibana</h3><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/5aa407d6-4820-4acb-99da-95058cc265e4.png" alt></p><p>最开始的架构中，由 Logstash 承担数据采集器和过滤功能，并部署在应用服务器。由于 Logstash 对大量日志进行过滤操作，会消耗应用系统的部分性能，带来不合理的资源分配问题；另一方面，过滤日志的配置，分布在每台应用服务器，不便于集中式配置管理。</p><h3 id="引入Logstash-forwarder"><a href="#引入Logstash-forwarder" class="headerlink" title="引入Logstash-forwarder"></a>引入Logstash-forwarder</h3><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/db6ea5c6-7135-4797-8405-cfb8eea22c36.jpg" alt></p><p>使用该架构，引入 Logstash-forwarder 作为数据采集，Logstash 和应用服务器分离，应用服务器只做数据采集，数据过滤统一在日志平台服务器，解决了之前存在的问题。但是 Logstash-forwarder 和 Logstash 间通信必须由 SSL 加密传输，部署麻烦且系统性能并没有显著提升；另一方面，Logstash-forwarder 的定位并不是数据采集插件，系统不易扩展。</p><h3 id="引入Beats"><a href="#引入Beats" class="headerlink" title="引入Beats"></a>引入Beats</h3><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/086379ce-c6f4-433d-82b9-3c108226af58.jpg" alt></p><p>该架构，基于 Logstash-forwarder 架构，将 Logstash-forwarder 替换为 Beats。由于 Beats 的系统性能开销更小，所以应用服务器性能开销可以忽略不计；另一方面，Beats 可以作为数据采集插件形式工作，可以按需启用 Beats 下不同功能的插件，更灵活，扩展性更强。例如，应用服务器只启用 Filebeat，则只收集日志文件数据，如果某天需要收集系统性能数据时，再启用 Metricbeat 即可，并不需要太多的修改和配置。</p><p>这种 ELK+Beats 的架构，已经满足大部分应用场景了，但当业务系统庞大，日志数据量较大、较实时时，业务系统就和日志系统耦合在一起了。</p><h3 id="引入队列"><a href="#引入队列" class="headerlink" title="引入队列"></a>引入队列</h3><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/b7139e8c-0c37-4ba8-b5ff-b16956ee2b36.jpg" alt></p><p>该架构，引入消息队列，均衡了网络传输，从而降低了网络闭塞，尤其是丢失数据的可能性；另一方面，这样可以系统解耦，具有更好的灵活性和扩展性。</p><h2 id="3-经验"><a href="#3-经验" class="headerlink" title="3 经验"></a>3 经验</h2><p>成熟的 ELK+Beats 架构，因其扩展性很强，是集中式日志平台的首选方案。在实际部署时，是否引入消息队列，根据业务系统量来确定，早期也可以不引入消息队列，简单部署，后续需要扩展再接入消息队列。</p><h2 id="4-ELK概念解读"><a href="#4-ELK概念解读" class="headerlink" title="4 ELK概念解读"></a>4 ELK概念解读</h2><h3 id="1-Elasticsearch"><a href="#1-Elasticsearch" class="headerlink" title="1 Elasticsearch"></a>1 Elasticsearch</h3><h4 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h4><p><strong>Elasticsearch</strong>是一个开源的分布式、RESTful 风格的搜索和数据分析引擎，它的底层是开源库Apache Lucene。</p><p>Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库——无论是开源还是私有，但它也仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理，因为Lucene 非常复杂。</p><p>为了解决Lucene使用时的繁复性，于是Elasticsearch便应运而生。它使用 Java 编写，内部采用 Lucene 做索引与搜索，但是它的目标是使全文检索变得更简单，简单来说，就是对Lucene 做了一层封装，它提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。</p><p>当然，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确地形容：</p><ul><li>一个分布式的实时文档存储，每个字段可以被索引与搜索；</li><li>一个分布式实时分析搜索引擎；</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li></ul><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/401b561c-02d3-447c-92ff-5f4cedf50f57.jpg" alt></p><h4 id="ES核心概念"><a href="#ES核心概念" class="headerlink" title="ES核心概念"></a>ES核心概念</h4><h5 id="1-节点-amp-集群（Node-amp-Cluster）"><a href="#1-节点-amp-集群（Node-amp-Cluster）" class="headerlink" title="1 节点 &amp; 集群（Node &amp; Cluster）"></a>1 节点 &amp; 集群（Node &amp; Cluster）</h5><p>Elasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个Elasticsearch实例。单个Elasticsearch实例称为一个节点（Node），一组节点构成一个集群（Cluster）。</p><h5 id="2-索引（Index）"><a href="#2-索引（Index）" class="headerlink" title="2 索引（Index）"></a>2 索引（Index）</h5><p>Elasticsearch 数据管理的顶层单位就叫做 Index（索引），相当于关系型数据库里的数据库的概念。另外，每个Index的名字必须是小写。</p><h5 id="3-Shard-分片"><a href="#3-Shard-分片" class="headerlink" title="3 Shard 分片"></a>3 Shard 分片</h5><p>当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。<br>当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。</p><h5 id="4-Replia-副本"><a href="#4-Replia-副本" class="headerlink" title="4 Replia 副本"></a>4 Replia 副本</h5><p>为提高查询吞吐量或实现高可用性，可以使用分片副本。<br>副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。<br>当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。</p><h5 id="5-全文搜索-Full-text-Search"><a href="#5-全文搜索-Full-text-Search" class="headerlink" title="5 全文搜索(Full-text Search)"></a>5 全文搜索(Full-text Search)</h5><p>文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。</p><p>在全文搜索的世界中，存在着几个庞大的帝国，也就是主流工具，主要有：</p><ul><li>Apache Lucene</li><li>Elasticsearch</li><li>Solr</li><li>Ferret</li></ul><h5 id="6-倒排索引（Inverted-Index）"><a href="#6-倒排索引（Inverted-Index）" class="headerlink" title="6 倒排索引（Inverted Index）"></a>6 倒排索引（Inverted Index）</h5><p>该索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引(inverted index)。Elasticsearch能够实现快速、高效的搜索功能，正是基于倒排索引原理。</p><h5 id="7-文档（Document）"><a href="#7-文档（Document）" class="headerlink" title="7 文档（Document）"></a>7 文档（Document）</h5><p>index里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。Document 使用 JSON 格式表示。同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><h5 id="8-类型（Type）"><a href="#8-类型（Type）" class="headerlink" title="8 类型（Type）"></a>8 类型（Type）</h5><p>Document 可以分组，比如employee这个 Index 里面，可以按部门分组，也可以按职级分组。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document，类似关系型数据库中的数据表。</p><p>不同的 Type 应该有相似的结构（Schema），性质完全不同的数据（比如 products 和 logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p><h5 id="9-文档元数据（Document-metadata）"><a href="#9-文档元数据（Document-metadata）" class="headerlink" title="9 文档元数据（Document metadata）"></a>9 文档元数据（Document metadata）</h5><p>文档元数据为_index, _type, _id, 这三者可以唯一表示一个文档，_index表示文档在哪存放，_type表示文档的对象类别，_id为文档的唯一标识。</p><h5 id="10-字段（Fields"><a href="#10-字段（Fields" class="headerlink" title="10 字段（Fields)"></a>10 字段（Fields)</h5><p>每个Document都类似一个JSON结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document，可以类比关系型数据库数据表中的字段。</p><p>在 Elasticsearch 中，文档（Document）归属于一种类型（Type），而这些类型存在于索引（Index）中，下图展示了Elasticsearch与传统关系型数据库的类比：</p><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/7e518ba2-3105-4448-b7ba-bed4bbfeaeff.jpg" alt></p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/fec9e928-09be-4fd7-b932-eaaf60a4e582.jpg" alt></p><h3 id="2-Kibana"><a href="#2-Kibana" class="headerlink" title="2 Kibana"></a>2 Kibana</h3><h4 id="软件介绍-1"><a href="#软件介绍-1" class="headerlink" title="软件介绍"></a>软件介绍</h4><p>Kibana 是为 Elasticsearch设计的开源分析和可视化平台。你可以使用 Kibana 来搜索，查看存储在 Elasticsearch 索引中的数据并与之交互。你可以很容易实现高级的数据分析和可视化，以图标的形式展现出来，通过改变Elasticsearch查询时间，可以完成动态仪表盘。</p><p><strong>使用场景</strong></p><ul><li><p>实时监控<br>通过 histogram 面板，配合不同条件的多个 queries 可以对一个事件走很多个维度组合出不同的时间序列走势。时间序列数据是最常见的监控报警了。</p></li><li><p>问题分析<br>关于 elk 的用途，可以参照其对应的商业产品 splunk 的场景：使用 Splunk 的意义在于使信息收集和处理智能化。</p></li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>搜索和展示信息，可以查看Discover页面。</p><p>图表和地图展示，可以查看Visualize。</p><p>创建一个仪表盘，可以使用Dashboard</p><h3 id="3-Logstash"><a href="#3-Logstash" class="headerlink" title="3 Logstash"></a>3 Logstash</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>建议在使用logstash之前先想清楚自己的需求是什么，从哪种数据源同步到哪里，需要经过怎么样的处理。因为logstash版本迭代较快，每个版本的插件都有点区别，比如filter中的http插件在6.6版本以后才有；output到现在(7.1)都没有jdbc的插件，然而你如果想使用output的jdbc插件就需要自己去安装热心人自己写的插件(logstash-output-jdbc),不幸的是，该作者指出没有很多的时间去维护此插件，不能保证6.3以后用户的正常使用。<br> 也就是说，如果你想用output的jdbc，你就必须使用6.3以下(最好5.x)的版本，如果你想用官方filter的http插件，你就得用6.5以上的版本。</p><blockquote><p>如果目标数据源的type为jdbc，则建议安装logstash-5.4.1或6.x一下的版本，因为logstash-output-jdbc只在6.x以下有效.</p></blockquote><h4 id="软件介绍-2"><a href="#软件介绍-2" class="headerlink" title="软件介绍"></a>软件介绍</h4><p>官方介绍：Logstash is an open source data collection engine with real-time pipelining capabilities。</p><p>Logstash是一个开源数据收集引擎，具有实时管道功能。Logstash可以动态地将来自不同数据源的数据统一起来，并将数据标准化到你所选择的目的地。</p><p><strong>Logstash常用于日志关系系统中做日志采集设备</strong></p><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/11b125b4-251c-4690-9d28-9c31bc618431.jpg" alt></p><h4 id="系统架构-1"><a href="#系统架构-1" class="headerlink" title="系统架构"></a>系统架构</h4><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/06abbb73-b15b-41fb-ab83-de441b586182.jpg" alt></p><p>Logstash的事件（logstash将数据流中等每一条数据称之为一个event）处理流水线有三个主要角色完成：inputs –&gt; filters –&gt; outputs：</p><ul><li><p>inpust：必须，负责产生事件（Inputs generate events），常用：File、syslog、redis、beats（如：Filebeats）</p></li><li><p>filters：可选，负责数据处理与转换（filters modify them），常用：grok、mutate、drop、clone、geoip</p></li><li><p>outpus：必须，负责数据输出（outputs ship them elsewhere），常用：elasticsearch、file、graphite、statsd</p></li><li><p>Codecs：Codecs(编码插件)不是一个单独的流程，而是在输入和输出等插件中用于数据转换的模块，用于对数据进行编码处理，常见的插件如json，multiline。Logstash不只是一个input | filter | output 的数据流，而是一个 input | decode | filter | encode | output 的数据流！codec 就是用来 decode、encode 事件的。</p></li></ul><p>其中inputs和outputs支持codecs（coder&amp;decoder）在1.3.0 版之前，logstash 只支持纯文本形式输入，然后以过滤器处理它。但现在，我们可以在输入 期处理不同类型的数据，所以完整的数据流程应该是：input | decode | filter | encode | output；codec 的引入，使得 logstash 可以更好更方便的与其他有自定义数据格式的运维产品共存，比如：graphite、fluent、netflow、collectd，以及使用 msgpack、json、edn 等通用数据格式的其他产品等。</p><h4 id="集中、转换、存储"><a href="#集中、转换、存储" class="headerlink" title="集中、转换、存储"></a>集中、转换、存储</h4><h5 id="输入-：采集各种样式、大小和来源的数据"><a href="#输入-：采集各种样式、大小和来源的数据" class="headerlink" title="输入 ：采集各种样式、大小和来源的数据"></a>输入 ：<strong>采集各种样式、大小和来源的数据</strong></h5><p>数据往往以各种各样的形式，或分散或集中地存在于很多系统中。Logstash 支持各种输入选择 ，可以在同一时间从众多常用来源捕捉事件。能够以连续的流式传输方式，轻松地从日志、指标、Web 应用、数据存储以及各种 AWS 服务采集数据</p><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/eae82eb4-f685-4eba-b74b-357634fe19d9.jpg" alt></p><h5 id="过滤器：实时解析和转换数据"><a href="#过滤器：实时解析和转换数据" class="headerlink" title="过滤器：实时解析和转换数据"></a><strong>过滤器：实时解析和转换数据</strong></h5><p>数据从源传输到存储库的过程中，Logstash 过滤器能够解析各个事件，识别已命名的字段以构建结构，并将它们转换成通用格式，以便更轻松、更快速地分析和实现商业价值。</p><p>Logstash 能够动态地转换和解析数据，不受格式或复杂度的影响：</p><ul><li>利用 Grok 从非结构化数据中派生出结构</li><li>从 IP 地址破译出地理坐标</li><li>将 PII 数据匿名化，完全排除敏感字段</li><li>整体处理不受数据源、格式或架构的影响</li></ul><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/4be6aefc-3d40-4006-8a3e-1fc15fb15f04.jpg" alt></p><h5 id="选择你的存储，导出你的数据"><a href="#选择你的存储，导出你的数据" class="headerlink" title="选择你的存储，导出你的数据"></a><strong>选择你的存储，导出你的数据</strong></h5><p>尽管 Elasticsearch 是我们的首选输出方向，能够为我们的搜索和分析带来无限可能，但它并非唯一选择。</p><p>Logstash 提供众多输出选择，您可以将数据发送到您要指定的地方，并且能够灵活地解锁众多下游用例。</p><p><img src="/2020/02/10/ELK%E6%97%A5%E5%BF%97%E5%B9%B3%E5%8F%B0-%E4%B8%8A/93857fc5-d1d3-4538-9465-4eabf3670670.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在过往的单体应用时代，我们所有组件都部署到一台服务器中，那时日志管理平台的需求可能并没有那么强烈，我们只需要登录到一台服务器通过shell命令就可以很方便的查看系统日志，并快速定位问题。随着互联网的发展，互联网已经全面渗入到生活的各个领域，使用互联网的用户量也越来越多，单体应用已不能够支持庞大的用户的并发量，那么将单体应用进行拆分，通过水平扩展来支持庞大用户的使用迫在眉睫，微服务概念就是在类似这样的阶段诞生，在微服务盛行的互联网技术时代，单个应用被拆分为多个应用，每个应用集群部署进行负载均衡，那么如果某项业务发生系统错误，开发或运维人员还是以过往单体应用方式登录一台一台登录服务器查看日志来定位问题，这种解决线上问题的效率可想而知。日志管理平台的建设就显得极其重要。通过Logstash去收集每台服务器日志文件，然后按定义的正则模板过滤后传输到Kafka或redis，然后由另一个Logstash从KafKa或redis读取日志存储到elasticsearch中创建索引，最后通过Kibana展示给开发者或运维人员进行分析。这样大大提升了运维线上问题的效率。除此之外，还可以将收集的日志进行大数据分析，得到更有价值的数据给到高层进行决策。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ELK 提供的功能满足使用要求，并有较高的扩展性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ELK 为一套开源项目，较低的维护成本。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ELK" scheme="http://JavaSsun.github.io/categories/ELK/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/categories/ELK/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/categories/ELK/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="日志" scheme="http://JavaSsun.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="ELK" scheme="http://JavaSsun.github.io/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://javassun.github.io/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-08T04:43:25.000Z</published>
    <updated>2020-04-16T16:17:20.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。<br>疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>速度更块</li><li>代码更少（Lambda表达式）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li></ul><p><font color="red">核心为：Lambda表达式与Stream API</font></p><a id="more"></a><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-为什么使用Lambda表达式"><a href="#1-为什么使用Lambda表达式" class="headerlink" title="1. 为什么使用Lambda表达式"></a>1. 为什么使用Lambda表达式</h3><p><strong>Lambda</strong>是一个<font color="red">匿名函数</font>，我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>（将代码像数据一样传递）。可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，使Java语言的表达更加凝练。</p><ul><li>从匿名类到 Lambda 的转换</li></ul><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匿名内部类</span><br><span class="line">Runnable r1 &#x3D; new Runnable()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">         System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原来使用匿名内部类作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(String o1,String o2)&#123;</span><br><span class="line">        return Integer.compare(o1.length,o2.length());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts2 &#x3D; new TreeSet&lt;&gt;(</span><br><span class="line">     (o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>匿名内部类</strong></font>：冗余的语法。导致了“Height Problem”（只有一行在工作）</p><h3 id="2-Lambda表达式语法"><a href="#2-Lambda表达式语法" class="headerlink" title="2. Lambda表达式语法"></a>2. Lambda表达式语法</h3><p>Lambda 表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “<font color="red"> -&gt; </font>“，该操作符被称为 Lambda操作符 或 箭头操作符。它将Lambda分为两个部分：</p><p><strong>左侧：</strong>指定了 Lambda 表达式需要的所有参数<br><strong>右侧：</strong>指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式一：无参，无返回值，Lambda只需一条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lambda需要一个参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun &#x3D; (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式三：Lambda只需要一个参数时，参数的小括号可省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consummer&lt;String&gt; fun &#x3D; args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lambda需要两个参数，并且有返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt;&#123;</span><br><span class="line">      System.out.println(&quot;实现函数接口方法&quot;);</span><br><span class="line">      return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：当Lambda体只有一条语句时，return与大括号可以省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：Long数据类型可以省略，可由编译器推断，即“类型推断”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (Long x,Long y) -&gt; &#123;</span><br><span class="line">         System.out.println(&quot;实现函数接口方法&quot;)；</span><br><span class="line">         x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong>是<font color="red"><strong>匿名内函数</strong></font>：提供了轻量级的语法。解决了匿名内部类带来的“高度”问题。</p><p>语法：<strong>参数列表</strong> <strong>-&gt;</strong> <strong>函数体</strong>三部分组成。<br>函数体：表达式、语句块。<br><font color="red"><strong>表达式</strong></font>：表达式会被执行然后返回执行结果。<br><font color="red"><strong>语句块</strong></font>：语句块中的语句会被依次执行，就像方法中的语句一样</p><ol><li>return语句会把控制权交给匿名函数的调用者</li><li>break和continue只能在循环中使用。</li><li>如果函数体有返回值。那么函数体内部的每一条路径都要有。</li></ol><p>表达式函数体适合小型<strong>Lambda</strong>表达式。消除了return关键字。简洁。</p><p><font color="red">新包</font>：<strong>java.util.function:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收 T对象 返回boolean</span><br><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收 T对象 不返回任何值</span><br><span class="line">Consumer&lt;T&gt; void accept(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收 T对象 返回R对象</span><br><span class="line">Function(T,R) R apply(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供 T对象（工厂T）</span><br><span class="line">Supplier&lt;T&gt; T get()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一元：接收T 返回T</span><br><span class="line">UnaryOperator&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二元：接收两个T 返回T</span><br><span class="line">BinaryOperator&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些 Lambda表达式简单例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int x,int y)-&gt;x+y; &#x2F;&#x2F;接收 x y 返回 x与y的和</span><br><span class="line">()-&gt;45;       &#x2F;&#x2F; 不接受参数 返回45</span><br><span class="line">(String s)-&gt;&#123;System.out.println(s);&#125; &#x2F;&#x2F;接收一个字符串，并把它打印在控制台</span><br></pre></td></tr></table></figure><h3 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h3><p>Lambda表达式无需指定类型，程序依然可以编译，因为 javac 根据程序上下文，在后台推断出了参数类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。即所谓的“类型推断”。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="1-什么是函数式接口"><a href="#1-什么是函数式接口" class="headerlink" title="1. 什么是函数式接口"></a>1. 什么是函数式接口</h3><ul><li><p>只包含了一个抽象方法的接口，称为<strong>函数式接口</strong></p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在任意函数式接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li></ul><h3 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2. 自定义函数式接口"></a>2. 自定义函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyNumber&#123;</span><br><span class="line">   public double getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式接口中使用泛型：</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">   public T getValue(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作为参数传递 Lambda 表达式</span><br><span class="line">public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123;</span><br><span class="line">        return mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       String newStr &#x3D; toUpperString(</span><br><span class="line">       (str) -&gt; str.toUpperCase(), &quot;abcdef&quot;);</span><br><span class="line">       System.out.println(newStr);</span><br></pre></td></tr></table></figure><p><font color="red">作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br></font></p><h3 id="3-Java内治四大核心函数式接口"><a href="#3-Java内治四大核心函数式接口" class="headerlink" title="3. Java内治四大核心函数式接口"></a>3. Java内治四大核心函数式接口</h3><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/97801292-5716-4519-9bff-9f8f08aed48b.png" alt></p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/743ea2bc-aeda-44e0-b691-31c354b94f47.png" alt></p><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况：</p><ul><li><p><strong>对象::实例方法</strong></p></li><li><p><strong>类::静态方法</strong></p></li><li><p><strong>类::实例方法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(x);</span><br><span class="line">等同于</span><br><span class="line">System.out::println;</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D; (x,y) -&gt; Math.pow(x,y);</span><br><span class="line">等同于</span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D;Math::pow;</span><br><span class="line"></span><br><span class="line">compare((x,y) -&gt;x.equals(y), &quot;abcdef&quot; , &quot;abcdef&quot;);</span><br><span class="line">等同于</span><br><span class="line">compare(String::equals,&quot;abc&quot;,&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p><strong>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</strong></p><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><p><strong>格式： ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，与构造器参数 列表要与接口中抽象方法的参数列表一致！</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; (n) -&gt; new MyClass(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; MyClass::new;</span><br></pre></td></tr></table></figure><h3 id="3-数字引用"><a href="#3-数字引用" class="headerlink" title="3. 数字引用"></a>3. 数字引用</h3><p><strong>格式： type[] :: new</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun &#x3D; (n) -&gt; new Integer(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; Integer[]::new;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><h3 id="1-了解Stream"><a href="#1-了解Stream" class="headerlink" title="1. 了解Stream"></a>1. 了解Stream</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一 个则是 <strong>Stream API(java.util.stream.*)</strong>。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>*<em>流(Stream)是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>*</em><br><font color="red">“集合讲的是数据，流讲的是计算！”</font></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="2-Stream三步骤"><a href="#2-Stream三步骤" class="headerlink" title="2. Stream三步骤"></a>2. Stream三步骤</h3><ul><li><p><strong>创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p></li><li><p><strong>中间操作</strong><br>一个中间操作链，对数据源的数据进行处理 </p></li><li><p><strong>终端操作</strong><br>一个终止操作，执行中间操作链，并产生结果<br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/37346492-7531-44b8-a2bf-681c14b381ec.jpg" alt></p></li></ul><h3 id="3-创建Stream"><a href="#3-创建Stream" class="headerlink" title="3. 创建Stream"></a>3. 创建Stream</h3><h4 id="1-Collection-创建流"><a href="#1-Collection-创建流" class="headerlink" title="1. Collection 创建流"></a>1. Collection 创建流</h4><ul><li><p>default Stream<E> stream() : 返回一个顺序流</E></p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p></li></ul><h4 id="2-数组-创建流（Arrays的静态方法stream-创建）"><a href="#2-数组-创建流（Arrays的静态方法stream-创建）" class="headerlink" title="2. 数组 创建流（Arrays的静态方法stream()创建）"></a>2. 数组 创建流（Arrays的静态方法stream()创建）</h4><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li></ul><p><strong>重载形式，能够处理对应基本类型的数组</strong></p><ul><li><p>public static IntStream stream(int[] array)</p></li><li><p>public static LongStream stream(long[] array)</p></li><li><p>public static DoubleStream stream(double[] array)</p></li></ul><h4 id="3-由值创建流"><a href="#3-由值创建流" class="headerlink" title="3. 由值创建流"></a>3. 由值创建流</h4><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li></ul><h4 id="4-由函数创建流：创建无限流"><a href="#4-由函数创建流：创建无限流" class="headerlink" title="4. 由函数创建流：创建无限流"></a>4. 由函数创建流：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>迭代</li></ul><p>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</T></T></T></p><ul><li>生成</li></ul><p>public static<T> Stream<T> generate(Supplier<T> s)</T></T></T></p><h3 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4. Stream 的中间操作"></a>4. Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><p><strong>筛选与切片</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/853fb496-9885-4191-b20d-1d5c8508def5.png" alt></p><p><strong>映射</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/feb89458-0a81-42a9-9aa4-33b20b5991bf.png" alt></p><p><strong>排序</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3a69b800-08f9-4bca-ab2d-51e3f3446635.png" alt></p><h3 id="5-Stream-的终止操作"><a href="#5-Stream-的终止操作" class="headerlink" title="5. Stream 的终止操作"></a>5. Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的 值，例如：List、Integer，甚至是 void 。</p><p><strong>查找与匹配</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1cd0233f-598b-4537-8998-5e5fa24aada0.png" alt><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/bae6b149-cc4f-4f84-aec0-e27bf8afe015.png" alt></p><p><strong>归约</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/037bfd49-78ed-468b-aa65-4ad0242e490b.png" alt></p><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</p><p><strong>收集</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2cccbffb-7df8-4a65-8153-537071e75bd7.png" alt></p><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><h3 id="6-并行流与串行流"><a href="#6-并行流与串行流" class="headerlink" title="6. 并行流与串行流"></a>6. 并行流与串行流</h3><p><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p><h3 id="7-了解-Fork-Join-框架"><a href="#7-了解-Fork-Join-框架" class="headerlink" title="7. 了解 Fork/Join 框架"></a>7. 了解 Fork/Join 框架</h3><p><strong>Fork/Join 框架</strong>:就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/84eaed9b-717b-47f9-9f0a-f5fde05f7472.jpg" alt></p><h3 id="8-Fork-Join-框架与传统线程池的区别"><a href="#8-Fork-Join-框架与传统线程池的区别" class="headerlink" title="8. Fork/Join 框架与传统线程池的区别"></a>8. Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的<br>处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因<br>无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果<br>某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子<br>问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程<br>的等待时间,提高了性能.</p><h2 id="5-新时间日期API"><a href="#5-新时间日期API" class="headerlink" title="5. 新时间日期API"></a>5. 新时间日期API</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实 例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1d49dcda-eb3d-4eb7-aa3c-889e5607867f.png" alt></p><p><strong>Instant 时间戳</strong></p><ul><li>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算</li></ul><p><strong>Duration 和 Period</strong></p><ul><li><p>Duration:用于计算两个“时间”间隔</p></li><li><p>Period:用于计算两个“日期”间隔</p></li><li><p>日期的操纵</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获 取例如：将日期调整到“下个周日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法提供了大量的常 用 TemporalAdjuster 的实现。</p></li></ul><p>例如获取下个周日：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday &#x3D; LocalDate.now().with(</span><br><span class="line">   TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析与格式化</strong></p><p>java.time.format.DateTimeFormatter 类：该类提供了三种 格式化方法：</p><ul><li><p>预定义的标准格式</p></li><li><p>语言环境相关的格式</p></li><li><p>自定义的格式</p></li></ul><p><strong>时区的处理</strong></p><ul><li>Java8 中加入了对时区的支持，带时区的时间为分别为：</li></ul><p>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><p>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><p><strong>与传统日期处理的转换</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/0b30f162-415f-4a9c-a650-ba13116ff20b.png" alt></p><h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6. 接口中的默认方法与静态方法"></a>6. 接口中的默认方法与静态方法</h2><h3 id="1-接口中的默认方法"><a href="#1-接口中的默认方法" class="headerlink" title="1. 接口中的默认方法"></a>1. 接口中的默认方法</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">  T func(int a);</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>接口默认方法的”类优先”原则 *</em></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyFunc&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Named&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello java8&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass implements MyFunc,Named&#123;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">        return Named.super.getName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口中的静态方法"><a href="#2-接口中的静态方法" class="headerlink" title="2. 接口中的静态方法"></a>2. 接口中的静态方法</h3><p>Java8 中，接口中允许添加静态方法</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">  public Integer myFun();</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show()&#123;</span><br><span class="line">     System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-其他新特性"><a href="#7-其他新特性" class="headerlink" title="7. 其他新特性"></a>7. 其他新特性</h2><p><strong>Optional 类</strong></p><p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p><p><strong>常用方法：</strong><br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值<br>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t<br>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</p><p><strong>重复注解与类型注解</strong></p><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations&#123;</span><br><span class="line">   MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation&#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyAnnotation(&quot;Hello&quot;)</span><br><span class="line">@MyAnnotation(&quot;World&quot;)</span><br><span class="line">public void show(@MyAnnotation(&quot;abc&quot;) String str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 交易员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class Trader &#123;</span><br><span class="line">     private String name;</span><br><span class="line">     private String city;</span><br><span class="line">     public Trader(String name, String city) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getter setter方法省略</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">     private Trader trader;</span><br><span class="line">     private int year;</span><br><span class="line">     private int value;</span><br><span class="line">     public Transaction(Trader trader, int year, int value) &#123;</span><br><span class="line">        this.trader &#x3D; trader;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PuttingIntoPractice &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Trader raoul &#x3D; new Trader(&quot;Raoul&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader mario &#x3D; new Trader(&quot;mario&quot;,&quot;Milan&quot;);</span><br><span class="line">        Trader alen &#x3D; new Trader(&quot;alen&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader brian &#x3D; new Trader(&quot;brian&quot;,&quot;Cambridge&quot;);</span><br><span class="line"></span><br><span class="line">  List&lt;Transaction&gt; transactions &#x3D; Arrays.asList(</span><br><span class="line">          new Transaction(brian,2011,300),</span><br><span class="line">          new Transaction(raoul,2012,1000),</span><br><span class="line">          new Transaction(raoul,2011,400),</span><br><span class="line">          new Transaction(mario,2012,710),</span><br><span class="line">          new Transaction(mario,2012,700),</span><br><span class="line">          new Transaction(alen,2012,950)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getYear() &#x3D;&#x3D; 2011)</span><br><span class="line">.sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (2) 交易员都在哪些不同的城市工作过？</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (3) 查找所有来自于剑桥的交易员，并按姓名排序。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (4) 返回所有交易员的姓名字符串，按字母顺序排序。</span><br><span class="line">  String traderStr &#x3D; transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">  System.out.println(traderStr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (5) 有没有交易员是在米兰工作的？</span><br><span class="line">  boolean miLanBased &#x3D; transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader()</span><br><span class="line">                        .getCity().equals(&quot;MiLan&quot;));</span><br><span class="line">  System.out.println(miLanBased);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (6) 打印生活在剑桥的交易员的所有交易额。</span><br><span class="line">         transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (7) 所有交易中，最高的交易额是多少？</span><br><span class="line">  int highestValue &#x3D; transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(0,Integer::max);</span><br><span class="line">  System.out.println(highestValue);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Transaction::getValue).reversed())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (8) 找到交易额最小的交易。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">             .min(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">                .min(Comparator.comparing((Transaction t1)-&gt; t1.getValue()))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (9) 统计每个交易员的记录</span><br><span class="line">  transactions.stream()</span><br><span class="line">       .collect(Collectors.groupingBy(Transaction::getTrader))</span><br><span class="line">                .entrySet().stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (10) 找到单笔交易最高的交易员</span><br><span class="line">  transactions.stream()</span><br><span class="line">             .max(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(tran -&gt;&#123;</span><br><span class="line">                    System.out.println(tran.getTrader());</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习参考网络</p><h2 id="8-java8红黑树"><a href="#8-java8红黑树" class="headerlink" title="8. java8红黑树"></a>8. java8红黑树</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>回顾：HashSet是基于HashCode实现元素不重复的。当插入元素的哈希码相同时，会调用equals方法进行二次比较，如果相同，则新值替旧值。如果不同，则以链表的形式挂在当前元素所在的位置。</p><p>扩容因子：0.75</p><p>如果是1 ，则可能永远是只插入到两个位置，形成部分元素的长链表。每次都要在哈希码相同时进行equals比较（哈希碰撞）。降低性能。</p><p>如果是&lt;0.75,则可能浪费空间。</p><h3 id="数组-链表-红黑树-二叉树的一种"><a href="#数组-链表-红黑树-二叉树的一种" class="headerlink" title="数组-链表-红黑树(二叉树的一种)"></a>数组-链表-红黑树(二叉树的一种)</h3><p><strong>条件：当碰撞袁术个数&gt;8 &amp;&amp; 总容量&gt;64 将其转换为红黑树</strong></p><p><font color="red">碰撞元素个数</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK7是数组-&gt;链表</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK8是数组-链表</font>： 当转变为红黑树时，添加的效率变低。其他效率都高了。平衡二叉树（比当前值与节点值的大小）</p><p>扩容是：原来表会计算hashcode值进行元素的再次填充。</p><p>现在只需要找原来表的总长度+当前所在的位置，就是当前扩容后的位置。（不需要再次进行哈希计算）。</p><p><strong>ConcurrentHashMap：效率提高</strong></p><p>JDK7: ConcurrentLevel = 16<br>JDK8：CAS算法</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/7d750713-3d72-48e3-b512-d11dc1900f92.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。&lt;br&gt;疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。&lt;/p&gt;
&lt;h3 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;速度更块&lt;/li&gt;
&lt;li&gt;代码更少（Lambda表达式）&lt;/li&gt;
&lt;li&gt;强大的Stream API&lt;/li&gt;
&lt;li&gt;便于并行&lt;/li&gt;
&lt;li&gt;最大化减少空指针异常 Optional&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;核心为：Lambda表达式与Stream API&lt;/font&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://JavaSsun.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Docker简单配置</title>
    <link href="http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://javassun.github.io/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</id>
    <published>2020-01-15T14:20:51.000Z</published>
    <updated>2020-05-06T06:33:32.647Z</updated>
    
    <content type="html"><![CDATA[<p>转自<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><a id="more"></a><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello Docker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DockerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>plugins 中添加 Docker 构建插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br><span class="line"></span><br><span class="line">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span><br><span class="line">systemctl  start docker.service</span><br><span class="line">systemctl  enable docker.service</span><br></pre></td></tr></table></figure><p>使用Docker 中国加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><p>配置环境变量 打开 <code>vim /etc/profile</code> 添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成之后，使其生效</p><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装MAVEN"><a href="#安装MAVEN" class="headerlink" title="安装MAVEN"></a>安装MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar vxf apache-maven-3.5.2-bin.tar.gz</span><br><span class="line">## 移动</span><br><span class="line">mv apache-maven-3.5.2 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#打包</span><br><span class="line">mvn package</span><br><span class="line">#启动</span><br><span class="line">java -jar target&#x2F;spring-boot-docker-1.0.jar</span><br></pre></td></tr></table></figure><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME &#x2F;tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line">Removing intermediate container 593ee5e1ea51</span><br><span class="line">Step 4 : ENTRYPOINT java -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar</span><br><span class="line"> ---&gt; Running in 85d558a10cd4</span><br><span class="line"> ---&gt; 7102f08b5e95</span><br><span class="line">Removing intermediate container 85d558a10cd4</span><br><span class="line">Successfully built 7102f08b5e95</span><br><span class="line">[INFO] Built springboot&#x2F;spring-boot-docker</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M&#x2F;182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot&#x2F;spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot&#x2F;spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot&#x2F;spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080&#x2F;tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;a href=&quot;http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纯洁的微笑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。&lt;/p&gt;
&lt;p&gt;首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/categories/SpringBoot/"/>
    
    
      <category term="Docker" scheme="http://JavaSsun.github.io/tags/Docker/"/>
    
      <category term="SpringBoot" scheme="http://JavaSsun.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>1-Hystrix知多少</title>
    <link href="http://javassun.github.io/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
    <id>http://javassun.github.io/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/</id>
    <published>2020-01-01T07:38:15.000Z</published>
    <updated>2020-05-18T08:55:20.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般来说，互联网的面试，一般都会考察你，什么是分布式系统，高并发，简单的高可用问题。限流、熔断、降级，在分布式的系统架构中，微服务架构中，其实都是最常见、基础和简单的保障系统高可用的手法。dubbo去开发了，spring cloud去开发了，在这个系统的接口调用中，我们是用hystrix去实现一整套的高可用保障机制，基于hystrix去做了限流、熔断和降级。</p><p>hystrix是国外的netflix开源的，netflix是国外很大的视频网站，系统非常复杂，微服务架构，多达几千个服务，为自己的场景，经过大量的工业验证，线上生产环境的实践，产出和开源了高可用相关的一个框架，熔断框架，hystrix。</p><p>hystrix未来或已经成为国内的高可用的限流、熔断和降级这一块的事实上的标准，spring cloud微服务框架，就是集成了hystrix来做微服务架构中的限流、降级和熔断的。</p><a id="more"></a><h2 id="1-连环炮"><a href="#1-连环炮" class="headerlink" title="1. 连环炮"></a>1. 连环炮</h2><h3 id="1-1-高可用架构"><a href="#1-1-高可用架构" class="headerlink" title="1.1 高可用架构"></a>1.1 高可用架构</h3><h3 id="1-2-限流"><a href="#1-2-限流" class="headerlink" title="1.2 限流"></a>1.2 限流</h3><p>如何限流？在工作中是怎么做的？说一下具体的实现？</p><h3 id="1-3-熔断"><a href="#1-3-熔断" class="headerlink" title="1.3 熔断"></a>1.3 熔断</h3><p>如何进行熔断？熔断框架都有哪些？具体实现原理知道吗？</p><h3 id="1-4-降级"><a href="#1-4-降级" class="headerlink" title="1.4 降级"></a>1.4 降级</h3><p>如何进行降级？</p><h2 id="2-hystrix与高可用系统架构：资源隔离-限流-熔断-降级-运维监控"><a href="#2-hystrix与高可用系统架构：资源隔离-限流-熔断-降级-运维监控" class="headerlink" title="2. hystrix与高可用系统架构：资源隔离+限流+熔断+降级+运维监控"></a>2. hystrix与高可用系统架构：资源隔离+限流+熔断+降级+运维监控</h2><h3 id="1、hystrix是什么？"><a href="#1、hystrix是什么？" class="headerlink" title="1、hystrix是什么？"></a>1、hystrix是什么？</h3><p>netflix（国外最大的类似于，爱奇艺，优酷）视频网站，五六年前，也是，感觉自己的系统，整个网站，经常出故障，可用性不太高</p><p>有时候一些vip会员不能支付，有时候看视频就卡顿，看不了视频。。。</p><p>影响公司的收入。。。</p><p>五六年前，netflix，api team，提升高可用性，开发了一个框架，类似于spring，mybatis，hibernate，等等这种框架</p><p>高可用性的框架，hystrix</p><p>hystrix，框架，提供了高可用相关的各种各样的功能，然后确保说在hystrix的保护下，整个系统可以长期处于高可用的状态，100%，99.99999%</p><p>最理想的状况下，软件的故障，就不应该说导致整个系统的崩溃，服务器硬件的一些故障，服务的冗余</p><p>唯一有可能导致系统彻底崩溃，就是类似于之前，支付宝的那个事故，工人施工，挖断了电缆，导致几个机房都停电</p><p>不可用，和产生一些故障或者bug的区别</p><h3 id="2、高可用系统架构"><a href="#2、高可用系统架构" class="headerlink" title="2、高可用系统架构"></a>2、高可用系统架构</h3><p>资源隔离、限流、熔断、降级、运维监控</p><p><strong>资源隔离</strong>：让你的系统里，某一块东西，在故障的情况下，不会耗尽系统所有的资源，比如线程资源</p><p>实际的项目中的一个case，有一块东西，是要用多线程做一些事情，小伙伴做项目的时候，没有太留神，资源隔离，那块代码，在遇到一些故障的情况下，每个线程在跑的时候，因为那个bug，直接就死循环了，导致那块东西启动了大量的线程，每个线程都死循环</p><p>最终导致我的系统资源耗尽，崩溃，不工作，不可用，废掉了</p><p>资源隔离，那一块代码，最多最多就是用掉10个线程，不能再多了，就废掉了，限定好的一些资源</p><p><strong>限流</strong>：高并发的流量涌入进来，比如说突然间一秒钟100万QPS，废掉了，10万QPS进入系统，其他90万QPS被拒绝了</p><p><strong>熔断</strong>：系统后端的一些依赖，出了一些故障，比如说mysql挂掉了，每次请求都是报错的，熔断了，后续的请求过来直接不接收了，拒绝访问，10分钟之后再尝试去看看mysql恢复没有</p><p><strong>降级</strong>：mysql挂了，系统发现了，自动降级，从内存里存的少量数据中，去提取一些数据出来</p><p><strong>运维监控</strong>：监控+报警+优化，各种异常的情况，有问题就及时报警，优化一些系统的配置和参数，或者代码。</p><p><strong>小结</strong></p><p>hystrix对系统进行各种高可用性的系统加固，来应对各种不可用的情况</p><h2 id="2-hystrix要解决的分布式系统可用性问题以及其设计原则"><a href="#2-hystrix要解决的分布式系统可用性问题以及其设计原则" class="headerlink" title="2. hystrix要解决的分布式系统可用性问题以及其设计原则"></a>2. hystrix要解决的分布式系统可用性问题以及其设计原则</h2><p><strong>分布式系统以及其中的故障和hystrix</strong></p><p><img src="/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/76133498-34a0-4806-a404-0ef0e6956377.png" alt></p><h3 id="1、Hystrix到底是什么？"><a href="#1、Hystrix到底是什么？" class="headerlink" title="1、Hystrix到底是什么？"></a>1、Hystrix到底是什么？</h3><p>在分布式系统中，每个服务都可能会调用很多其他服务，被调用的那些服务就是依赖服务，有的时候某些依赖服务出现故障也是很正常的。</p><p>Hystrix可以让我们在分布式系统中对服务间的调用进行控制，加入一些调用延迟或者依赖故障的容错机制。</p><p>Hystrix通过将依赖服务进行资源隔离，进而组织某个依赖服务出现故障的时候，这种故障在整个系统所有的依赖服务调用中进行蔓延，同时Hystrix还提供故障时的fallback降级机制</p><p>总而言之，Hystrix通过这些方法帮助我们提升分布式系统的可用性和稳定性</p><h3 id="2、Hystrix的历史"><a href="#2、Hystrix的历史" class="headerlink" title="2、Hystrix的历史"></a>2、Hystrix的历史</h3><p>hystrix，就是一种高可用保障的一个框架，类似于spring（ioc，mvc），mybatis，activiti，lucene，框架，预先封装好的为了解决某个特定领域的特定问题的一套代码库</p><p>框架，用了框架之后，来解决这个领域的特定的问题，就可以大大减少我们的工作量，提升我们的工作质量和工作效率，框架</p><p>hystrix，高可用性保障的一个框架</p><p>Netflix（可以认为是国外的优酷或者爱奇艺之类的视频网站），API团队从2011年开始做一些提升系统可用性和稳定性的工作，Hystrix就是从那时候开始发展出来的。</p><p>在2012年的时候，Hystrix就变得比较成熟和稳定了，Netflix中，除了API团队以外，很多其他的团队都开始使用Hystrix。</p><p>时至今日，Netflix中每天都有数十亿次的服务间调用，通过Hystrix框架在进行，而Hystrix也帮助Netflix网站提升了整体的可用性和稳定性</p><h3 id="3、初步看一看Hystrix的设计原则是什么？"><a href="#3、初步看一看Hystrix的设计原则是什么？" class="headerlink" title="3、初步看一看Hystrix的设计原则是什么？"></a>3、初步看一看Hystrix的设计原则是什么？</h3><p>hystrix为了实现高可用性的架构，设计hystrix的时候，一些设计原则是什么？？？</p><p>（1）对依赖服务调用时出现的调用延迟和调用失败进行控制和容错保护</p><p>（2）在复杂的分布式系统中，阻止某一个依赖服务的故障在整个系统中蔓延，服务A-&gt;服务B-&gt;服务C，服务C故障了，服务B也故障了，服务A故障了，整套分布式系统全部故障，整体宕机</p><p>（3）提供fail-fast（快速失败）和快速恢复的支持</p><p>（4）提供fallback优雅降级的支持</p><p>（5）支持近实时的监控、报警以及运维操作</p><p>调用延迟+失败，提供容错<br>阻止故障蔓延<br>快速失败+快速恢复<br>降级<br>监控+报警+运维</p><p>完全描述了hystrix的功能，提供整个分布式系统的高可用的架构</p><h3 id="4、Hystrix要解决的问题是什么？"><a href="#4、Hystrix要解决的问题是什么？" class="headerlink" title="4、Hystrix要解决的问题是什么？"></a>4、Hystrix要解决的问题是什么？</h3><p>在复杂的分布式系统架构中，每个服务都有很多的依赖服务，而每个依赖服务都可能会故障</p><p>如果服务没有和自己的依赖服务进行隔离，那么可能某一个依赖服务的故障就会拖垮当前这个服务</p><p>举例来说，某个服务有30个依赖服务，每个依赖服务的可用性非常高，已经达到了99.99%的高可用性</p><p>那么该服务的可用性就是99.99%的30次方，也就是99.7%的可用性</p><p>99.7%的可用性就意味着3%的请求可能会失败，因为3%的时间内系统可能出现了故障不可用了</p><p>对于1亿次访问来说，3%的请求失败，也就意味着300万次请求会失败，也意味着每个月有2个小时的时间系统是不可用的</p><p>在真实生产环境中，可能更加糟糕</p><p>上面也就是说，即使你每个依赖服务都是99.99%高可用性，但是一旦你有几十个依赖服务，还是会导致你每个月都有几个小时是不可用的</p><p>画图分析说，当某一个依赖服务出现了调用延迟或者调用失败时，为什么会拖垮当前这个服务？以及在分布式系统中，故障是如何快速蔓延的？</p><p><img src="/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/430e908e-a25c-4ee3-8280-ecebf71cac28.png" alt></p><h3 id="5、再看Hystrix的更加细节的设计原则是什么？"><a href="#5、再看Hystrix的更加细节的设计原则是什么？" class="headerlink" title="5、再看Hystrix的更加细节的设计原则是什么？"></a>5、再看Hystrix的更加细节的设计原则是什么？</h3><p>（1）阻止任何一个依赖服务耗尽所有的资源，比如tomcat中的所有线程资源</p><p>（2）避免请求排队和积压，采用限流和fail fast来控制故障</p><p>（3）提供fallback降级机制来应对故障</p><p>（4）使用资源隔离技术，比如bulkhead（舱壁隔离技术），swimlane（泳道技术），circuit breaker（短路技术），来限制任何一个依赖服务的故障的影响</p><p>（5）通过近实时的统计/监控/报警功能，来提高故障发现的速度</p><p>（6）通过近实时的属性和配置热修改功能，来提高故障处理和恢复的速度</p><p>（7）保护依赖服务调用的所有故障情况，而不仅仅只是网络故障情况</p><p>调用这个依赖服务的时候，client调用包有bug，阻塞，等等，依赖服务的各种各样的调用的故障，都可以处理</p><h3 id="6、Hystrix是如何实现它的目标的？"><a href="#6、Hystrix是如何实现它的目标的？" class="headerlink" title="6、Hystrix是如何实现它的目标的？"></a>6、Hystrix是如何实现它的目标的？</h3><p>（1）通过HystrixCommand或者HystrixObservableCommand来封装对外部依赖的访问请求，这个访问请求一般会运行在独立的线程中，资源隔离</p><p>（2）对于超出我们设定阈值的服务调用，直接进行超时，不允许其耗费过长时间阻塞住。这个超时时间默认是99.5%的访问时间，但是一般我们可以自己设置一下</p><p>（3）为每一个依赖服务维护一个独立的线程池，或者是semaphore，当线程池已满时，直接拒绝对这个服务的调用</p><p>（4）对依赖服务的调用的成功次数，失败次数，拒绝次数，超时次数，进行统计</p><p>（5）如果对一个依赖服务的调用失败次数超过了一定的阈值，自动进行熔断，在一定时间内对该服务的调用直接降级，一段时间后再自动尝试恢复</p><p>（6）当一个服务调用出现失败，被拒绝，超时，短路等异常情况时，自动调用fallback降级机制</p><p>（7）对属性和配置的修改提供近实时的支持</p><p>画图分析，对依赖进行资源隔离后，如何避免依赖服务调用延迟或失败导致当前服务的故障</p><p><img src="/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/2ba73e70-9465-4327-bb9a-e1a9a487646a.png" alt></p><h2 id="3-电商网站的商品详情页缓存服务业务背景以及框架结构说明"><a href="#3-电商网站的商品详情页缓存服务业务背景以及框架结构说明" class="headerlink" title="3. 电商网站的商品详情页缓存服务业务背景以及框架结构说明"></a>3. 电商网站的商品详情页缓存服务业务背景以及框架结构说明</h2><p>大背景：电商网站，首页，商品详情页，搜索结果页，广告页，促销活动，购物车，订单系统，库存系统，物流系统</p><p>小背景：商品详情页，如何用最快的结果将商品数据填充到一个页面中，然后将页面显示出来</p><p>分布式系统：商品详情页，缓存服务，+底层源数据服务，商品信息服务，店铺信息服务，广告信息服务，推荐信息服务，综合起来组成一个分布式的系统</p><h3 id="1、电商网站的商品详情页系统架构"><a href="#1、电商网站的商品详情页系统架构" class="headerlink" title="1、电商网站的商品详情页系统架构"></a>1、电商网站的商品详情页系统架构</h3><p>（1）小型电商网站的商品详情页系统架构</p><p>（2）大型电商网站的商品详情页系统架构</p><p>（3）页面模板</p><p>举个例子</p><p>将数据动态填充/渲染到一个html模板中，是什么意思呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;#&#123;name&#125;的页面&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        商品的价格是：#&#123;price&#125;</span><br><span class="line">        商品的介绍：#&#123;description&#125;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面这个就可以认为是一个页面模板，里面的很多内容是不确定的，#{name}，#{price}，#{description}，这都是一些模板脚本，不确定里面的值是什么？</p><p>将数据填充/渲染到html模板中，是什么意思呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;iphone7 plus（玫瑰金+32G）&quot;,</span><br><span class="line">    &quot;price&quot;: 5599.50</span><br><span class="line">    &quot;description&quot;: &quot;这个手机特别好用。。。。。。&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;title&gt;iphone7 plus（玫瑰金+32G）的页面&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        商品的价格是：5599.50</span><br><span class="line">        商品的介绍：这个手机特别好用。。。。。。</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>上面这个就是一份填充好数据的一个html页面</p><h3 id="2、缓存服务"><a href="#2、缓存服务" class="headerlink" title="2、缓存服务"></a>2、缓存服务</h3><p>缓存服务，订阅一个MQ的消息变更，如果有消息变更的话，那么就会发送一个网络请求，调用一个底层的对应的源数据服务的接口，去获取变更后的数据</p><p>将获取到的变更后的数据填充到分布式的redis缓存中去</p><p>高可用这一块儿，最可能出现说可用性不高的情况，是什么呢？就是说，在接收到消息之后，可能在调用各种底层依赖服务的接口时，会遇到各种不稳定的情况</p><p>比如底层服务的接口调用超时，200ms，2s都没有返回; 底层服务的接口调用失败，比如说卡了500ms之后，返回一个报错</p><p>在分布式系统中，对于这种大量的底层依赖服务的调用，就可能会出现各种可用性的问题，一旦没有处理好的话</p><p>可能就会导致缓存服务自己本身会挂掉，或者故障掉，就会导致什么呢？不可以对外提供服务，严重情况下，甚至会导致说整个商品详情页显示不出来</p><p>缓存服务接收到变更消息后，去调用各个底层依赖服务时的高可用架构的实现</p><h3 id="3、框架结构"><a href="#3、框架结构" class="headerlink" title="3、框架结构"></a>3、框架结构</h3><p><strong>大型电商网站的详情页系统的架构</strong></p><p><img src="/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/8f197a0b-d589-4320-b220-81f744a29a42.png" alt></p><p><strong>小型电商网站的静态化方案</strong></p><p><img src="/2020/01/01/1-Hystrix%E7%9F%A5%E5%A4%9A%E5%B0%91/56054641-b5a0-4509-b545-a50049446cc0.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一般来说，互联网的面试，一般都会考察你，什么是分布式系统，高并发，简单的高可用问题。限流、熔断、降级，在分布式的系统架构中，微服务架构中，其实都是最常见、基础和简单的保障系统高可用的手法。dubbo去开发了，spring cloud去开发了，在这个系统的接口调用中，我们是用hystrix去实现一整套的高可用保障机制，基于hystrix去做了限流、熔断和降级。&lt;/p&gt;
&lt;p&gt;hystrix是国外的netflix开源的，netflix是国外很大的视频网站，系统非常复杂，微服务架构，多达几千个服务，为自己的场景，经过大量的工业验证，线上生产环境的实践，产出和开源了高可用相关的一个框架，熔断框架，hystrix。&lt;/p&gt;
&lt;p&gt;hystrix未来或已经成为国内的高可用的限流、熔断和降级这一块的事实上的标准，spring cloud微服务框架，就是集成了hystrix来做微服务架构中的限流、降级和熔断的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hystrix" scheme="http://JavaSsun.github.io/categories/Hystrix/"/>
    
      <category term="面试" scheme="http://JavaSsun.github.io/categories/Hystrix/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/categories/Hystrix/%E9%9D%A2%E8%AF%95/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="面试" scheme="http://JavaSsun.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="系统架构" scheme="http://JavaSsun.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Hystrix" scheme="http://JavaSsun.github.io/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>25-Nginx变量原理-应用</title>
    <link href="http://javassun.github.io/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/"/>
    <id>http://javassun.github.io/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/</id>
    <published>2019-12-13T12:10:53.000Z</published>
    <updated>2020-05-14T11:53:59.342Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，<strong>变量是一个解耦工具</strong>。它同样可以在 openresty 中 lua 语言中大有用处。</p><a id="more"></a><h2 id="变量原理"><a href="#变量原理" class="headerlink" title="变量原理"></a>变量原理</h2><h3 id="变量的提供模块与使用模块"><a href="#变量的提供模块与使用模块" class="headerlink" title="变量的提供模块与使用模块"></a>变量的提供模块与使用模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d4564092-81ea-4d1e-a6e6-55b113cd6724.jpg" alt></p><p><strong>流程：</strong></p><p><font color="red">提供变量名的模块</font></p><p>Nginx启动后，发现当前是一个HTTP模块。它其中有一个 <strong>preconfiguration回调方法</strong>，如 realip模块的 realip变量等等。它定义的是一对值，即<strong>变量名</strong>和<strong>解析出当前变量名的方法</strong>。如给出输入（如http请求头部中的名称），输出就是对应的值。此处<strong>定义规则</strong>。</p><p><font color="red">使用变量名的模块</font></p><p>通过变量名完成解耦。</p><p><strong>两个模块各自专注于自己的职责</strong></p><h3 id="变量的特性"><a href="#变量的特性" class="headerlink" title="变量的特性"></a>变量的特性</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/16c0d0ee-eea1-4e84-b72f-0d99716a1a82.jpg" alt></p><h3 id="存放变量的哈希表"><a href="#存放变量的哈希表" class="headerlink" title="存放变量的哈希表"></a>存放变量的哈希表</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a51c5b96-8f90-4db7-8a3c-5be8fc35c05b.jpg" alt></p><h2 id="HTTP框架提供的请求有关变量"><a href="#HTTP框架提供的请求有关变量" class="headerlink" title="HTTP框架提供的请求有关变量"></a>HTTP框架提供的请求有关变量</h2><p>除许多HTTP模块会提供变量外，Nginx的HTTP框架也提供了大量的变量，这些变量不需要编译、引入新的HTTP模块，而且框架提供的变量往往反映了用户发来的请求时被Nginx处理的流程与细节。因此，熟悉Nginx框架提供的每一个变量的用法是非常有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf配置文件中</span><br><span class="line"></span><br><span class="line">vim var.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/780053e8-ebbd-4515-a257-109fdd50ba0f.jpg" alt><br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8dd34c5-839c-4201-a384-06a439b4a88f.jpg" alt></p><p>为了演示有些变量在不同的阶段时不同的，添加了日志文件。return中，将相关联的变量以一行显示，以逗号分隔。冒号前是变量名，冒号后是变量值。</p><p>做一次访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B7.PNG" alt></p><h3 id="HTTP框架提供的变量"><a href="#HTTP框架提供的变量" class="headerlink" title="HTTP框架提供的变量"></a>HTTP框架提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/535214ab-1e4a-40d3-a006-333711c9259c.jpg" alt></p><h3 id="HTTP请求有关变量"><a href="#HTTP请求有关变量" class="headerlink" title="HTTP请求有关变量"></a>HTTP请求有关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7b486912-8cd7-47a3-89c7-48843fd52723.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c9fdf904-3f7d-416a-b4be-e49b2f4a33c4.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e2070844-a852-4cf3-978b-4b27ba67365b.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8abd28c-0ef9-4070-98f4-914b88414852.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a43e65e2-6f41-47f0-8f3e-a62e9dc13303.jpg" alt></p><h2 id="HTTP框架提供的其他变量"><a href="#HTTP框架提供的其他变量" class="headerlink" title="HTTP框架提供的其他变量"></a>HTTP框架提供的其他变量</h2><h3 id="TCP连接有关的变量"><a href="#TCP连接有关的变量" class="headerlink" title="TCP连接有关的变量"></a>TCP连接有关的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d920d0da-2705-45e4-92d3-7591b589a20f.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/962047ba-83c2-416d-87a1-8a5b26102403.jpg" alt></p><h3 id="Nginx处理请求过程中产生的变量"><a href="#Nginx处理请求过程中产生的变量" class="headerlink" title="Nginx处理请求过程中产生的变量"></a>Nginx处理请求过程中产生的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e25f6442-1682-4d3e-acf1-8fe712fc7601.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/b7821b26-bd21-4930-b315-96c7b4f4a582.jpg" alt></p><h3 id="发送HTTP响应时相关变量"><a href="#发送HTTP响应时相关变量" class="headerlink" title="发送HTTP响应时相关变量"></a>发送HTTP响应时相关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589440450988.PNG" alt></p><h3 id="Nginx系统变量"><a href="#Nginx系统变量" class="headerlink" title="Nginx系统变量"></a>Nginx系统变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/14088861-0f90-4cba-ba31-ee728fc9ea81.jpg" alt></p><h2 id="变量防盗链"><a href="#变量防盗链" class="headerlink" title="变量防盗链"></a>变量防盗链</h2><h3 id="简单有效的防盗链手段：referer模块"><a href="#简单有效的防盗链手段：referer模块" class="headerlink" title="简单有效的防盗链手段：referer模块"></a>简单有效的防盗链手段：referer模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52fc1d8f-49eb-4f0a-9260-cde0e218ccd5.jpg" alt></p><h3 id="referer模块的指令"><a href="#referer模块的指令" class="headerlink" title="referer模块的指令"></a>referer模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a01e89ed-9426-420a-98b8-c9255c31d197.jpg" alt></p><h3 id="valid-referers-指令"><a href="#valid-referers-指令" class="headerlink" title="valid_referers 指令"></a>valid_referers 指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e54ac723-8063-4e30-92fc-ae1e90441ddd.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6deb74a6-c5ac-4d39-b36c-32af38a57191.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim referer.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/746f4c69-3700-40f1-b5c1-b2ed3c4b9c5c.jpg" alt></p><p>将带测验8个请求放入 testurl中</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8449207d-4d7c-4da3-b7a8-e161e01c19b2.jpg" alt></p><p><strong>第一个：403 没有匹配上</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d12d9d27-044e-4f2a-9bd1-ca85d432b590.jpg" alt></p><p><strong>第二个：valid,匹配上了 *.taohui.pub</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5d42d29d-4018-41ac-84e6-1005638b2f3e.jpg" alt></p><p><strong>第三个：valid，以内没有referer，匹配上了blocked</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/af7b6ab0-34a0-4a1d-a4f5-df816de7855f.jpg" alt></p><p><strong>第四个：valid，匹配上了 none</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c1f5564a-ef69-45d9-af0e-7a0c27306f77.jpg" alt></p><p><strong>第五个：403 没有匹配上<a href="http://www.taohui.tech" target="_blank" rel="noopener">www.taohui.tech</a></strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a7a7df59-3678-49ca-a876-6c2f54f8d166.jpg" alt></p><p><strong>第六个：valid，匹配上了 server_name</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7f671a43-86f3-47e5-99b2-8ec29753c44b.jpg" alt></p><p><strong>第七个：403 没有配置与baidu有关的</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/f3f2d117-77c7-4e6e-b9dd-7664cdcd4f80.jpg" alt></p><p><strong>第八个：匹配上了正则表达式</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a15fd9ff-cf2e-4ce8-ac7f-94b6d6db4886.jpg" alt></p><h2 id="为复杂业务生成新的变量：map模块"><a href="#为复杂业务生成新的变量：map模块" class="headerlink" title="为复杂业务生成新的变量：map模块"></a>为复杂业务生成新的变量：map模块</h2><p>很多时候，直接使用某些变量的值做逻辑判断是比较困难的，而Map模块提供了可根据1个或多个变量组合成的值结果做判断，进而生成新的变量。再判断新的变量值做逻辑判断。</p><h3 id="通过映射新变量提供更多的可能性：map模块"><a href="#通过映射新变量提供更多的可能性：map模块" class="headerlink" title="通过映射新变量提供更多的可能性：map模块"></a>通过映射新变量提供更多的可能性：map模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/85a00cd6-ef9c-4b74-9843-d3add7d242c5.jpg" alt></p><h3 id="map模块的指令"><a href="#map模块的指令" class="headerlink" title="map模块的指令"></a>map模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/dd78cd48-64fa-4fad-ac21-41d2f7184f58.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/65abe6b5-434d-4b47-bc9f-ac482844cf51.jpg" alt></p><p><strong>问题：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/028fd1ec-f458-4ec8-a901-cc4ce08d150a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589442692006.PNG" alt></p><p>将待检测url放入 testurl，方便拷贝访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/50eed808-e466-43c3-af8f-b744b4f33625.jpg" alt></p><p>访问 map.taohui.org.cn ，匹配上了 泛域名正则、前缀、后缀。而前缀最优先，所以返回 2:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6e049513-0650-42b2-a1e7-ccca35715a47.jpg" alt></p><p>访问 map.tao123.org.cn，只有正则表达式匹配上 1:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8f07ad7f-d832-45bd-b698-5fa0567236e4.jpg" alt></p><p>访问 map.taohui.tech， 完全匹配 与  后缀匹配 都行，但是完全匹配优先级最高，所以 3:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/bf57c2ab-44d3-4e0c-a1c6-af7883535d12.jpg" alt></p><h2 id="通过变量指定少量用户实现AB测试：split-clients模块"><a href="#通过变量指定少量用户实现AB测试：split-clients模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_clients模块"></a>通过变量指定少量用户实现AB测试：split_clients模块</h2><p>该模块可以根据变量的值按照百分比方式生成新的变量。</p><h3 id="AB测试：split-clients模块"><a href="#AB测试：split-clients模块" class="headerlink" title="AB测试：split_clients模块"></a>AB测试：split_clients模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443194182.PNG" alt></p><h3 id="split-clients-模块指令"><a href="#split-clients-模块指令" class="headerlink" title="split_clients 模块指令"></a>split_clients 模块指令</h3><p><strong>AB测试：产品推出的功能不太确定用户是否接受，所以推出多个类似功能，让某一个百分比用户去尝试某一类功能，看大家的反馈来决定最终使用哪一个功能的版本。关键：确保按照某一定的百分比决定用户的行为。</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/3b3fc65c-30fd-47b3-82cd-83d467f82da1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5f8c251c-a7e5-4e44-a908-c1bfe51b26b9.jpg" alt></p><p>上述问题是已经超过100%了。此时重启会发现，重启失败。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/485b6f96-2886-43a2-a5bf-4f413c9856d4.jpg" alt></p><p>将 40% 注释掉。再次访问，server-location中额 $variant 取自 split_clients 中的配置项。而他又取决于$(http_testcli)经算法改造后的值，看这个值落在那个区域，就返回后面对应的值。</p><p><strong>testcli: xxx</strong>，xxx值随便填写，<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443935577.PNG" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589444022423.PNG" alt></p><h2 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h2><p>可根据子网掩码来生成新变量。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/208fe8ff-79ac-4ae0-9568-9b650664ea54.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a751238f-27ba-4fae-b8ae-a7b5c5e6980e.jpg" alt></p><p><strong>geo模块示例</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9b9883bc-c88a-48d8-9017-54b3afbb84bd.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9a632337-6e6d-48c1-b019-c3f9b08daf6a.jpg" alt></p><p>访问<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589449028238.PNG" alt></p><h2 id="使用变量获得用户的地理位置：geoip模块"><a href="#使用变量获得用户的地理位置：geoip模块" class="headerlink" title="使用变量获得用户的地理位置：geoip模块"></a>使用变量获得用户的地理位置：geoip模块</h2><p>可以根据IP地址库自动的计算出IP地址找到相应的地理位置。</p><h3 id="基于MaxMind数据库从客户端地址获取变量：geoip模块"><a href="#基于MaxMind数据库从客户端地址获取变量：geoip模块" class="headerlink" title="基于MaxMind数据库从客户端地址获取变量：geoip模块"></a>基于MaxMind数据库从客户端地址获取变量：geoip模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589450542232.PNG" alt></p><h3 id="geoip-country指令提供的变量"><a href="#geoip-country指令提供的变量" class="headerlink" title="geoip_country指令提供的变量"></a>geoip_country指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/557efae0-fbc2-4a0f-be6f-cf302b8ba368.jpg" alt></p><h3 id="geoip-city指令提供的变量"><a href="#geoip-city指令提供的变量" class="headerlink" title="geoip_city指令提供的变量"></a>geoip_city指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52203507-2fba-4aa3-9a1c-f52fbf4903ff.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/212dbcb2-ddaa-4b31-b1a6-3e78e9f4f2ad.jpg" alt></p><p><a href="https://dev.maxmind.com/geoip/legacy/downloadable/" target="_blank" rel="noopener">MaxMind</a>网址，因为Nginx使用C语言，所以选中C语言的GitHub，进行下载。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7930ddd0-47f0-4e0e-b982-c81bca70c522.png" alt></p><p><a href="https://github.com/maxmind/geoip-api-c" target="_blank" rel="noopener">Github下载zip文件</a></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6793d729-e928-47a5-b427-3920b0c71f28.png" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d07ee523-b404-4c4b-ab54-24c96cbb361f.jpg" alt></p><p>编译进nginx后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e6863285-196c-4e7d-af76-e8df4f44fb06.jpg" alt></p><p>在 <a href="http://www.goubanjia.com/" target="_blank" rel="noopener">http://www.goubanjia.com/</a>选择一些IP来做测试。</p><p>广东IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453163330.PNG" alt></p><p>纽约IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453218372.PNG" alt></p><h2 id="对客户端使用keepalive提升连接效率"><a href="#对客户端使用keepalive提升连接效率" class="headerlink" title="对客户端使用keepalive提升连接效率"></a>对客户端使用keepalive提升连接效率</h2><p>此处是 HTTP协议中的Keepalive，不是TCP协议中的Keepalive</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/86c74fbd-439f-434f-b50c-8e9f25123974.jpg" alt></p><p><strong>语法：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/2205cb77-407c-4672-8c3d-682654a9a5a4.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，&lt;strong&gt;变量是一个解耦工具&lt;/strong&gt;。它同样可以在 openresty 中 lua 语言中大有用处。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>24-详解HTTP过滤模块</title>
    <link href="http://javassun.github.io/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/</id>
    <published>2019-12-12T11:10:53.000Z</published>
    <updated>2020-05-14T11:51:57.407Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文介绍了HTTP模块的11个阶段，在<strong>content</strong>阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到<strong>HTTP过滤模块</strong>，因此，它是处于 <strong>Log</strong>阶段之前，<strong>content</strong>阶段之后去介入请求的处理。</p><a id="more"></a><h2 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h2><h3 id="HTTP过滤模块位置"><a href="#HTTP过滤模块位置" class="headerlink" title="HTTP过滤模块位置"></a>HTTP过滤模块位置</h3><p>image_filter resize 长 宽；（此处图片略有问题）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B7.PNG" alt></p><p><strong>content阶段的 static模块生成响应内容后，到达 header过滤模块的 image_filter，再到 gzip压缩，二者不可翻转。</strong></p><h3 id="返回响应-加工响应内容"><a href="#返回响应-加工响应内容" class="headerlink" title="返回响应-加工响应内容"></a>返回响应-加工响应内容</h3><p>查看 Nginx_module.c数组中内容，也是如下图一样，由下往上看，先被下面的过滤模块处理，在推送到上方的过滤模块。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B71589376248179.PNG" alt></p><h2 id="用过滤模块更改响应中的字符串-sub模块"><a href="#用过滤模块更改响应中的字符串-sub模块" class="headerlink" title="用过滤模块更改响应中的字符串-sub模块"></a>用过滤模块更改响应中的字符串-sub模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/b3d6ce9b-3543-4171-8024-f6a6365fe8e0.jpg" alt></p><h3 id="sub模块指令"><a href="#sub模块指令" class="headerlink" title="sub模块指令"></a>sub模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/f13609e6-c454-4416-a81f-fd26a6238b3b.jpg" alt></p><ul><li><p><strong>sub_filter string replacement，将响应中的string换成replacement</strong></p></li><li><p><strong>sub_filter_last_modified：off,是否同时返回上次未修改过的旧内容（默认是不返回旧内容）</strong></p></li><li><p><strong>sub_filter_once：on  只修改 1次，如果改为off，则是扫描整个body内容，全文修改</strong></p></li><li><p><strong>sub_filter_types mimie-type，只针对 mimie-type类型的响应进行替换，默认是 text/html</strong></p></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim sub.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/be46d0e3-7da9-4c95-be47-dd161c2736a9.jpg" alt></p><p>首先，将配置全部注释，访问域名：端口，得到的是一个index.html欢迎页面。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/312e41fc-b9f1-4657-b13f-2874fbeee811.jpg" alt></p><p>看到 nginx.org 这个超链接中，显示的是<strong>nginx.org</strong>文字，将其替换掉。<strong>替换时忽略大小写</strong>。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/36a19f55-6752-4a68-8bd3-0440f6e09b1d.jpg" alt></p><p>再次访问，发现文字没有变，但是超链接已经变了。（因为开启了只替换一次的功能，所以只替换了超链接，没有替换文字）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/7770d995-813c-4a6c-a224-6c00a5517ff7.jpg" alt></p><p>同时响应头中没有返回<strong>last-modified</strong>有关的内容</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/76b8d1d8-ef27-4e57-b0a3-f1d3c16a70e0.jpg" alt></p><p>再次修改配置项，将 once 改为 off , last_modified 改为 on</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e45f5291-7c8c-4116-9ae0-1a107a67333a.jpg" alt></p><p>访问时会发现被替换掉，且有last-modified</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e5feba71-f287-4ba6-bf46-5dba4f3927c0.jpg" alt></p><h2 id="用过滤模块在http响应前后添加内容-addition模块"><a href="#用过滤模块在http响应前后添加内容-addition模块" class="headerlink" title="用过滤模块在http响应前后添加内容-addition模块"></a>用过滤模块在http响应前后添加内容-addition模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/6f8bae7e-41c0-474a-93d1-a1804c570499.jpg" alt></p><h3 id="addition模块指令"><a href="#addition模块指令" class="headerlink" title="addition模块指令"></a>addition模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/20fa76fe-2f13-4024-a514-4061c47c44b2.jpg" alt></p><p>add_before|after_body uri：添加的URI是<strong>子请求</strong>，让Nginx去访问这个URI，将响应内容添加到body前后。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim addition.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/2cced630-36cc-417e-a563-40c1d92ebb95.jpg" alt></p><p>先访问一个存在的文件 a.txt</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/85d9e2c2-7f2d-4919-baf2-59a045663850.jpg" alt></p><p>修改 addition.conf ，将3个注释解开，再次访问</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/41aacb64-baf1-4429-a122-0cae9ba421c1.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上文介绍了HTTP模块的11个阶段，在&lt;strong&gt;content&lt;/strong&gt;阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到&lt;strong&gt;HTTP过滤模块&lt;/strong&gt;，因此，它是处于 &lt;strong&gt;Log&lt;/strong&gt;阶段之前，&lt;strong&gt;content&lt;/strong&gt;阶段之后去介入请求的处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>23-详解HTTP请求的11个阶段</title>
    <link href="http://javassun.github.io/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>http://javassun.github.io/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/</id>
    <published>2019-12-11T11:10:53.000Z</published>
    <updated>2020-05-14T11:49:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除<strong>HTTP过滤模块</strong> 和 <strong>只提供变量的Nginx模块</strong>之外，所有的HTTP模块必须从Nginx定义好的<strong>11</strong>个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？</p><h2 id="HTTP请求处理时的11个阶段"><a href="#HTTP请求处理时的11个阶段" class="headerlink" title="HTTP请求处理时的11个阶段"></a>HTTP请求处理时的11个阶段</h2><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG" alt></p><a id="more"></a><ul><li><p><strong>post_read</strong>：read到Header内容，刚读完HTTP头部，没有做任何加工之前的原始数据。涉及到 <font color="red"><strong>realip模块</strong></font>。</p></li><li><p><strong>server_rewrite、rewrite</strong>：涉及到<strong>rewrite模块</strong>.</p></li><li><p><strong>find_config</strong>：Nginx框架会做，其实是在做location的匹配。</p></li><li><p><strong>post_rewrite</strong>：即 rewrite之后，需要做的一些工作</p></li></ul><p><strong>Access有关的三个模块</strong>：确认访问权限的。（能不能访问）</p><ul><li><p><strong>preaccess</strong>：在access之前做一些处理。</p></li><li><p><strong>access</strong>：auth_basic（用户名密码），access（访问IP），auth_request(第三方授权等)</p></li><li><p><strong>post_access</strong>：在access之后做一些处理。</p></li></ul><p><strong>content有关的</strong></p><ul><li><p><strong>precontent</strong>：在处理content之前做一些处理。</p></li><li><p><strong>content</strong>：诸如一些方向代理等都是在这个阶段生效的。</p></li><li><p><strong>log</strong>：打印access日志的</p></li></ul><p><strong>所有的请求都是由上到下一个阶段一个阶段按序执行。</strong>在debug时可以清楚地看到。</p><h2 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h2><p>当一个HTTP请求进入到Nginx这11个阶段时，由于每一个阶段都可能有0-n个HTTP模块，如果某一个模块不再把HTTP请求向下传递，那么后面的模块是不会执行的。同一阶段中的多个模块，也不是每个模块都有机会执行到的，可能会有前面的模块把请求直接传递给下一个阶段的模块去处理。下面看一看HTTP模块顺序以及他们的处理流程。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2009d91-a832-44c0-bb11-cdb5ac1dd40c.jpg" alt></p><p><strong>每一个蓝色的模块都属于某一个阶段，这些模块是有序的</strong>。</p><p><strong>char *ngx_module_name[]</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe4091aa-9ac8-4596-895b-ed7041e5b2f5.jpg" alt></p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>顺序如何确定呢？可以去看 ngx_modules.c，即configure执行时，会用 with添加模块，这些都会出现在 ngx_module_name[]数组中，这些模块出现的顺序非常关键。</p><p>如 <strong>limit_req</strong> 与 <strong>limit_conn</strong>，二者同属于<strong>preaccess阶段</strong>，在数组中则是 limit_conn 先出现，limit_req后出现，但是对应于请求的处理时它们是相反的。<strong>一个HTTP请求，会先被 limit_req处理，再被limit_conn处理</strong>，假设这两个同时生效去阻止一个请求时，假设这两个返回值也不同，limit_req返回值是没有机会得到执行的，他已经先于limit_conn将请求结果返回给用户。</p><p><strong>灰色的是Nginx框架执行的，其他的第三方HTTP模块没有机会在此运行。</strong></p><h3 id="非顺序处理"><a href="#非顺序处理" class="headerlink" title="非顺序处理"></a>非顺序处理</h3><p>有些则是不会顺序执行的。如 access阶段，当某一个access模块满足，可以直接跳到 try_files模块。当content阶段index模块执行时有时会直接跳到log模块执行。</p><h2 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h2><p>它可以发现用户的真实IP地址，为后续模块的限速、限流等等功能提供了前提。</p><h3 id="如何拿到真实的用户IP地址？"><a href="#如何拿到真实的用户IP地址？" class="headerlink" title="如何拿到真实的用户IP地址？"></a>如何拿到真实的用户IP地址？</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/17157206-ab2d-457a-8e29-331609170ff3.jpg" alt></p><p>TCP连接有一个四元组，根据一条连接的Source_IP就能够判断出用户的IP地址了，但是网络中存在许多反向代理，这又导致反向代理后与上游服务器又建立了一个新的TCP连接。因此上游服务器想通过TCP中的Source_IP获取用户原始IP地址，是不可能的。</p><p><strong>举例：</strong></p><p>在家里上网时，家里的路由器可能分配了一个<strong>内网IP 192.168.0.x</strong>，当通过运营商（电信可能给分配了一个<strong>公网的IP：115.204.33.1</strong>）去访问某一个网站时，先命中到它的<strong>CDN</strong>，这个网站使用CDN加速（如图片等），这个CDN如果还没有把我所访问的资源缓存时，它可能要去<strong>回源</strong>，又建立了一条新的连接，回源过程中可能进入到一个<strong>反向代理</strong>中（如服务器买在阿里云，可能会用<strong>阿里云的SLB</strong>），这个SLB又会去建立一个新的连接，到我购买的服务器的<strong>Nginx</strong>，因此，Nginx如果仅通过拿地址的话，只能拿到<strong>反向代理的IP地址（2.2.2.2）</strong>，反向代理之前的<strong>CDN的地址是1.1.1.1</strong>，其实我们要拿到的是用户的<strong>公网地址115.204.33.1.</strong>， 如果要做限速、并发连接控制，肯定是基于这个公网IP进行的。</p><p><strong>现在拿到的remote_addr是2.2.2.2，想要的是115.204.33.1，如何做到呢？</strong></p><p>通过 <strong>2</strong>、<strong>3</strong>即可做到。</p><ul><li><p><strong>HTTP头部中有 X-Forwarded-For用来传递IP，如CDN的IP地址是1.1.1.1，他又建立了一个新的到反向代理的连接，这个方向代理服务器收到的Header中，可能会存在 X-Forwarded-for 与 X-Real-IP，这个是CDN添加的。</strong></p></li><li><p><strong>X-Forwarded-For 与 X-Real-IP不同，X-Real-IP永远都是一个用户真实IP地址，而X-Forwarded-For则是累加的。如上图中反向代理到Nginx的连接中，加上了CDN的IP地址</strong></p></li></ul><h3 id="拿到用户真实IP地址如何使用？"><a href="#拿到用户真实IP地址如何使用？" class="headerlink" title="拿到用户真实IP地址如何使用？"></a>拿到用户真实IP地址如何使用？</h3><p>基于变量来解耦使用。根据我们在realip模块中配置的指令，<strong>realip模块</strong>会把从 <strong>X-Forwarded-For、X-Real-IP</strong>中获取到的用户真实IP地址去覆盖 binary_remote_addr、remote_addr这两个变量的值。而这两个变量原来指向的是直接与Nginx连接的客户端地址。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1be2a418-5fc1-4400-9f52-4351644d8728.jpg" alt></p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/45c34dc4-a550-45ac-90bb-451c4f10798e.jpg" alt></p><h3 id="realip模块的指令"><a href="#realip模块的指令" class="headerlink" title="realip模块的指令"></a>realip模块的指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/41eb8af6-6c20-4df5-a634-a0034257f583.jpg" alt></p><p>real_ip_recursive：环回地址，默认是关闭的，当它打开时，他会将X-Forwarded-For中，最后的那个地址如果是和客户端地址相同，就会赔pass掉，去取上一个地址。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要自己添加realip.con配置，并且include到nginx.conf中</span><br><span class="line">vim realip.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589215977643.PNG" alt></p><p>此处的server_name 用的是 realip_.taohui.tech;<br>因为当前所在的机器是 116.62.160.193，所以这个测试是不会跨服务器的，本机访问，所以将本机设置为可信地址（set_real_ip_from 116.62.160.193;）没有用它的默认配置（ real_ip_header X-Real-IP;），而是重新作了配置（real_ip_header X-Forwarded-For;）环回地址用了默认 off ，对于这样的请求，返回 remote_addr 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#39;X-Forwarded-For: 1.1.1.1,116.62.160.193&#39; realip taohui.tech</span><br><span class="line"></span><br><span class="line">-H 可以对我的请求中添加一个Header，Header中放了两个IP，一个是1.1.1.1（模拟上一个对端地址），另一个是116.62.160.193；</span><br></pre></td></tr></table></figure><p>返回的 116.62.160.193</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e52cfd9f-d514-40f6-9aca-2f0226969883.jpg" alt></p><p>如果开启了环回地址 即为 on，Nginx做一次 realod，再次访问，因为我们最后一个地址是本机地址，出发了环回地址被pass掉，发现变为上一个对端地址 1.1.1.1</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/789f10ab-1a2c-4646-b6c1-0d7d5f73f356.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 post_read阶段中的realip模块，因为它处于的阶段，可以拿到没有加工过的X-Forwarded-For或X-Real-IP中的用户地址，因为后续的很多模块会去修改 X-Forwarded-For中头部的值。</p><h2 id="rewrite阶段：rewrite模块"><a href="#rewrite阶段：rewrite模块" class="headerlink" title="rewrite阶段：rewrite模块"></a>rewrite阶段：rewrite模块</h2><p><strong>rewrite模块</strong>中的<strong>return指令</strong>会在 server_rewrite 与 rewrite阶段都会生效，生效后，后续的HTTP模块的其他阶段是没有机会得到执行的。</p><h3 id="rewrite模块：return指令"><a href="#rewrite模块：return指令" class="headerlink" title="rewrite模块：return指令"></a>rewrite模块：return指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/62d86676-c710-43e4-b52a-bdd1f59ee2c9.jpg" alt></p><p>444 表示Nginx立即关闭连接，不再向客户端返回任何内容。</p><h3 id="rewrite模块：return指令与error-page指令"><a href="#rewrite模块：return指令与error-page指令" class="headerlink" title="rewrite模块：return指令与error_page指令"></a>rewrite模块：return指令与error_page指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ffdd9a3d-294a-4148-9b6b-4b51b00f7f55.jpg" alt></p><h3 id="return示例"><a href="#return示例" class="headerlink" title="return示例"></a>return示例</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5c75f1a9-fe7a-4e37-9720-d5bafda5d1cd.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建return.conf，并include进nginx.conf</span><br><span class="line">vim return.conf</span><br></pre></td></tr></table></figure><p>root html/  即我们访问 location 下的某个资源时，会去html下去找资源是否存在。如果文件没有找到，会生成一个404错误码，正常会这样返回，但这里注释掉，并且定义了一个 error_page 404 /403.html；即当看到404时给他重新定向到 403.html页面。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589217726606.PNG" alt></p><p>访问时故意找一个不存在的资源</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02ea6d8e-a71b-460e-a4a5-c67390fd926f.jpg" alt></p><p>此时，解开 return 404 的注释，再次访问， error_page是没有机会得到执行的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/36b9a97b-5f89-4733-8205-b6c0f14fdd27.jpg" alt></p><p>再如：在server中加入了一个 return 405;</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/09fad081-c6bd-4e98-b361-d231b97374d4.jpg" alt></p><p>此时会执行谁呢？ 在11个阶段中不难发现， server配置项中的return 是在 server_rewrite中的，location中的return是在 rewrite中的，肯定是 server_rewrite中的return先执行，而 location中的return是没有机会执行的。<strong>即肯定返回405</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/482f0981-162a-44e1-b2a6-7c71e67a86d7.jpg" alt></p><h3 id="rewrite模块：rewrite指令重写URL"><a href="#rewrite模块：rewrite指令重写URL" class="headerlink" title="rewrite模块：rewrite指令重写URL"></a>rewrite模块：rewrite指令重写URL</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/42d90672-258b-43f1-bfca-758460fbbaa2.jpg" alt></p><h4 id="rewrite指令示例（一）"><a href="#rewrite指令示例（一）" class="headerlink" title="rewrite指令示例（一）"></a>rewrite指令示例（一）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/118bb95d-6343-4197-a1f1-3e588ba5d3b4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/40344274-ece7-4745-8cbc-1495bbe764f5.jpg" alt></p><p>首先访问 first/3.txt</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6b709829-c696-4633-a415-a1f23c883a66.jpg" alt></p><p>在second中间 break注释放开，会有什么不一样呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d8c0525e-65d8-4b72-b88c-2699d513bf92.jpg" alt></p><h4 id="rewrite指令示例（二）"><a href="#rewrite指令示例（二）" class="headerlink" title="rewrite指令示例（二）"></a>rewrite指令示例（二）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0d88d297-907e-452a-9348-28f6bb1db4a8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd30f763-825d-4e63-a7d6-bc80aba824e9.jpg" alt></p><p>访问第一个，因为指定了 permanent（永久重定向），返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3717eeea-bc58-4d62-96f1-4c7c6e2c0b4a.jpg" alt></p><p>访问第二个，因为指令了 redirect（临时重定向），返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d719b0-ea6b-4891-93cb-32dcea315dfb.jpg" alt></p><p>访问第三个，因为什么都没有指定，但前面又有一个 http、https等，会返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f37d3915-6a05-4f68-af33-1c418890ad66.jpg" alt></p><p>访问第四个，虽然前面有 http、https，但最后指定了 permanent，会返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d55a475a-8a3f-43b6-b002-60a63daee590.jpg" alt></p><p><strong>rewrite_log指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8e0d3f73-8412-402c-b627-4a4c47dae229.jpg" alt></p><p>默认是不会开启的，需要显示开启，打开后，刚刚访问过的所有重定向的URL都会在指定的 <strong>logs/rewrite_error.log</strong>中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim rewrite_error.log</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8216df9e-65f7-40d8-b14d-81f473e58d38.jpg" alt></p><h3 id="rewrite模块：if指令-条件判断"><a href="#rewrite模块：if指令-条件判断" class="headerlink" title="rewrite模块：if指令-条件判断"></a>rewrite模块：if指令-条件判断</h3><p><strong>if指令</strong>可以让我们判断请求中的变量的值是否满足某个条件，再去决定由哪一个配置块执行，再根据这些配置块调用相应的模块去解析请求。（逻辑判断）</p><h4 id="rewrite模块的if指令"><a href="#rewrite模块的if指令" class="headerlink" title="rewrite模块的if指令"></a>rewrite模块的if指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/437f5e32-4633-43cd-a275-e96edcd4a1fc.jpg" alt></p><h4 id="if指令的条件表达式"><a href="#if指令的条件表达式" class="headerlink" title="if指令的条件表达式"></a>if指令的条件表达式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fdb72d21-a525-4781-b8aa-671d915b59f6.jpg" alt></p><p><strong>简单示例</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/25e97781-e9a3-4b33-af77-19c7189b6aa5.jpg" alt></p><h2 id="find-config阶段"><a href="#find-config阶段" class="headerlink" title="find_config阶段"></a>find_config阶段</h2><p>当我们在server块下的rewrite系列指令执行完毕后，开始根据用户请求中的URL去location中对应的URL正则表达式进行匹配。这一步【匹配完成后，就确定了由哪一个location对这个请求进行处理。</p><h3 id="处理请求的-location-指令块"><a href="#处理请求的-location-指令块" class="headerlink" title="处理请求的 location 指令块"></a>处理请求的 location 指令块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/96b8444c-2c2d-44f7-a224-24b101a157ca.jpg" alt></p><p><strong>merge_slashes</strong>可以去合并URL里的斜杠，两个斜杠在一起时，默认打开该配置项，会合并成一个。只有当URL中用到<strong>base64编码</strong>等等规则时，才需要关闭。</p><h4 id="location匹配规则：仅匹配URI，忽略参数"><a href="#location匹配规则：仅匹配URI，忽略参数" class="headerlink" title="location匹配规则：仅匹配URI，忽略参数"></a>location匹配规则：仅匹配URI，忽略参数</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bc97e48a-b6da-45b3-9a94-ccdb4dfdeb4d.jpg" alt></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/46154d9b-cde7-44aa-8011-b571869ddf18.jpg" alt></p><h4 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/db8723bd-dfe2-4cca-a421-fa5e85e6eec4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim locations.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/afea573c-c8c2-46f9-9964-81a5dfe637a0.jpg" alt></p><p>访问Test1,精确匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f8816478-51ce-4992-bf10-57198fc681c7.jpg" alt></p><p>访问Test1/,虽然有多个匹配，但是前缀字符串中遵循<strong>最长匹配</strong>的规则，所以匹配到了 Test1/，并且匹配上后，禁止后续正则表达式的匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe863375-e5e2-45b7-9d29-5c59ddc3b0d2.jpg" alt></p><p>访问/Test1/Test2 ，/Test1/Test2 与 <del>* /Test1/(\w+)$ 都匹配上了，但由于没有使用 ^</del>禁止正则表达式匹配，所以匹配的是带有正则表达式的最长匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c4e6b72-6e3a-4789-beec-aad6474d0f44.jpg" alt></p><p>访问/Test1/Test2/ ，因为正则没有匹配上，所以使用最长字符串匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/937460a9-1add-4e3d-a739-ef415bb617c0.jpg" alt></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 location的匹配规则，对于URI的请求，到底是由哪一个location下的指令去执行，就十分了然了，同时也知道了当location数量非常多时，怎样通过 <strong>禁止正则表达式匹配</strong>、<strong>使用=精确匹配</strong>等等方式对非常频繁发起的请求来减少它们做location匹配的次数。</p><h2 id="preaccess阶段"><a href="#preaccess阶段" class="headerlink" title="preaccess阶段"></a>preaccess阶段</h2><h3 id="对连接做限制的limit-conn模块"><a href="#对连接做限制的limit-conn模块" class="headerlink" title="对连接做限制的limit_conn模块"></a>对连接做限制的limit_conn模块</h3><p><strong>问题：如何限制每个客户端的并发连接数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/c2bbb690-8f6f-4a6b-a5e9-ef85c44d74b9.jpg" alt></p><h4 id="limit-conn指令"><a href="#limit-conn指令" class="headerlink" title="limit_conn指令"></a>limit_conn指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7fcdbe6a-773f-4720-9636-475b1fa1f457.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0126152a-bb75-4b70-bac7-0030bdb75d55.jpg" alt></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;3r&#x2F;s</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        limit_rate 50;</span><br><span class="line">        limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;1 nodelay;</span><br><span class="line">        #limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/636ff2ff-a1c4-408a-9b79-9dfa88be33f8.jpg" alt></p><p>上述配置文件定义了一个 <strong>10M</strong> 的共享内存，共享内存中使用 binary_remote_addr，这是一个二进制格式的IP地址（IPV4协议下只有4个字节,效率较高）。</p><p>定义了向用户返回的错误码是500（默认是503）</p><p>将 log_level调成了 warn（默认是error）</p><p>limit_conn_addr 1; 即限制了并发连接数为1（只为演示效果，当有两个客户端同时访问时，就会返回500）</p><p>limit_rate 50; 为了更好的演示，又加上了该配置项，即限制向用户返回的速度，每秒钟只返回50个字节，比较容易出现限制并发连接的场景。</p><p>在一个shell中访问，回复速度非常慢</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b53e8635-ea6e-477f-baf7-d7e9a41130ae.jpg" alt></p><p>在另一个shell中也访问，会回复500错误码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8032adb7-ee5f-4213-b7e5-6d37ba578735.jpg" alt></p><p>在 myerror.log中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d9f8cbfc-d250-42a1-b59a-542a21ee2700.jpg" alt></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>当Nginx作为资源服务器为用户提供服务时，限制用户能够同时发起的并发连接数，是一个很常用的功能。Nginx默认编辑进去的 ngx_http_limit_conn_module模块提供了这样的功能。<strong>设计好Key是关键</strong>。</p><h3 id="对请求做限制的limit-req模块"><a href="#对请求做限制的limit-req模块" class="headerlink" title="对请求做限制的limit_req模块"></a>对请求做限制的limit_req模块</h3><p><strong>问题：如何限制每个客户端的每秒处理请求数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f310270f-af32-456f-a8bc-10f9d88052ea.jpg" alt></p><h4 id="leaky-bucket算法"><a href="#leaky-bucket算法" class="headerlink" title="leaky bucket算法"></a>leaky bucket算法</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a55435d0-d50f-48e1-92e6-48e569f84fe6.jpg" alt></p><p>对于突发性流量，前两秒12Mbps，总共24M，2-7s没有流量，7-10为2Mbps，共6M，前10秒总共30M。</p><p>使用了该算法后，可以限制为3Mbps,前10秒总共 30M。</p><p>可以比喻为一个水龙头，向盆里流动的是突发性流量，而盆向下流的则是恒速流量。</p><ul><li><p><strong>当盆burst满的时候，立刻向用户返回503错误码</strong>。</p></li><li><p><strong>当盆burst没有满的时候，但向下速率已经达到最大化的时，水滴就会存在盆里，即用户的响应会变慢，请求并不会被拒绝</strong>。</p></li></ul><h4 id="limit-req指令"><a href="#limit-req指令" class="headerlink" title="limit_req指令"></a>limit_req指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/39b5d9e6-fc0a-486b-9ba3-417d57dc2ae0.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bafe56ec-ff77-4371-b9de-7bf7dbb7a0f8.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab666467-5387-42cf-b454-0b3ddf8c26b4.jpg" alt></p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;2r&#x2F;m</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        #limit_rate 50;</span><br><span class="line">        #limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;3 nodelay;</span><br><span class="line">        limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有加 burst 与 nodelay时，结果会是怎样？同时注释掉 limit_rate 这样可以快速返回内容。<strong>每分钟两条</strong></p><p><strong>curl limit.haoran.tech</strong> ，看到结果</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7db81b53-d952-41df-aa52-23651ef9a701.jpg" alt></p><p>再次访问</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/034093e0-7e6e-4aa0-8022-e4d36bbb5818.jpg" alt></p><p>将  burst的注释解开会是什么样的呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f129ccd-e03c-45ef-a3de-27ab1087cea7.jpg" alt></p><p>访问3次都可以看到结果，访问第4次时，会有503错误码。</p><p>现在将限制连接与限制请求同时打开。看下效果。返回500（限制连接生效），返回503（限制请求生效），</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/80d4681d-1e8d-410e-9491-4dc792b7e05d.jpg" alt></p><p>每分钟只能处理2个请求，所以第3次访问时，<strong>limit_req生效</strong>，但其实 第二次访问时 <strong>limit_conn</strong>同样生效了。返回的还是503，而不是500，这是因为 limit_req模块是在limit_conn模块之前生效的，limit_req已经向用户拒绝了，limit_conn就没有机会得到执行了。<br><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1eba94b3-b698-40f9-9d67-3243174af439.jpg" alt></p><h2 id="access阶段"><a href="#access阶段" class="headerlink" title="access阶段"></a>access阶段</h2><h3 id="对IP做限制的-access-模块"><a href="#对IP做限制的-access-模块" class="headerlink" title="对IP做限制的 access 模块"></a>对IP做限制的 access 模块</h3><p><strong>access模块</strong> 可以控制那些IP可以访问某些URL，那些不可以访问。</p><p><strong>问题：如何限制那些IP地址的访问权限？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/832769b6-fcc5-4fa5-9da7-4c17ec221d47.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/066c8482-4e64-46a6-b6a6-4ff35b0056e2.jpg" alt></p><h3 id="对用户名-密码做限制的-auth-basic-模块"><a href="#对用户名-密码做限制的-auth-basic-模块" class="headerlink" title="对用户名-密码做限制的 auth_ basic 模块"></a>对用户名-密码做限制的 auth_ basic 模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/609f0ee1-f934-4a18-be91-114657084c86.jpg" alt></p><p><strong>auth_basic模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/98ca71bc-ed6b-4332-910d-a6d02f593c64.jpg" alt></p><p><strong>生成密码文件</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d1d3a69a-f867-448b-a035-8a86dfc57870.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br><span class="line"></span><br><span class="line">htpasswd -c file -b user pass</span><br><span class="line"></span><br><span class="line">-c 指定生成的文件，-b 指定用户名密码</span><br><span class="line"></span><br><span class="line">假设现在已经生成了 auth.pass文件</span><br><span class="line"></span><br><span class="line">vim auth.pass</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4f016d91-a721-4522-a1fb-80cd531197ce.jpg" alt></p><p>上述密码文件中的密码做了一个简单的base64编码。</p><p>在 nginx.conf配置文件中指定有关配置</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/895f11ef-d463-4cd3-ac87-55a76b65174e.jpg" alt></p><p>浏览器访问 access.taohui.tech；会发现需要输入用户名-密码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d41f3894-95a1-4f95-b711-327495299542.jpg" alt></p><p>当我们提供一个非常简单的页面时，如go-access，想对他做一个安全保护，auth_basic是一个不错的做法。</p><h3 id="使用第三方做权限控制的-auth-request-模块"><a href="#使用第三方做权限控制的-auth-request-模块" class="headerlink" title="使用第三方做权限控制的 auth_request 模块"></a>使用第三方做权限控制的 auth_request 模块</h3><p>在生产环境中，往往会有一个动态Web服务器或者相应的一些应用服务器，它们提供更复杂的用户名-密码权限验证，这个时候可以通过访问Nginx的资源池先将这个请求传递给应用服务器上，根据应用服务器返回的结果再判断这个请求资源能不能继续执行，那么Nginx的access阶段有一个模块为 auth_request模块，他就可以完成这样的功能。</p><p><strong>统一的用户权限验证系统</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7af33897-413a-4e91-ace2-ec13a7099185.jpg" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6a69a3f-c156-4852-9303-e6f37b8e8210.jpg" alt></p><p>当访问 / 时 通过 auth_request 生成子请求,会去访问这个URL test_auth，而这个URL通过 proxy_pass反向代理到本机的另一个Nginx服务器（监听端口为8090），他提供的URL为 auth_upstream。成功后，因为有一个默认的配置 root html/(即使注释了也会正常显示html下的 index页面)，如果被拒绝，就会返回 8090 这台机器的错误码。</p><p>8090这台nginx的内容如下（成功的时候）：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7ec46de9-417b-4c2e-9538-92900bc23395.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/cacc2da6-43af-49a1-a0c2-5c875a1c29eb.jpg" alt></p><p>将上游的返回值改为403：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b3662788-1074-492f-9d3c-5c370f409aec.jpg" alt></p><p>禁用缓存后，再次访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e887c996-2eb0-47f2-a0e6-d7c049bc7c2b.jpg" alt></p><h3 id="access阶段的-satisfy-指令"><a href="#access阶段的-satisfy-指令" class="headerlink" title="access阶段的 satisfy 指令"></a>access阶段的 satisfy 指令</h3><p>前面提到了 access 阶段的3个模块，那这三个模块任意一个模块拒绝了用户的请求，用户请求就无法执行了呢？其实并不是这样的，那他们是否严格的按照顺序往下执行呢？同样不是这样的。</p><p>因为 Nginx的HTTP框架中提供了一个 <strong>satisfy指令</strong>，允许我们改变模块的执行顺序。</p><p><strong>限制所有access阶段模块的 satisfy指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9e0e322a-b59c-477b-8787-131df574d6ca.jpg" alt></p><p>即一个 access模块，有三种处理结果：</p><ul><li><p><strong>忽略，即没有任何配置，直接跳到下一个access模块</strong></p></li><li><p><strong>放行（allow），先判断satisfy开关，如果配置为 all（表示必须所有的access模块都同意放行这个请求才可以通过），所以继续执行下一个access模块；如果配置为 any（即不用再去考虑后续的access模块是否同意，直接跳到下一个 post_access阶段执行）</strong></p></li><li><p><strong>拒绝（deny），同样判断satisfy开关，如果配置为 all（直接拒绝请求），不再向下执行。如果是 any，虽然当前这个模块拒绝了，但也会后续模块会同意放行，所以继续执行下一个access模块</strong></p></li></ul><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/11fb6c5d-da39-4d6e-afeb-47fc345a904e.jpg" alt></p><ul><li><p><strong>1：肯定不会生效，因为return指令的生效期是 server_rewrite 与 rewrite阶段，二者都领先于 access，access是没有机会得到执行的。</strong></p></li><li><p><strong>2：肯定有影响，即如果 access阶段已经拒绝了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li><li><p><strong>3：可以访问到，配置了 satisfy any</strong></p></li><li><p><strong>4：提到之前，仍然可以访问，因为模块间的顺序ok就行了，配置指令间的顺序无关紧要</strong></p></li><li><p><strong>5：将 deny all 改为 allow all，没有机会输入，因为配置的 satisfy all，任意的模块同意就可以了，allow all是 access模块的，它先于auth_basic模块执行的，它已经同意了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li></ul><h2 id="precontent阶段"><a href="#precontent阶段" class="headerlink" title="precontent阶段"></a>precontent阶段</h2><h3 id="按序访问资源的-try-files-模块"><a href="#按序访问资源的-try-files-模块" class="headerlink" title="按序访问资源的 try_files 模块"></a>按序访问资源的 try_files 模块</h3><p><strong>对于反向代理的场景十分有用，Nginx先尝试去获取磁盘上的文件内容，如果没有再反向代理到上游服务。</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/728821e7-c28a-470a-8c79-2cc85b353fd3.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim tryfiles.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3eb1c77a-1125-49b9-ac41-bb1c00ee2057.jpg" alt></p><p>访问 /first，如果系统在维护的话可能会有一个 /system/maintenance.html文件，如果这个文件找不到的话，我们就去找 uri（即 html下first有没有），同样没有，$uri/index.html、$uri.html同样都没有，这时使用了 @lasturl 符号 去访问 另一个 location @lasturl。在这个location中返回 200的状态码。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/93bb2a64-19b6-4c1c-9e5a-ae4127d27779.jpg" alt></p><p>访问 /second，一样与一个去尝试，所有文件都找不到时，返回404.</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e14e4c54-713c-4f5d-afe3-826434d572c8.jpg" alt></p><h3 id="实时拷贝流量-mirror-模块"><a href="#实时拷贝流量-mirror-模块" class="headerlink" title="实时拷贝流量 mirror 模块"></a>实时拷贝流量 mirror 模块</h3><p>mirror模块可以帮我们创造一份镜像流量，如生产环境中处理一些请求，这些请求可能需要把他们同步的拷贝一份到我的测试、开发环境中做处理。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8611ad8c-6413-4e49-8c81-14d5dcc9d7bb.jpg" alt></p><p>即当请求到了Nginx后，可以生成一个子请求，这个子请求可以通过反向代理去访问我们的其他环境（测试环境等），对其他环境返回值不作处理。</p><p><strong>举例</strong></p><p>需要一个上游服务器</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8262d188-51e4-42cf-9020-9d191d34a19a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim mirror.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/dfe18329-89d0-4458-b28a-2415d5d86bde.jpg" alt></p><p>收到一个请求时，会拷贝一份流量到 mirror 中去，/mirror收到后，会指定 internal（内部），将其方向代理到本机的10020端口上去。</p><p>访问8001</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5602b6ce-74a5-4899-895c-8a0996c08303.jpg" alt></p><p>实时查看日志</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd01d90d-8679-434b-90d7-76bcdd1da763.jpg" alt></p><p>再去看上游Nginx(10020)的日志，是否收到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8fb49605-4b51-43a3-93b5-482835b2f6f5.jpg" alt></p><h2 id="content阶段"><a href="#content阶段" class="headerlink" title="content阶段"></a>content阶段</h2><h3 id="static模块-root-和-alias-指令"><a href="#static模块-root-和-alias-指令" class="headerlink" title="static模块 root 和 alias 指令"></a>static模块 root 和 alias 指令</h3><p>content阶段中 static模块  默认是在Nginx框架中的，是没有办法做移除的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b281027a-aae7-4dfe-88bc-ac86be3b0a78.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/85228787-c832-42d3-abcc-d1c9a88e6bf8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8ecfd588-3241-470e-87bb-05787d28f3c5.jpg" alt></p><p><font color="red">直接访问 root/，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0c140f6a-cbcd-47c6-9d3b-709a76fee58e.jpg" alt></p><p>查看日志，在 html后又加上了刚刚 location中的root，因为有个 反斜杠，所有有添加了 index.html，这个文件其实是不存在的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b653fc8e-67c4-41b4-8a47-8ab73f3bb163.jpg" alt></p><p><font color="red">直接访问 root/1.txt，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a47c5ad2-58ce-400b-9310-0c10ef8caff9.jpg" alt></p><p>查看日志，它其实是在 html/first/1.txt 后面又添加了 /root/1.txt，即 html/first/1.txt/root/1.txt</p><p><font color="red">直接访问 curl static.taohui.tech/alias/   ,他匹配到了 location /alias  会去访问 html下的index.html，所以应该访问首页</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e81ffef0-5e33-44d9-b9fc-87cdc23a59f0.jpg" alt></p><p><font color="red">直接访问 curl static.taohui.tech/alias/1.txt  ，不会添加完整路径，文件存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c61806a-68d3-412a-bdae-c38891d6fe4e.jpg" alt></p><h3 id="static模块-3个变量"><a href="#static模块-3个变量" class="headerlink" title="static模块 3个变量"></a>static模块 3个变量</h3><p><strong>生成待访问文件的三个相关变量</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363559193.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ef33b509-ef3c-4791-9a89-de3d330cd1f9.jpg" alt></p><p>realpath 实际上是一个软链接，他指向了 first目录下，这个目录下有一个1.txt文件</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2fc334d9-4140-4ae2-b475-c8c70453c88e.jpg" alt></p><p>在下图中可看到，返回3个路径，第一个是完整路径，后两个都是1.txt所在的目录，只不过 document_root 没有做软链接的替换，还是根据配置项拼接出来的，而 realpath_root 已经将 realpath 替换为真实 first目录。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363849390.PNG" alt></p><h3 id="static模块提供的其他功能"><a href="#static模块提供的其他功能" class="headerlink" title="static模块提供的其他功能"></a>static模块提供的其他功能</h3><h4 id="静态文件返回时的-content-type"><a href="#静态文件返回时的-content-type" class="headerlink" title="静态文件返回时的 content-type"></a>静态文件返回时的 content-type</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fcc5c202-7370-4c46-9781-5c3013c3ac45.jpg" alt></p><p>当我们去读磁盘上的文件时，根据文件的扩展名做一次映射。<strong>types指令</strong>就是做这个事情的，为了加速，需要将 content-type  与 扩展名 做一次映射放入 Hash 表中。</p><p><strong>default_type</strong>是在没有文件名时用来告诉用户这个content-type究竟怎样解析</p><h4 id="未找到文件时的错误日志"><a href="#未找到文件时的错误日志" class="headerlink" title="未找到文件时的错误日志"></a>未找到文件时的错误日志</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/73be5c25-2a92-49df-9fa6-4e5a2f18d0e1.jpg" alt></p><h3 id="static模块对url不以斜杠结尾却访问目录的做法"><a href="#static模块对url不以斜杠结尾却访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾却访问目录的做法"></a>static模块对url不以斜杠结尾却访问目录的做法</h3><p>很多人使用 static 模块的  root/alias 指令将Nginx当做静态资源服务器时，很可能会发现，当我们去访问一个目录，但是在url结尾没有加上斜杠时，实际上Nginx会返回一个301的重定向，那么对于重定向中的内容，Nginx提供了3种不同的指令，去控制location这样的行为。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d79721a2-30b5-45d1-bc5f-5a23376cb8f0.jpg" alt></p><p><strong>重定向跳转的域名</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5be98a60-9879-424b-af00-20da33bd9ac6.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim dirredirect.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0f59cecd-1d65-4878-a2fc-ed552e9a8ced.jpg" alt></p><p>在 server_name 中配置了两个域名，第一个是主域名。将 absolute_redireect off 开启（默认是on），root指向 html/ 下有一个 first文件夹。</p><p>先来访问 first文件夹，没有加反斜杠，此时应该获得一个301重定向</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f469702-82cb-4d21-9e94-87b8d4cbbbb2.jpg" alt></p><p>将 absolute_redirect off 注释掉。再次访问，发现 在 <strong>Location</strong>中将域名都添加了进去。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f4c52dee-e694-456e-a032-3adf3c6cb7cc.jpg" alt></p><p>如果头部有一个 <strong>Host: aaa</strong>，那么就会将它替换掉掉Location中的localhost。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3be924e8-441e-49aa-b014-0639d6707a30.jpg" alt></p><p>将 dirredirect.conf配置文件中的 <strong>server_name_in_redirect on</strong>开启后，再去访问，会发现Location中以主域名来绑定。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ea6acb6d-f387-4f79-b80e-04aaa22ace11.jpg" alt></p><h3 id="index-与-autoindex模块"><a href="#index-与-autoindex模块" class="headerlink" title="index 与 autoindex模块"></a>index 与 autoindex模块</h3><p>在前面已经演示过，autoindex会以目录形式显示服务器上的资源。但有时在搭建的时候，会没有看到目录结构，看到的是一个文件的内容，这是因为** index 模块** 先于 <strong>autoindex 模块</strong>产生作用。</p><h4 id="对访问-时的处理：content阶段的index模块"><a href="#对访问-时的处理：content阶段的index模块" class="headerlink" title="对访问/时的处理：content阶段的index模块"></a>对访问/时的处理：content阶段的index模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/03f6d0ed-8176-4fa7-9d84-94e0b6ba03d1.jpg" alt></p><h4 id="显示目录内容：content阶段的autoindex模块"><a href="#显示目录内容：content阶段的autoindex模块" class="headerlink" title="显示目录内容：content阶段的autoindex模块"></a>显示目录内容：content阶段的autoindex模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab7fdd2b-3bc0-411f-a706-72de6fa40001.jpg" alt></p><p><strong>autoindex 模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4a0c0058-8c44-4e61-bf74-a4a1031a99fe.jpg" alt></p><p>autoindex_exact_size on|off ：当默认打开的格式（向用户返回的是html格式时才有效）是显式相对的路径。<strong>绝对路径：</strong>以<strong>字节</strong>来显示。<strong>相对路径：</strong>以<strong>K、M</strong>显示。</p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim autoindex.conf</span><br></pre></td></tr></table></figure><p>监听了1个8080端口，以server_name指定的域名进行访问，默认没有修改index a.html（注释掉了）。当访问 / 时，会去找 index.html，在 alias指定的html下是有这个文件。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bf6a5afc-224c-4ace-bb0d-9980a58ef6d6.jpg" alt></p><p>去访问 autoindex.taohui.tech:8080，得到的是index.html内容</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/35ca0dd5-1174-4d4c-8ab4-f29a4e95c157.jpg" alt></p><p>因为 index 模块是没有办法从  Nginx中移除的，所以可以去修改 index指向的文件，将它指向一个不存在的 a.html文件（即将 index a.html 注释解开）</p><p>再次访问autoindex.taohui.tech:8080，是JSON格式返回这个目录</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d928ea5f-1314-45f7-8c2b-2bfa98a9379b.jpg" alt></p><p>同理，将 autoindex_format json 改为 html</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2f0517d-faa7-47bd-9d91-aaa32607b218.jpg" alt></p><p>reload后，再次访问，因为是以相对路径，所以可以显示到K。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a18c6759-3aae-41de-8cdf-f7b93d5e3473.jpg" alt></p><h3 id="content阶段中有Alibaba提供的concat模块"><a href="#content阶段中有Alibaba提供的concat模块" class="headerlink" title="content阶段中有Alibaba提供的concat模块"></a>content阶段中有Alibaba提供的concat模块</h3><p>concat模块可在一次请求中返回多个文件的内容，这对在Web页面中访问多个小文件来提升性能十分有用。（需要下载并且在 .configure 时编译进Nginx）</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/68e622ae-6d7a-42c3-9890-3cb801bc37d8.jpg" alt></p><p><strong>concat模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9d3beaf0-7b29-4534-81e5-7649b057033b.jpg" alt></p><ul><li><p><strong>concat 开启或者关闭</strong></p></li><li><p><strong>concat_delimiter：String，如果服务器返回多个文件，通过指定的String分隔符进行分割</strong></p></li><li><p><strong>concat_types: MIME types，对那些文件的类型做合并</strong></p></li><li><p><strong>concat_unique：对某一种文件类型进行合并，还是对多个文件类型进行合并</strong></p></li><li><p><strong>concat_ignore_file_error：如果某个文件出现错误，是忽略它，返回其他文件的内容</strong></p></li><li><p><strong>concat_max_files：最多合并多少个文件，默认为10</strong></p></li></ul><p><strong>看一下淘宝网的做法</strong></p><p>可以看到他的大部分请求，都使用了 <strong>??</strong>，后面添加了多个文件，后面用逗号隔开。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02e8a5f0-565f-4068-92ac-01046a0008ab.jpg" alt></p><p>在响应中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/14b5a5c5-325f-42ae-8156-591e00c25231.png" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim concat.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d44649-a349-4292-b964-44f983a5e1b3.jpg" alt></p><p>在 concat.conf配置文件中，首先打开了这个功能，最多20个文件，类型是 text/plain，以 <strong>三个分号</strong>来分隔多个文件。</p><p>现在来访问，他回去 html/concat 路径下找 1.txt 与 2.txt，这两个文件是存在的，内容如下：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e9612a1d-ca16-462c-a9e5-eaba187d31d5.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d3025d36-8921-429f-81f4-f5eefb3dd611.jpg" alt></p><h2 id="Log阶段（记录请求访问日志的log模块）"><a href="#Log阶段（记录请求访问日志的log模块）" class="headerlink" title="Log阶段（记录请求访问日志的log模块）"></a>Log阶段（记录请求访问日志的log模块）</h2><h3 id="http-log模块"><a href="#http-log模块" class="headerlink" title="http_log模块"></a>http_log模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a7c1944c-6b8c-4a7e-9155-dd3a886d2584.jpg" alt></p><h4 id="access-日志格式"><a href="#access-日志格式" class="headerlink" title="access 日志格式"></a>access 日志格式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2b74ec9f-c476-4e23-8162-da5fe03379b0.jpg" alt></p><h4 id="配置日志文件路径"><a href="#配置日志文件路径" class="headerlink" title="配置日志文件路径"></a>配置日志文件路径</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2806838-8e42-4e9f-992b-b9357b7a2820.jpg" alt></p><h4 id="对日志文件名包含变量时的优化"><a href="#对日志文件名包含变量时的优化" class="headerlink" title="对日志文件名包含变量时的优化"></a>对日志文件名包含变量时的优化</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589375413620.PNG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;除&lt;strong&gt;HTTP过滤模块&lt;/strong&gt; 和 &lt;strong&gt;只提供变量的Nginx模块&lt;/strong&gt;之外，所有的HTTP模块必须从Nginx定义好的&lt;strong&gt;11&lt;/strong&gt;个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？&lt;/p&gt;
&lt;h2 id=&quot;HTTP请求处理时的11个阶段&quot;&gt;&lt;a href=&quot;#HTTP请求处理时的11个阶段&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求处理时的11个阶段&quot;&gt;&lt;/a&gt;HTTP请求处理时的11个阶段&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>22-如何找到处理请求的Server指令块</title>
    <link href="http://javassun.github.io/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/</id>
    <published>2019-12-10T12:10:53.000Z</published>
    <updated>2020-05-14T11:47:19.401Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个<strong>server块</strong>处理，因此，要先介绍一个配置指令 <strong>server_name</strong>，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。</p><a id="more"></a><h2 id="Server-name-指令"><a href="#Server-name-指令" class="headerlink" title="Server_name 指令"></a>Server_name 指令</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/df26bdab-3bfd-42ee-86f7-638175ac5b63.jpg" alt></p><p><strong>简单演示：</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/afcba697-6524-4d0a-b0de-26c81a9e6f51.jpg" alt><br><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/9fb82a75-fe58-4cbb-b484-6e81b8ce6784.png" alt></p><p>主域名当前不会生效，curl 域名 -I  （-I 显示头部），访问second开头的域名，返回second开头的域名</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/28d97c9d-1dff-48c5-8da5-7ffe4c7bce25.jpg" alt></p><p>如果先返回是是主域名，就要将 off 改为 on，主域名开始生效。访问second开始的域名，发挥primary开头的主域名。</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/b8921fa4-75db-4574-a213-1614397578e8.jpg" alt></p><p><strong>server_name指令其他用法</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/7150b181-f5f1-4210-8132-47aad432be28.jpg" alt></p><h2 id="Server匹配顺序"><a href="#Server匹配顺序" class="headerlink" title="Server匹配顺序"></a>Server匹配顺序</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/eb693887-6efd-474d-be89-0322bb142a96.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了当Nginx框架取到了Host头部值时，就可以用这个值与我们<strong>Server</strong>块下的<strong>Server_name</strong>指令进行匹配，然后利用其中定义的规则进行解析处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个&lt;strong&gt;server块&lt;/strong&gt;处理，因此，要先介绍一个配置指令 &lt;strong&gt;server_name&lt;/strong&gt;，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>21-Nginx中的正则表达式</title>
    <link href="http://javassun.github.io/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://javassun.github.io/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-12-09T15:34:53.000Z</published>
    <updated>2020-05-14T11:45:23.188Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到<strong>正则表达式</strong>，它可以让我们匹配到的功能更为强大。</p><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/0e4b9acc-6d13-4199-8470-93df39ce4d0b.jpg" alt></p><p><strong>举例：</strong><br><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7fb63cc5-8759-486f-8d6d-c533584d10e1.jpg" alt></p><p><strong>工具：pcretest</strong></p><p>输入模式，输入待校验数据，查看匹配结果，可验证正则书写是否正确。</p><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7b9755d2-be5c-4b01-b2c2-1c91929f9831.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到&lt;strong&gt;正则表达式&lt;/strong&gt;，它可以让我们匹配到的功能更为强大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>20-处理HTTP请求头部流程</title>
    <link href="http://javassun.github.io/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://javassun.github.io/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-09T11:34:53.000Z</published>
    <updated>2020-05-14T11:42:43.774Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 <strong>HTTP Line</strong>，如方法、URL等，再去接收到所有的<strong>Header</strong>，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。</p><a id="more"></a><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/6db1c81d-6992-4757-bdda-4bd8ea201a0c.jpg" alt></p><p>大致分为3个层次：<strong>操作系统内核</strong>、<strong>事件模块</strong>、<strong>HTTP模块</strong>，流程大致如下：</p><ul><li><p><strong>操作系统内核：3次握手，当用户发来SYN时，内核会回复一个SYN+ACK表示已确认，当客户端再发来ACK时，标明连接已成功建立，Nginx有很多Worker进程，都监听了80、443端口，操作系统会依据它的负载均衡算法，选中某一个Worker进程</strong></p></li><li><p><strong>被选中的Worker进程会通过 epoll_wait方法去返回刚刚建立好连接的句柄，拿到句柄后，这其实是一个读事件（读到了一个ACK报文），根据读事件，找到监听的80、443端口，可以调用accept方法，分配连接内存池，默认为 connection_pool_size 512字节</strong></p></li><li><p><strong>所有的HTTP模块开始从事件模块中接入请求，HTTP模块在启动时会定义一个ngx_http_init_connection回调方法，通过 epoll_ctl将读事件加入其中，同时设置超时定时器（client_header_timeout:60s）</strong></p></li><li><p><strong>当用户真的把一个HTTP请求（get、post）发来时，其实是DATA，在TCP层（内核层），会回复一个ACK，同时事件模块的epoll_wait又拿到这个请求，回调方法是 ngx_http_wait_request_handler，需要将内核中的DATA读到Nginx的用户态中，需要分配内存，从连接内存池分配1k(client_header_buffer_size),并不是越大越好，因为只要用户有1个字节发过来，就要为他分配1k大小内存，但是如果用户发来的DATA（URL、Header）超过1K了呢？</strong></p></li></ul><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/301c6d75-7166-4bd4-b44f-9e1e8470fae6.jpg" alt></p><h3 id="接收URI"><a href="#接收URI" class="headerlink" title="接收URI"></a>接收URI</h3><p>刚刚分配完1K后，已经收到了 小于等于1K的请求内容。</p><ul><li><p><strong>分配请求内存池：</strong>处理请求与处理连接不同，处理连接只需要将它收到Nginx内存中就OK了，但处理请求时，去做大量的上下文分析，分析它的HTTP协议、Header，因此要分配一个<strong>请求内存池</strong>，默认 request_pool_size:4k，基本上是<strong>connection_pool_size</strong>的8倍，因为请求的上下文涉及到业务，通常4K是一个比价合适的大小（如果分配过小，请求内存池需要不断地扩充，分配内存的次数变多时，肯定会影响性能），要不要改这个4K要根据业务来决定。</p></li><li><p><strong>状态机解析请求行：</strong>解析请求的行， /r /n之前的 方法名、URL、协议。解析过程中可能会发现URL特别大，超过了刚刚分配的1K内存。</p></li><li><p><strong>分配大内存：</strong>主要是来解决大URL的问题，分多大的呢？<strong>large_client_header_buffers:4 8k</strong>，分配的并不是32K 这么大的内存，而是先分配一个8K的内存，将刚刚1K内存中内容拷贝到这个8K内存中来，还剩7K的内存，用剩下的7K再去接收URL，然后用状态机去继续解析URL，如果发现7K都没有解析完，再次分配第二个8K，即一共分配了16K，最多分配32K。</p></li><li><p><strong>解析完成时，就可以标识URI</strong>，类似于超链接，Nginx用指针指向这个URI。</p></li></ul><h3 id="接收Header"><a href="#接收Header" class="headerlink" title="接收Header"></a>接收Header</h3><p>HTTP请求中的Header可能会非常长，如有Cookie、Host等字段。</p><ul><li><p><strong>状态机解析Header</strong>,Header非常有可能超过1K,又需要分配大内存。</p></li><li><p><strong>分配大内存</strong>与左边接收URI是共用的，如左边已用了2个8K，此处最多只能在分配2个8k。</p></li><li><p><strong>标识header</strong></p></li><li><p><strong>移除超时定时器</strong>，是在收到完整的Header后，才可移除。</p></li><li><p><strong>开始11个阶段的HTTP请求处理</strong></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上都是Nginx框架处理的，11个流程是HTTP模块处理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 &lt;strong&gt;HTTP Line&lt;/strong&gt;，如方法、URL等，再去接收到所有的&lt;strong&gt;Header&lt;/strong&gt;，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>19-Nginx中Listen指令用法</title>
    <link href="http://javassun.github.io/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
    <id>http://javassun.github.io/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/</id>
    <published>2019-12-08T12:34:53.000Z</published>
    <updated>2020-05-14T11:40:33.422Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一个请求进入Nginx开始处理之前，都首先需要<strong>监听端口</strong>，以使得Nginx与客户端建立起<strong>TCP连接</strong>，监听端口的指令为<strong>listen</strong>指令，它是放在<strong>server</strong>配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。</p><a id="more"></a><h2 id="Listen-指令"><a href="#Listen-指令" class="headerlink" title="Listen 指令"></a>Listen 指令</h2><p><img src="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/729d148b-a54e-49ff-a745-fd79853e3e8f.jpg" alt></p><ul><li><p><strong>lisent address[:port]</strong></p></li><li><p><strong>listen port</strong></p></li><li><p><strong>listen unix:path 只用于本机通讯</strong></p></li><li><p><strong>listen 127.0.0.1; 此处默认使用 80端口</strong></p></li></ul><p>详细的Listen用法在后续文章实践时再提及。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;每一个请求进入Nginx开始处理之前，都首先需要&lt;strong&gt;监听端口&lt;/strong&gt;，以使得Nginx与客户端建立起&lt;strong&gt;TCP连接&lt;/strong&gt;，监听端口的指令为&lt;strong&gt;listen&lt;/strong&gt;指令，它是放在&lt;strong&gt;server&lt;/strong&gt;配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>18-Nginx冲突的配置指令以谁为准</title>
    <link href="http://javassun.github.io/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/"/>
    <id>http://javassun.github.io/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/</id>
    <published>2019-12-08T10:34:53.000Z</published>
    <updated>2020-05-14T11:38:28.549Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正式开始学习<strong>HTTP模块</strong>之前，先要谈一谈指令的<strong>嵌套结构</strong>，每一个HTTP模块出现的指令，可能出现的<strong>Context(上下文)</strong>，既可以在<strong>location</strong>中，也可以在<strong>server</strong>中，或是<strong>http</strong>中，当一个指令出现在多个<strong>配置块</strong>中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的<strong>第三方模块</strong>可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？</p><a id="more"></a><h2 id="典型的配置块嵌套"><a href="#典型的配置块嵌套" class="headerlink" title="典型的配置块嵌套"></a>典型的配置块嵌套</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/2d6e5c41-6a8b-4259-bf26-934c752a9249.jpg" alt></p><p>http–server–location 是<strong>HTTP框架来定义</strong>，处理一个请求时，先按照请求中的<strong>域名：如 host</strong>找到对应的<strong>server</strong>,再根据<strong>URL</strong>找到对应的<strong>location</strong>，根据location下具体的指令来处理请求。</p><h2 id="指令的-Context"><a href="#指令的-Context" class="headerlink" title="指令的 Context"></a>指令的 Context</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1b48fc0d-3015-4f35-b87c-6d2eb15f8be8.jpg" alt></p><ul><li><strong>log_format</strong>出现的上下文Context是在<strong>http</strong>中的，如果把它放在<strong>server</strong>、<strong>location</strong>时，启动nginx检查配置文件语法时，会失败，无法启动。</li><li><strong>access_log</strong> 同理。</li></ul><h2 id="指令的合并"><a href="#指令的合并" class="headerlink" title="指令的合并"></a>指令的合并</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/7edbb2e6-b36d-4b34-959d-7db4f481fd9b.jpg" alt></p><h2 id="存储值的指令继承规则：向上覆盖"><a href="#存储值的指令继承规则：向上覆盖" class="headerlink" title="存储值的指令继承规则：向上覆盖"></a>存储值的指令继承规则：向上覆盖</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/82868d03-da97-48c9-af03-557cf3a81ead.jpg" alt></p><ul><li><p><strong>listen指令只能出现在server上下文中</strong></p></li><li><p><strong>alias指令虽然可以出现在 http、server、location中，但是在上述图示中只在location中出现</strong></p></li><li><p><strong>server下的root /home/geek/nginx/html;而其他location中没有定义root，同样可以使用父配置块定义的root，如最下方的root。这是一个通用配置规则，只要该指令允许在子配置块中生效</strong></p></li><li><p><strong>在 location /test 下重新定义了一个 root /home/geek/nginx/test; 或者 access_log 也重新定义了，此时直接使用子配置覆盖父配置</strong></p></li></ul><h2 id="HTTP模块合并配置的实现"><a href="#HTTP模块合并配置的实现" class="headerlink" title="HTTP模块合并配置的实现"></a>HTTP模块合并配置的实现</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/d052eae4-743b-4529-90ba-69e184b87f48.jpg" alt></p><p>举一个例子 <strong>ngx_http_referer_module</strong>防盗链模块，它们都有一个结构体是 <strong>ngx_module_t</strong>，相当于说明书。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/5c0f1a1b-ac60-4725-92e0-cc4f19839d32.jpg" alt></p><p>该模块提供的配置指令，都在 *<em>ngx_command_t &nbsp; &nbsp;ngx_http_referer_commands[] *</em>中提及。<br><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/658fa363-3808-499a-b04d-f78aa16ec8e1.jpg" alt></p><p>如 <strong>valid|referers</strong> 指令可以出现在 server、location下，可以携带1MORE（1个或多个）参数。</p><p>所有指令解析完要做合并，可以看 <strong>ngx_http_module_t</strong> 结构体。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1afde405-4fb7-4e72-963f-45ce63bfe249.jpg" alt></p><p>它定义了 8个回调方法，重点看 <strong>ngx_http_referer_merge_conf</strong>，以上指令都是在location下生效的，所以需要 http、server向location合并。</p><p><strong>合并规则</strong></p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/aa4e4b16-319b-434f-9a0b-dc098312b979.jpg" alt></p><p>parent：父指令<br>child： 子指令</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了HTTP模块指令合并规则，为下面正式学习HTTP每一个模块提供了技术帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正式开始学习&lt;strong&gt;HTTP模块&lt;/strong&gt;之前，先要谈一谈指令的&lt;strong&gt;嵌套结构&lt;/strong&gt;，每一个HTTP模块出现的指令，可能出现的&lt;strong&gt;Context(上下文)&lt;/strong&gt;，既可以在&lt;strong&gt;location&lt;/strong&gt;中，也可以在&lt;strong&gt;server&lt;/strong&gt;中，或是&lt;strong&gt;http&lt;/strong&gt;中，当一个指令出现在多个&lt;strong&gt;配置块&lt;/strong&gt;中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的&lt;strong&gt;第三方模块&lt;/strong&gt;可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>17-Nginx动态模块</title>
    <link href="http://javassun.github.io/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/"/>
    <id>http://javassun.github.io/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/</id>
    <published>2019-12-07T10:34:53.000Z</published>
    <updated>2020-05-14T11:36:27.663Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>动态模块</strong>可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。</p><h2 id="动态模块-减少编译环节"><a href="#动态模块-减少编译环节" class="headerlink" title="动态模块-减少编译环节"></a>动态模块-减少编译环节</h2><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg" alt></p><a id="more"></a><p>左上图 是没有使用动态模块的编译方式及结果。</p><p>左下图 是使用了动态模块的编译及结果（生成了<strong>指定模块的动态库</strong>）。</p><p><font color="red">动态库</font>与<font color="red">静态库</font>区别：静态库会将所有的源代码编译进最终的二进制可执行文件中；动态库在Nginx二进制可执行文件中只保留了<strong>调用它的地址</strong>，在需要用到动态库的功能时，由<strong>Nginx的二进制可执行文件（Nginx Executable）</strong>去调用这个动态库，再去完成对应的功能。好处：当我们仅仅需要修改某一个模块、升级某个模块的功能时（特别是当Nginx编译了大量的第三方模块），重新编译这个动态库，而不用替换二进制可执行文件，编译出新的动态库后，只需要替换出旧的动态库，让 Nginx reload即可使用新的模块功能。</p><p><strong>具体步骤：上右图6步骤</strong></p><p>工作流程：</p><ul><li><p><strong>Configure加入动态模块</strong>：只有<strong>部分模块</strong>可以以动态模块的身份编译</p></li><li><p><strong>执行make，编译出 binary</strong></p></li><li><p><strong>启动时会去读 ngx_modules[] 数组，在模块数组中会发现使用了某个动态模块</strong></p></li><li><p><strong>在nginx.conf中需要加入一个配置项 load_modules，这个配置项指明了这个动态模块所在的路径</strong></p></li><li><p><strong>接下来就可以在Nginx进程中打开动态库并上面的模块加入模块数组中</strong>。</p></li><li><p><strong>基于模块数组再进行初始化过程</strong>。</p></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>查看可以增加哪些动态模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br><span class="line"></span><br><span class="line">后面带有 dynamic 关键字的即为可以动态模块身份编译的</span><br><span class="line">--with-xx-xx-module&#x3D;dynamic</span><br></pre></td></tr></table></figure><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/13afd584-3542-46c9-ad01-e852d8644ff3.png" alt></p><p>以<strong>–with-http-image_filter_module=dynamic</strong> 为例来进行演示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">如果出现 下列信息</span><br><span class="line">.&#x2F;configure: error: the HTTP image filter module requires the GD library.</span><br><span class="line">You can either do not enable the module or install the libraries.</span><br><span class="line"></span><br><span class="line">按照下面这个命令安装依赖库</span><br><span class="line">yum install gd-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次运行编译</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们打开了 8080端口，把一些文件放在了test文件下</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/03066fd1-e17b-4cda-b8fe-90713600cc0d.png" alt></p><p>在test文件夹下，我们存放了一张图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/1786e7f3-3033-4e31-9792-d402fec8b880.png" alt></p><p>用浏览器访问该图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e63ab0bf-c704-4dc9-bc3a-583f3f3f7126.jpg" alt></p><p><strong>而上述动态模块的功能则是可以实时的把图片压缩成更小的图片</strong></p><p>安装好的目录中多了一个 <strong>modules</strong>目录，在这个目录中多出了一个动态库，Linux中所有的动态库是以 .so结尾，静态库是以 .a 结尾的。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/5f9d8e7e-ed30-48db-9bf1-8800ecef0f50.png" alt></p><p>打开nginx配置文件，调用 load_module 这个配置项，将相对路径放在此处。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e1e82aa5-e27d-4576-b1b6-adf007925733.png" alt></p><p>同时将图片放缩</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/328f5eca-3b8c-4fe5-8995-a16cc8f6c49a.png" alt></p><p>图片没有放缩，是因为浏览器缓存了这张图片，按F12，禁用缓存，再次刷新就可以了。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/a836cbf8-ddc3-412e-bc6a-43ef0000240a.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;动态模块&lt;/strong&gt;可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。&lt;/p&gt;
&lt;h2 id=&quot;动态模块-减少编译环节&quot;&gt;&lt;a href=&quot;#动态模块-减少编译环节&quot; class=&quot;headerlink&quot; title=&quot;动态模块-减少编译环节&quot;&gt;&lt;/a&gt;动态模块-减少编译环节&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>16-Nginx容器</title>
    <link href="http://javassun.github.io/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/"/>
    <id>http://javassun.github.io/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/</id>
    <published>2019-12-06T12:13:29.000Z</published>
    <updated>2020-05-14T11:34:25.855Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。</p><h2 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h2><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg" alt></p><a id="more"></a><h3 id="Nginx哈希表"><a href="#Nginx哈希表" class="headerlink" title="Nginx哈希表"></a>Nginx哈希表</h3><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/deb747db-853d-49bc-98b9-34edffd68808.jpg" alt></p><h4 id="哈希表配置"><a href="#哈希表配置" class="headerlink" title="哈希表配置"></a>哈希表配置</h4><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/42459f32-e90c-4688-a0b9-aad76a907fd1.jpg" alt></p><p>与常见的哈希表不同的是：</p><ul><li><strong>应用场景不同</strong>。用于<strong>静态不变的内容</strong>，即在运行过程中，哈希表通常不会出现插入、删除等操作，Nginx刚启动时就基本确定这个Hash表中一共有多少个元素。因此使用Hash表这种数据结构的模块通常会暴露出 <strong>max_size</strong> 与 <strong>bucket size</strong>。max size仅仅控制了最大的哈希表 bucket的个数，而不是实际上 bucket的个数，它的意义在于限制最大化使用内存。</li></ul><p>如上图所示，所有使用哈希表的模块有一些特点。stream/http中所有的变量使用了哈希表，因为变量在模块编译进去的时候就已经定义清楚了。还有 map、反向代理等。反向代理中需要对在配置文件中定义好的Header做哈希来提升它的访问性能。哈希表在访问的时候是一个O(1)的复杂度。</p><p>哈希表中有一个称之为 <strong>Bucket size</strong>，在这个里面会有一些默认值，这些默认值在Nginx的配置文档中说会使CPU Cache len 对齐到这样一个值。这实际上影响了怎样去配置 Bucket size，现在的主流CPU会有 L1、L2、L3缓存，它在取主存（内存）上的数据时，并不是按照所想像的那样，按照64位、32位去取。现在主流CPU去主存，一次取得的字节数是就是 CPU Cache len 。如现在是 64 字节。</p><p>为什么Hash表要向64字节对齐呢？</p><p>假设每一个Hash表的 Bucket是59字节，如果紧密排列在一起，取第一个Hash表元素，仅需要访问一次，还多取了一个自己。取第二个时，要访问主存两次，包括第一个64字节中的最后一个字节以及第二个单元中的58个字节。为了避免取两次的问题，Nginx在它的代码中自动向上对齐。在配置Bucket size时，要注意两个问题。</p><ul><li><p><strong>1 如果配置的不是CPU Cache Len，如配置了70字节，他就会向上分配，每个元素分配128字节。</strong></p></li><li><p><strong>2 如果有可能，尽量不要超过64字节，以减少CPU访问每个Hash表的次数。</strong></p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>哈希表专注于为<strong>静态不变</strong>的内容服务。</li><li>Hash表的 Bucket size 需要考虑CPU Cache Len 对齐问题。</li></ol><h3 id="Nginx红黑树"><a href="#Nginx红黑树" class="headerlink" title="Nginx红黑树"></a>Nginx红黑树</h3><p>Nginx多个Worker进程间做进程间通讯时，经常在共享内存上使用红黑树来管理对象，实际上，在Nginx内存中也会大量使用红黑树。</p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/fc01b91e-4a3c-42a7-b2e8-37b11db20474.jpg" alt></p><p><strong>特点：n为节点数</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/88f836f9-ea9e-4adf-9bae-fe33c6d0d709.jpg" alt></p><p><strong>红黑树的使用模块</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/9388a073-697f-4253-b903-2d36628116b2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。&lt;/p&gt;
&lt;h2 id=&quot;Nginx容器&quot;&gt;&lt;a href=&quot;#Nginx容器&quot; class=&quot;headerlink&quot; title=&quot;Nginx容器&quot;&gt;&lt;/a&gt;Nginx容器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>15-Worker集成协同工作的关键</title>
    <link href="http://javassun.github.io/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/"/>
    <id>http://javassun.github.io/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/</id>
    <published>2019-12-06T10:13:29.000Z</published>
    <updated>2020-05-14T11:32:00.720Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。</p><h2 id="Nginx进程间通讯方式"><a href="#Nginx进程间通讯方式" class="headerlink" title="Nginx进程间通讯方式"></a>Nginx进程间通讯方式</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg" alt></p><a id="more"></a><ul><li><p><strong>信号</strong>：前文也提及过。</p></li><li><p><strong>共享内存</strong>：数据同步。所谓的共享内存也就是我们打开了一个内存空间，如10M，那么一整块0-10M内存，多个Worker之间可以同时访问它，包括读取、写入等操作。为了使用好这样一块共享内存，就会引出另外两个问题。</p></li></ul><blockquote><p><strong>第一个就是锁</strong>，多个Worker进程同时操作一块内存，一定会出现竞争关系，不得不加锁。早期是基于<strong>信号量</strong>的锁，信号量是Linux中比较久远的一种进程同步方式，会导致进程进入休眠状态，即发生了主动切换。而现在大都使用的是<strong>自旋锁</strong>，当锁的条件没有满足，会一直请求。如：这块内存被Worker1使用，Worker2需要去获取锁时，只要Worker1没有释放锁，Worker2会一直在不停地去请求这把锁。<strong>自旋锁</strong>要求所有的Nginx模块必须快速的使用共享内存，即快速取锁，快速释放锁。一旦出现有的第三方模块不遵守这样的规则，就可能导致死锁。</p></blockquote><blockquote><p>一整块共享内存通常是给许多对象同时使用的，如果在模块中手动的去编写、分配内存给到不同的对象，是非常繁琐的，此时引入了<strong>Slab内存管理器</strong>。</p></blockquote><h2 id="共享内存：跨worker进程通讯"><a href="#共享内存：跨worker进程通讯" class="headerlink" title="共享内存：跨worker进程通讯"></a>共享内存：跨worker进程通讯</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/456d7c90-48ea-4f21-9f96-6563bb043d8d.jpg" alt></p><p><strong>红黑树</strong> ：限速、流控场景。（插入、删除快）。</p><p><strong>单链表</strong>：将共享元素串起来。</p><p><strong>Ngx_http_lua_api</strong>：Openresty核心模块</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/685b875f-0c66-4a51-96b0-b1b4dd0626d0.jpg" alt></p><h2 id="共享内存工具-Slab管理器"><a href="#共享内存工具-Slab管理器" class="headerlink" title="共享内存工具-Slab管理器"></a>共享内存工具-Slab管理器</h2><p>上文谈到Nginx不同的Worker进程间需要共享信息时，只能通过共享内存。共享内存上可以使用链表、红黑树这样的数据结构，但每一个红黑树上有许多节点，每一个节点都需要分配内存去存放。怎样把一整块共享内存切割成小块给红黑树上的每个节点使用呢？</p><h3 id="Slab内存管理"><a href="#Slab内存管理" class="headerlink" title="Slab内存管理"></a>Slab内存管理</h3><p>详见 <strong>408 操作系统、计算机组成原理-内存管理与分配</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/edd2057b-fbb7-4724-a215-48c2d898ed15.jpg" alt></p><p><a href="http://tengine.taobao.org/document/ngx_slab_stat.html" target="_blank" rel="noopener">Tengine-Slab</a></p><p><strong>Tengine上 ngx_sla_stat:统计Slab使用状态</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/28245628-4a49-4dd0-a117-a51e6a8568ba.jpg" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/601995b6-b99a-4324-b88e-14106a22871c.png" alt></p><p>会发现没有Github地址，即没有作为一个独立模块发布出来，所以只能点击<strong>Download</strong>下载整个Tengine项目。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0f3a65a0-3276-4dd7-b396-7ea3c5338bdb.png" alt></p><p>解压后，发现tengine中多出一个modules目录，进去查看</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/eed3a379-a7f8-4379-9982-16f2b6dcc0f5.png" alt></p><p>在最后发现 <strong>ngx_slab_stat</strong>模块。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/79bcae21-d7f4-4314-ae50-33d8b9762854.png" alt></p><p>这是一个标准的第三方模块。.c文件是它的说明书。config帮助他编译进目标nginx中。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>现在回到<strong>Openresty</strong>中，让Openresty编译时将<strong>Tengine的Slab_Stat模块</strong>编译进去，然后使用Openrety下的 <strong>share_dict</strong>去分配共享内存，再用<strong>slab_state</strong>查看共享内存的使用情况。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/262f2390-9a34-4537-bf05-74dad3bb3775.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --add-module&#x3D;..&#x2F;tengine-2.3.2&#x2F;modules&#x2F;ngx_slab_stat&#x2F;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0cf928f7-a528-4746-8894-5c1d923feab3.png" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/5b4305a1-3c01-4a02-a48b-2253016dc8de.png" alt></p><p><strong>set、get、slab_stat 得到信息</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/a8f4040f-2d4e-4b38-8d11-d882abc30425.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。&lt;/p&gt;
&lt;h2 id=&quot;Nginx进程间通讯方式&quot;&gt;&lt;a href=&quot;#Nginx进程间通讯方式&quot; class=&quot;headerlink&quot; title=&quot;Nginx进程间通讯方式&quot;&gt;&lt;/a&gt;Nginx进程间通讯方式&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>14-Nginx连接池处理网络请求-内存池对性能的影响</title>
    <link href="http://javassun.github.io/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <id>http://javassun.github.io/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</id>
    <published>2019-12-05T10:13:29.000Z</published>
    <updated>2020-05-14T11:29:48.736Z</updated>
    
    <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？</p><p>Nginx使用了<strong>连接池</strong>来增加它对资源的利用率。</p><h2 id="Nginx通过连接池处理网络请求"><a href="#Nginx通过连接池处理网络请求" class="headerlink" title="Nginx通过连接池处理网络请求"></a>Nginx通过连接池处理网络请求</h2><p><strong>连接池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg" alt></p><a id="more"></a><p>右边图中每一个Worker进程中都有一个独立的数据结构：<strong>ngx_cycle_t</strong>。其中有三个中重要的数据。</p><ul><li><strong>connection数组</strong>：即连接池，他指向的数组有多大呢？其实是有一个配置项可以查看的。512大小的数组。</li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/85000415-fd2a-4026-a7c7-58328179c6f3.jpg" alt></p><ul><li><strong>read_event数组</strong>：数组大小与上述配置一致。</li><li><strong>write_event数组</strong>：同上。</li></ul><p>三者通过序号对应，5号连接自然对应5号读写事件。</p><p><strong>核心数据结构</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c5ba5443-c176-4ef7-b010-486eebe81312.jpg" alt></p><p>一般是 235 + 96*2   （乘2是因为读写两个分配）。</p><p>rb_tree_node_t 红黑树中每个节点指向的 timer，标志读写事件是否超时。</p><p>定时器也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/59848113-bab2-42fa-ae47-d22a8a33595e.jpg" alt></p><p>ngx_queue_t 事件进队列。</p><p>右边的 <strong>off_t</strong> 可以理解为一个无符号的变量，即已经向客户端发送了多少字节。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/9c81e155-3996-4a06-9890-5d00a60de797.jpg" alt></p><p>这个也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/b0b1dcdf-5169-45e1-a438-1c24df64e78c.jpg" alt></p><p>在access.log中可以看到上述配置生效。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c86ece93-3a3a-444d-bcb7-ae03da2b5c3d.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是 ngx_connection_t 与 ngx_event的配置。即连接与事件是怎样对应在一起的。当我们需要配置高并发的nginx时，需要将connection的数目配置的足够大。每一个connection对应的两个event（读写）都会消耗一定的内存。Nginx结构体中的许多成员与内置变量是可以对应做配置的。</p><h2 id="Nginx内存池对性能的影响"><a href="#Nginx内存池对性能的影响" class="headerlink" title="Nginx内存池对性能的影响"></a>Nginx内存池对性能的影响</h2><p>如果开发过第三方模块，会发现虽然在写C语言代码，但我们不需要关心内存的释放。如果在配置一些比较罕见的Nginx使用场景，可能需要去修改Nginx在请求和连接上初始分配的内存池大小。Nginx官方通常推荐不需要修改有关配置。究竟要不要改呢？</p><p><strong>内存池运转方式</strong><br>在上面的 <font color="red">核心数据结构</font>中，发现ngx_connection_s结构体中有一个<strong>ngx_pool_t</strong> 结构。它对应着当前连接所使用的内存池，可以通过 connection_pool_size去定义。</p><p><strong>内存池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/3e50c6d2-f117-49df-bc57-79dc8df8c829.jpg" alt></p><ul><li><p><strong>连接内存池</strong>上只分配一次，只要连接不关闭，分配的内存永远不需要释放，只有当关闭连接时才会释放。</p></li><li><p><strong>请求内存池</strong>：每一个HTTP请求开始分配时并不知道分配多少合适，但对于HTTP1.1 通常分配 4k大小（URL、Header往往需要这么多）。如果没有内存池，可能需要频繁而小块的分配，可能会造成内存碎片过多这样的代价。</p></li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/759a1245-2d83-43a9-b133-553b16c11061.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/1e0b5619-0a02-44af-8fda-989c9671877e.jpg" alt></p><p>当分配的内存超过 256|521 这种预分配大小时，还是可以继续分配的，这里只是提前分配空间，为了减少分配次数。</p><p>请求内存池大小</p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/93e8541a-d8a5-4616-a1ab-2a9f576d8855.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/304ff837-d46a-4e4a-86c3-68d0c54dde1e.jpg" alt></p><p>对于连接而言，他所需要的空间很小，只需要帮助后面的请求读取最初的一部分字节就ok了，而对于请求而言，要保存大量的上下文信息（URL、Header）等。如果URL过大，可以考虑修改这个配置项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Author: haoransun&lt;br&gt;Wechat: SHR—97&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？&lt;/p&gt;
&lt;p&gt;Nginx使用了&lt;strong&gt;连接池&lt;/strong&gt;来增加它对资源的利用率。&lt;/p&gt;
&lt;h2 id=&quot;Nginx通过连接池处理网络请求&quot;&gt;&lt;a href=&quot;#Nginx通过连接池处理网络请求&quot; class=&quot;headerlink&quot; title=&quot;Nginx通过连接池处理网络请求&quot;&gt;&lt;/a&gt;Nginx通过连接池处理网络请求&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;连接池&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://JavaSsun.github.io/tags/Nginx/"/>
    
  </entry>
  
</feed>
