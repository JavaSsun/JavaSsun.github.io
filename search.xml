<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ详解</title>
      <link href="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载<a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/RabbitMQ01.png" alt></p><ul><li>左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。</li><li>中间即是 RabbitMQ，其中包括了 交换机 和 队列。</li><li>右侧 C 代表 消费者，也就是从 RabbitMQ 拿消息的程序。</li></ul><p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机，交换机，队列，和绑定。</p><ul><li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li><li>交换机：<em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li><li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系</li></ul><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout</p><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置 header attribute 参数类型的交换机</li><li>Fanout：转发消息到所有绑定队列</li></ul><p><strong>Direct Exchange</strong></p><p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/rabbitMq_direct.png" alt></p><p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p><p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p><p><strong>Topic Exchange</strong></p><p>Topic Exchange 转发消息主要是根据通配符。_ 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p><p>在这种交换机模式下：</p><ul><li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li><li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li></ul><p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br></pre></td></tr></table></figure><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p><ul><li><code>*</code>表示一个词.</li><li><code>#</code>表示零个或多个词.</li></ul><p><strong>Headers Exchange</strong></p><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><p><strong>Fanout Exchange</strong></p><p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，_会把消息发给绑定给它的全部队列_，如果配置了 routing_key 会被忽略。</p><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了<code>spring-boot-starter-amqp</code> 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 <code>spring-boot-starter-amqp</code> 的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;Spring-boot-rabbitmq</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.0.86</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue Queue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><p>rabbitTemplate 是 Spring Boot 提供的默认实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component</span><br><span class="line">public class HelloSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context &#x3D; &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;hello&quot;)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver  : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，发送者和接收者的 queue name 必须一致，不然不能接收</p></blockquote><h3 id="多对多使用"><a href="#多对多使用" class="headerlink" title="多对多使用"></a>多对多使用</h3><p>一个发送者，N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p><p><strong>一对多发送</strong></p><p>对上面的代码进行了小改造，接收端注册了两个 Receiver,Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void oneToMany() throws Exception &#123;</span><br><span class="line">    for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 12</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 14</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 13</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 15</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 16</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 18</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 17</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 19</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br></pre></td></tr></table></figure><p>根据返回结果得到以下结论</p><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><p><strong>多对多发送</strong></p><p>复制了一份发送者，加入标记，在一百个循环中相互交替发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void manyToMany() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            neoSender.send(i);</span><br><span class="line">            neoSender2.send(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 25</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 25</span><br></pre></td></tr></table></figure><blockquote><p>结论：和一对多一样，接收端仍然会均匀接收到消息</p></blockquote><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p><strong>对象的支持</strong></p><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送者</span><br><span class="line">public void send(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Sender object: &quot; + user.toString());</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;object&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收者</span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Receiver object : &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sender object: User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Receiver object : User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>Topic Exchange</strong></p><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列</p><p>首先对 topic 规则配置，这里使用两个队列来测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    final static String message &#x3D; &quot;topic.message&quot;;</span><br><span class="line">    final static String messages &#x3D; &quot;topic.messages&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;exchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am message 1&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.message&quot;, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am messages 2&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.messages&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息</p><p><strong>Fanout Exchange</strong></p><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>Fanout 相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FanoutRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue AMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue BMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue CMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue AMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, fanout msg &quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver A  : hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg</span><br></pre></td></tr></table></figure><p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zouyesheng.com/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p><p><a href="https://github.com/401Studio/WeekLearn/issues/2" target="_blank" rel="noopener">RabbitMQ：Spring 集成 RabbitMQ 与其概念，消息持久化，ACK机制</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot面试</title>
      <link href="/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：</p><p>问：你觉得 Spring Boot 最大的优势是什么呢？</p><p>答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。</p><p>答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？</p><p>问：Spring Boot Starter 的工作原理是什么？</p><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li><p>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</p></li><li><p>② 根据 spring.factories 配置加载 AutoConfigure 类</p></li><li><p>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</p></li></ul><p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p><a id="more"></a><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p><p>第三部：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>是不是很爽？</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p><h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p><p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p><p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p><h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p><h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p><p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p><p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p><h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p><p>一般前端的解决方案有：</p><ul><li><p>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</p></li><li><p>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</p></li></ul><p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p><p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p><p>第一，配置 CorsFilter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置上述的一段代码。第二种方式稍微简单一些。</p><p>第二，在启动类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p><p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p><h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>用一组不太合理的包含关系来表达它们之间的关系。</p><p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。<br>疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>速度更块</li><li>代码更少（Lambda表达式）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li></ul><p><font color="red">核心为：Lambda表达式与Stream API</font></p><a id="more"></a><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-为什么使用Lambda表达式"><a href="#1-为什么使用Lambda表达式" class="headerlink" title="1. 为什么使用Lambda表达式"></a>1. 为什么使用Lambda表达式</h3><p><strong>Lambda</strong>是一个<font color="red">匿名函数</font>，我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>（将代码像数据一样传递）。可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，使Java语言的表达更加凝练。</p><ul><li>从匿名类到 Lambda 的转换</li></ul><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匿名内部类</span><br><span class="line">Runnable r1 &#x3D; new Runnable()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">         System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原来使用匿名内部类作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(String o1,String o2)&#123;</span><br><span class="line">        return Integer.compare(o1.length,o2.length());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts2 &#x3D; new TreeSet&lt;&gt;(</span><br><span class="line">     (o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>匿名内部类</strong></font>：冗余的语法。导致了“Height Problem”（只有一行在工作）</p><h3 id="2-Lambda表达式语法"><a href="#2-Lambda表达式语法" class="headerlink" title="2. Lambda表达式语法"></a>2. Lambda表达式语法</h3><p>Lambda 表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “<font color="red"> -&gt; </font>“，该操作符被称为 Lambda操作符 或 箭头操作符。它将Lambda分为两个部分：</p><p><strong>左侧：</strong>指定了 Lambda 表达式需要的所有参数<br><strong>右侧：</strong>指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式一：无参，无返回值，Lambda只需一条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lambda需要一个参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun &#x3D; (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式三：Lambda只需要一个参数时，参数的小括号可省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consummer&lt;String&gt; fun &#x3D; args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lambda需要两个参数，并且有返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt;&#123;</span><br><span class="line">      System.out.println(&quot;实现函数接口方法&quot;);</span><br><span class="line">      return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：当Lambda体只有一条语句时，return与大括号可以省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：Long数据类型可以省略，可由编译器推断，即“类型推断”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (Long x,Long y) -&gt; &#123;</span><br><span class="line">         System.out.println(&quot;实现函数接口方法&quot;)；</span><br><span class="line">         x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong>是<font color="red"><strong>匿名内函数</strong></font>：提供了轻量级的语法。解决了匿名内部类带来的“高度”问题。</p><p>语法：<strong>参数列表</strong> <strong>-&gt;</strong> <strong>函数体</strong>三部分组成。<br>函数体：表达式、语句块。<br><font color="red"><strong>表达式</strong></font>：表达式会被执行然后返回执行结果。<br><font color="red"><strong>语句块</strong></font>：语句块中的语句会被依次执行，就像方法中的语句一样</p><ol><li>return语句会把控制权交给匿名函数的调用者</li><li>break和continue只能在循环中使用。</li><li>如果函数体有返回值。那么函数体内部的每一条路径都要有。</li></ol><p>表达式函数体适合小型<strong>Lambda</strong>表达式。消除了return关键字。简洁。</p><p><font color="red">新包</font>：<strong>java.util.function:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收 T对象 返回boolean</span><br><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收 T对象 不返回任何值</span><br><span class="line">Consumer&lt;T&gt; void accept(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收 T对象 返回R对象</span><br><span class="line">Function(T,R) R apply(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供 T对象（工厂T）</span><br><span class="line">Supplier&lt;T&gt; T get()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一元：接收T 返回T</span><br><span class="line">UnaryOperator&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二元：接收两个T 返回T</span><br><span class="line">BinaryOperator&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些 Lambda表达式简单例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int x,int y)-&gt;x+y; &#x2F;&#x2F;接收 x y 返回 x与y的和</span><br><span class="line">()-&gt;45;       &#x2F;&#x2F; 不接受参数 返回45</span><br><span class="line">(String s)-&gt;&#123;System.out.println(s);&#125; &#x2F;&#x2F;接收一个字符串，并把它打印在控制台</span><br></pre></td></tr></table></figure><h3 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h3><p>Lambda表达式无需指定类型，程序依然可以编译，因为 javac 根据程序上下文，在后台推断出了参数类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。即所谓的“类型推断”。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="1-什么是函数式接口"><a href="#1-什么是函数式接口" class="headerlink" title="1. 什么是函数式接口"></a>1. 什么是函数式接口</h3><ul><li><p>只包含了一个抽象方法的接口，称为<strong>函数式接口</strong></p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在任意函数式接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li></ul><h3 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2. 自定义函数式接口"></a>2. 自定义函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyNumber&#123;</span><br><span class="line">   public double getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式接口中使用泛型：</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">   public T getValue(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作为参数传递 Lambda 表达式</span><br><span class="line">public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123;</span><br><span class="line">        return mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       String newStr &#x3D; toUpperString(</span><br><span class="line">       (str) -&gt; str.toUpperCase(), &quot;abcdef&quot;);</span><br><span class="line">       System.out.println(newStr);</span><br></pre></td></tr></table></figure><p><font color="red">作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br></font></p><h3 id="3-Java内治四大核心函数式接口"><a href="#3-Java内治四大核心函数式接口" class="headerlink" title="3. Java内治四大核心函数式接口"></a>3. Java内治四大核心函数式接口</h3><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/97801292-5716-4519-9bff-9f8f08aed48b.png" alt></p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/743ea2bc-aeda-44e0-b691-31c354b94f47.png" alt></p><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况：</p><ul><li><p><strong>对象::实例方法</strong></p></li><li><p><strong>类::静态方法</strong></p></li><li><p><strong>类::实例方法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(x);</span><br><span class="line">等同于</span><br><span class="line">System.out::println;</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D; (x,y) -&gt; Math.pow(x,y);</span><br><span class="line">等同于</span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D;Math::pow;</span><br><span class="line"></span><br><span class="line">compare((x,y) -&gt;x.equals(y), &quot;abcdef&quot; , &quot;abcdef&quot;);</span><br><span class="line">等同于</span><br><span class="line">compare(String::equals,&quot;abc&quot;,&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p><strong>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</strong></p><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><p><strong>格式： ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，与构造器参数 列表要与接口中抽象方法的参数列表一致！</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; (n) -&gt; new MyClass(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; MyClass::new;</span><br></pre></td></tr></table></figure><h3 id="3-数字引用"><a href="#3-数字引用" class="headerlink" title="3. 数字引用"></a>3. 数字引用</h3><p><strong>格式： type[] :: new</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun &#x3D; (n) -&gt; new Integer(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; Integer[]::new;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><h3 id="1-了解Stream"><a href="#1-了解Stream" class="headerlink" title="1. 了解Stream"></a>1. 了解Stream</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一 个则是 <strong>Stream API(java.util.stream.*)</strong>。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>*<em>流(Stream)是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>*</em><br><font color="red">“集合讲的是数据，流讲的是计算！”</font></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="2-Stream三步骤"><a href="#2-Stream三步骤" class="headerlink" title="2. Stream三步骤"></a>2. Stream三步骤</h3><ul><li><p><strong>创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p></li><li><p><strong>中间操作</strong><br>一个中间操作链，对数据源的数据进行处理 </p></li><li><p><strong>终端操作</strong><br>一个终止操作，执行中间操作链，并产生结果<br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/37346492-7531-44b8-a2bf-681c14b381ec.jpg" alt></p></li></ul><h3 id="3-创建Stream"><a href="#3-创建Stream" class="headerlink" title="3. 创建Stream"></a>3. 创建Stream</h3><h4 id="1-Collection-创建流"><a href="#1-Collection-创建流" class="headerlink" title="1. Collection 创建流"></a>1. Collection 创建流</h4><ul><li><p>default Stream<E> stream() : 返回一个顺序流</E></p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p></li></ul><h4 id="2-数组-创建流（Arrays的静态方法stream-创建）"><a href="#2-数组-创建流（Arrays的静态方法stream-创建）" class="headerlink" title="2. 数组 创建流（Arrays的静态方法stream()创建）"></a>2. 数组 创建流（Arrays的静态方法stream()创建）</h4><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li></ul><p><strong>重载形式，能够处理对应基本类型的数组</strong></p><ul><li><p>public static IntStream stream(int[] array)</p></li><li><p>public static LongStream stream(long[] array)</p></li><li><p>public static DoubleStream stream(double[] array)</p></li></ul><h4 id="3-由值创建流"><a href="#3-由值创建流" class="headerlink" title="3. 由值创建流"></a>3. 由值创建流</h4><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li></ul><h4 id="4-由函数创建流：创建无限流"><a href="#4-由函数创建流：创建无限流" class="headerlink" title="4. 由函数创建流：创建无限流"></a>4. 由函数创建流：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>迭代</li></ul><p>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</T></T></T></p><ul><li>生成</li></ul><p>public static<T> Stream<T> generate(Supplier<T> s)</T></T></T></p><h3 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4. Stream 的中间操作"></a>4. Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><p><strong>筛选与切片</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/853fb496-9885-4191-b20d-1d5c8508def5.png" alt></p><p><strong>映射</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/feb89458-0a81-42a9-9aa4-33b20b5991bf.png" alt></p><p><strong>排序</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3a69b800-08f9-4bca-ab2d-51e3f3446635.png" alt></p><h3 id="5-Stream-的终止操作"><a href="#5-Stream-的终止操作" class="headerlink" title="5. Stream 的终止操作"></a>5. Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的 值，例如：List、Integer，甚至是 void 。</p><p><strong>查找与匹配</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1cd0233f-598b-4537-8998-5e5fa24aada0.png" alt><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/bae6b149-cc4f-4f84-aec0-e27bf8afe015.png" alt></p><p><strong>归约</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/037bfd49-78ed-468b-aa65-4ad0242e490b.png" alt></p><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</p><p><strong>收集</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2cccbffb-7df8-4a65-8153-537071e75bd7.png" alt></p><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><h3 id="6-并行流与串行流"><a href="#6-并行流与串行流" class="headerlink" title="6. 并行流与串行流"></a>6. 并行流与串行流</h3><p><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p><h3 id="7-了解-Fork-Join-框架"><a href="#7-了解-Fork-Join-框架" class="headerlink" title="7. 了解 Fork/Join 框架"></a>7. 了解 Fork/Join 框架</h3><p><strong>Fork/Join 框架</strong>:就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/84eaed9b-717b-47f9-9f0a-f5fde05f7472.jpg" alt></p><h3 id="8-Fork-Join-框架与传统线程池的区别"><a href="#8-Fork-Join-框架与传统线程池的区别" class="headerlink" title="8. Fork/Join 框架与传统线程池的区别"></a>8. Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的<br>处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因<br>无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果<br>某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子<br>问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程<br>的等待时间,提高了性能.</p><h2 id="5-新时间日期API"><a href="#5-新时间日期API" class="headerlink" title="5. 新时间日期API"></a>5. 新时间日期API</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实 例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1d49dcda-eb3d-4eb7-aa3c-889e5607867f.png" alt></p><p><strong>Instant 时间戳</strong></p><ul><li>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算</li></ul><p><strong>Duration 和 Period</strong></p><ul><li><p>Duration:用于计算两个“时间”间隔</p></li><li><p>Period:用于计算两个“日期”间隔</p></li><li><p>日期的操纵</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获 取例如：将日期调整到“下个周日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法提供了大量的常 用 TemporalAdjuster 的实现。</p></li></ul><p>例如获取下个周日：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday &#x3D; LocalDate.now().with(</span><br><span class="line">   TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析与格式化</strong></p><p>java.time.format.DateTimeFormatter 类：该类提供了三种 格式化方法：</p><ul><li><p>预定义的标准格式</p></li><li><p>语言环境相关的格式</p></li><li><p>自定义的格式</p></li></ul><p><strong>时区的处理</strong></p><ul><li>Java8 中加入了对时区的支持，带时区的时间为分别为：</li></ul><p>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><p>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><p><strong>与传统日期处理的转换</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/0b30f162-415f-4a9c-a650-ba13116ff20b.png" alt></p><h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6. 接口中的默认方法与静态方法"></a>6. 接口中的默认方法与静态方法</h2><h3 id="1-接口中的默认方法"><a href="#1-接口中的默认方法" class="headerlink" title="1. 接口中的默认方法"></a>1. 接口中的默认方法</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">  T func(int a);</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>接口默认方法的”类优先”原则 *</em></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyFunc&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Named&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello java8&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass implements MyFunc,Named&#123;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">        return Named.super.getName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口中的静态方法"><a href="#2-接口中的静态方法" class="headerlink" title="2. 接口中的静态方法"></a>2. 接口中的静态方法</h3><p>Java8 中，接口中允许添加静态方法</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">  public Integer myFun();</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show()&#123;</span><br><span class="line">     System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-其他新特性"><a href="#7-其他新特性" class="headerlink" title="7. 其他新特性"></a>7. 其他新特性</h2><p><strong>Optional 类</strong></p><p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p><p><strong>常用方法：</strong><br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值<br>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t<br>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</p><p><strong>重复注解与类型注解</strong></p><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations&#123;</span><br><span class="line">   MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation&#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyAnnotation(&quot;Hello&quot;)</span><br><span class="line">@MyAnnotation(&quot;World&quot;)</span><br><span class="line">public void show(@MyAnnotation(&quot;abc&quot;) String str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 交易员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class Trader &#123;</span><br><span class="line">     private String name;</span><br><span class="line">     private String city;</span><br><span class="line">     public Trader(String name, String city) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getter setter方法省略</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">     private Trader trader;</span><br><span class="line">     private int year;</span><br><span class="line">     private int value;</span><br><span class="line">     public Transaction(Trader trader, int year, int value) &#123;</span><br><span class="line">        this.trader &#x3D; trader;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PuttingIntoPractice &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Trader raoul &#x3D; new Trader(&quot;Raoul&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader mario &#x3D; new Trader(&quot;mario&quot;,&quot;Milan&quot;);</span><br><span class="line">        Trader alen &#x3D; new Trader(&quot;alen&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader brian &#x3D; new Trader(&quot;brian&quot;,&quot;Cambridge&quot;);</span><br><span class="line"></span><br><span class="line">  List&lt;Transaction&gt; transactions &#x3D; Arrays.asList(</span><br><span class="line">          new Transaction(brian,2011,300),</span><br><span class="line">          new Transaction(raoul,2012,1000),</span><br><span class="line">          new Transaction(raoul,2011,400),</span><br><span class="line">          new Transaction(mario,2012,710),</span><br><span class="line">          new Transaction(mario,2012,700),</span><br><span class="line">          new Transaction(alen,2012,950)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getYear() &#x3D;&#x3D; 2011)</span><br><span class="line">.sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (2) 交易员都在哪些不同的城市工作过？</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (3) 查找所有来自于剑桥的交易员，并按姓名排序。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (4) 返回所有交易员的姓名字符串，按字母顺序排序。</span><br><span class="line">  String traderStr &#x3D; transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">  System.out.println(traderStr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (5) 有没有交易员是在米兰工作的？</span><br><span class="line">  boolean miLanBased &#x3D; transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader()</span><br><span class="line">                        .getCity().equals(&quot;MiLan&quot;));</span><br><span class="line">  System.out.println(miLanBased);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (6) 打印生活在剑桥的交易员的所有交易额。</span><br><span class="line">         transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (7) 所有交易中，最高的交易额是多少？</span><br><span class="line">  int highestValue &#x3D; transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(0,Integer::max);</span><br><span class="line">  System.out.println(highestValue);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Transaction::getValue).reversed())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (8) 找到交易额最小的交易。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">             .min(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">                .min(Comparator.comparing((Transaction t1)-&gt; t1.getValue()))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (9) 统计每个交易员的记录</span><br><span class="line">  transactions.stream()</span><br><span class="line">       .collect(Collectors.groupingBy(Transaction::getTrader))</span><br><span class="line">                .entrySet().stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (10) 找到单笔交易最高的交易员</span><br><span class="line">  transactions.stream()</span><br><span class="line">             .max(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(tran -&gt;&#123;</span><br><span class="line">                    System.out.println(tran.getTrader());</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习参考网络</p><h2 id="8-java8红黑树"><a href="#8-java8红黑树" class="headerlink" title="8. java8红黑树"></a>8. java8红黑树</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>回顾：HashSet是基于HashCode实现元素不重复的。当插入元素的哈希码相同时，会调用equals方法进行二次比较，如果相同，则新值替旧值。如果不同，则以链表的形式挂在当前元素所在的位置。</p><p>扩容因子：0.75</p><p>如果是1 ，则可能永远是只插入到两个位置，形成部分元素的长链表。每次都要在哈希码相同时进行equals比较（哈希碰撞）。降低性能。</p><p>如果是&lt;0.75,则可能浪费空间。</p><h3 id="数组-链表-红黑树-二叉树的一种"><a href="#数组-链表-红黑树-二叉树的一种" class="headerlink" title="数组-链表-红黑树(二叉树的一种)"></a>数组-链表-红黑树(二叉树的一种)</h3><p><strong>条件：当碰撞袁术个数&gt;8 &amp;&amp; 总容量&gt;64 将其转换为红黑树</strong></p><p><font color="red">碰撞元素个数</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK7是数组-&gt;链表</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK8是数组-链表</font>： 当转变为红黑树时，添加的效率变低。其他效率都高了。平衡二叉树（比当前值与节点值的大小）</p><p>扩容是：原来表会计算hashcode值进行元素的再次填充。</p><p>现在只需要找原来表的总长度+当前所在的位置，就是当前扩容后的位置。（不需要再次进行哈希计算）。</p><p><strong>ConcurrentHashMap：效率提高</strong></p><p>JDK7: ConcurrentLevel = 16<br>JDK8：CAS算法</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/7d750713-3d72-48e3-b512-d11dc1900f92.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Docker简单配置</title>
      <link href="/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><a id="more"></a><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello Docker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DockerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>plugins 中添加 Docker 构建插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br><span class="line"></span><br><span class="line">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span><br><span class="line">systemctl  start docker.service</span><br><span class="line">systemctl  enable docker.service</span><br></pre></td></tr></table></figure><p>使用Docker 中国加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><p>配置环境变量 打开 <code>vim /etc/profile</code> 添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成之后，使其生效</p><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装MAVEN"><a href="#安装MAVEN" class="headerlink" title="安装MAVEN"></a>安装MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar vxf apache-maven-3.5.2-bin.tar.gz</span><br><span class="line">## 移动</span><br><span class="line">mv apache-maven-3.5.2 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#打包</span><br><span class="line">mvn package</span><br><span class="line">#启动</span><br><span class="line">java -jar target&#x2F;spring-boot-docker-1.0.jar</span><br></pre></td></tr></table></figure><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME &#x2F;tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line">Removing intermediate container 593ee5e1ea51</span><br><span class="line">Step 4 : ENTRYPOINT java -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar</span><br><span class="line"> ---&gt; Running in 85d558a10cd4</span><br><span class="line"> ---&gt; 7102f08b5e95</span><br><span class="line">Removing intermediate container 85d558a10cd4</span><br><span class="line">Successfully built 7102f08b5e95</span><br><span class="line">[INFO] Built springboot&#x2F;spring-boot-docker</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M&#x2F;182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot&#x2F;spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot&#x2F;spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot&#x2F;spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080&#x2F;tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-Nginx变量原理-应用</title>
      <link href="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/"/>
      <url>/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，<strong>变量是一个解耦工具</strong>。它同样可以在 openresty 中 lua 语言中大有用处。</p><a id="more"></a><h2 id="变量原理"><a href="#变量原理" class="headerlink" title="变量原理"></a>变量原理</h2><h3 id="变量的提供模块与使用模块"><a href="#变量的提供模块与使用模块" class="headerlink" title="变量的提供模块与使用模块"></a>变量的提供模块与使用模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d4564092-81ea-4d1e-a6e6-55b113cd6724.jpg" alt></p><p><strong>流程：</strong></p><p><font color="red">提供变量名的模块</font></p><p>Nginx启动后，发现当前是一个HTTP模块。它其中有一个 <strong>preconfiguration回调方法</strong>，如 realip模块的 realip变量等等。它定义的是一对值，即<strong>变量名</strong>和<strong>解析出当前变量名的方法</strong>。如给出输入（如http请求头部中的名称），输出就是对应的值。此处<strong>定义规则</strong>。</p><p><font color="red">使用变量名的模块</font></p><p>通过变量名完成解耦。</p><p><strong>两个模块各自专注于自己的职责</strong></p><h3 id="变量的特性"><a href="#变量的特性" class="headerlink" title="变量的特性"></a>变量的特性</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/16c0d0ee-eea1-4e84-b72f-0d99716a1a82.jpg" alt></p><h3 id="存放变量的哈希表"><a href="#存放变量的哈希表" class="headerlink" title="存放变量的哈希表"></a>存放变量的哈希表</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a51c5b96-8f90-4db7-8a3c-5be8fc35c05b.jpg" alt></p><h2 id="HTTP框架提供的请求有关变量"><a href="#HTTP框架提供的请求有关变量" class="headerlink" title="HTTP框架提供的请求有关变量"></a>HTTP框架提供的请求有关变量</h2><p>除许多HTTP模块会提供变量外，Nginx的HTTP框架也提供了大量的变量，这些变量不需要编译、引入新的HTTP模块，而且框架提供的变量往往反映了用户发来的请求时被Nginx处理的流程与细节。因此，熟悉Nginx框架提供的每一个变量的用法是非常有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf配置文件中</span><br><span class="line"></span><br><span class="line">vim var.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/780053e8-ebbd-4515-a257-109fdd50ba0f.jpg" alt><br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8dd34c5-839c-4201-a384-06a439b4a88f.jpg" alt></p><p>为了演示有些变量在不同的阶段时不同的，添加了日志文件。return中，将相关联的变量以一行显示，以逗号分隔。冒号前是变量名，冒号后是变量值。</p><p>做一次访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B7.PNG" alt></p><h3 id="HTTP框架提供的变量"><a href="#HTTP框架提供的变量" class="headerlink" title="HTTP框架提供的变量"></a>HTTP框架提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/535214ab-1e4a-40d3-a006-333711c9259c.jpg" alt></p><h3 id="HTTP请求有关变量"><a href="#HTTP请求有关变量" class="headerlink" title="HTTP请求有关变量"></a>HTTP请求有关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7b486912-8cd7-47a3-89c7-48843fd52723.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c9fdf904-3f7d-416a-b4be-e49b2f4a33c4.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e2070844-a852-4cf3-978b-4b27ba67365b.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8abd28c-0ef9-4070-98f4-914b88414852.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a43e65e2-6f41-47f0-8f3e-a62e9dc13303.jpg" alt></p><h2 id="HTTP框架提供的其他变量"><a href="#HTTP框架提供的其他变量" class="headerlink" title="HTTP框架提供的其他变量"></a>HTTP框架提供的其他变量</h2><h3 id="TCP连接有关的变量"><a href="#TCP连接有关的变量" class="headerlink" title="TCP连接有关的变量"></a>TCP连接有关的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d920d0da-2705-45e4-92d3-7591b589a20f.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/962047ba-83c2-416d-87a1-8a5b26102403.jpg" alt></p><h3 id="Nginx处理请求过程中产生的变量"><a href="#Nginx处理请求过程中产生的变量" class="headerlink" title="Nginx处理请求过程中产生的变量"></a>Nginx处理请求过程中产生的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e25f6442-1682-4d3e-acf1-8fe712fc7601.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/b7821b26-bd21-4930-b315-96c7b4f4a582.jpg" alt></p><h3 id="发送HTTP响应时相关变量"><a href="#发送HTTP响应时相关变量" class="headerlink" title="发送HTTP响应时相关变量"></a>发送HTTP响应时相关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589440450988.PNG" alt></p><h3 id="Nginx系统变量"><a href="#Nginx系统变量" class="headerlink" title="Nginx系统变量"></a>Nginx系统变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/14088861-0f90-4cba-ba31-ee728fc9ea81.jpg" alt></p><h2 id="变量防盗链"><a href="#变量防盗链" class="headerlink" title="变量防盗链"></a>变量防盗链</h2><h3 id="简单有效的防盗链手段：referer模块"><a href="#简单有效的防盗链手段：referer模块" class="headerlink" title="简单有效的防盗链手段：referer模块"></a>简单有效的防盗链手段：referer模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52fc1d8f-49eb-4f0a-9260-cde0e218ccd5.jpg" alt></p><h3 id="referer模块的指令"><a href="#referer模块的指令" class="headerlink" title="referer模块的指令"></a>referer模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a01e89ed-9426-420a-98b8-c9255c31d197.jpg" alt></p><h3 id="valid-referers-指令"><a href="#valid-referers-指令" class="headerlink" title="valid_referers 指令"></a>valid_referers 指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e54ac723-8063-4e30-92fc-ae1e90441ddd.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6deb74a6-c5ac-4d39-b36c-32af38a57191.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim referer.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/746f4c69-3700-40f1-b5c1-b2ed3c4b9c5c.jpg" alt></p><p>将带测验8个请求放入 testurl中</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8449207d-4d7c-4da3-b7a8-e161e01c19b2.jpg" alt></p><p><strong>第一个：403 没有匹配上</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d12d9d27-044e-4f2a-9bd1-ca85d432b590.jpg" alt></p><p><strong>第二个：valid,匹配上了 *.taohui.pub</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5d42d29d-4018-41ac-84e6-1005638b2f3e.jpg" alt></p><p><strong>第三个：valid，以内没有referer，匹配上了blocked</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/af7b6ab0-34a0-4a1d-a4f5-df816de7855f.jpg" alt></p><p><strong>第四个：valid，匹配上了 none</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c1f5564a-ef69-45d9-af0e-7a0c27306f77.jpg" alt></p><p><strong>第五个：403 没有匹配上<a href="http://www.taohui.tech" target="_blank" rel="noopener">www.taohui.tech</a></strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a7a7df59-3678-49ca-a876-6c2f54f8d166.jpg" alt></p><p><strong>第六个：valid，匹配上了 server_name</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7f671a43-86f3-47e5-99b2-8ec29753c44b.jpg" alt></p><p><strong>第七个：403 没有配置与baidu有关的</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/f3f2d117-77c7-4e6e-b9dd-7664cdcd4f80.jpg" alt></p><p><strong>第八个：匹配上了正则表达式</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a15fd9ff-cf2e-4ce8-ac7f-94b6d6db4886.jpg" alt></p><h2 id="为复杂业务生成新的变量：map模块"><a href="#为复杂业务生成新的变量：map模块" class="headerlink" title="为复杂业务生成新的变量：map模块"></a>为复杂业务生成新的变量：map模块</h2><p>很多时候，直接使用某些变量的值做逻辑判断是比较困难的，而Map模块提供了可根据1个或多个变量组合成的值结果做判断，进而生成新的变量。再判断新的变量值做逻辑判断。</p><h3 id="通过映射新变量提供更多的可能性：map模块"><a href="#通过映射新变量提供更多的可能性：map模块" class="headerlink" title="通过映射新变量提供更多的可能性：map模块"></a>通过映射新变量提供更多的可能性：map模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/85a00cd6-ef9c-4b74-9843-d3add7d242c5.jpg" alt></p><h3 id="map模块的指令"><a href="#map模块的指令" class="headerlink" title="map模块的指令"></a>map模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/dd78cd48-64fa-4fad-ac21-41d2f7184f58.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/65abe6b5-434d-4b47-bc9f-ac482844cf51.jpg" alt></p><p><strong>问题：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/028fd1ec-f458-4ec8-a901-cc4ce08d150a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589442692006.PNG" alt></p><p>将待检测url放入 testurl，方便拷贝访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/50eed808-e466-43c3-af8f-b744b4f33625.jpg" alt></p><p>访问 map.taohui.org.cn ，匹配上了 泛域名正则、前缀、后缀。而前缀最优先，所以返回 2:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6e049513-0650-42b2-a1e7-ccca35715a47.jpg" alt></p><p>访问 map.tao123.org.cn，只有正则表达式匹配上 1:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8f07ad7f-d832-45bd-b698-5fa0567236e4.jpg" alt></p><p>访问 map.taohui.tech， 完全匹配 与  后缀匹配 都行，但是完全匹配优先级最高，所以 3:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/bf57c2ab-44d3-4e0c-a1c6-af7883535d12.jpg" alt></p><h2 id="通过变量指定少量用户实现AB测试：split-clients模块"><a href="#通过变量指定少量用户实现AB测试：split-clients模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_clients模块"></a>通过变量指定少量用户实现AB测试：split_clients模块</h2><p>该模块可以根据变量的值按照百分比方式生成新的变量。</p><h3 id="AB测试：split-clients模块"><a href="#AB测试：split-clients模块" class="headerlink" title="AB测试：split_clients模块"></a>AB测试：split_clients模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443194182.PNG" alt></p><h3 id="split-clients-模块指令"><a href="#split-clients-模块指令" class="headerlink" title="split_clients 模块指令"></a>split_clients 模块指令</h3><p><strong>AB测试：产品推出的功能不太确定用户是否接受，所以推出多个类似功能，让某一个百分比用户去尝试某一类功能，看大家的反馈来决定最终使用哪一个功能的版本。关键：确保按照某一定的百分比决定用户的行为。</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/3b3fc65c-30fd-47b3-82cd-83d467f82da1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5f8c251c-a7e5-4e44-a908-c1bfe51b26b9.jpg" alt></p><p>上述问题是已经超过100%了。此时重启会发现，重启失败。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/485b6f96-2886-43a2-a5bf-4f413c9856d4.jpg" alt></p><p>将 40% 注释掉。再次访问，server-location中额 $variant 取自 split_clients 中的配置项。而他又取决于$(http_testcli)经算法改造后的值，看这个值落在那个区域，就返回后面对应的值。</p><p><strong>testcli: xxx</strong>，xxx值随便填写，<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443935577.PNG" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589444022423.PNG" alt></p><h2 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h2><p>可根据子网掩码来生成新变量。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/208fe8ff-79ac-4ae0-9568-9b650664ea54.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a751238f-27ba-4fae-b8ae-a7b5c5e6980e.jpg" alt></p><p><strong>geo模块示例</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9b9883bc-c88a-48d8-9017-54b3afbb84bd.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9a632337-6e6d-48c1-b019-c3f9b08daf6a.jpg" alt></p><p>访问<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589449028238.PNG" alt></p><h2 id="使用变量获得用户的地理位置：geoip模块"><a href="#使用变量获得用户的地理位置：geoip模块" class="headerlink" title="使用变量获得用户的地理位置：geoip模块"></a>使用变量获得用户的地理位置：geoip模块</h2><p>可以根据IP地址库自动的计算出IP地址找到相应的地理位置。</p><h3 id="基于MaxMind数据库从客户端地址获取变量：geoip模块"><a href="#基于MaxMind数据库从客户端地址获取变量：geoip模块" class="headerlink" title="基于MaxMind数据库从客户端地址获取变量：geoip模块"></a>基于MaxMind数据库从客户端地址获取变量：geoip模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589450542232.PNG" alt></p><h3 id="geoip-country指令提供的变量"><a href="#geoip-country指令提供的变量" class="headerlink" title="geoip_country指令提供的变量"></a>geoip_country指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/557efae0-fbc2-4a0f-be6f-cf302b8ba368.jpg" alt></p><h3 id="geoip-city指令提供的变量"><a href="#geoip-city指令提供的变量" class="headerlink" title="geoip_city指令提供的变量"></a>geoip_city指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52203507-2fba-4aa3-9a1c-f52fbf4903ff.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/212dbcb2-ddaa-4b31-b1a6-3e78e9f4f2ad.jpg" alt></p><p><a href="https://dev.maxmind.com/geoip/legacy/downloadable/" target="_blank" rel="noopener">MaxMind</a>网址，因为Nginx使用C语言，所以选中C语言的GitHub，进行下载。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7930ddd0-47f0-4e0e-b982-c81bca70c522.png" alt></p><p><a href="https://github.com/maxmind/geoip-api-c" target="_blank" rel="noopener">Github下载zip文件</a></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6793d729-e928-47a5-b427-3920b0c71f28.png" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d07ee523-b404-4c4b-ab54-24c96cbb361f.jpg" alt></p><p>编译进nginx后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e6863285-196c-4e7d-af76-e8df4f44fb06.jpg" alt></p><p>在 <a href="http://www.goubanjia.com/" target="_blank" rel="noopener">http://www.goubanjia.com/</a>选择一些IP来做测试。</p><p>广东IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453163330.PNG" alt></p><p>纽约IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453218372.PNG" alt></p><h2 id="对客户端使用keepalive提升连接效率"><a href="#对客户端使用keepalive提升连接效率" class="headerlink" title="对客户端使用keepalive提升连接效率"></a>对客户端使用keepalive提升连接效率</h2><p>此处是 HTTP协议中的Keepalive，不是TCP协议中的Keepalive</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/86c74fbd-439f-434f-b50c-8e9f25123974.jpg" alt></p><p><strong>语法：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/2205cb77-407c-4672-8c3d-682654a9a5a4.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-详解HTTP过滤模块</title>
      <link href="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文介绍了HTTP模块的11个阶段，在<strong>content</strong>阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到<strong>HTTP过滤模块</strong>，因此，它是处于 <strong>Log</strong>阶段之前，<strong>content</strong>阶段之后去介入请求的处理。</p><a id="more"></a><h2 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h2><h3 id="HTTP过滤模块位置"><a href="#HTTP过滤模块位置" class="headerlink" title="HTTP过滤模块位置"></a>HTTP过滤模块位置</h3><p>image_filter resize 长 宽；（此处图片略有问题）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B7.PNG" alt></p><p><strong>content阶段的 static模块生成响应内容后，到达 header过滤模块的 image_filter，再到 gzip压缩，二者不可翻转。</strong></p><h3 id="返回响应-加工响应内容"><a href="#返回响应-加工响应内容" class="headerlink" title="返回响应-加工响应内容"></a>返回响应-加工响应内容</h3><p>查看 Nginx_module.c数组中内容，也是如下图一样，由下往上看，先被下面的过滤模块处理，在推送到上方的过滤模块。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B71589376248179.PNG" alt></p><h2 id="用过滤模块更改响应中的字符串-sub模块"><a href="#用过滤模块更改响应中的字符串-sub模块" class="headerlink" title="用过滤模块更改响应中的字符串-sub模块"></a>用过滤模块更改响应中的字符串-sub模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/b3d6ce9b-3543-4171-8024-f6a6365fe8e0.jpg" alt></p><h3 id="sub模块指令"><a href="#sub模块指令" class="headerlink" title="sub模块指令"></a>sub模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/f13609e6-c454-4416-a81f-fd26a6238b3b.jpg" alt></p><ul><li><p><strong>sub_filter string replacement，将响应中的string换成replacement</strong></p></li><li><p><strong>sub_filter_last_modified：off,是否同时返回上次未修改过的旧内容（默认是不返回旧内容）</strong></p></li><li><p><strong>sub_filter_once：on  只修改 1次，如果改为off，则是扫描整个body内容，全文修改</strong></p></li><li><p><strong>sub_filter_types mimie-type，只针对 mimie-type类型的响应进行替换，默认是 text/html</strong></p></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim sub.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/be46d0e3-7da9-4c95-be47-dd161c2736a9.jpg" alt></p><p>首先，将配置全部注释，访问域名：端口，得到的是一个index.html欢迎页面。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/312e41fc-b9f1-4657-b13f-2874fbeee811.jpg" alt></p><p>看到 nginx.org 这个超链接中，显示的是<strong>nginx.org</strong>文字，将其替换掉。<strong>替换时忽略大小写</strong>。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/36a19f55-6752-4a68-8bd3-0440f6e09b1d.jpg" alt></p><p>再次访问，发现文字没有变，但是超链接已经变了。（因为开启了只替换一次的功能，所以只替换了超链接，没有替换文字）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/7770d995-813c-4a6c-a224-6c00a5517ff7.jpg" alt></p><p>同时响应头中没有返回<strong>last-modified</strong>有关的内容</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/76b8d1d8-ef27-4e57-b0a3-f1d3c16a70e0.jpg" alt></p><p>再次修改配置项，将 once 改为 off , last_modified 改为 on</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e45f5291-7c8c-4116-9ae0-1a107a67333a.jpg" alt></p><p>访问时会发现被替换掉，且有last-modified</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e5feba71-f287-4ba6-bf46-5dba4f3927c0.jpg" alt></p><h2 id="用过滤模块在http响应前后添加内容-addition模块"><a href="#用过滤模块在http响应前后添加内容-addition模块" class="headerlink" title="用过滤模块在http响应前后添加内容-addition模块"></a>用过滤模块在http响应前后添加内容-addition模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/6f8bae7e-41c0-474a-93d1-a1804c570499.jpg" alt></p><h3 id="addition模块指令"><a href="#addition模块指令" class="headerlink" title="addition模块指令"></a>addition模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/20fa76fe-2f13-4024-a514-4061c47c44b2.jpg" alt></p><p>add_before|after_body uri：添加的URI是<strong>子请求</strong>，让Nginx去访问这个URI，将响应内容添加到body前后。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim addition.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/2cced630-36cc-417e-a563-40c1d92ebb95.jpg" alt></p><p>先访问一个存在的文件 a.txt</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/85d9e2c2-7f2d-4919-baf2-59a045663850.jpg" alt></p><p>修改 addition.conf ，将3个注释解开，再次访问</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/41aacb64-baf1-4429-a122-0cae9ba421c1.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-详解HTTP请求的11个阶段</title>
      <link href="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
      <url>/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除<strong>HTTP过滤模块</strong> 和 <strong>只提供变量的Nginx模块</strong>之外，所有的HTTP模块必须从Nginx定义好的<strong>11</strong>个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？</p><h2 id="HTTP请求处理时的11个阶段"><a href="#HTTP请求处理时的11个阶段" class="headerlink" title="HTTP请求处理时的11个阶段"></a>HTTP请求处理时的11个阶段</h2><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG" alt></p><a id="more"></a><ul><li><p><strong>post_read</strong>：read到Header内容，刚读完HTTP头部，没有做任何加工之前的原始数据。涉及到 <font color="red"><strong>realip模块</strong></font>。</p></li><li><p><strong>server_rewrite、rewrite</strong>：涉及到<strong>rewrite模块</strong>.</p></li><li><p><strong>find_config</strong>：Nginx框架会做，其实是在做location的匹配。</p></li><li><p><strong>post_rewrite</strong>：即 rewrite之后，需要做的一些工作</p></li></ul><p><strong>Access有关的三个模块</strong>：确认访问权限的。（能不能访问）</p><ul><li><p><strong>preaccess</strong>：在access之前做一些处理。</p></li><li><p><strong>access</strong>：auth_basic（用户名密码），access（访问IP），auth_request(第三方授权等)</p></li><li><p><strong>post_access</strong>：在access之后做一些处理。</p></li></ul><p><strong>content有关的</strong></p><ul><li><p><strong>precontent</strong>：在处理content之前做一些处理。</p></li><li><p><strong>content</strong>：诸如一些方向代理等都是在这个阶段生效的。</p></li><li><p><strong>log</strong>：打印access日志的</p></li></ul><p><strong>所有的请求都是由上到下一个阶段一个阶段按序执行。</strong>在debug时可以清楚地看到。</p><h2 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h2><p>当一个HTTP请求进入到Nginx这11个阶段时，由于每一个阶段都可能有0-n个HTTP模块，如果某一个模块不再把HTTP请求向下传递，那么后面的模块是不会执行的。同一阶段中的多个模块，也不是每个模块都有机会执行到的，可能会有前面的模块把请求直接传递给下一个阶段的模块去处理。下面看一看HTTP模块顺序以及他们的处理流程。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2009d91-a832-44c0-bb11-cdb5ac1dd40c.jpg" alt></p><p><strong>每一个蓝色的模块都属于某一个阶段，这些模块是有序的</strong>。</p><p><strong>char *ngx_module_name[]</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe4091aa-9ac8-4596-895b-ed7041e5b2f5.jpg" alt></p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>顺序如何确定呢？可以去看 ngx_modules.c，即configure执行时，会用 with添加模块，这些都会出现在 ngx_module_name[]数组中，这些模块出现的顺序非常关键。</p><p>如 <strong>limit_req</strong> 与 <strong>limit_conn</strong>，二者同属于<strong>preaccess阶段</strong>，在数组中则是 limit_conn 先出现，limit_req后出现，但是对应于请求的处理时它们是相反的。<strong>一个HTTP请求，会先被 limit_req处理，再被limit_conn处理</strong>，假设这两个同时生效去阻止一个请求时，假设这两个返回值也不同，limit_req返回值是没有机会得到执行的，他已经先于limit_conn将请求结果返回给用户。</p><p><strong>灰色的是Nginx框架执行的，其他的第三方HTTP模块没有机会在此运行。</strong></p><h3 id="非顺序处理"><a href="#非顺序处理" class="headerlink" title="非顺序处理"></a>非顺序处理</h3><p>有些则是不会顺序执行的。如 access阶段，当某一个access模块满足，可以直接跳到 try_files模块。当content阶段index模块执行时有时会直接跳到log模块执行。</p><h2 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h2><p>它可以发现用户的真实IP地址，为后续模块的限速、限流等等功能提供了前提。</p><h3 id="如何拿到真实的用户IP地址？"><a href="#如何拿到真实的用户IP地址？" class="headerlink" title="如何拿到真实的用户IP地址？"></a>如何拿到真实的用户IP地址？</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/17157206-ab2d-457a-8e29-331609170ff3.jpg" alt></p><p>TCP连接有一个四元组，根据一条连接的Source_IP就能够判断出用户的IP地址了，但是网络中存在许多反向代理，这又导致反向代理后与上游服务器又建立了一个新的TCP连接。因此上游服务器想通过TCP中的Source_IP获取用户原始IP地址，是不可能的。</p><p><strong>举例：</strong></p><p>在家里上网时，家里的路由器可能分配了一个<strong>内网IP 192.168.0.x</strong>，当通过运营商（电信可能给分配了一个<strong>公网的IP：115.204.33.1</strong>）去访问某一个网站时，先命中到它的<strong>CDN</strong>，这个网站使用CDN加速（如图片等），这个CDN如果还没有把我所访问的资源缓存时，它可能要去<strong>回源</strong>，又建立了一条新的连接，回源过程中可能进入到一个<strong>反向代理</strong>中（如服务器买在阿里云，可能会用<strong>阿里云的SLB</strong>），这个SLB又会去建立一个新的连接，到我购买的服务器的<strong>Nginx</strong>，因此，Nginx如果仅通过拿地址的话，只能拿到<strong>反向代理的IP地址（2.2.2.2）</strong>，反向代理之前的<strong>CDN的地址是1.1.1.1</strong>，其实我们要拿到的是用户的<strong>公网地址115.204.33.1.</strong>， 如果要做限速、并发连接控制，肯定是基于这个公网IP进行的。</p><p><strong>现在拿到的remote_addr是2.2.2.2，想要的是115.204.33.1，如何做到呢？</strong></p><p>通过 <strong>2</strong>、<strong>3</strong>即可做到。</p><ul><li><p><strong>HTTP头部中有 X-Forwarded-For用来传递IP，如CDN的IP地址是1.1.1.1，他又建立了一个新的到反向代理的连接，这个方向代理服务器收到的Header中，可能会存在 X-Forwarded-for 与 X-Real-IP，这个是CDN添加的。</strong></p></li><li><p><strong>X-Forwarded-For 与 X-Real-IP不同，X-Real-IP永远都是一个用户真实IP地址，而X-Forwarded-For则是累加的。如上图中反向代理到Nginx的连接中，加上了CDN的IP地址</strong></p></li></ul><h3 id="拿到用户真实IP地址如何使用？"><a href="#拿到用户真实IP地址如何使用？" class="headerlink" title="拿到用户真实IP地址如何使用？"></a>拿到用户真实IP地址如何使用？</h3><p>基于变量来解耦使用。根据我们在realip模块中配置的指令，<strong>realip模块</strong>会把从 <strong>X-Forwarded-For、X-Real-IP</strong>中获取到的用户真实IP地址去覆盖 binary_remote_addr、remote_addr这两个变量的值。而这两个变量原来指向的是直接与Nginx连接的客户端地址。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1be2a418-5fc1-4400-9f52-4351644d8728.jpg" alt></p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/45c34dc4-a550-45ac-90bb-451c4f10798e.jpg" alt></p><h3 id="realip模块的指令"><a href="#realip模块的指令" class="headerlink" title="realip模块的指令"></a>realip模块的指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/41eb8af6-6c20-4df5-a634-a0034257f583.jpg" alt></p><p>real_ip_recursive：环回地址，默认是关闭的，当它打开时，他会将X-Forwarded-For中，最后的那个地址如果是和客户端地址相同，就会赔pass掉，去取上一个地址。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要自己添加realip.con配置，并且include到nginx.conf中</span><br><span class="line">vim realip.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589215977643.PNG" alt></p><p>此处的server_name 用的是 realip_.taohui.tech;<br>因为当前所在的机器是 116.62.160.193，所以这个测试是不会跨服务器的，本机访问，所以将本机设置为可信地址（set_real_ip_from 116.62.160.193;）没有用它的默认配置（ real_ip_header X-Real-IP;），而是重新作了配置（real_ip_header X-Forwarded-For;）环回地址用了默认 off ，对于这样的请求，返回 remote_addr 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#39;X-Forwarded-For: 1.1.1.1,116.62.160.193&#39; realip taohui.tech</span><br><span class="line"></span><br><span class="line">-H 可以对我的请求中添加一个Header，Header中放了两个IP，一个是1.1.1.1（模拟上一个对端地址），另一个是116.62.160.193；</span><br></pre></td></tr></table></figure><p>返回的 116.62.160.193</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e52cfd9f-d514-40f6-9aca-2f0226969883.jpg" alt></p><p>如果开启了环回地址 即为 on，Nginx做一次 realod，再次访问，因为我们最后一个地址是本机地址，出发了环回地址被pass掉，发现变为上一个对端地址 1.1.1.1</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/789f10ab-1a2c-4646-b6c1-0d7d5f73f356.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 post_read阶段中的realip模块，因为它处于的阶段，可以拿到没有加工过的X-Forwarded-For或X-Real-IP中的用户地址，因为后续的很多模块会去修改 X-Forwarded-For中头部的值。</p><h2 id="rewrite阶段：rewrite模块"><a href="#rewrite阶段：rewrite模块" class="headerlink" title="rewrite阶段：rewrite模块"></a>rewrite阶段：rewrite模块</h2><p><strong>rewrite模块</strong>中的<strong>return指令</strong>会在 server_rewrite 与 rewrite阶段都会生效，生效后，后续的HTTP模块的其他阶段是没有机会得到执行的。</p><h3 id="rewrite模块：return指令"><a href="#rewrite模块：return指令" class="headerlink" title="rewrite模块：return指令"></a>rewrite模块：return指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/62d86676-c710-43e4-b52a-bdd1f59ee2c9.jpg" alt></p><p>444 表示Nginx立即关闭连接，不再向客户端返回任何内容。</p><h3 id="rewrite模块：return指令与error-page指令"><a href="#rewrite模块：return指令与error-page指令" class="headerlink" title="rewrite模块：return指令与error_page指令"></a>rewrite模块：return指令与error_page指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ffdd9a3d-294a-4148-9b6b-4b51b00f7f55.jpg" alt></p><h3 id="return示例"><a href="#return示例" class="headerlink" title="return示例"></a>return示例</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5c75f1a9-fe7a-4e37-9720-d5bafda5d1cd.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建return.conf，并include进nginx.conf</span><br><span class="line">vim return.conf</span><br></pre></td></tr></table></figure><p>root html/  即我们访问 location 下的某个资源时，会去html下去找资源是否存在。如果文件没有找到，会生成一个404错误码，正常会这样返回，但这里注释掉，并且定义了一个 error_page 404 /403.html；即当看到404时给他重新定向到 403.html页面。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589217726606.PNG" alt></p><p>访问时故意找一个不存在的资源</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02ea6d8e-a71b-460e-a4a5-c67390fd926f.jpg" alt></p><p>此时，解开 return 404 的注释，再次访问， error_page是没有机会得到执行的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/36b9a97b-5f89-4733-8205-b6c0f14fdd27.jpg" alt></p><p>再如：在server中加入了一个 return 405;</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/09fad081-c6bd-4e98-b361-d231b97374d4.jpg" alt></p><p>此时会执行谁呢？ 在11个阶段中不难发现， server配置项中的return 是在 server_rewrite中的，location中的return是在 rewrite中的，肯定是 server_rewrite中的return先执行，而 location中的return是没有机会执行的。<strong>即肯定返回405</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/482f0981-162a-44e1-b2a6-7c71e67a86d7.jpg" alt></p><h3 id="rewrite模块：rewrite指令重写URL"><a href="#rewrite模块：rewrite指令重写URL" class="headerlink" title="rewrite模块：rewrite指令重写URL"></a>rewrite模块：rewrite指令重写URL</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/42d90672-258b-43f1-bfca-758460fbbaa2.jpg" alt></p><h4 id="rewrite指令示例（一）"><a href="#rewrite指令示例（一）" class="headerlink" title="rewrite指令示例（一）"></a>rewrite指令示例（一）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/118bb95d-6343-4197-a1f1-3e588ba5d3b4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/40344274-ece7-4745-8cbc-1495bbe764f5.jpg" alt></p><p>首先访问 first/3.txt</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6b709829-c696-4633-a415-a1f23c883a66.jpg" alt></p><p>在second中间 break注释放开，会有什么不一样呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d8c0525e-65d8-4b72-b88c-2699d513bf92.jpg" alt></p><h4 id="rewrite指令示例（二）"><a href="#rewrite指令示例（二）" class="headerlink" title="rewrite指令示例（二）"></a>rewrite指令示例（二）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0d88d297-907e-452a-9348-28f6bb1db4a8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd30f763-825d-4e63-a7d6-bc80aba824e9.jpg" alt></p><p>访问第一个，因为指定了 permanent（永久重定向），返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3717eeea-bc58-4d62-96f1-4c7c6e2c0b4a.jpg" alt></p><p>访问第二个，因为指令了 redirect（临时重定向），返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d719b0-ea6b-4891-93cb-32dcea315dfb.jpg" alt></p><p>访问第三个，因为什么都没有指定，但前面又有一个 http、https等，会返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f37d3915-6a05-4f68-af33-1c418890ad66.jpg" alt></p><p>访问第四个，虽然前面有 http、https，但最后指定了 permanent，会返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d55a475a-8a3f-43b6-b002-60a63daee590.jpg" alt></p><p><strong>rewrite_log指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8e0d3f73-8412-402c-b627-4a4c47dae229.jpg" alt></p><p>默认是不会开启的，需要显示开启，打开后，刚刚访问过的所有重定向的URL都会在指定的 <strong>logs/rewrite_error.log</strong>中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim rewrite_error.log</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8216df9e-65f7-40d8-b14d-81f473e58d38.jpg" alt></p><h3 id="rewrite模块：if指令-条件判断"><a href="#rewrite模块：if指令-条件判断" class="headerlink" title="rewrite模块：if指令-条件判断"></a>rewrite模块：if指令-条件判断</h3><p><strong>if指令</strong>可以让我们判断请求中的变量的值是否满足某个条件，再去决定由哪一个配置块执行，再根据这些配置块调用相应的模块去解析请求。（逻辑判断）</p><h4 id="rewrite模块的if指令"><a href="#rewrite模块的if指令" class="headerlink" title="rewrite模块的if指令"></a>rewrite模块的if指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/437f5e32-4633-43cd-a275-e96edcd4a1fc.jpg" alt></p><h4 id="if指令的条件表达式"><a href="#if指令的条件表达式" class="headerlink" title="if指令的条件表达式"></a>if指令的条件表达式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fdb72d21-a525-4781-b8aa-671d915b59f6.jpg" alt></p><p><strong>简单示例</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/25e97781-e9a3-4b33-af77-19c7189b6aa5.jpg" alt></p><h2 id="find-config阶段"><a href="#find-config阶段" class="headerlink" title="find_config阶段"></a>find_config阶段</h2><p>当我们在server块下的rewrite系列指令执行完毕后，开始根据用户请求中的URL去location中对应的URL正则表达式进行匹配。这一步【匹配完成后，就确定了由哪一个location对这个请求进行处理。</p><h3 id="处理请求的-location-指令块"><a href="#处理请求的-location-指令块" class="headerlink" title="处理请求的 location 指令块"></a>处理请求的 location 指令块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/96b8444c-2c2d-44f7-a224-24b101a157ca.jpg" alt></p><p><strong>merge_slashes</strong>可以去合并URL里的斜杠，两个斜杠在一起时，默认打开该配置项，会合并成一个。只有当URL中用到<strong>base64编码</strong>等等规则时，才需要关闭。</p><h4 id="location匹配规则：仅匹配URI，忽略参数"><a href="#location匹配规则：仅匹配URI，忽略参数" class="headerlink" title="location匹配规则：仅匹配URI，忽略参数"></a>location匹配规则：仅匹配URI，忽略参数</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bc97e48a-b6da-45b3-9a94-ccdb4dfdeb4d.jpg" alt></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/46154d9b-cde7-44aa-8011-b571869ddf18.jpg" alt></p><h4 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/db8723bd-dfe2-4cca-a421-fa5e85e6eec4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim locations.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/afea573c-c8c2-46f9-9964-81a5dfe637a0.jpg" alt></p><p>访问Test1,精确匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f8816478-51ce-4992-bf10-57198fc681c7.jpg" alt></p><p>访问Test1/,虽然有多个匹配，但是前缀字符串中遵循<strong>最长匹配</strong>的规则，所以匹配到了 Test1/，并且匹配上后，禁止后续正则表达式的匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe863375-e5e2-45b7-9d29-5c59ddc3b0d2.jpg" alt></p><p>访问/Test1/Test2 ，/Test1/Test2 与 <del>* /Test1/(\w+)$ 都匹配上了，但由于没有使用 ^</del>禁止正则表达式匹配，所以匹配的是带有正则表达式的最长匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c4e6b72-6e3a-4789-beec-aad6474d0f44.jpg" alt></p><p>访问/Test1/Test2/ ，因为正则没有匹配上，所以使用最长字符串匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/937460a9-1add-4e3d-a739-ef415bb617c0.jpg" alt></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 location的匹配规则，对于URI的请求，到底是由哪一个location下的指令去执行，就十分了然了，同时也知道了当location数量非常多时，怎样通过 <strong>禁止正则表达式匹配</strong>、<strong>使用=精确匹配</strong>等等方式对非常频繁发起的请求来减少它们做location匹配的次数。</p><h2 id="preaccess阶段"><a href="#preaccess阶段" class="headerlink" title="preaccess阶段"></a>preaccess阶段</h2><h3 id="对连接做限制的limit-conn模块"><a href="#对连接做限制的limit-conn模块" class="headerlink" title="对连接做限制的limit_conn模块"></a>对连接做限制的limit_conn模块</h3><p><strong>问题：如何限制每个客户端的并发连接数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/c2bbb690-8f6f-4a6b-a5e9-ef85c44d74b9.jpg" alt></p><h4 id="limit-conn指令"><a href="#limit-conn指令" class="headerlink" title="limit_conn指令"></a>limit_conn指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7fcdbe6a-773f-4720-9636-475b1fa1f457.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0126152a-bb75-4b70-bac7-0030bdb75d55.jpg" alt></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;3r&#x2F;s</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        limit_rate 50;</span><br><span class="line">        limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;1 nodelay;</span><br><span class="line">        #limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/636ff2ff-a1c4-408a-9b79-9dfa88be33f8.jpg" alt></p><p>上述配置文件定义了一个 <strong>10M</strong> 的共享内存，共享内存中使用 binary_remote_addr，这是一个二进制格式的IP地址（IPV4协议下只有4个字节,效率较高）。</p><p>定义了向用户返回的错误码是500（默认是503）</p><p>将 log_level调成了 warn（默认是error）</p><p>limit_conn_addr 1; 即限制了并发连接数为1（只为演示效果，当有两个客户端同时访问时，就会返回500）</p><p>limit_rate 50; 为了更好的演示，又加上了该配置项，即限制向用户返回的速度，每秒钟只返回50个字节，比较容易出现限制并发连接的场景。</p><p>在一个shell中访问，回复速度非常慢</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b53e8635-ea6e-477f-baf7-d7e9a41130ae.jpg" alt></p><p>在另一个shell中也访问，会回复500错误码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8032adb7-ee5f-4213-b7e5-6d37ba578735.jpg" alt></p><p>在 myerror.log中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d9f8cbfc-d250-42a1-b59a-542a21ee2700.jpg" alt></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>当Nginx作为资源服务器为用户提供服务时，限制用户能够同时发起的并发连接数，是一个很常用的功能。Nginx默认编辑进去的 ngx_http_limit_conn_module模块提供了这样的功能。<strong>设计好Key是关键</strong>。</p><h3 id="对请求做限制的limit-req模块"><a href="#对请求做限制的limit-req模块" class="headerlink" title="对请求做限制的limit_req模块"></a>对请求做限制的limit_req模块</h3><p><strong>问题：如何限制每个客户端的每秒处理请求数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f310270f-af32-456f-a8bc-10f9d88052ea.jpg" alt></p><h4 id="leaky-bucket算法"><a href="#leaky-bucket算法" class="headerlink" title="leaky bucket算法"></a>leaky bucket算法</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a55435d0-d50f-48e1-92e6-48e569f84fe6.jpg" alt></p><p>对于突发性流量，前两秒12Mbps，总共24M，2-7s没有流量，7-10为2Mbps，共6M，前10秒总共30M。</p><p>使用了该算法后，可以限制为3Mbps,前10秒总共 30M。</p><p>可以比喻为一个水龙头，向盆里流动的是突发性流量，而盆向下流的则是恒速流量。</p><ul><li><p><strong>当盆burst满的时候，立刻向用户返回503错误码</strong>。</p></li><li><p><strong>当盆burst没有满的时候，但向下速率已经达到最大化的时，水滴就会存在盆里，即用户的响应会变慢，请求并不会被拒绝</strong>。</p></li></ul><h4 id="limit-req指令"><a href="#limit-req指令" class="headerlink" title="limit_req指令"></a>limit_req指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/39b5d9e6-fc0a-486b-9ba3-417d57dc2ae0.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bafe56ec-ff77-4371-b9de-7bf7dbb7a0f8.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab666467-5387-42cf-b454-0b3ddf8c26b4.jpg" alt></p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;2r&#x2F;m</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        #limit_rate 50;</span><br><span class="line">        #limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;3 nodelay;</span><br><span class="line">        limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有加 burst 与 nodelay时，结果会是怎样？同时注释掉 limit_rate 这样可以快速返回内容。<strong>每分钟两条</strong></p><p><strong>curl limit.haoran.tech</strong> ，看到结果</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7db81b53-d952-41df-aa52-23651ef9a701.jpg" alt></p><p>再次访问</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/034093e0-7e6e-4aa0-8022-e4d36bbb5818.jpg" alt></p><p>将  burst的注释解开会是什么样的呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f129ccd-e03c-45ef-a3de-27ab1087cea7.jpg" alt></p><p>访问3次都可以看到结果，访问第4次时，会有503错误码。</p><p>现在将限制连接与限制请求同时打开。看下效果。返回500（限制连接生效），返回503（限制请求生效），</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/80d4681d-1e8d-410e-9491-4dc792b7e05d.jpg" alt></p><p>每分钟只能处理2个请求，所以第3次访问时，<strong>limit_req生效</strong>，但其实 第二次访问时 <strong>limit_conn</strong>同样生效了。返回的还是503，而不是500，这是因为 limit_req模块是在limit_conn模块之前生效的，limit_req已经向用户拒绝了，limit_conn就没有机会得到执行了。<br><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1eba94b3-b698-40f9-9d67-3243174af439.jpg" alt></p><h2 id="access阶段"><a href="#access阶段" class="headerlink" title="access阶段"></a>access阶段</h2><h3 id="对IP做限制的-access-模块"><a href="#对IP做限制的-access-模块" class="headerlink" title="对IP做限制的 access 模块"></a>对IP做限制的 access 模块</h3><p><strong>access模块</strong> 可以控制那些IP可以访问某些URL，那些不可以访问。</p><p><strong>问题：如何限制那些IP地址的访问权限？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/832769b6-fcc5-4fa5-9da7-4c17ec221d47.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/066c8482-4e64-46a6-b6a6-4ff35b0056e2.jpg" alt></p><h3 id="对用户名-密码做限制的-auth-basic-模块"><a href="#对用户名-密码做限制的-auth-basic-模块" class="headerlink" title="对用户名-密码做限制的 auth_ basic 模块"></a>对用户名-密码做限制的 auth_ basic 模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/609f0ee1-f934-4a18-be91-114657084c86.jpg" alt></p><p><strong>auth_basic模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/98ca71bc-ed6b-4332-910d-a6d02f593c64.jpg" alt></p><p><strong>生成密码文件</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d1d3a69a-f867-448b-a035-8a86dfc57870.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br><span class="line"></span><br><span class="line">htpasswd -c file -b user pass</span><br><span class="line"></span><br><span class="line">-c 指定生成的文件，-b 指定用户名密码</span><br><span class="line"></span><br><span class="line">假设现在已经生成了 auth.pass文件</span><br><span class="line"></span><br><span class="line">vim auth.pass</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4f016d91-a721-4522-a1fb-80cd531197ce.jpg" alt></p><p>上述密码文件中的密码做了一个简单的base64编码。</p><p>在 nginx.conf配置文件中指定有关配置</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/895f11ef-d463-4cd3-ac87-55a76b65174e.jpg" alt></p><p>浏览器访问 access.taohui.tech；会发现需要输入用户名-密码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d41f3894-95a1-4f95-b711-327495299542.jpg" alt></p><p>当我们提供一个非常简单的页面时，如go-access，想对他做一个安全保护，auth_basic是一个不错的做法。</p><h3 id="使用第三方做权限控制的-auth-request-模块"><a href="#使用第三方做权限控制的-auth-request-模块" class="headerlink" title="使用第三方做权限控制的 auth_request 模块"></a>使用第三方做权限控制的 auth_request 模块</h3><p>在生产环境中，往往会有一个动态Web服务器或者相应的一些应用服务器，它们提供更复杂的用户名-密码权限验证，这个时候可以通过访问Nginx的资源池先将这个请求传递给应用服务器上，根据应用服务器返回的结果再判断这个请求资源能不能继续执行，那么Nginx的access阶段有一个模块为 auth_request模块，他就可以完成这样的功能。</p><p><strong>统一的用户权限验证系统</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7af33897-413a-4e91-ace2-ec13a7099185.jpg" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6a69a3f-c156-4852-9303-e6f37b8e8210.jpg" alt></p><p>当访问 / 时 通过 auth_request 生成子请求,会去访问这个URL test_auth，而这个URL通过 proxy_pass反向代理到本机的另一个Nginx服务器（监听端口为8090），他提供的URL为 auth_upstream。成功后，因为有一个默认的配置 root html/(即使注释了也会正常显示html下的 index页面)，如果被拒绝，就会返回 8090 这台机器的错误码。</p><p>8090这台nginx的内容如下（成功的时候）：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7ec46de9-417b-4c2e-9538-92900bc23395.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/cacc2da6-43af-49a1-a0c2-5c875a1c29eb.jpg" alt></p><p>将上游的返回值改为403：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b3662788-1074-492f-9d3c-5c370f409aec.jpg" alt></p><p>禁用缓存后，再次访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e887c996-2eb0-47f2-a0e6-d7c049bc7c2b.jpg" alt></p><h3 id="access阶段的-satisfy-指令"><a href="#access阶段的-satisfy-指令" class="headerlink" title="access阶段的 satisfy 指令"></a>access阶段的 satisfy 指令</h3><p>前面提到了 access 阶段的3个模块，那这三个模块任意一个模块拒绝了用户的请求，用户请求就无法执行了呢？其实并不是这样的，那他们是否严格的按照顺序往下执行呢？同样不是这样的。</p><p>因为 Nginx的HTTP框架中提供了一个 <strong>satisfy指令</strong>，允许我们改变模块的执行顺序。</p><p><strong>限制所有access阶段模块的 satisfy指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9e0e322a-b59c-477b-8787-131df574d6ca.jpg" alt></p><p>即一个 access模块，有三种处理结果：</p><ul><li><p><strong>忽略，即没有任何配置，直接跳到下一个access模块</strong></p></li><li><p><strong>放行（allow），先判断satisfy开关，如果配置为 all（表示必须所有的access模块都同意放行这个请求才可以通过），所以继续执行下一个access模块；如果配置为 any（即不用再去考虑后续的access模块是否同意，直接跳到下一个 post_access阶段执行）</strong></p></li><li><p><strong>拒绝（deny），同样判断satisfy开关，如果配置为 all（直接拒绝请求），不再向下执行。如果是 any，虽然当前这个模块拒绝了，但也会后续模块会同意放行，所以继续执行下一个access模块</strong></p></li></ul><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/11fb6c5d-da39-4d6e-afeb-47fc345a904e.jpg" alt></p><ul><li><p><strong>1：肯定不会生效，因为return指令的生效期是 server_rewrite 与 rewrite阶段，二者都领先于 access，access是没有机会得到执行的。</strong></p></li><li><p><strong>2：肯定有影响，即如果 access阶段已经拒绝了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li><li><p><strong>3：可以访问到，配置了 satisfy any</strong></p></li><li><p><strong>4：提到之前，仍然可以访问，因为模块间的顺序ok就行了，配置指令间的顺序无关紧要</strong></p></li><li><p><strong>5：将 deny all 改为 allow all，没有机会输入，因为配置的 satisfy all，任意的模块同意就可以了，allow all是 access模块的，它先于auth_basic模块执行的，它已经同意了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li></ul><h2 id="precontent阶段"><a href="#precontent阶段" class="headerlink" title="precontent阶段"></a>precontent阶段</h2><h3 id="按序访问资源的-try-files-模块"><a href="#按序访问资源的-try-files-模块" class="headerlink" title="按序访问资源的 try_files 模块"></a>按序访问资源的 try_files 模块</h3><p><strong>对于反向代理的场景十分有用，Nginx先尝试去获取磁盘上的文件内容，如果没有再反向代理到上游服务。</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/728821e7-c28a-470a-8c79-2cc85b353fd3.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim tryfiles.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3eb1c77a-1125-49b9-ac41-bb1c00ee2057.jpg" alt></p><p>访问 /first，如果系统在维护的话可能会有一个 /system/maintenance.html文件，如果这个文件找不到的话，我们就去找 uri（即 html下first有没有），同样没有，$uri/index.html、$uri.html同样都没有，这时使用了 @lasturl 符号 去访问 另一个 location @lasturl。在这个location中返回 200的状态码。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/93bb2a64-19b6-4c1c-9e5a-ae4127d27779.jpg" alt></p><p>访问 /second，一样与一个去尝试，所有文件都找不到时，返回404.</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e14e4c54-713c-4f5d-afe3-826434d572c8.jpg" alt></p><h3 id="实时拷贝流量-mirror-模块"><a href="#实时拷贝流量-mirror-模块" class="headerlink" title="实时拷贝流量 mirror 模块"></a>实时拷贝流量 mirror 模块</h3><p>mirror模块可以帮我们创造一份镜像流量，如生产环境中处理一些请求，这些请求可能需要把他们同步的拷贝一份到我的测试、开发环境中做处理。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8611ad8c-6413-4e49-8c81-14d5dcc9d7bb.jpg" alt></p><p>即当请求到了Nginx后，可以生成一个子请求，这个子请求可以通过反向代理去访问我们的其他环境（测试环境等），对其他环境返回值不作处理。</p><p><strong>举例</strong></p><p>需要一个上游服务器</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8262d188-51e4-42cf-9020-9d191d34a19a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim mirror.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/dfe18329-89d0-4458-b28a-2415d5d86bde.jpg" alt></p><p>收到一个请求时，会拷贝一份流量到 mirror 中去，/mirror收到后，会指定 internal（内部），将其方向代理到本机的10020端口上去。</p><p>访问8001</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5602b6ce-74a5-4899-895c-8a0996c08303.jpg" alt></p><p>实时查看日志</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd01d90d-8679-434b-90d7-76bcdd1da763.jpg" alt></p><p>再去看上游Nginx(10020)的日志，是否收到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8fb49605-4b51-43a3-93b5-482835b2f6f5.jpg" alt></p><h2 id="content阶段"><a href="#content阶段" class="headerlink" title="content阶段"></a>content阶段</h2><h3 id="static模块-root-和-alias-指令"><a href="#static模块-root-和-alias-指令" class="headerlink" title="static模块 root 和 alias 指令"></a>static模块 root 和 alias 指令</h3><p>content阶段中 static模块  默认是在Nginx框架中的，是没有办法做移除的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b281027a-aae7-4dfe-88bc-ac86be3b0a78.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/85228787-c832-42d3-abcc-d1c9a88e6bf8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8ecfd588-3241-470e-87bb-05787d28f3c5.jpg" alt></p><p><font color="red">直接访问 root/，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0c140f6a-cbcd-47c6-9d3b-709a76fee58e.jpg" alt></p><p>查看日志，在 html后又加上了刚刚 location中的root，因为有个 反斜杠，所有有添加了 index.html，这个文件其实是不存在的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b653fc8e-67c4-41b4-8a47-8ab73f3bb163.jpg" alt></p><p><font color="red">直接访问 root/1.txt，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a47c5ad2-58ce-400b-9310-0c10ef8caff9.jpg" alt></p><p>查看日志，它其实是在 html/first/1.txt 后面又添加了 /root/1.txt，即 html/first/1.txt/root/1.txt</p><p><font color="red">直接访问 curl static.taohui.tech/alias/   ,他匹配到了 location /alias  会去访问 html下的index.html，所以应该访问首页</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e81ffef0-5e33-44d9-b9fc-87cdc23a59f0.jpg" alt></p><p><font color="red">直接访问 curl static.taohui.tech/alias/1.txt  ，不会添加完整路径，文件存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c61806a-68d3-412a-bdae-c38891d6fe4e.jpg" alt></p><h3 id="static模块-3个变量"><a href="#static模块-3个变量" class="headerlink" title="static模块 3个变量"></a>static模块 3个变量</h3><p><strong>生成待访问文件的三个相关变量</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363559193.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ef33b509-ef3c-4791-9a89-de3d330cd1f9.jpg" alt></p><p>realpath 实际上是一个软链接，他指向了 first目录下，这个目录下有一个1.txt文件</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2fc334d9-4140-4ae2-b475-c8c70453c88e.jpg" alt></p><p>在下图中可看到，返回3个路径，第一个是完整路径，后两个都是1.txt所在的目录，只不过 document_root 没有做软链接的替换，还是根据配置项拼接出来的，而 realpath_root 已经将 realpath 替换为真实 first目录。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363849390.PNG" alt></p><h3 id="static模块提供的其他功能"><a href="#static模块提供的其他功能" class="headerlink" title="static模块提供的其他功能"></a>static模块提供的其他功能</h3><h4 id="静态文件返回时的-content-type"><a href="#静态文件返回时的-content-type" class="headerlink" title="静态文件返回时的 content-type"></a>静态文件返回时的 content-type</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fcc5c202-7370-4c46-9781-5c3013c3ac45.jpg" alt></p><p>当我们去读磁盘上的文件时，根据文件的扩展名做一次映射。<strong>types指令</strong>就是做这个事情的，为了加速，需要将 content-type  与 扩展名 做一次映射放入 Hash 表中。</p><p><strong>default_type</strong>是在没有文件名时用来告诉用户这个content-type究竟怎样解析</p><h4 id="未找到文件时的错误日志"><a href="#未找到文件时的错误日志" class="headerlink" title="未找到文件时的错误日志"></a>未找到文件时的错误日志</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/73be5c25-2a92-49df-9fa6-4e5a2f18d0e1.jpg" alt></p><h3 id="static模块对url不以斜杠结尾却访问目录的做法"><a href="#static模块对url不以斜杠结尾却访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾却访问目录的做法"></a>static模块对url不以斜杠结尾却访问目录的做法</h3><p>很多人使用 static 模块的  root/alias 指令将Nginx当做静态资源服务器时，很可能会发现，当我们去访问一个目录，但是在url结尾没有加上斜杠时，实际上Nginx会返回一个301的重定向，那么对于重定向中的内容，Nginx提供了3种不同的指令，去控制location这样的行为。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d79721a2-30b5-45d1-bc5f-5a23376cb8f0.jpg" alt></p><p><strong>重定向跳转的域名</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5be98a60-9879-424b-af00-20da33bd9ac6.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim dirredirect.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0f59cecd-1d65-4878-a2fc-ed552e9a8ced.jpg" alt></p><p>在 server_name 中配置了两个域名，第一个是主域名。将 absolute_redireect off 开启（默认是on），root指向 html/ 下有一个 first文件夹。</p><p>先来访问 first文件夹，没有加反斜杠，此时应该获得一个301重定向</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f469702-82cb-4d21-9e94-87b8d4cbbbb2.jpg" alt></p><p>将 absolute_redirect off 注释掉。再次访问，发现 在 <strong>Location</strong>中将域名都添加了进去。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f4c52dee-e694-456e-a032-3adf3c6cb7cc.jpg" alt></p><p>如果头部有一个 <strong>Host: aaa</strong>，那么就会将它替换掉掉Location中的localhost。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3be924e8-441e-49aa-b014-0639d6707a30.jpg" alt></p><p>将 dirredirect.conf配置文件中的 <strong>server_name_in_redirect on</strong>开启后，再去访问，会发现Location中以主域名来绑定。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ea6acb6d-f387-4f79-b80e-04aaa22ace11.jpg" alt></p><h3 id="index-与-autoindex模块"><a href="#index-与-autoindex模块" class="headerlink" title="index 与 autoindex模块"></a>index 与 autoindex模块</h3><p>在前面已经演示过，autoindex会以目录形式显示服务器上的资源。但有时在搭建的时候，会没有看到目录结构，看到的是一个文件的内容，这是因为** index 模块** 先于 <strong>autoindex 模块</strong>产生作用。</p><h4 id="对访问-时的处理：content阶段的index模块"><a href="#对访问-时的处理：content阶段的index模块" class="headerlink" title="对访问/时的处理：content阶段的index模块"></a>对访问/时的处理：content阶段的index模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/03f6d0ed-8176-4fa7-9d84-94e0b6ba03d1.jpg" alt></p><h4 id="显示目录内容：content阶段的autoindex模块"><a href="#显示目录内容：content阶段的autoindex模块" class="headerlink" title="显示目录内容：content阶段的autoindex模块"></a>显示目录内容：content阶段的autoindex模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab7fdd2b-3bc0-411f-a706-72de6fa40001.jpg" alt></p><p><strong>autoindex 模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4a0c0058-8c44-4e61-bf74-a4a1031a99fe.jpg" alt></p><p>autoindex_exact_size on|off ：当默认打开的格式（向用户返回的是html格式时才有效）是显式相对的路径。<strong>绝对路径：</strong>以<strong>字节</strong>来显示。<strong>相对路径：</strong>以<strong>K、M</strong>显示。</p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim autoindex.conf</span><br></pre></td></tr></table></figure><p>监听了1个8080端口，以server_name指定的域名进行访问，默认没有修改index a.html（注释掉了）。当访问 / 时，会去找 index.html，在 alias指定的html下是有这个文件。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bf6a5afc-224c-4ace-bb0d-9980a58ef6d6.jpg" alt></p><p>去访问 autoindex.taohui.tech:8080，得到的是index.html内容</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/35ca0dd5-1174-4d4c-8ab4-f29a4e95c157.jpg" alt></p><p>因为 index 模块是没有办法从  Nginx中移除的，所以可以去修改 index指向的文件，将它指向一个不存在的 a.html文件（即将 index a.html 注释解开）</p><p>再次访问autoindex.taohui.tech:8080，是JSON格式返回这个目录</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d928ea5f-1314-45f7-8c2b-2bfa98a9379b.jpg" alt></p><p>同理，将 autoindex_format json 改为 html</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2f0517d-faa7-47bd-9d91-aaa32607b218.jpg" alt></p><p>reload后，再次访问，因为是以相对路径，所以可以显示到K。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a18c6759-3aae-41de-8cdf-f7b93d5e3473.jpg" alt></p><h3 id="content阶段中有Alibaba提供的concat模块"><a href="#content阶段中有Alibaba提供的concat模块" class="headerlink" title="content阶段中有Alibaba提供的concat模块"></a>content阶段中有Alibaba提供的concat模块</h3><p>concat模块可在一次请求中返回多个文件的内容，这对在Web页面中访问多个小文件来提升性能十分有用。（需要下载并且在 .configure 时编译进Nginx）</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/68e622ae-6d7a-42c3-9890-3cb801bc37d8.jpg" alt></p><p><strong>concat模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9d3beaf0-7b29-4534-81e5-7649b057033b.jpg" alt></p><ul><li><p><strong>concat 开启或者关闭</strong></p></li><li><p><strong>concat_delimiter：String，如果服务器返回多个文件，通过指定的String分隔符进行分割</strong></p></li><li><p><strong>concat_types: MIME types，对那些文件的类型做合并</strong></p></li><li><p><strong>concat_unique：对某一种文件类型进行合并，还是对多个文件类型进行合并</strong></p></li><li><p><strong>concat_ignore_file_error：如果某个文件出现错误，是忽略它，返回其他文件的内容</strong></p></li><li><p><strong>concat_max_files：最多合并多少个文件，默认为10</strong></p></li></ul><p><strong>看一下淘宝网的做法</strong></p><p>可以看到他的大部分请求，都使用了 <strong>??</strong>，后面添加了多个文件，后面用逗号隔开。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02e8a5f0-565f-4068-92ac-01046a0008ab.jpg" alt></p><p>在响应中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/14b5a5c5-325f-42ae-8156-591e00c25231.png" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim concat.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d44649-a349-4292-b964-44f983a5e1b3.jpg" alt></p><p>在 concat.conf配置文件中，首先打开了这个功能，最多20个文件，类型是 text/plain，以 <strong>三个分号</strong>来分隔多个文件。</p><p>现在来访问，他回去 html/concat 路径下找 1.txt 与 2.txt，这两个文件是存在的，内容如下：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e9612a1d-ca16-462c-a9e5-eaba187d31d5.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d3025d36-8921-429f-81f4-f5eefb3dd611.jpg" alt></p><h2 id="Log阶段（记录请求访问日志的log模块）"><a href="#Log阶段（记录请求访问日志的log模块）" class="headerlink" title="Log阶段（记录请求访问日志的log模块）"></a>Log阶段（记录请求访问日志的log模块）</h2><h3 id="http-log模块"><a href="#http-log模块" class="headerlink" title="http_log模块"></a>http_log模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a7c1944c-6b8c-4a7e-9155-dd3a886d2584.jpg" alt></p><h4 id="access-日志格式"><a href="#access-日志格式" class="headerlink" title="access 日志格式"></a>access 日志格式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2b74ec9f-c476-4e23-8162-da5fe03379b0.jpg" alt></p><h4 id="配置日志文件路径"><a href="#配置日志文件路径" class="headerlink" title="配置日志文件路径"></a>配置日志文件路径</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2806838-8e42-4e9f-992b-b9357b7a2820.jpg" alt></p><h4 id="对日志文件名包含变量时的优化"><a href="#对日志文件名包含变量时的优化" class="headerlink" title="对日志文件名包含变量时的优化"></a>对日志文件名包含变量时的优化</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589375413620.PNG" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-如何找到处理请求的Server指令块</title>
      <link href="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/"/>
      <url>/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个<strong>server块</strong>处理，因此，要先介绍一个配置指令 <strong>server_name</strong>，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。</p><a id="more"></a><h2 id="Server-name-指令"><a href="#Server-name-指令" class="headerlink" title="Server_name 指令"></a>Server_name 指令</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/df26bdab-3bfd-42ee-86f7-638175ac5b63.jpg" alt></p><p><strong>简单演示：</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/afcba697-6524-4d0a-b0de-26c81a9e6f51.jpg" alt><br><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/9fb82a75-fe58-4cbb-b484-6e81b8ce6784.png" alt></p><p>主域名当前不会生效，curl 域名 -I  （-I 显示头部），访问second开头的域名，返回second开头的域名</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/28d97c9d-1dff-48c5-8da5-7ffe4c7bce25.jpg" alt></p><p>如果先返回是是主域名，就要将 off 改为 on，主域名开始生效。访问second开始的域名，发挥primary开头的主域名。</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/b8921fa4-75db-4574-a213-1614397578e8.jpg" alt></p><p><strong>server_name指令其他用法</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/7150b181-f5f1-4210-8132-47aad432be28.jpg" alt></p><h2 id="Server匹配顺序"><a href="#Server匹配顺序" class="headerlink" title="Server匹配顺序"></a>Server匹配顺序</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/eb693887-6efd-474d-be89-0322bb142a96.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了当Nginx框架取到了Host头部值时，就可以用这个值与我们<strong>Server</strong>块下的<strong>Server_name</strong>指令进行匹配，然后利用其中定义的规则进行解析处理。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-Nginx中的正则表达式</title>
      <link href="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到<strong>正则表达式</strong>，它可以让我们匹配到的功能更为强大。</p><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/0e4b9acc-6d13-4199-8470-93df39ce4d0b.jpg" alt></p><p><strong>举例：</strong><br><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7fb63cc5-8759-486f-8d6d-c533584d10e1.jpg" alt></p><p><strong>工具：pcretest</strong></p><p>输入模式，输入待校验数据，查看匹配结果，可验证正则书写是否正确。</p><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7b9755d2-be5c-4b01-b2c2-1c91929f9831.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-处理HTTP请求头部流程</title>
      <link href="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 <strong>HTTP Line</strong>，如方法、URL等，再去接收到所有的<strong>Header</strong>，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。</p><a id="more"></a><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/6db1c81d-6992-4757-bdda-4bd8ea201a0c.jpg" alt></p><p>大致分为3个层次：<strong>操作系统内核</strong>、<strong>事件模块</strong>、<strong>HTTP模块</strong>，流程大致如下：</p><ul><li><p><strong>操作系统内核：3次握手，当用户发来SYN时，内核会回复一个SYN+ACK表示已确认，当客户端再发来ACK时，标明连接已成功建立，Nginx有很多Worker进程，都监听了80、443端口，操作系统会依据它的负载均衡算法，选中某一个Worker进程</strong></p></li><li><p><strong>被选中的Worker进程会通过 epoll_wait方法去返回刚刚建立好连接的句柄，拿到句柄后，这其实是一个读事件（读到了一个ACK报文），根据读事件，找到监听的80、443端口，可以调用accept方法，分配连接内存池，默认为 connection_pool_size 512字节</strong></p></li><li><p><strong>所有的HTTP模块开始从事件模块中接入请求，HTTP模块在启动时会定义一个ngx_http_init_connection回调方法，通过 epoll_ctl将读事件加入其中，同时设置超时定时器（client_header_timeout:60s）</strong></p></li><li><p><strong>当用户真的把一个HTTP请求（get、post）发来时，其实是DATA，在TCP层（内核层），会回复一个ACK，同时事件模块的epoll_wait又拿到这个请求，回调方法是 ngx_http_wait_request_handler，需要将内核中的DATA读到Nginx的用户态中，需要分配内存，从连接内存池分配1k(client_header_buffer_size),并不是越大越好，因为只要用户有1个字节发过来，就要为他分配1k大小内存，但是如果用户发来的DATA（URL、Header）超过1K了呢？</strong></p></li></ul><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/301c6d75-7166-4bd4-b44f-9e1e8470fae6.jpg" alt></p><h3 id="接收URI"><a href="#接收URI" class="headerlink" title="接收URI"></a>接收URI</h3><p>刚刚分配完1K后，已经收到了 小于等于1K的请求内容。</p><ul><li><p><strong>分配请求内存池：</strong>处理请求与处理连接不同，处理连接只需要将它收到Nginx内存中就OK了，但处理请求时，去做大量的上下文分析，分析它的HTTP协议、Header，因此要分配一个<strong>请求内存池</strong>，默认 request_pool_size:4k，基本上是<strong>connection_pool_size</strong>的8倍，因为请求的上下文涉及到业务，通常4K是一个比价合适的大小（如果分配过小，请求内存池需要不断地扩充，分配内存的次数变多时，肯定会影响性能），要不要改这个4K要根据业务来决定。</p></li><li><p><strong>状态机解析请求行：</strong>解析请求的行， /r /n之前的 方法名、URL、协议。解析过程中可能会发现URL特别大，超过了刚刚分配的1K内存。</p></li><li><p><strong>分配大内存：</strong>主要是来解决大URL的问题，分多大的呢？<strong>large_client_header_buffers:4 8k</strong>，分配的并不是32K 这么大的内存，而是先分配一个8K的内存，将刚刚1K内存中内容拷贝到这个8K内存中来，还剩7K的内存，用剩下的7K再去接收URL，然后用状态机去继续解析URL，如果发现7K都没有解析完，再次分配第二个8K，即一共分配了16K，最多分配32K。</p></li><li><p><strong>解析完成时，就可以标识URI</strong>，类似于超链接，Nginx用指针指向这个URI。</p></li></ul><h3 id="接收Header"><a href="#接收Header" class="headerlink" title="接收Header"></a>接收Header</h3><p>HTTP请求中的Header可能会非常长，如有Cookie、Host等字段。</p><ul><li><p><strong>状态机解析Header</strong>,Header非常有可能超过1K,又需要分配大内存。</p></li><li><p><strong>分配大内存</strong>与左边接收URI是共用的，如左边已用了2个8K，此处最多只能在分配2个8k。</p></li><li><p><strong>标识header</strong></p></li><li><p><strong>移除超时定时器</strong>，是在收到完整的Header后，才可移除。</p></li><li><p><strong>开始11个阶段的HTTP请求处理</strong></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上都是Nginx框架处理的，11个流程是HTTP模块处理的。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-Nginx中Listen指令用法</title>
      <link href="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
      <url>/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一个请求进入Nginx开始处理之前，都首先需要<strong>监听端口</strong>，以使得Nginx与客户端建立起<strong>TCP连接</strong>，监听端口的指令为<strong>listen</strong>指令，它是放在<strong>server</strong>配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。</p><a id="more"></a><h2 id="Listen-指令"><a href="#Listen-指令" class="headerlink" title="Listen 指令"></a>Listen 指令</h2><p><img src="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/729d148b-a54e-49ff-a745-fd79853e3e8f.jpg" alt></p><ul><li><p><strong>lisent address[:port]</strong></p></li><li><p><strong>listen port</strong></p></li><li><p><strong>listen unix:path 只用于本机通讯</strong></p></li><li><p><strong>listen 127.0.0.1; 此处默认使用 80端口</strong></p></li></ul><p>详细的Listen用法在后续文章实践时再提及。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-Nginx冲突的配置指令以谁为准</title>
      <link href="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/"/>
      <url>/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正式开始学习<strong>HTTP模块</strong>之前，先要谈一谈指令的<strong>嵌套结构</strong>，每一个HTTP模块出现的指令，可能出现的<strong>Context(上下文)</strong>，既可以在<strong>location</strong>中，也可以在<strong>server</strong>中，或是<strong>http</strong>中，当一个指令出现在多个<strong>配置块</strong>中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的<strong>第三方模块</strong>可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？</p><a id="more"></a><h2 id="典型的配置块嵌套"><a href="#典型的配置块嵌套" class="headerlink" title="典型的配置块嵌套"></a>典型的配置块嵌套</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/2d6e5c41-6a8b-4259-bf26-934c752a9249.jpg" alt></p><p>http–server–location 是<strong>HTTP框架来定义</strong>，处理一个请求时，先按照请求中的<strong>域名：如 host</strong>找到对应的<strong>server</strong>,再根据<strong>URL</strong>找到对应的<strong>location</strong>，根据location下具体的指令来处理请求。</p><h2 id="指令的-Context"><a href="#指令的-Context" class="headerlink" title="指令的 Context"></a>指令的 Context</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1b48fc0d-3015-4f35-b87c-6d2eb15f8be8.jpg" alt></p><ul><li><strong>log_format</strong>出现的上下文Context是在<strong>http</strong>中的，如果把它放在<strong>server</strong>、<strong>location</strong>时，启动nginx检查配置文件语法时，会失败，无法启动。</li><li><strong>access_log</strong> 同理。</li></ul><h2 id="指令的合并"><a href="#指令的合并" class="headerlink" title="指令的合并"></a>指令的合并</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/7edbb2e6-b36d-4b34-959d-7db4f481fd9b.jpg" alt></p><h2 id="存储值的指令继承规则：向上覆盖"><a href="#存储值的指令继承规则：向上覆盖" class="headerlink" title="存储值的指令继承规则：向上覆盖"></a>存储值的指令继承规则：向上覆盖</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/82868d03-da97-48c9-af03-557cf3a81ead.jpg" alt></p><ul><li><p><strong>listen指令只能出现在server上下文中</strong></p></li><li><p><strong>alias指令虽然可以出现在 http、server、location中，但是在上述图示中只在location中出现</strong></p></li><li><p><strong>server下的root /home/geek/nginx/html;而其他location中没有定义root，同样可以使用父配置块定义的root，如最下方的root。这是一个通用配置规则，只要该指令允许在子配置块中生效</strong></p></li><li><p><strong>在 location /test 下重新定义了一个 root /home/geek/nginx/test; 或者 access_log 也重新定义了，此时直接使用子配置覆盖父配置</strong></p></li></ul><h2 id="HTTP模块合并配置的实现"><a href="#HTTP模块合并配置的实现" class="headerlink" title="HTTP模块合并配置的实现"></a>HTTP模块合并配置的实现</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/d052eae4-743b-4529-90ba-69e184b87f48.jpg" alt></p><p>举一个例子 <strong>ngx_http_referer_module</strong>防盗链模块，它们都有一个结构体是 <strong>ngx_module_t</strong>，相当于说明书。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/5c0f1a1b-ac60-4725-92e0-cc4f19839d32.jpg" alt></p><p>该模块提供的配置指令，都在 *<em>ngx_command_t &nbsp; &nbsp;ngx_http_referer_commands[] *</em>中提及。<br><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/658fa363-3808-499a-b04d-f78aa16ec8e1.jpg" alt></p><p>如 <strong>valid|referers</strong> 指令可以出现在 server、location下，可以携带1MORE（1个或多个）参数。</p><p>所有指令解析完要做合并，可以看 <strong>ngx_http_module_t</strong> 结构体。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1afde405-4fb7-4e72-963f-45ce63bfe249.jpg" alt></p><p>它定义了 8个回调方法，重点看 <strong>ngx_http_referer_merge_conf</strong>，以上指令都是在location下生效的，所以需要 http、server向location合并。</p><p><strong>合并规则</strong></p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/aa4e4b16-319b-434f-9a0b-dc098312b979.jpg" alt></p><p>parent：父指令<br>child： 子指令</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了HTTP模块指令合并规则，为下面正式学习HTTP每一个模块提供了技术帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-Nginx动态模块</title>
      <link href="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>动态模块</strong>可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。</p><h2 id="动态模块-减少编译环节"><a href="#动态模块-减少编译环节" class="headerlink" title="动态模块-减少编译环节"></a>动态模块-减少编译环节</h2><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg" alt></p><a id="more"></a><p>左上图 是没有使用动态模块的编译方式及结果。</p><p>左下图 是使用了动态模块的编译及结果（生成了<strong>指定模块的动态库</strong>）。</p><p><font color="red">动态库</font>与<font color="red">静态库</font>区别：静态库会将所有的源代码编译进最终的二进制可执行文件中；动态库在Nginx二进制可执行文件中只保留了<strong>调用它的地址</strong>，在需要用到动态库的功能时，由<strong>Nginx的二进制可执行文件（Nginx Executable）</strong>去调用这个动态库，再去完成对应的功能。好处：当我们仅仅需要修改某一个模块、升级某个模块的功能时（特别是当Nginx编译了大量的第三方模块），重新编译这个动态库，而不用替换二进制可执行文件，编译出新的动态库后，只需要替换出旧的动态库，让 Nginx reload即可使用新的模块功能。</p><p><strong>具体步骤：上右图6步骤</strong></p><p>工作流程：</p><ul><li><p><strong>Configure加入动态模块</strong>：只有<strong>部分模块</strong>可以以动态模块的身份编译</p></li><li><p><strong>执行make，编译出 binary</strong></p></li><li><p><strong>启动时会去读 ngx_modules[] 数组，在模块数组中会发现使用了某个动态模块</strong></p></li><li><p><strong>在nginx.conf中需要加入一个配置项 load_modules，这个配置项指明了这个动态模块所在的路径</strong></p></li><li><p><strong>接下来就可以在Nginx进程中打开动态库并上面的模块加入模块数组中</strong>。</p></li><li><p><strong>基于模块数组再进行初始化过程</strong>。</p></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>查看可以增加哪些动态模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br><span class="line"></span><br><span class="line">后面带有 dynamic 关键字的即为可以动态模块身份编译的</span><br><span class="line">--with-xx-xx-module&#x3D;dynamic</span><br></pre></td></tr></table></figure><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/13afd584-3542-46c9-ad01-e852d8644ff3.png" alt></p><p>以<strong>–with-http-image_filter_module=dynamic</strong> 为例来进行演示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">如果出现 下列信息</span><br><span class="line">.&#x2F;configure: error: the HTTP image filter module requires the GD library.</span><br><span class="line">You can either do not enable the module or install the libraries.</span><br><span class="line"></span><br><span class="line">按照下面这个命令安装依赖库</span><br><span class="line">yum install gd-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次运行编译</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们打开了 8080端口，把一些文件放在了test文件下</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/03066fd1-e17b-4cda-b8fe-90713600cc0d.png" alt></p><p>在test文件夹下，我们存放了一张图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/1786e7f3-3033-4e31-9792-d402fec8b880.png" alt></p><p>用浏览器访问该图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e63ab0bf-c704-4dc9-bc3a-583f3f3f7126.jpg" alt></p><p><strong>而上述动态模块的功能则是可以实时的把图片压缩成更小的图片</strong></p><p>安装好的目录中多了一个 <strong>modules</strong>目录，在这个目录中多出了一个动态库，Linux中所有的动态库是以 .so结尾，静态库是以 .a 结尾的。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/5f9d8e7e-ed30-48db-9bf1-8800ecef0f50.png" alt></p><p>打开nginx配置文件，调用 load_module 这个配置项，将相对路径放在此处。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e1e82aa5-e27d-4576-b1b6-adf007925733.png" alt></p><p>同时将图片放缩</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/328f5eca-3b8c-4fe5-8995-a16cc8f6c49a.png" alt></p><p>图片没有放缩，是因为浏览器缓存了这张图片，按F12，禁用缓存，再次刷新就可以了。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/a836cbf8-ddc3-412e-bc6a-43ef0000240a.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-Nginx容器</title>
      <link href="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。</p><h2 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h2><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg" alt></p><a id="more"></a><h3 id="Nginx哈希表"><a href="#Nginx哈希表" class="headerlink" title="Nginx哈希表"></a>Nginx哈希表</h3><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/deb747db-853d-49bc-98b9-34edffd68808.jpg" alt></p><h4 id="哈希表配置"><a href="#哈希表配置" class="headerlink" title="哈希表配置"></a>哈希表配置</h4><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/42459f32-e90c-4688-a0b9-aad76a907fd1.jpg" alt></p><p>与常见的哈希表不同的是：</p><ul><li><strong>应用场景不同</strong>。用于<strong>静态不变的内容</strong>，即在运行过程中，哈希表通常不会出现插入、删除等操作，Nginx刚启动时就基本确定这个Hash表中一共有多少个元素。因此使用Hash表这种数据结构的模块通常会暴露出 <strong>max_size</strong> 与 <strong>bucket size</strong>。max size仅仅控制了最大的哈希表 bucket的个数，而不是实际上 bucket的个数，它的意义在于限制最大化使用内存。</li></ul><p>如上图所示，所有使用哈希表的模块有一些特点。stream/http中所有的变量使用了哈希表，因为变量在模块编译进去的时候就已经定义清楚了。还有 map、反向代理等。反向代理中需要对在配置文件中定义好的Header做哈希来提升它的访问性能。哈希表在访问的时候是一个O(1)的复杂度。</p><p>哈希表中有一个称之为 <strong>Bucket size</strong>，在这个里面会有一些默认值，这些默认值在Nginx的配置文档中说会使CPU Cache len 对齐到这样一个值。这实际上影响了怎样去配置 Bucket size，现在的主流CPU会有 L1、L2、L3缓存，它在取主存（内存）上的数据时，并不是按照所想像的那样，按照64位、32位去取。现在主流CPU去主存，一次取得的字节数是就是 CPU Cache len 。如现在是 64 字节。</p><p>为什么Hash表要向64字节对齐呢？</p><p>假设每一个Hash表的 Bucket是59字节，如果紧密排列在一起，取第一个Hash表元素，仅需要访问一次，还多取了一个自己。取第二个时，要访问主存两次，包括第一个64字节中的最后一个字节以及第二个单元中的58个字节。为了避免取两次的问题，Nginx在它的代码中自动向上对齐。在配置Bucket size时，要注意两个问题。</p><ul><li><p><strong>1 如果配置的不是CPU Cache Len，如配置了70字节，他就会向上分配，每个元素分配128字节。</strong></p></li><li><p><strong>2 如果有可能，尽量不要超过64字节，以减少CPU访问每个Hash表的次数。</strong></p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>哈希表专注于为<strong>静态不变</strong>的内容服务。</li><li>Hash表的 Bucket size 需要考虑CPU Cache Len 对齐问题。</li></ol><h3 id="Nginx红黑树"><a href="#Nginx红黑树" class="headerlink" title="Nginx红黑树"></a>Nginx红黑树</h3><p>Nginx多个Worker进程间做进程间通讯时，经常在共享内存上使用红黑树来管理对象，实际上，在Nginx内存中也会大量使用红黑树。</p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/fc01b91e-4a3c-42a7-b2e8-37b11db20474.jpg" alt></p><p><strong>特点：n为节点数</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/88f836f9-ea9e-4adf-9bae-fe33c6d0d709.jpg" alt></p><p><strong>红黑树的使用模块</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/9388a073-697f-4253-b903-2d36628116b2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-Worker集成协同工作的关键</title>
      <link href="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/"/>
      <url>/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。</p><h2 id="Nginx进程间通讯方式"><a href="#Nginx进程间通讯方式" class="headerlink" title="Nginx进程间通讯方式"></a>Nginx进程间通讯方式</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg" alt></p><a id="more"></a><ul><li><p><strong>信号</strong>：前文也提及过。</p></li><li><p><strong>共享内存</strong>：数据同步。所谓的共享内存也就是我们打开了一个内存空间，如10M，那么一整块0-10M内存，多个Worker之间可以同时访问它，包括读取、写入等操作。为了使用好这样一块共享内存，就会引出另外两个问题。</p></li></ul><blockquote><p><strong>第一个就是锁</strong>，多个Worker进程同时操作一块内存，一定会出现竞争关系，不得不加锁。早期是基于<strong>信号量</strong>的锁，信号量是Linux中比较久远的一种进程同步方式，会导致进程进入休眠状态，即发生了主动切换。而现在大都使用的是<strong>自旋锁</strong>，当锁的条件没有满足，会一直请求。如：这块内存被Worker1使用，Worker2需要去获取锁时，只要Worker1没有释放锁，Worker2会一直在不停地去请求这把锁。<strong>自旋锁</strong>要求所有的Nginx模块必须快速的使用共享内存，即快速取锁，快速释放锁。一旦出现有的第三方模块不遵守这样的规则，就可能导致死锁。</p></blockquote><blockquote><p>一整块共享内存通常是给许多对象同时使用的，如果在模块中手动的去编写、分配内存给到不同的对象，是非常繁琐的，此时引入了<strong>Slab内存管理器</strong>。</p></blockquote><h2 id="共享内存：跨worker进程通讯"><a href="#共享内存：跨worker进程通讯" class="headerlink" title="共享内存：跨worker进程通讯"></a>共享内存：跨worker进程通讯</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/456d7c90-48ea-4f21-9f96-6563bb043d8d.jpg" alt></p><p><strong>红黑树</strong> ：限速、流控场景。（插入、删除快）。</p><p><strong>单链表</strong>：将共享元素串起来。</p><p><strong>Ngx_http_lua_api</strong>：Openresty核心模块</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/685b875f-0c66-4a51-96b0-b1b4dd0626d0.jpg" alt></p><h2 id="共享内存工具-Slab管理器"><a href="#共享内存工具-Slab管理器" class="headerlink" title="共享内存工具-Slab管理器"></a>共享内存工具-Slab管理器</h2><p>上文谈到Nginx不同的Worker进程间需要共享信息时，只能通过共享内存。共享内存上可以使用链表、红黑树这样的数据结构，但每一个红黑树上有许多节点，每一个节点都需要分配内存去存放。怎样把一整块共享内存切割成小块给红黑树上的每个节点使用呢？</p><h3 id="Slab内存管理"><a href="#Slab内存管理" class="headerlink" title="Slab内存管理"></a>Slab内存管理</h3><p>详见 <strong>408 操作系统、计算机组成原理-内存管理与分配</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/edd2057b-fbb7-4724-a215-48c2d898ed15.jpg" alt></p><p><a href="http://tengine.taobao.org/document/ngx_slab_stat.html" target="_blank" rel="noopener">Tengine-Slab</a></p><p><strong>Tengine上 ngx_sla_stat:统计Slab使用状态</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/28245628-4a49-4dd0-a117-a51e6a8568ba.jpg" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/601995b6-b99a-4324-b88e-14106a22871c.png" alt></p><p>会发现没有Github地址，即没有作为一个独立模块发布出来，所以只能点击<strong>Download</strong>下载整个Tengine项目。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0f3a65a0-3276-4dd7-b396-7ea3c5338bdb.png" alt></p><p>解压后，发现tengine中多出一个modules目录，进去查看</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/eed3a379-a7f8-4379-9982-16f2b6dcc0f5.png" alt></p><p>在最后发现 <strong>ngx_slab_stat</strong>模块。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/79bcae21-d7f4-4314-ae50-33d8b9762854.png" alt></p><p>这是一个标准的第三方模块。.c文件是它的说明书。config帮助他编译进目标nginx中。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>现在回到<strong>Openresty</strong>中，让Openresty编译时将<strong>Tengine的Slab_Stat模块</strong>编译进去，然后使用Openrety下的 <strong>share_dict</strong>去分配共享内存，再用<strong>slab_state</strong>查看共享内存的使用情况。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/262f2390-9a34-4537-bf05-74dad3bb3775.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --add-module&#x3D;..&#x2F;tengine-2.3.2&#x2F;modules&#x2F;ngx_slab_stat&#x2F;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0cf928f7-a528-4746-8894-5c1d923feab3.png" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/5b4305a1-3c01-4a02-a48b-2253016dc8de.png" alt></p><p><strong>set、get、slab_stat 得到信息</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/a8f4040f-2d4e-4b38-8d11-d882abc30425.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-Nginx连接池处理网络请求-内存池对性能的影响</title>
      <link href="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？</p><p>Nginx使用了<strong>连接池</strong>来增加它对资源的利用率。</p><h2 id="Nginx通过连接池处理网络请求"><a href="#Nginx通过连接池处理网络请求" class="headerlink" title="Nginx通过连接池处理网络请求"></a>Nginx通过连接池处理网络请求</h2><p><strong>连接池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg" alt></p><a id="more"></a><p>右边图中每一个Worker进程中都有一个独立的数据结构：<strong>ngx_cycle_t</strong>。其中有三个中重要的数据。</p><ul><li><strong>connection数组</strong>：即连接池，他指向的数组有多大呢？其实是有一个配置项可以查看的。512大小的数组。</li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/85000415-fd2a-4026-a7c7-58328179c6f3.jpg" alt></p><ul><li><strong>read_event数组</strong>：数组大小与上述配置一致。</li><li><strong>write_event数组</strong>：同上。</li></ul><p>三者通过序号对应，5号连接自然对应5号读写事件。</p><p><strong>核心数据结构</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c5ba5443-c176-4ef7-b010-486eebe81312.jpg" alt></p><p>一般是 235 + 96*2   （乘2是因为读写两个分配）。</p><p>rb_tree_node_t 红黑树中每个节点指向的 timer，标志读写事件是否超时。</p><p>定时器也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/59848113-bab2-42fa-ae47-d22a8a33595e.jpg" alt></p><p>ngx_queue_t 事件进队列。</p><p>右边的 <strong>off_t</strong> 可以理解为一个无符号的变量，即已经向客户端发送了多少字节。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/9c81e155-3996-4a06-9890-5d00a60de797.jpg" alt></p><p>这个也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/b0b1dcdf-5169-45e1-a438-1c24df64e78c.jpg" alt></p><p>在access.log中可以看到上述配置生效。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c86ece93-3a3a-444d-bcb7-ae03da2b5c3d.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是 ngx_connection_t 与 ngx_event的配置。即连接与事件是怎样对应在一起的。当我们需要配置高并发的nginx时，需要将connection的数目配置的足够大。每一个connection对应的两个event（读写）都会消耗一定的内存。Nginx结构体中的许多成员与内置变量是可以对应做配置的。</p><h2 id="Nginx内存池对性能的影响"><a href="#Nginx内存池对性能的影响" class="headerlink" title="Nginx内存池对性能的影响"></a>Nginx内存池对性能的影响</h2><p>如果开发过第三方模块，会发现虽然在写C语言代码，但我们不需要关心内存的释放。如果在配置一些比较罕见的Nginx使用场景，可能需要去修改Nginx在请求和连接上初始分配的内存池大小。Nginx官方通常推荐不需要修改有关配置。究竟要不要改呢？</p><p><strong>内存池运转方式</strong><br>在上面的 <font color="red">核心数据结构</font>中，发现ngx_connection_s结构体中有一个<strong>ngx_pool_t</strong> 结构。它对应着当前连接所使用的内存池，可以通过 connection_pool_size去定义。</p><p><strong>内存池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/3e50c6d2-f117-49df-bc57-79dc8df8c829.jpg" alt></p><ul><li><p><strong>连接内存池</strong>上只分配一次，只要连接不关闭，分配的内存永远不需要释放，只有当关闭连接时才会释放。</p></li><li><p><strong>请求内存池</strong>：每一个HTTP请求开始分配时并不知道分配多少合适，但对于HTTP1.1 通常分配 4k大小（URL、Header往往需要这么多）。如果没有内存池，可能需要频繁而小块的分配，可能会造成内存碎片过多这样的代价。</p></li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/759a1245-2d83-43a9-b133-553b16c11061.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/1e0b5619-0a02-44af-8fda-989c9671877e.jpg" alt></p><p>当分配的内存超过 256|521 这种预分配大小时，还是可以继续分配的，这里只是提前分配空间，为了减少分配次数。</p><p>请求内存池大小</p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/93e8541a-d8a5-4616-a1ab-2a9f576d8855.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/304ff837-d46a-4e4a-86c3-68d0c54dde1e.jpg" alt></p><p>对于连接而言，他所需要的空间很小，只需要帮助后面的请求读取最初的一部分字节就ok了，而对于请求而言，要保存大量的上下文信息（URL、Header）等。如果URL过大，可以考虑修改这个配置项。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-Nginx模块</title>
      <link href="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx之所以有如此多的特性，是因为有大量的第三方开发者在为它开发模块。Nginx之所以有这么丰富的生态圈，是因为它的模块设计十分优良。如TCP协议一样，从上个世纪70年代设计至今，没有做过大的变动。Nginx同样如此，从2004年发布后，没有发生过大的变化。</p><a id="more"></a><h2 id="Nginx模块就是什么？"><a href="#Nginx模块就是什么？" class="headerlink" title="Nginx模块就是什么？"></a>Nginx模块就是什么？</h2><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/4e23e191-595e-4e1c-a473-b1d92c0732e8.jpg" alt></p><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx开源文档</a>，如 gzip模块文档中，会有它的用法以及内置变量等。<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">Nginx-gzip</a></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f286212a-ebdb-4f32-899d-7d0c6b2173e2.png" alt></p><p>有的第三方模块没有详细说明，可到 安装模块中查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;nginx&#x2F;nginx-1.16.0</span><br><span class="line"></span><br><span class="line">.&#x2F;configure</span><br><span class="line"></span><br><span class="line">之后会生成 objs文件夹</span><br><span class="line"></span><br><span class="line">cd objs</span><br><span class="line">vim ngx_module.c</span><br><span class="line"></span><br><span class="line">其中是ngx_modules数组，都是被加载进ngx中的模块</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/cf1f0e17-1b30-4c69-9839-ee34e6908b47.png" alt></p><p>如 gzip模块已经被加载进来，每一个模块在 *<em>/usr/local/geek/nginx/nginx-1.16.0/src/http/modules<br>*</em>中都会有对应的 .c文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http_gzip_filter_module.c</span><br></pre></td></tr></table></figure><p>在每一个源文件中，都会由 ngx_command_t 这样一个唯一的结构体。</p><p>该结构体是一个数组，其中的元素是它所支持的指令名，参数名、参数类型等等参考文档。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/8925c799-45a5-4fc5-a28c-4d947eaf2c5a.png" alt></p><p><strong>Nginx模块</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/92a824bb-768f-4e0a-94d0-127e5091f5e4.jpg" alt></p><h2 id="Nginx模块的分类"><a href="#Nginx模块的分类" class="headerlink" title="Nginx模块的分类"></a>Nginx模块的分类</h2><p>针对不同的应用场景，Nginx会细分为不同的子模块。在特定的复杂的应用场景下，这些子模块会增加许多新的特性和功能。</p><p><strong>Nginx模块分类</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/10ed37f5-43f0-43dd-a089-416575abc55b.jpg" alt></p><p><strong>/usr/local/geek/nginx/nginx-1.16.0/src目录下</strong></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/fcfe9d98-d06e-44e7-a821-85cfc3d17eef.png" alt></p><p><strong>core目录</strong>：仅仅是Nginx的核心框架代码，并不是Nginx的 Core Module。</p><p><strong>event、http、mail、stream</strong>则是对应的子类型模块。</p><p>以最复杂的<strong>http</strong>为例</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/6003a348-cd71-423c-b7e7-ed9cf983e0f1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http.c</span><br><span class="line"></span><br><span class="line">&#x2F;ngx_module_t </span><br><span class="line">可以看到类型type是 ngx_core_module</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f23c4bbb-17b5-470e-b0ab-e81187cd3ee0.png" alt></p><p>官方提供的都是在上述目录下，非官方提供的在 modules目录下。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/7f92c21d-6a1b-4770-874e-672773ea4d9b.png" alt></p><p>上述模块大概分为 3 类：</p><p>处理请求、生成响应 + 响应过滤 + 与上游服务器交互（负载均衡等工作）</p><p>响应过滤的名称有<strong>filter</strong>关键字。</p><p>与上游服务器交互的有<strong>upstream</strong>关键字。</p><p>其它模块都是生成响应或为生成响应而工作的。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-网络收发与Nginx事件模型</title>
      <link href="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个<strong>事件驱动</strong>的框架。事件主要指的是<strong>网络事件</strong>。Nginx每个连接会自然对应两个网络事件，<strong>读事件</strong> 与 <strong>写事件</strong>。因此，我们在深入了解Nginx的各种原理以及它在极端场景下的各种错误处理时，必须首先理解什么是网络事件。</p><a id="more"></a><h2 id="网络收发"><a href="#网络收发" class="headerlink" title="网络收发"></a>网络收发</h2><p><strong>网络传输</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/bd0ed4ad-9ab4-4f02-b787-cd11c0157c85.jpg" alt></p><p><strong>TCP流与报文</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/7f4caf3e-3802-450c-958a-7cce48864829.jpg" alt></p><p><strong>TCP协议与非阻塞接口</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/04d4fa8e-bcb4-42d2-bd74-5901fab6af91.jpg" alt></p><h2 id="Nginx网络事件实例演示"><a href="#Nginx网络事件实例演示" class="headerlink" title="Nginx网络事件实例演示"></a>Nginx网络事件实例演示</h2><p>访问 116.62.160.193:8080 这是一个之前搭建的Nginx-Web静态资源服务器.</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/e446f920-ae60-4cc9-9698-02daad34ba0f.jpg" alt></p><p>同时要安装 Wireshark网络抓包器。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/ba356c5e-97af-4987-9957-452919556294.jpg" alt></p><p>TCP三次握手时会发送 <strong>SYN、SYN+ACK、ACK包</strong></p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/1442eeeb-7de3-4a6e-a140-b30a86df688d.jpg" alt></p><p><strong>TCP</strong>层主要是做进程与进程间的通讯，本地打开1875端口，远程是8080端口</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/597d3231-48b6-4424-8a89-a25bfad8fbe2.jpg" alt></p><p><strong>IP层</strong>主要解决机器之间互相找到的问题。本地IP是 192.168.74.142，远端Nginx所在IP是 116.62.160.193</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/78f77e0d-0a29-479f-b894-5d946f30d640.jpg" alt></p><h2 id="Nginx事件驱动模型"><a href="#Nginx事件驱动模型" class="headerlink" title="Nginx事件驱动模型"></a>Nginx事件驱动模型</h2><p>在了解了网络事件以及事件分发、收集器后，再来学习Nginx是如何处理事件的。</p><p><strong>Nginx事件循环</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/875ec507-3b0b-462b-891e-6045caf65664.jpg" alt></p><p>流程：<br>当Nginx刚刚启动时，处于 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态，即我们打开了80、443端口后，等待新的事件进来（如新的客户端连上了Nginx,向我们发起了连接）。这一步对应着 epoll中的 epoll_wait方法。Nginx是处于<strong>Sleep</strong>进程状态。</p><p>当操作系统收到了一个建立连接的TCP握手报文并处理完成后，操作系统就会通知epoll_wait阻塞方法，告之可以往下走了（找操作系统要事件），并且唤醒我们的Nginx-Worker进程。</p><p>Kernel 即操作系统内核会将事件放入到事件队列中。从事件队列中，Nginx可以获取到要处理事件，如 建立连接、TCP请求报文等。取出来后就会处理对应的事件，进入 <strong>PROCESS THE EVENTS QUEUE CIRCLE</strong>，即右边的图。</p><p>队列不为空，就将事件取出来进行处理。在处理事件的过程中可能会生成一些新的事件（如：新连接建立，要设置一个超时时间，超时时间后，浏览器不向我发送新的请求，我就关闭它。又比如：当收完完整的HTTP请求后，可以进行HTTP响应了，这个响应是需要我可以向操作系统的写缓存区中把响应写进来的，要求操作系统尽快把这样一段写的内容发回给浏览器，即期待一个写事件等等）。</p><p>所有的事件处理完成后，又会返回到 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态。</p><p><strong>知道上述流程的好处：</strong><br>一些第三方模块可能会做大量的CPU运算，此类计算任务会导致我处理一个事件的时间非常长，在上述流程图中会导致后续队列中的大量事件长时间得不到处理。从而引发恶性循环，他们的超时时间可能到了，CPU都消耗到处理连接不正常的断开。</p><p>有些第三方模块长时间的消耗大量CPU进行计算任务，这是Nginx不能容忍的。gzip等模块不会一次使用大量的CPU，而是分段使用。</p><h2 id="epoll的优势及原理"><a href="#epoll的优势及原理" class="headerlink" title="epoll的优势及原理"></a>epoll的优势及原理</h2><p>上面讨论到了Nginx事件分发机制，最关键的就是Nginx怎样快速的从操作系统的Kernel中获取到等待处理的事件。这一步经历了很长时间的解决。当下Nginx主要是使用epoll网络事件收集器模型。</p><p><strong>各个模型性能对比</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/b1948077-bc41-410e-ad9a-78281102880f.jpg" alt></p><p><strong>epoll</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/9ee0a593-037f-4c48-b96a-6e1583f5bd92.jpg" alt></p><h2 id="Nginx请求切换场景使用epoll带来的争议"><a href="#Nginx请求切换场景使用epoll带来的争议" class="headerlink" title="Nginx请求切换场景使用epoll带来的争议"></a>Nginx请求切换场景使用epoll带来的争议</h2><p><strong>请求切换</strong></p><p>传统服务依赖OS，处理大量连接时很困难。<br>Nginx用户态即可完成切换。除非Nginx-Worker时间片到了（5ms-800ms），才会依赖OS切换，因此往往将Nginx-Worker优先级加到最高（-19），操作系统分配的时间片往往是最大的。这样能比较好的在用户态完成进程切换，使得CPU少做无用功。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/f88e575b-fd29-4890-90ad-9a1e9a33f41c.jpg" alt></p><h2 id="同步-amp-异步-阻塞-amp-非阻塞之间的区别"><a href="#同步-amp-异步-阻塞-amp-非阻塞之间的区别" class="headerlink" title="同步&amp;异步 阻塞&amp;非阻塞之间的区别"></a>同步&amp;异步 阻塞&amp;非阻塞之间的区别</h2><p>同步是两个对象之间的关系，而阻塞是一个对象的状态。</p><p>阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</p><p><strong>阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/52aa1fc5-cf86-4aff-9cb5-aa70a6c11518.jpg" alt></p><p><strong>非阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/4f1b1ce6-f00d-4303-83f4-c54520ef08e2.jpg" alt></p><p><strong>非阻塞调用下的同步与异步</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/03334dfa-1e2a-4510-955a-08cd8528e1c8.jpg" alt></p><p><strong>四种组合方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步阻塞方式： </span><br><span class="line">发送方发送请求之后一直等待响应。 </span><br><span class="line">接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步非阻塞方式： </span><br><span class="line">发送方发送请求之后，一直等待响应。</span><br><span class="line">接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。 </span><br><span class="line">但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步阻塞方式：</span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。</span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步非阻塞方式： </span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。 </span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 </span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-Nginx架构_相关流程</title>
      <link href="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>为什么要讨论Nginx的架构技术呢？</strong></p><p>因为Nginx运行在企业内网的最外层-边缘节点，它处理的流量是其他应用服务器的几个数量级。任何一种问题在不同的场景下解决方式不尽相同。因此，Nginx处理问题时的难度会被放大，我们有必要熟知:</p><p><font color="red">为什么Nginx采用<strong>Master-Worker</strong>这样一种架构模型</font><br><font color="red">为什么Worker进程的数量要与CPU的核数相匹配</font><br><font color="red">在多个Worker之间共享数据时，为什么在TLS或者限流、限速场景下的共享方式是有所不同的。</font></p><p>这些都需要我们对Nginx架构有一个清晰的了解。</p><a id="more"></a><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/bd9bd159-e718-4206-9d7e-1e9a460c9bcb.jpg" alt></p><p>网络大致有三种流量 Web、Email、TCP 。</p><p>三种状态机：处理Tcp/Ip的第四层状态机、HTTP应用层状态机、mail邮件状态机。为什么需要状态机呢？因为Nginx中是使用 <strong>非阻塞的事件驱动处理引擎</strong>来工作的，即<strong>Epoll</strong>，当使用异步时，通常需要用状态机将请求正确的识别处理。</p><h2 id="Nginx进程结构"><a href="#Nginx进程结构" class="headerlink" title="Nginx进程结构"></a>Nginx进程结构</h2><h3 id="1-单进程结构"><a href="#1-单进程结构" class="headerlink" title="1 单进程结构"></a>1 单进程结构</h3><p>不适用于生产环境，只适合做开发、调试。<br>生产环境要保持Nginx足够健壮，同时发挥Nginx可利用多核的特性。</p><p><font color="red">默认配置都是打开多进程Nginx</font></p><h3 id="2-多进程结构"><a href="#2-多进程结构" class="headerlink" title="2 多进程结构"></a>2 多进程结构</h3><p><strong>为什么是多进程而不是多线程呢？</strong></p><p>Nginx要保证它的高可用性、高可靠性。当Nginx使用多线程结构时，因为线程间是共享同一个地址空间的，当某一个第三方模块引发了地址空间的越界时，会导致整个nginx进程挂掉。多进程结构则不会出现上述问题。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/d2ec02bd-fac8-40f1-9343-b1f7a8d4aa25.jpg" alt></p><p>Nginx在做进程设计时，同样遵循了高可用、高可靠原则。</p><p><strong>在Master进程中</strong>，通常第三方模块是不会在这里加入自己的功能代码的。<br>虽然Nginx在设计时，允许第三方模块在Master进程中，添加自己独有的自定义的一些方法，但是第三方模块通常不会这么做。</p><p><strong>Master进程</strong>是被设计用来做 <strong>Worker进程</strong>的管理的。</p><p><strong>Worker进程</strong>是真正处理请求的，而Master进程是负责监控每个Worker进程是否正常工作、需不需要重新载入配置文件、热部署等。</p><p><strong>缓存</strong>是在多个Worker进程间共享，而且还要被 <strong>Cache Manager/loader进程</strong>使用。</p><p><strong>Cache Manager/loader进程</strong>是为反向代理时后端发过来的动态请求做缓存负责的。Manager负责缓存的管理。 Loader负责缓存的载入。</p><p>实际上每一个请求处理时用到的缓存还是由Worker进程响应的。</p><p>进程间的通讯都是使用共享内存解决。</p><p><strong>为什么worker进程很多呢？</strong></p><p>Nginx采用事件驱动模型后，希望每一个Worker进程从头到尾占有一颗CPU，因此，通常不仅要把Worker进程数量与服务器上的CPU核数一致，还要把每一个Worker进程与它对应的CPU绑定在一起。可以更好地使用每颗CPU核上对应的CPU缓存来减少缓存失效的命中率。</p><h3 id="3-多进程结构实例演示"><a href="#3-多进程结构实例演示" class="headerlink" title="3 多进程结构实例演示"></a>3 多进程结构实例演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进入 openstry的安装目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx</span><br><span class="line"></span><br><span class="line">vim config&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">修改 从1 到2（此处只为演示）</span><br><span class="line">worker_process 2</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line">sbin&#x2F;nginx -c config&#x2F;nginx.conf</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h4 id="1-首次查看"><a href="#1-首次查看" class="headerlink" title="1 首次查看"></a>1 首次查看</h4><p>第一次：1个master(12906) + 2个worker(父进程是12906，即master进程)</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9ccf4f35-8fe8-4f1d-b7a7-fa4181171712.png" alt></p><p>现在使用 -s reload 会将之前的 worker + cache进程 优雅的退出，重载新的配置项，新起新的 worker 与  cache进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbin&#x2F;nginx -s reload</span><br><span class="line"></span><br><span class="line">worker 进程号与上述已经不同，证明是新起的worker进程，同时他们的父进程ID 依然是 12906</span><br></pre></td></tr></table></figure><h4 id="2-reload后查看"><a href="#2-reload后查看" class="headerlink" title="2 reload后查看"></a>2 reload后查看</h4><p>第二次：master不变，worker 新起<br><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/7bc1fe02-d57d-4ea4-87b5-476b8721fd82.png" alt></p><h4 id="3-发送hup信号查看"><a href="#3-发送hup信号查看" class="headerlink" title="3 发送hup信号查看"></a>3 发送hup信号查看</h4><p>第三次： reload 与 hup的作用相同,现在向 12906的 master进程发送 hup信号，结果依然相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGHUP 12906</span><br></pre></td></tr></table></figure><p>master进程依然没有变，worker进程是新起的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/fe405a29-14c4-4e24-acd4-27bd1e762a4b.png" alt></p><h4 id="4-quit、stop信号查看"><a href="#4-quit、stop信号查看" class="headerlink" title="4 quit、stop信号查看"></a>4 quit、stop信号查看</h4><p>第四次：向一个 worker进程发送 quit信号，该worker进程再退出的同时，会自动的向他的父进程 12906 发送一个CHLD退出信号，master进程收到信号后，会新起一个worker进程，维持worker进程的进程结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigterm 退出信号</span><br><span class="line"></span><br><span class="line">kill -SIGTERM 13041</span><br></pre></td></tr></table></figure><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/0d2af2bd-d80e-4343-a21e-fba21550e359.png" alt></p><p>因此，<strong>命令行中的需多子命令，就是向Master进程发送信号而已。</strong></p><h3 id="4-进程模型"><a href="#4-进程模型" class="headerlink" title="4 进程模型"></a>4 进程模型</h3><p><strong>进程</strong></p><p>master、worker、cache manager、cache loader</p><p><strong>通讯方式</strong></p><p>信号：TERM、INT、QUIT、HUP、USR1、USR2、WINCH</p><p>共享内存：slab内存管理、互斥锁</p><h3 id="5-信号管理Nginx父子进程"><a href="#5-信号管理Nginx父子进程" class="headerlink" title="5 信号管理Nginx父子进程"></a>5 信号管理Nginx父子进程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/442e24b0-cc0b-48df-ab6a-169534de3cfd.jpg" alt></p><p><strong>Master进程</strong></p><ul><li><p><strong>CHLD</strong>：当worker进程因为某些bug而停止工作时，它在退出时会向Master进程发送 CHLD信号，Master进程可以立刻通过 CHLD信号发现问题，重新拉起一个Worker进程。</p></li><li><p><strong>TERM，INT</strong>：立刻停止Nginx进程</p></li><li><p><strong>QUIT</strong>：优雅的停止Nginx进程</p></li><li><p><strong>HUP</strong>：重载配置文件</p></li><li><p><strong>USR1</strong>：重新打开日志文件，做日志文件的切割</p></li></ul><p>以上可以直接在 Nginx命令行 + 特定命令 向Master进程发送。</p><p>下面两个 只能通过 Linux中的  kill + 命令发送给Master进程，即先找到 Master的 PID，对 PID 发送信号。</p><ul><li><p><strong>USR2</strong>：热部署时使用</p></li><li><p><strong>WINCH</strong>：热部署时使用</p></li></ul><p><strong>Worker进程</strong></p><p>通常是不会直接对Worker进程发送相应的信号的，应该将信号发送给Master进程，由Master进程管控Worker进程。</p><p><strong>Nginx命令行</strong></p><p>当启动Nginx后，Nginx会将它的 PID 记录到 Nginx安装目录的 logs文件夹下的 Nginx.pid文件中，记录了 Master进程的PID，再次执行 nginx -s 时，Nginx命令行会读取 Nginx.pid，向Master进程所在的PID同样的去发送对应的信号。</p><p><font color="red">综上，命令行与发送信号本质是一致的</font></p><h2 id="reload重载配置文件流程"><a href="#reload重载配置文件流程" class="headerlink" title="reload重载配置文件流程"></a>reload重载配置文件流程</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当我们更改了 <strong>nginx.conf</strong> 配置文件后，再次启动时都会执行 <strong>-s reload</strong> 命令。</p><p><strong>好处：</strong>Nginx不停止服务，始终在处理新的请求，同时把Nginx的配置文件平滑的从旧的 nginx.conf 更新为新的 nginx.conf。</p><p>有时在执行完后，发现Nginx的 <strong>Worker进程</strong>变多了，这是因为老的 配置所运行的 Nginx-Worker进程长时间没有退出，当使用 stream做4层反向代理时可能会更多。</p><h3 id="reload流程"><a href="#reload流程" class="headerlink" title="reload流程"></a>reload流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b0a2b9a6-281b-4474-b39b-b7ca834ffa2f.jpg" alt></p><p>第3步：因为所有的子进程会继承父进程已经打开的端口。</p><p>第4-5步：是为了平滑过渡，先创建新的，在慢慢关闭老的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9b6e6e8a-d5f8-46ef-a03c-48344fe5c7ad.jpg" alt></p><p>当有些绿色的 老 worker进程因为一些bug，长时间不退出时，也只会影响已存在的连接，不会影响新的连接。如何处理这些异常存活的worker进程呢</p><p>Nginx新的版本中，提供了一个配置项，称为 worker shutdown timeout<br>，即超时时间；Master进程在启动 黄色的 新的 Worker进程时，会为老的绿色的Worker进程加上一个 定时器，超时后，将依然存在的老的Worker进程强制退出掉。</p><h2 id="热升级完整过程"><a href="#热升级完整过程" class="headerlink" title="热升级完整过程"></a>热升级完整过程</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在Nginx不停止服务的情况下，做版本的更新。但也会遇到新的问题，如：</p><ul><li><p>老的Worker进程一直退不掉。</p></li><li><p>新的Worker进程起来后出现了问题，考虑回滚等。</p></li><li><p>使用了新的Nginx.conf配置文件后，发现好多功能出现了错误，只能回滚等。</p></li></ul><h3 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/43851d55-23fc-4e2e-876d-4d13226725f8.jpg" alt></p><p><strong>第一步</strong>：<br>将旧的 binary文件替换为新的 binary文件。之所以只替换binary文件，是因为在大部分场景下，我们新编译的Nginx文件所指定的配置选项（配置文件的目录在哪里，logs文件所在的目录在哪里），必须保持和老的Nginx是一致的，否则无法使用 nginx.conf文件。替换时要注意备份，同时，新版本的Linux中，要求覆盖一个正在使用的文件时，需要这样写命令<strong>cp -f</strong></p><p><strong>第二步</strong>：<br>向老的Master进程发送 USR2信号。此时我们是没有办法通过Nginx命令行直接用 <strong>nginx -s</strong>这个信号来处理，这是因为Nginx到目前为止还没有持这样的信号。</p><p><strong>第三步</strong>：<br>老的Master进程为了给新的Master让路，修改自己的pid文件名，以方便新的Master进程创建自己的PID文件。</p><p><strong>第四步</strong>：<br>新的Master进程起来后，会出现新老Master、老的Worker同时存在的情况。新的Master会去拉起新的Worker进程。</p><p><strong>第五步</strong>：</p><p>通过查看 .oldbin 或者 ps -ef|grep nginx 查看老的Master进程号，以便向他发送WINCH信号。老的Master会优雅关闭老Worker进程。热升级已经完成。<strong>但是老的Master进程会一直存在，方便回滚</strong>。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b1685e4b-8e80-4a2a-baa2-b9f977363671.jpg" alt></p><p>新的Master进程是 老的Master进程的子进程。新的使用了新的binary来载入的。新老并存时，老的会在处理完请求后，关闭自己监听的端口，优雅的退出。完成后，就只剩下新的Master+Worker进程。</p><h2 id="优雅关闭Worker进程"><a href="#优雅关闭Worker进程" class="headerlink" title="优雅关闭Worker进程"></a>优雅关闭Worker进程</h2><p><strong>nginx - stop</strong> : 立即停止Nginx。<br><strong>nginx - quit</strong> : 优雅关闭Nginx。<br>在上面的热部署、reload时都是优雅的停止Nginx，那他的过程如何呢？</p><p>优雅的关闭：即Nginx的worker进程可以识别出当前的连接没有正在处理请求，此时再次关闭它。能不能做到这一点呢？</p><p>对于有些请求，Nginx是做不到的。如：</p><ul><li><p>Nginx代理 <strong>Web Socket</strong>协议时，在Web Socket通讯的 Frame帧中，Nginx是不解析这个帧的是没有办法识别的。</p></li><li><p>Nginx做TCP、UDP层的反向代理时，是没有办法识别一个请求需要经历多少报文才算是结束。</p></li></ul><p>对于<font color="red"> <strong>HTTP</strong></font>请求是可以识别的。因此，优雅的关闭，主要针对HTTP请求。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/f4bde9ab-dc0d-4741-baa5-25d0fffe95c9.jpg" alt></p><p><strong>第一步</strong>：<br>设置完定时器后，会加一个标志位，表示现在进入优雅的关闭流程了。</p><p><strong>第二步</strong>：<br>保证所在的Worker进程不会再去处理新的连接。</p><p><strong>第三步</strong>：<br>查看Nginx的连接池，Nginx为了保证对资源的充分利用，经常会保持一些空闲连接不断开。此时会关闭所有的空闲连接。</p><p><strong>第四步</strong>：<br>用时可能会超过第一步 worker_shutdonw_timeout设置的时间。一旦超时，即使请求还没有处理完，依然会强制关闭连接。优雅的关闭只完成一半，有一部分是立即停止。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap实现原理_探险</title>
      <link href="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)</p><p>从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。 <a id="more"></a>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说， 假设你插入的键的顺序为 1、2、3、4，后来再次插入 2，迭代时的顺序还是 1、2、 3、4，而不会因为后来插入的 2 变成 1、3、4、2。（但其实我们可以改变它的规则， 使它变成 1、3、4、2）</p><p>LinkedHashMap 的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希 表部分继承了 HashMap，拥有了 HashMap 那一套高效的操作，所以我们要看的就是 LinkedHashMap 中链表的部分，了解它是如何来维护有序性的。</p><p>LinkedHashMap 的大致实现如下图所示，当然链表和哈希表中相同的键值对都是指 向同一个对象，这里把它们分开来画只是为了呈现出比较清晰的结构。</p><p><img src="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/123e5c16-da83-4e2b-99ca-ac014847a73a.jpg" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>在看属性之前，我们先来看一下 LinkedHashMap 的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; imple ments Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>从上面的声明中，我们可以看见 LinkedHashMap 是继承自 HashMap 的，所以它已 经从 HashMap 那里继承了与哈希表相关的操作了，那么在 LinkedHashMap 中，它 可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedHashMap 的链表节点继承了 HashMap 的节点，而且每个节点都包含</span><br><span class="line">了前指针和后指针，所以这里可以看出它是一个双向链表</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尾指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认为 false。当为 true 时，表示链表中键值对的顺序与每个键的插入顺</span><br><span class="line">序一致，也就是说重复插入键，也会更新顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单来说，为 false 时，就是上面所指的 1、2、3、4 的情况；为 true 时，</span><br><span class="line">就是 1、3、4、2 的情况</span><br><span class="line"></span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><p>如果仔细看过 HashMap 源码的话，会发现 HashMap 中有如下三个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果没有注意到注释的解释的话，可能会很奇怪为什么会有三个空方法，而且 有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点 之后，进行一些处理，它们在 LinkedHashMap 都有各自的实现。LinkedHashMap 正 是通过重写这三个方法来保证链表的插入、删除的有序性。</p><h2 id="1-afterNodeAccess方法"><a href="#1-afterNodeAccess方法" class="headerlink" title="1 afterNodeAccess方法"></a>1 afterNodeAccess方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    &#x2F;&#x2F;当 accessOrder 的值为 true，且 e 不是尾节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思简洁明了，就是把当前节点 e 移至链表的尾部。因为使用的是双向 链表，所以在尾部插入可以以 O（1）的时间复杂度来完成。并且只有当accessOrder<br>设置为 true 时，才会执行这个操作。在 HashMap 的 putVal 方法中，就调用了这个 方法。</p><h2 id="2-afterNodeInsertion方法"><a href="#2-afterNodeInsertion方法" class="headerlink" title="2 afterNodeInsertion方法"></a>2 afterNodeInsertion方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remov e eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntr y(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterNodeInsertion 方法是在哈希表中插入了一个新节点时调用的，它会把链表的头 节点删除掉，删除的方式是通过调用 HashMap 的 removeNode 方法。想一想，通过 afterNodeInsertion 方法和 afterNodeAccess 方法，是不是就可以简单的实现一个基于 最近最少使用（LRU）的淘汰策略了？当然，我们还要重写 removeEldestEntry 方法， 因为它默认返回的是 false。</p><h2 id="3-afterNodeRemoval方法"><a href="#3-afterNodeRemoval方法" class="headerlink" title="3 afterNodeRemoval方法"></a>3 afterNodeRemoval方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.aft er;</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当 HashMap 删除一个键值对时调用的，它会把在 HashMap 中删除的那 个键值对一并从链表中删除，保证了哈希表和链表的一致性。 </p><h2 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4 get方法"></a>4 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，LinkedHashMap 的 get 方法就是这么简单，因为它调用的是 HashMap 的 getNode 方法来获取结果的。并且，如果你把 accessOrder 设置为 true，那么在获取到值之后，还会调用 afterNodeAccess 方法。这样是不是就能保证一个 LRU 的算法了.</p><h2 id="5-put和remove方法"><a href="#5-put和remove方法" class="headerlink" title="5 put和remove方法"></a>5 put和remove方法</h2><p>在 LinkedHashMap 的源码中没有找到 put 方法，这就说明了它并没有重写 put 方 法，所以我们调用的 put 方法其实是 HashMap 的 put 方法。因为 HashMap 的 put 方 法中调用了 afterNodeAccess 方法和 afterNodeInsertion 方法，已经足够保证链表的有 序性了，所以它也就没有重写 put 方法了。remove 方法也是如此。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashTable实现原理_探险</title>
      <link href="/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>Hashtable 可以说已经具有一定的历史了，现在也很少使用到 Hashtable 了，更多的是使 用 HashMap 或 ConcurrentHashMap。HashTable 是一个线程安全的哈希表，它通过使用 synchronized 关键字来对方法进行加锁，从而保证了线程安全。但这也导致了在单线程 环境中效率低下等问题。Hashtable 与 HashMap 不同，它不允许插入 null 值和 null 键。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>Hashtable 并没有像 HashMap 那样定义了很多的常量，而是直接写死在了方法里（看下 去就知道了），所以它的属性相比 HashMap 来说，可以获取的信息还是比较少的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">private transient Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录哈希表中键值对的个数</span><br><span class="line">private transient int count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩容的阈值</span><br><span class="line">private int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">private float loadFactor;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+l oadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">        initialCapacity &#x3D; 1;</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    table &#x3D; new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二话不说，上来先丢了三个构造函数。从构造函数中，我们可以获取到这些信息： Hashtable默认的初始化容量为11（与HashMap不同），负载因子默认为0.75（与HashMap 相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以 先推断出，Hashtable 使用的哈希函数跟 HashMap 是不一样的（事实也确实如此）。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;通过哈希函数，计算出 key 对应的桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F;遍历该桶的所有元素，寻找该 key</span><br><span class="line">    for (Entry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 HashMap 相比，Hashtable 的 get 方法非常简单。我们首先可以看见 get 方法使用了 synchronized 来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。 另外，我们还可以看见 HashTable 并没有像 HashMap 那样封装一个哈希函数，而是直接 把哈希函数写在了方法中。而哈希函数也是比较简单的，它仅对哈希表的长度进行了取模。</p><h2 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3 put方法"></a>3 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">    if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;计算桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    &#x2F;&#x2F;遍历桶中的元素，判断是否存在相同的 key</span><br><span class="line">    for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">        if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old &#x3D; entry.value;</span><br><span class="line">            entry.value &#x3D; value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不存在相同的 key，则把该 key 插入到桶中</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F;哈希表的键值对个数达到了阈值，则进行扩容</span><br><span class="line">    if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">        &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab &#x3D; table;</span><br><span class="line">        hash &#x3D; key.hashCode();</span><br><span class="line">        index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    &#x2F;&#x2F;把新节点插入桶中（头插法）</span><br><span class="line">    tab[index] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 方法一开始就表明了不能有 null 值，否则就会向你抛出一个空指针异常。Hashtable 的 put 方法也是使用 synchronized 来修饰。你可以发现，在 Hashtable 中，几乎所有的方 法都使用了 synchronized 来保证线程安全。</p><h2 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4 remove方法"></a>4 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(Entry&lt;K,V&gt; prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.nex t) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity &#x3D; table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;扩容扩为原来的两倍+1</span><br><span class="line">    int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    &#x2F;&#x2F;判断是否超过最大容量</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">            &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">            return;</span><br><span class="line">        newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap &#x3D; new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F;计算下一次 rehash 的阈值</span><br><span class="line">    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRA Y_SIZE + 1);</span><br><span class="line">    table &#x3D; newMap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;把旧哈希表的键值对重新哈希到新哈希表中去</span><br><span class="line">    for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old &#x3D; (Entry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">            old &#x3D; old.next;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next &#x3D; (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hashtable 的 rehash 方法相当于 HashMap 的 resize 方法。跟 HashMap 那种巧妙的 rehash 方式相比，Hashtable 的 rehash 过程需要对每个键值对都重新计算哈希值，而比起异或 和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理_探险</title>
      <link href="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>大致意思是：这个哈希表是基于 Map 接口的实现的，它允许 null 值和 null 键，它不是线程同步的，同时也不保证有序。</p><a id="more"></a><p>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.  An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p><p>大意：讲的是 Map 的这种实现方式为 get （取）和 put（存）带来了比较好的性能。但是如果涉及到大量的遍历操作的话，就 尽量不要把 capacity 设置得太高（或 load factor 设置得太低），否则会严重降低遍历的效率。</p><p>影响 HashMap 性能的两个重要参数：“initial capacity”（初始化容量）和”load factor“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对 个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash 操作来进行扩容。</p><p>HashMap 的大致结构如下图所示，其中哈希表是一个数组，我们经常把数组中的每 一个节点称为一个桶，哈希表中的每个节点都用来存储一个键值对。在插入元素时， 如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解 决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过 key 的<br>哈希值先定位到桶，再遍历桶上的所有键值对，找出 key 相等的键值对，从而来获 取 value。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0f32057b-e876-449b-99ec-fbcf3b3bbcce.png" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的初始容量为 16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最大的容量上限为 2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的负载因子为 0.75 </span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变成树型结构的临界值为 8</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;恢复链式结构的临界值为 6</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表中键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表被修改的次数</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span><br><span class="line">就会进行扩容操作</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采</span><br><span class="line">取扩容来尝试减少冲突</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure><p>Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个 节点都是 Node 类型。我们可以看到，Node 类中有 4 个属性，其中除了 key 和 value 之外，还有 hash 和 next 两个属性。hash 是用来存储 key 的哈希值的，next 是在构建链表时用来指向后继节点的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + valu e; &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(val ue); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三方法"><a href="#三方法" class="headerlink" title="三方法"></a>三方法</h1><h2 id="1-get方法"><a href="#1-get方法" class="headerlink" title="1 get方法"></a>1 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的</span><br><span class="line">实现</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;是否直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first n ode </span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; ke y.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F;判断是否有后续节点 </span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode (hash, key);</span><br><span class="line">                &#x2F;&#x2F;不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下： </p><ol><li>通过 hash 值获取该 key 映射到的桶。</li><li>桶上的 key 就是要查找的 key，则直接命中。</li><li>桶上的 key 不是要查找的 key，则查看后续节点：<br>（1）如果后续节点是树节点，通过调用树的方法查找该 key。<br>（2）如果后续节点是链式节点，则通过循环遍历链查找该 key。</li></ol><h2 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2 put方法"></a>2 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;put 方法的具体实现也是在 putVal 方法中，所以我们重点看下面的 putVal 方法</span><br><span class="line">   public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIf Absent,boolean evict) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">       &#x2F;&#x2F;如果哈希表为空，则先创建一个哈希表</span><br><span class="line">       if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">           n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">       &#x2F;&#x2F;如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span><br><span class="line">       if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">           tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">       else &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           &#x2F;&#x2F;如果桶上节点的 key 与当前 key 重复，那你就是我要找的节点了</span><br><span class="line">           if (p.hash &#x3D;&#x3D; hash &amp;&amp;((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equ als(k))))</span><br><span class="line">               e &#x3D; p;</span><br><span class="line">           &#x2F;&#x2F;如果是采用红黑树的方式处理冲突，则通过红黑树的 putTreeVal 方法去插入这个键值对</span><br><span class="line">           else if (p instanceof TreeNode)</span><br><span class="line">               e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">           &#x2F;&#x2F;否则就是传统的链式结构</span><br><span class="line">           else &#123;</span><br><span class="line">               &#x2F;&#x2F;采用循环遍历的方式，判断链中是否有重复的 key</span><br><span class="line">               for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                   &#x2F;&#x2F;到了链尾还没找到重复的 key，则说明 HashMap 没有包含该键</span><br><span class="line">                   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       &#x2F;&#x2F;创建一个新节点插入到尾部</span><br><span class="line">                       p.next &#x3D; newNode(hash, key, value, nul l);</span><br><span class="line"></span><br><span class="line">                       &#x2F;&#x2F;如果链的长度大于 TREEIFY_THRESHOLD 这个临界值，则把链变为红黑树</span><br><span class="line">                       if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   &#x2F;&#x2F;找到了重复的 key</span><br><span class="line">                   if (e.hash &#x3D;&#x3D; hash</span><br><span class="line">                       ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                       break;</span><br><span class="line">                   p &#x3D; e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span><br><span class="line">           if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">               V oldValue &#x3D; e.value;</span><br><span class="line">               if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               return oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       &#x2F;&#x2F;判断是否需要进行扩容</span><br><span class="line">       if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>put 方法比较复杂，实现步骤大致如下：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红 黑树。</li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果 size 大于阈值，则进行扩容。</li></ol><h2 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="3  remove方法"></a>3  remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove 方法的具体实现在 removeNode 方法中，所以我们重点看下面的 removeNode 方法</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, tru e)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object va lue,</span><br><span class="line">                           boolean matchValue, boolean movabl e) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    &#x2F;&#x2F;如果当前 key 映射到的桶不为空</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        &#x2F;&#x2F;如果桶上的节点就是要找的 key，则直接命中</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是以红黑树处理冲突，则构建一个树节点</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F;如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;比对找到的 key 的 value 跟要删除的是否匹配</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals (v)))) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过调用红黑树的方法来删除节点</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, t ab, movable);</span><br><span class="line">            &#x2F;&#x2F;使用链表的操作来删除节点</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Hash方法"><a href="#5-Hash方法" class="headerlink" title="5 Hash方法"></a>5 Hash方法</h2><p>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作， 计算的主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的 n 指的是哈希表的大小，hash 指的是 key 的哈希值，hash 是通过下面 这个方法计算出来的，采用了二次哈希的方式，其中 key 的 hashCode 方法是一个 native 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>这个 hash 方法先通过 key 的 hashCode 方法获取一个哈希值，再拿这个哈希值与它 的高 16 位的哈希值做一个异或操作来得到最后的哈希值，计算过程可以参考下图。 为啥要这样做呢？注释中是这样解释的：如果当 n 很小，假设为 64 的话，那么 n-1 即为 63（0x111111），这样的值跟 hashCode()直接做与操作，实际上只使用了哈希 值的后 6 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲 突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0dfe17b4-be06-48e2-90e1-0383e587a440.jpg" alt></p><p>正是因为与的这个操作，决定了 HashMap 的大小只能是 2 的幂次方，想一想，如果 不是2的幂次方，会发生什么事情？即使你在创建HashMap的时候指定了初始大小， HashMap 在构建的时候也会调用下面这个方法来调整大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_C APACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用看起来可能不是很直观，它的实际作用就是把 cap 变成第一个大于 等于 2 的幂次方的数。例如，16 还是 16，13 就会调整为 16，17 就会调整为 32。</p><h2 id="5-resize方法"><a href="#5-resize方法" class="headerlink" title="5 resize方法"></a>5 resize方法</h2><p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与 原来计算（n-1）&amp;hash 的结果相比，只是多了一个 bit 位，所以节点要么就在原来 的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为 32，那么应该拿 hash 跟 31（0x11111）做与操作；在扩容扩到 了 64 的容量之后，应该拿 hash 跟 63（0x111111）做与操作。新容量跟原来相比只 是多了一个 bit 位，假设原来的位置在 23，那么当新增的那个 bit 位的计算结果为 0 时，那么该节点还是在 23；相反，计算结果为 1 时，则该节点会被分配到 23+31 的 桶上。</p><p>正是因为这样巧妙的 rehash 方式，保证了 rehash 之后每个桶上的节点数必定小于等 于原来桶上的节点数，即保证了 rehash 之后不会出现更严重的冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;计算扩容后的大小</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量超过最大容量，则无法进行扩容</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没超过最大值则扩为原来的两倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp; &amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">     &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in t hreshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIA L_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)M AXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;新的 resize 阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F;创建新的哈希表</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;如果桶上只有一个键值对，则直接插入</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F;如果是通过红黑树来处理冲突的，则调用相关方法把树分</span><br><span class="line">离开</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                &#x2F;&#x2F;如果采用链式处理冲突 </span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    &#x2F;&#x2F;通过上面讲的方法来计算节点的新位置</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个需要注意的地方，有些文章指出当哈希表的桶占用超过阈值时就进行 扩容，这是不对的；实际上是当哈希表中的<strong>键值对个数超过阈值</strong>时，才进行扩容的.</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>通过红黑树的方式来处理哈希冲突是我第一次看见！学过哈希，学过红黑树，从来没有想过两个可以结合到一起这么用，或许这就是大佬吧！！！</p><p>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表 的效率降低至 O（n），而通过红黑树的方式，可以把效率改进至 O（logn）。相比 链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis多数据源配置</title>
      <link href="/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多数据源，一般都来解决主从模式或者业务比较复杂需要连接不同的分库来支持业务。我们遇到的情况是后者，网上找了很多，大都是根据 Jpa 来做多数据源解决方案，要不就是老的 Spring 多数据源解决方案，还有的是利用 Aop 动态切换，过于复杂，当前已Mybatis Xml为例，简单配置。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Pom 包就不贴了比较简单该依赖的就依赖，主要是数据库这边的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location&#x3D;classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line"></span><br><span class="line">spring.datasource.test1.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test1?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test1.username&#x3D;root</span><br><span class="line">spring.datasource.test1.password&#x3D;root</span><br><span class="line">spring.datasource.test1.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.test2.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test2?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test2.username&#x3D;root</span><br><span class="line">spring.datasource.test2.password&#x3D;root</span><br><span class="line">spring.datasource.test2.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>一个 test1 库和一个 test2 库，其中 test1 位主库，在使用的过程中必须指定主库，不然会报错</p><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">public class DataSource1Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1DataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.test1&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource testDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis&#x2F;mapper&#x2F;test1&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1TransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的地方就是这块了，一层一层注入,首先创建 DataSource，然后创建 SqlSessionFactory 再创建事务，最后包装到 SqlSessionTemplate 中。其中需要指定分库的 mapper 文件地址，以及分库dao层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br></pre></td></tr></table></figure><p>这块的注解就是指明了扫描 dao 层，并且给 dao 层注入指定的 SqlSessionTemplate。所有<code>@Bean</code>都需要按照命名指定正确。</p><h2 id="dao-层和-xml层"><a href="#dao-层和-xml层" class="headerlink" title="dao 层和 xml层"></a>dao 层和 xml层</h2><p>dao 层和 xml 需要按照库来分在不同的目录，比如：test1 库 dao 层在 <code>com.neo.mapper.test1</code> 包下，test2 库在<code>com.neo.mapper.test2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    List&lt;UserEntity&gt; getAll();</span><br><span class="line">    UserEntity getOne(Long id);</span><br><span class="line">    void insert(UserEntity user);</span><br><span class="line">    void update(UserEntity user);</span><br><span class="line">    void delete(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.neo.mapper.test1.User1Mapper&quot; &gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;BIGINT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;userName&quot; property&#x3D;&quot;userName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;passWord&quot; property&#x3D;&quot;passWord&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;user_sex&quot; property&#x3D;&quot;userSex&quot; javaType&#x3D;&quot;com.neo.enums.UserSexEnum&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;nick_name&quot; property&#x3D;&quot;nickName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id&#x3D;&quot;Base_Column_List&quot; &gt;</span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    &lt;&#x2F;sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getAll&quot; resultMap&#x3D;&quot;BaseResultMap&quot;  &gt;</span><br><span class="line">       SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getOne&quot; parameterType&#x3D;&quot;java.lang.Long&quot; resultMap&#x3D;&quot;BaseResultMap&quot; &gt;</span><br><span class="line">        SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">     WHERE id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       INSERT INTO </span><br><span class="line">          users</span><br><span class="line">          (userName,passWord,user_sex) </span><br><span class="line">        VALUES</span><br><span class="line">          (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       UPDATE </span><br><span class="line">          users </span><br><span class="line">       SET </span><br><span class="line">        &lt;if test&#x3D;&quot;userName !&#x3D; null&quot;&gt;userName &#x3D; #&#123;userName&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;passWord !&#x3D; null&quot;&gt;passWord &#x3D; #&#123;passWord&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        nick_name &#x3D; #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">          id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id&#x3D;&quot;delete&quot; parameterType&#x3D;&quot;java.lang.Long&quot; &gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">           users </span><br><span class="line">       WHERE </span><br><span class="line">           id &#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试可以使用 SpringBootTest,也可以放到 Controller中，这里只贴 Controller 层的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User1Mapper user1Mapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User2Mapper user2Mapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUsers&quot;)</span><br><span class="line">    public List&lt;UserEntity&gt; getUsers() &#123;</span><br><span class="line">        List&lt;UserEntity&gt; users&#x3D;user1Mapper.getAll();</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">    public UserEntity getUser(Long id) &#123;</span><br><span class="line">        UserEntity user&#x3D;user2Mapper.getOne(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">    public void save(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;update&quot;)</span><br><span class="line">    public void update(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void delete(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">        user1Mapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis多数据源配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList实现原理_探险</title>
      <link href="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</p><p>All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</p><p>Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list</p><p>由上述注释中可以大概得知： LinkedList 是由一个双向链表来实现的，它允许插入所有元素，包括 null，同时，它是线程不同步的。</p><a id="more"></a><p>双向链表结构示意图：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/01a8426b-2594-400f-8475-71d402cb4550.png" alt><br>双向链表每个结点除了数据域之外，还有一个前指针和后指针，分别指向前驱结点 和后继结点（如果有前驱/后继的话）。另外，双向链表还有一个 first 指针，指向头 节点，和 last 指针，指向尾节点。</p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;链表的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向头节点的指针</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向尾节点的指针</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>LinkedList属性非常少，由上述三个属性基本可以知道他是怎么实现的。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h2><p>Node 是在 LinkedList 里定义的一个静态内部类，它表示链表每个节点的结构，包括一个数据域 item，一个后置指针 next，一个前置指针 prev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2 添加元素"></a>2 添加元素</h2><p>对于链表这种数据结构来说，添加元素的操作无非就是在表头/表尾插入元素，又或 者在指定位置插入元素。因为 LinkedList 有头指针和尾指针，所以在表头或表尾进 行插入元素只需要 O(1) 的时间，而在指定位置插入元素则需要先遍历一下链表， 所以复杂度为 O(n)。</p><p>在表头添加元素的过程如下：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/04a15498-61a8-41a2-933e-f1da8796db53.png" alt></p><p>当向表头插入一个节点时，很显然当前节点的前驱一定为 null，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节<br>点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点， 源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向 null，后继指针原来的头节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">    &#x2F;&#x2F;头指针指向新的头节点</span><br><span class="line">    first &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有头节点，则更新原来节点的前驱指针，否则更新尾指针</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在表尾添加元素跟在表头添加元素大同小异，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/241772bf-9089-4aa3-9636-5d5e59215f01.png" alt></p><p>当向表尾插入一个节点时，很显然当前节点的后继一定为 null，而前驱结点是 last 指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾 节点的后继指针，使它指向新的尾节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向尾节点，后继指向 null</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    &#x2F;&#x2F;尾指针指向新的尾节点</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有尾节点，则更新原来节点的后继指针，否则更新头指针</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在指定节点之前插入，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/ee88f767-33ee-4e11-ba24-bdfb1413ad86.png" alt></p><p>当向指定节点之前插入一个节点时，当前节点的后继为指定节点，而前驱结点为指 定节点的前驱节点。此外，还要修改前驱节点的后继为当前节点，以及后继节点的 前驱为当前节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;指定节点的前驱</span><br><span class="line">    final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱为指点节点的前驱，后继为指定的节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    &#x2F;&#x2F;更新指定节点的前驱为当前节点</span><br><span class="line">    succ.prev &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;更新前驱节点的后继</span><br><span class="line">    if (pred &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        pred.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3 删除元素"></a>3 删除元素</h2><p>删除操作与添加操作大同小异，例如删除指定节点的过程如下图所示，需要把当前 节点的前驱节点的后继修改为当前节点的后继，以及当前节点的后继结点的前驱修 改为当前节点的前驱</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/571734ca-b358-465a-8bba-0c785301a2c7.png" alt></p><p>删除头节点和尾节点跟删除指定节点非常类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头节点，返回表头元素的值</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next; &#x2F;&#x2F;头指针指向后一个节点</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;新头节点的前驱为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾节点，返回表尾元素的值</span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev; &#x2F;&#x2F;尾指针指向前一个节点</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null; &#x2F;&#x2F;新尾节点的后继为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定节点，返回指定元素的值 </span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next; &#x2F;&#x2F;当前节点的后继</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev; &#x2F;&#x2F;当前节点的前驱</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next; &#x2F;&#x2F;更新前驱节点的后继为当前节点的后继</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev; &#x2F;&#x2F;更新后继节点的前驱为当前节点的前驱</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取元素"><a href="#4-获取元素" class="headerlink" title="4 获取元素"></a>4 获取元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取表头元素</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取表尾元素 </span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据下标是否超过链表长度的一半，来选择从头部开始遍历还是从尾部</span><br><span class="line">开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-常用方法"><a href="#5-常用方法" class="headerlink" title="5 常用方法"></a>5 常用方法</h2><p>上述方法都不是 public 的，LinkedList 是在这些基础的方法进行操作的，下面就来看看可以调用的方法有哪些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头元素 </span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾元素</span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表头节点</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表尾节点</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;链表的大小</span><br><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表尾</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index); &#x2F;&#x2F;先检查是否越界</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;替换指定下标的值</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">    E oldVal &#x3D; x.item;</span><br><span class="line">    x.item &#x3D; element;</span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在指定位置插入节点</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定下标的节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空抛出异常</span><br><span class="line">public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，并删除表头节点，表头为空返回 null</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表头</span><br><span class="line">public void push(E e) &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表头元素</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>1、LinkedList 的底层结构是一个带头/尾指针的双向链表，可以快速的对头/尾节点 进行操作。</p><p>2、相比数组，链表的特点就是在指定位置插入和删除元素的效率较高，但是查找的 效率就不如数组那么高了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList实现原理_探险</title>
      <link href="/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p><p>由上文注释可以大概得知：ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认容量的大小</span><br><span class="line">private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空数组常量</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的空数组常量</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存放元素的数组，可以发现 ArrayList 的底层实现就是一个 Object数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组中包含的元素个数</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组的最大上限 </span><br><span class="line">private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALU E - 8;</span><br></pre></td></tr></table></figure><p>ArrayList 的属性非常少，就只有这些。其中最重要的莫过于 elementData 了，ArrayList 所有的方法都是建立在 elementData 之上。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity]; </span><br><span class="line">    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中可以看出，默认情况下，elementData 是一个大小为 0 的空数组，当我们指定了初始大小的时候，elementData 的初始大小就变成了我们所指定的初始大小了。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; size)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg (index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 ArrayList 是采用数组结构来存储的，所以它的 get 方法非常简单，先是判断一下有没有越界，之后就可以直接通过数组下标来获取元素了，所以 get 的时间复杂 度是 O(1)。</p><h2 id="3-add方法"><a href="#3-add方法" class="headerlink" title="3 add方法"></a>3 add方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    &#x2F;&#x2F;调用一个 native 的复制方法，把 index 位置开始的元素都往后挪一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, inde x + 1, size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacit y);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 的 add 方法也很好理解，在插入元素之前，它会先检查是否需要扩容，然 后再把元素添加到数组中最后一个元素的后面。在 ensureCapacityInternal 方法中， 可以看见，如果当 elementData 为空数组时，它会使用默认的大小去扩容。所以 说，通过无参构造方法来创建 ArrayList 时，它的大小其实是为 0 的，只有在使用到 的时候，才会通过 grow 方法去创建一个大小为 10 的数组。<br>第一个 add 方法的复杂度为 O(1)，虽然有时候会涉及到扩容的操作，但是扩容的次 数是非常少的，所以这一部分的时间可以忽略不计。如果使用的是带指定下标的 add 方法，则复杂度为 O(n)，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p><h2 id="4-set方法"><a href="#4-set方法" class="headerlink" title="4 set方法"></a>4 set方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 方法的作用是把下标为 index 的元素替换成 element，跟 get 非常类似，时间复杂度度为 O(1)。</p><h2 id="5-remove方法"><a href="#5-remove方法" class="headerlink" title="5 remove方法"></a>5 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(inderemove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。x);</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its wo rk</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。</p><h2 id="6-grow方法"><a href="#6-grow方法" class="headerlink" title="6 grow方法"></a>6 grow方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; minCapacity is usually close to size, so this is a wi n:</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 方法是在数组进行扩容的时候用到的，从中可以看见，ArrayList 每次扩容 都是扩 1.5 倍，然后调用 Arrays 类的 copyOf 方法，把元素重新拷贝到一个新的数组 中去。</p><h2 id="7-ize方法"><a href="#7-ize方法" class="headerlink" title="7 ize方法"></a>7 ize方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size 方法非常简单，它是直接返回 size 的值，也就是<strong>数组中元素的个数</strong>间 复杂度为 O(1)。这里要注意一下，返回的并不是数组的实际大小。</p><h2 id="8-indexOf-amp-lastIndexOf"><a href="#8-indexOf-amp-lastIndexOf" class="headerlink" title="8 indexOf &amp; lastIndexOf"></a>8 indexOf &amp; lastIndexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf 方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组 中每个元素的值来查找的，所以它的时间复杂度是 O(n)。</p><p>lastIndexOf 的原理跟 indexOf 一样，而它仅仅是从后往前找起罢了。</p><h1 id="四-Vector"><a href="#四-Vector" class="headerlink" title="四 Vector"></a>四 Vector</h1><p>很多方法都跟 ArrayList 一样，只是多加了个 synchronized 来保证线程安全,主要汇总二者不同点</p><p>Vector 比 ArrayList 多了一个属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩 capacityIncrement 个空间就 足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    this.capacityIncrement &#x3D; capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中，可以看出 Vector 的默认大小也是 10，而且它在初始化的时候就 已经创建了数组了，这点跟 ArrayList 不一样。再来看一下 grow 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 grow 方法中可以发现，newCapacity 默认情况下是两倍的 oldCapacity，而当 指定了 capacityIncrement 的值之后，newCapacity 变成了 oldCapacity+capacityIncrement。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h1><p>1、ArrayList 创建时的大小为 0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10</p><p>2、ArrayList 每次扩容都以当前数组大小的 1.5 倍去扩容。  3、Vector 创建时的默认大小为 10</p><p>4、Vector 每次扩容都以当前数组大小的 2 倍去扩容。当指定了 capacityIncrement 之 后，每次扩容仅在原先基础上增加 capacityIncrement 个单位空间。</p><p>5、ArrayList 和 Vector 的 add、get、size 方法的复杂度都为 O(1)，remove 方法的复 杂度为 O(n)。</p><p>6、ArrayList 是非线程安全的，Vector 是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-OpenResty用Lua语言实现简单服务</title>
      <link href="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/93c7612e-307f-4fe2-84c8-ac0e13a042e0.png" alt></p><a id="more"></a><p><a href="http://openresty.org/cn/" target="_blank" rel="noopener">Openresty官方站点</a></p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5f3c391e-6f44-44af-b4f9-f02244dda8b2.png" alt></p><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/f9783f7c-7a09-47ac-9971-b437c34d1a86.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.15.8.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf openresty-1.15.8.3.tar.gz </span><br><span class="line"></span><br><span class="line">cd openresty-1.15.8.3</span><br><span class="line"></span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h3 id="2-分析目录结构"><a href="#2-分析目录结构" class="headerlink" title="2 分析目录结构"></a>2 分析目录结构</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/7944541f-db36-4847-a046-9d2cea4a65e0.png" alt></p><p>看出与 nginx相比 少了很多东西，都在 bundle模块下，核心为 nginx-x模块。</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/560b6198-f80c-43f2-b7e1-a109ffcfcb95.png" alt></p><p>主要分为 两大模块<br><strong>nginx c代码模块</strong>，通常以 ngx打头。<br><strong>lua模块</strong>，使用 ngx c代码模块提供的功能。</p><p>编译时也主要是编译 <strong>C模块</strong></p><p>观看 openresty 的configure模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p>基本没有什么不同，只不过集合了更多的第三方模块。<br><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/2c32f29e-6114-4fec-beb4-1b663cdef9e3.jpg" alt></p><h3 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认, &#96;--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#96; 程序会被安装到&#x2F;usr&#x2F;local&#x2F;openresty目录。</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="4-添加lua代码"><a href="#4-添加lua代码" class="headerlink" title="4 添加lua代码"></a>4 添加lua代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">因为被安装到了这里，所以进入这个目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">添加如下内容</span><br><span class="line"></span><br><span class="line">location &#x2F;lua &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        content_by_lua</span><br><span class="line">           &#39;ngx.say(&quot;User-Agent: &quot;, ngx.req.get_headers()[&quot;User-Agent&quot;])&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -c conf&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>浏览器输入 192.168.121.100:80</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5a886d20-993f-4a00-b51b-492b6fdbe3a7.png" alt></p><p>浏览器输入 192.168.121.100:80/lua</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/3abd7c85-86d2-47bd-94aa-d58a42498346.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Openresty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Openresty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-SSL-Nginx</title>
      <link href="/2019/11/11/9-SSL-Nginx/"/>
      <url>/2019/11/11/9-SSL-Nginx/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络安全是当前非常受到关注的一个问题，大部分站点都是通过 <strong>HTTPS</strong> 来实现安全访问。如何将自己的站点改造成 <strong>HTTPS</strong> 站点呢？我们需要了解 <strong>SSL</strong> 协议。</p><h2 id="知识普及"><a href="#知识普及" class="headerlink" title="知识普及"></a>知识普及</h2><ul><li>TLS/SSL 发展历程<br><img src="/2019/11/11/9-SSL-Nginx/c97e2236-9c76-47a7-8101-c6a81360c5d0.jpg" alt><a id="more"></a></li><li>TLS安全密码套件解读</li></ul><p>抓包或者观察服务器端的配置时，可看到下图</p><p><img src="/2019/11/11/9-SSL-Nginx/b90659c2-af11-44dd-96c1-e06f39232949.jpg" alt></p><h3 id="概要介绍"><a href="#概要介绍" class="headerlink" title="概要介绍"></a>概要介绍</h3><p><strong>ECDHE</strong>: 密钥交换算法（此处是一个椭圆曲线加密算法），用来解决浏览器与服务器则那样独立生成相同的密钥，接下来会用此密钥加密数据。</p><p><strong>RSA</strong>: 身份验证算法。密钥交换过程中，需要验证各自身份。</p><p>数据加密、解密时要用到对称加密算法，即 <strong>AES_128_GCM</strong></p><p><strong>AES</strong>: 算法名称</p><p><strong>128</strong>：AES支持3种加密强度，此处使用 128</p><p><strong>GCM</strong>：AES有很多分组模式，GCM是较新的一种模式，可以提高多核CPU下加解密的性能。</p><p><strong>SHA256</strong>: 摘要算法，用来把不定长度的字符串生成一个固定长度的更短的摘要。</p><h4 id="对称加密-VS-非对称加密"><a href="#对称加密-VS-非对称加密" class="headerlink" title="对称加密 VS 非对称加密"></a>对称加密 VS 非对称加密</h4><h5 id="对称加密（同一把密钥）"><a href="#对称加密（同一把密钥）" class="headerlink" title="对称加密（同一把密钥）"></a>对称加密（同一把密钥）</h5><p><img src="/2019/11/11/9-SSL-Nginx/5e4ccaf3-a19e-418e-91a8-618eebf304d0.jpg" alt></p><p>使用相同的 密钥序列 进行 异或运算，第一次加密，再异或一次即解密。<br><img src="/2019/11/11/9-SSL-Nginx/4252405b-8e3e-4396-97aa-e0862c67a72f.jpg" alt></p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>同一份文档，用<strong>公钥</strong>加密的，只能用对应的<strong>私钥</strong>进行解密</p><p><img src="/2019/11/11/9-SSL-Nginx/3d318d9b-74f0-49b5-8ef1-53c5eb195619.jpg" alt></p><ul><li><p>文档加密</p></li><li><p>身份验证</p></li></ul><h4 id="SSL证书公信力的保证"><a href="#SSL证书公信力的保证" class="headerlink" title="SSL证书公信力的保证"></a>SSL证书公信力的保证</h4><p>爱丽丝 与 鲍勃 进行通信，但有个前提条件，爱丽丝就是爱丽丝，鲍勃就是鲍勃，这样一个新问题，在多方通讯过程中必须有一个公信机构，即 <strong>CA机构</strong></p><p><strong>CA是怎样颁发证书，使证书过期的呢?</strong></p><p><strong>PKI公钥基础设施</strong><br><img src="/2019/11/11/9-SSL-Nginx/f539cc97-f8b6-421f-80a3-47ee62687cfd.jpg" alt></p><p><font color="red">流程：</font></p><p>图中的<strong>CA</strong>即是一个公信机构，用来颁发证书的。</p><p>我们作为一个站点的维护者，就是一个 <strong>证书订阅人</strong>，首先我们要去申请一个证书，必要要登记（我是谁、我属于什么组织、我想做什么）</p><p>到了登记机构后，通过 <strong>CSR</strong> 发送给 <strong>CA</strong>，申请通过后。</p><p><strong>CA</strong>会生成一对公私钥，公钥保存在CA的证书链中，公私钥被证书订阅人拿到后。</p><p><strong>证书订阅人</strong> 会把拿到的公私钥部署到自己的 <strong>Web服务器</strong>，如 Nginx服务器等。</p><p>当 <strong>浏览器</strong>通过 第 1 步 访问我们的 HTTPS站点时，会去请求我们的证书，而Nginx这样的Web站点服务器 会将我们的 <strong>公钥证书</strong> 发给我们的浏览器。 浏览器需要去验证 我们颁发给他的证书是否 <strong>合法有效</strong></p><p>如果我们用 <strong>Let’s encrypt</strong> 会发现证书只有 90天的有效期。而用其他的SSL-CA可能会有1年的有效期。</p><p><strong>有效期如何体现</strong>： CA中心 会把过期的证书放到 <strong>CRL服务器</strong>中</p><p><strong>CRL服务器</strong>会把所有的过期证书形成一个很长很长的链条，性能极差。</p><p>所以又推出一个称为 <strong>OCSP响应程序</strong>，它可以就一个证书去查询是否过期。 因此 <strong>浏览器</strong>可以直接查询 <strong>OCSP响应程序</strong>，但 OCSP 性能依然不高。</p><p>因此，我们的 <strong>Nginx Web服务器</strong> 往往会有一个 <strong>OCSP开关</strong>，当打开时，会由 <strong>Nginx</strong> 主动地去<strong>OCSP</strong>查询, 这样，大量的客户端可以直接从 <strong>Nginx</strong> 服务器获取到证书是否有效。</p><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><p><img src="/2019/11/11/9-SSL-Nginx/9f804386-3565-4c92-8a82-ae32e6a9afaa.jpg" alt></p><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>浏览器对 DV OV EV 验证效果是一样的，唯一区别的 就是他的 证书链。</p><p><img src="/2019/11/11/9-SSL-Nginx/a6f3f984-33c9-46cc-a6e8-842e9849c9f5.jpg" alt></p><p>目前所有站点的 主证书都是有 3级结构。<strong>根证书、二级证书、主证书</strong>。</p><p>为什么形成这样的3级证书结构呢？</p><p>那是因为 根证书的 验证十分谨慎，像 Window 、 Android 等操作系统 每 1年以上才会去更新它的根证书库。所以，一个新的根证书库CA机构是很难快速加入到操作系统、浏览器认可的证书库中的。</p><p>大部分浏览器使用的是操作系统的根证书库，像Firefox可能会维护自己的根证书库。所以浏览器在验证我们的证书是否有效时，最主要是验证 根证书是否无过期，有效。</p><p>Nginx 服务器向 浏览器发送 两个证书（主证书、二级证书）即可。根证书是被操作系统、浏览器内置的，无需发送。</p><h4 id="SSL协议握手时Nginx的性能瓶颈"><a href="#SSL协议握手时Nginx的性能瓶颈" class="headerlink" title="SSL协议握手时Nginx的性能瓶颈"></a>SSL协议握手时Nginx的性能瓶颈</h4><h5 id="TLS通讯过程"><a href="#TLS通讯过程" class="headerlink" title="TLS通讯过程"></a>TLS通讯过程</h5><p><img src="/2019/11/11/9-SSL-Nginx/64515879-b4e9-46d9-85f0-49ad2d5f8b86.png" alt></p><p><font color="red">流程：</font></p><ul><li><p>1 Client Hello 浏览器发给服务器。因为我们的浏览器是非常多元化的。Chrome、IE、FireFox等。浏览器的版本也在不停的变更。不同的浏览器所支持的安全套件、加密算法是不同的。因此在第一步，主要是告诉服务器，我支持哪些算法。</p></li><li><p>2 Server Hello 如 Nginx会有一个自己知道自己可支持的加密算法列表，以及自己倾向于使用哪一个加密算法套件，Nginx会选择自己最喜欢的一个加密算法套件发送给客户端。如果想复用 Session，即 Nginx 打开了 Session Cache ，希望一天内断开了连接的客户端，不用再次协商密钥，在这一步可以直接复用之前的密钥。因此 这一步主要是发送 究竟我们选择哪一个安全套件</p></li><li><p>3 Server Certificates 会把自己的公钥证书发送给浏览器，公钥证书中是包含证书链的，所以浏览器可以找到自己的跟证书库，去验证证书是否有效。<strong>Check Certificate validity</strong></p></li><li><p>4 Server Hello Done 服务器会发送此消息，但如果之前协商的安全套件，如椭圆曲线算法，此时需要在 3 与 4 之间 将椭圆曲线的参数发送给客户端。以方便我们在 6 生成最终加密的密钥。</p></li><li><p>5 ClientKey Exchange Message 客户端也需要根据椭圆曲线的公共参数生成自己的私钥后，将公钥发送给服务器。此时，服务器也有了自己的私钥，将公钥发送给客户端。</p></li><li><p>6  Key generation 服务器可以根据自己的私钥和客户端的公钥共同生成双方加密的密钥， 客户端可以根据自己的私钥和服务器的公钥共同生成双方加密的密钥。这两个各自生成的密钥是相同的。这是由 非正式加密算法来保证的。</p></li><li><p>7 CipherSpec Exchange Finished 接下来就可以用生成的密钥进行数据加密与通讯了。</p></li></ul><p><strong>由上述过程可以看到，TLS通讯过程主要是做 交换密钥 + 加密数据</strong>，这两个最耗费性能。</p><h5 id="Nginx优化性能"><a href="#Nginx优化性能" class="headerlink" title="Nginx优化性能"></a>Nginx优化性能</h5><p>对于小文件。握手是主要影响他 QPS性能的主要指标</p><p><img src="/2019/11/11/9-SSL-Nginx/cc318a18-f172-4688-8496-aa81fbf22abc.jpg" alt></p><h5 id="Nginx数据加密性能"><a href="#Nginx数据加密性能" class="headerlink" title="Nginx数据加密性能"></a>Nginx数据加密性能</h5><p><img src="/2019/11/11/9-SSL-Nginx/b18c290e-fbd4-4cf5-8ffe-199e8b7ccdcf.jpg" alt></p><h5 id="Nginx综合性能"><a href="#Nginx综合性能" class="headerlink" title="Nginx综合性能"></a>Nginx综合性能</h5><p>当以小文件为主时，考虑优化Nginx非对称加密性能（椭圆曲线）。<br>当以大文件为主时，考虑优化Nginx非对称加密性能（AES）。<br><img src="/2019/11/11/9-SSL-Nginx/f926e156-3fa6-4969-9b6e-70b174299402.jpg" alt></p><h2 id="免费SSL实现HTTPS站点"><a href="#免费SSL实现HTTPS站点" class="headerlink" title="免费SSL实现HTTPS站点"></a>免费SSL实现HTTPS站点</h2><p><strong>前提：</strong></p><ol><li>拥有一个域名，且ICP备案。</li><li>在域名服务器创建一条A记录，指向云主机的公网IP地址。例如demo.mydomain.com指向xxx.xxx.xxx.xxx的IP地址。</li><li>要等到新创建的域名解析能在公网上被解析到。</li></ol><p><img src="/2019/11/11/9-SSL-Nginx/a12032d4-c88b-4387-aec6-9fd44a280024.jpg" alt></p><p>演示如何使用 <strong>Let’s encrypt</strong> 生成免费的DV证书，将网站改造为 https站点。</p><h3 id="1-http协议请求标识"><a href="#1-http协议请求标识" class="headerlink" title="1 http协议请求标识"></a>1 http协议请求标识</h3><p><img src="/2019/11/11/9-SSL-Nginx/df826605-29a0-4e52-a185-b581eb423338.jpg" alt><br>没有小锁，说明现在是一个 http请求。</p><h3 id="2-Nginx-conf配置"><a href="#2-Nginx-conf配置" class="headerlink" title="2 Nginx.conf配置"></a>2 Nginx.conf配置</h3><p><img src="/2019/11/11/9-SSL-Nginx/d19e0b8a-2dcf-49ed-bba7-ba4aff4eb8f6.jpg" alt></p><p>在<strong>server</strong>中，有一个 server_name，这个域名会被 <strong>Let’s encrypt</strong>脚本所使用，<strong>location</strong> 指向了一个具体的文件</p><h3 id="3-脚本安装与使用"><a href="#3-脚本安装与使用" class="headerlink" title="3 脚本安装与使用"></a>3 脚本安装与使用</h3><p><a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install python2-certbot-nginx</span><br><span class="line"></span><br><span class="line">不成功的话，下面方法可以考虑，但要慎用，因为要做全面更新</span><br><span class="line"></span><br><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum install python2-certbot-nginx</span><br></pre></td></tr></table></figure><p>该工具会提供一个命令  <strong>certbot</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx --nginx-server-root&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openrestry&#x2F;nginx&#x2F;conf&#x2F; -d geektime.taohui.pub</span><br></pre></td></tr></table></figure><p>–nginx 会为nginx的配置文件自动执行相应的修改，通常默认会去修改 /usr/local/nginx/conf/ 下的配置文件，但此处因为路径不同，所以使用</p><p>–nginx-server-port 单独指定nginx.conf所在路径。</p><p>-d 指定 申请证书的域名。</p><p><img src="/2019/11/11/9-SSL-Nginx/8e6b10a7-a712-4016-b9b9-47d352a53654.jpg" alt></p><p>首先会去获取一个证书，验证证书，投放证书到配置文件。<br>1：不做重定向。（此处选择1）<br>2：做重定向。</p><p>区别：当有了 https站点后，希望所有的http流量，明文显示的不安全流量都是用 301 、302重定向协议转到https站点。</p><p><strong>HTTPS站点标识</strong><br><img src="/2019/11/11/9-SSL-Nginx/75ac2b42-8b6c-4479-ab0c-8ca3953cd045.jpg" alt></p><p>此时查看 nginx.conf,增加了5行</p><p><img src="/2019/11/11/9-SSL-Nginx/4fa55fe8-ee24-4191-9cf2-6de0f40a54bf.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">监听443端口 使用ssl协议</span><br><span class="line"></span><br><span class="line">ssl_certificate 、 ssl_certificate_key 分别为公私钥证书部署到对应的路径中。</span><br><span class="line"></span><br><span class="line">include 通用参数加了进来</span><br><span class="line"></span><br><span class="line">ssl_dhparam:表示使用非对称加密时，使用怎样的参数，这些参数决定网络加密的强度</span><br></pre></td></tr></table></figure><p>看一下 <code>/etc/letsencrypt/options-ssl-nginx.conf</code></p><p><img src="/2019/11/11/9-SSL-Nginx/9217ebcd-3850-4766-b60a-2b12cb122f05.jpg" alt></p><p>ssl中最降低性能的就是握手，因此设置了一个 ssl_session_cache ，大小为1M。在 1440m（分钟）即1天 时间内可以复用之前的。</p><p>ssl_protocols: ssl支持哪些版本的协议。</p><p>ssl_perfer_server_ciphers on 表示nginx服务器使用那些协议与浏览器进行通讯。</p><p>ssl_ciphers 中的安全套件以 分号为分隔符。排在前面的会优先使用。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> SSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-Nginx配置文件简易解析</title>
      <link href="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png" alt></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#运行用户</span><br><span class="line">user nobody;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"></span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # nginx作为http服务器的时候</span><br><span class="line"># max_clients &#x3D; worker_processes * worker_connections</span><br><span class="line">    # nginx作为反向代理服务器的时候：</span><br><span class="line">#max_clients &#x3D; worker_processes * worker_connections &#x2F; 4  </span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6].&quot;;</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"></span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"></span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs&#x2F;nginx.access.log  main;</span><br><span class="line"></span><br><span class="line">        #默认请求</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^&#x2F;(images|javascript|js|css|flash|media|static)&#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ &#x2F;.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-Nginx安装详解</title>
      <link href="/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx是一款轻量级高性能的Web服务器/反向代理服务器，</p><p>并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，<br>中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><a id="more"></a><h1 id="1-新方法安装"><a href="#1-新方法安装" class="headerlink" title="1 新方法安装"></a>1 新方法安装</h1><p><strong>Nginx是C语言开发，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. gcc安装</span><br><span class="line">yum install gcc-c++</span><br><span class="line">2. PCRE pcre-devel安装</span><br><span class="line">PCRE（Perl Compatible Regular Expressions）是一个Perl库，包括perl兼容的正则表达式。Nginx的http模块使用pcre来解析正则表达式。所以需要在linux安装pcre库。pcre-devel是pcre开发的一个二次开发库，nginx也需要此命令。</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">3. zlib安装</span><br><span class="line">zlib库提供了很多种压缩和解压额方式，Nginx使用zlib对http包的内容进行gzip，所以需要</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">4. Open-SSL安装</span><br><span class="line">OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法，常用的密钥和证书封装管理功能以及SSL协议，并提供丰富的应用程序供测试或其他目的。</span><br><span class="line">Nginx不仅支持http协议，还支持https（在ssl协议上传输http）,所以需要安装OpenSSL库</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h1 id="2-老方法安装"><a href="#2-老方法安装" class="headerlink" title="2 老方法安装"></a>2 老方法安装</h1><ol><li><p>安装gcc</p><p> rpm -Uvh glibc-2.12-1.209.el6_9.2.x86_64.rpm glibc-common-2.12-1.209.el6_9.2.x86_64.rpm libgcc-4.4.7-18.el6_9.2.x86_64.rpm tzdata-2018e-3.el6.noarch.rpm </p><p> rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm cpp-4.4.7-18.el6_9.2.x86_64.rpm glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm     kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm libgomp-4.4.7-18.el6_9.2.x86_64.rpm mpfr-2.4.1-6.el6.x86_64.rpm ppl-0.10.2-11.el6.x86_64.rpm </p><p> rpm -ivh gcc-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装gcc-c++<br> rpm -Uvh libstdc++-4.4.7-18.el6_9.2.x86_64.rpm<br> rpm -ivh libstdc++-devel-4.4.7-18.el6_9.2.x86_64.rpm  gcc-c++-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装pcre<br> tar -zxvf pcre-8.40.tar.gz<br> cd pcre-8.40<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装zlib</p><p> tar -zxvf zlib-1.2.11.tar.gz<br> cd zlib-1.2.11<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装启动</p><p> ./configure –prefix=/usr/local/nginx  配置nginx 并且指定nginx的安装目录</p><p> make &amp;&amp; make install</p><p> cd /usr/local/nginx/sbin</p><p> netstat -ano | grep 80     //检查80端口是否占用</p><p> ./nginx -c /usr/local/nginx/conf/nginx.conf</p><p> 注意：</p><pre><code>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：ln -s /usr/local/lib/libpcre.so.1 /lib64/</code></pre></li></ol><hr><p>Nginx运行和控制<br>    /usr/local/nginx/sbin/nginx 命令</p><pre><code>nginx命令参数：不像许多其他软件系统，Nginx 仅有几个命令行参数，完全通过配置文件来配置。参数如下：-s reload | reopen | stop 进程相关（重新载入配置文件 | 重启Nginx | 停止Nginx）-c &lt;/path/to/config&gt; 为 Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。-v 显示 nginx 的版本。-V 显示 nginx 的版本，编译器版本和配置参数。</code></pre><hr><p>nginx负载均衡</p><p>1.常用的负载均衡策略<br>    a. 轮询（默认）<br>    每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>    upstream backserver {<br>        server 192.168.0.14;<br>        server 192.168.0.15;<br>    }<br>    b. 指定权重<br>    指定轮询几率（权重默认为1），weight和访问比率成正比，用于后端服务器性能不均的情况。<br>    upstream backserver {<br>        server 192.168.0.14 weight=10;<br>        server 192.168.0.15 weight=10;<br>    }<br>    c. IP绑定 ip_hash<br>    每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>    upstream backserver {<br>        ip_hash;<br>        server 192.168.0.14:88;<br>        server 192.168.0.15:80;<br>    }</p><ol start="2"><li><p>完整配置</p><p> #添加tomcat列表，真实应用服务器都放在这<br> upstream tomcat_pool {</p><pre><code>#server tomcat地址:端口号 weight表示权值，权值越大，被分配的几率越大;</code></pre><p>　　    server 192.168.0.223:8080 weight=4 max_fails=2 fail_timeout=30s;<br> 　　server 192.168.0.224:8080 weight=4 max_fails=2 fail_timeout=30s;<br> }</p><p> server{</p><pre><code>......</code></pre></li></ol><pre><code>    location / {        proxy_pass    http://tomcat_pool;    #转向tomcat处理    }    ......}</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-GoAccess实现可视化并实时监控access日志</title>
      <link href="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>access日志</strong> 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。使用 cat、awk、sed 等命令做一些简单的日志分析统计，这样分析结果不理想也不全面，方法也极不高效。</p><p><strong>GoAccess</strong> 这款工具以图形化的方式通过<strong>web socket</strong>协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。</p><a id="more"></a><h2 id="1-Nginx配置"><a href="#1-Nginx配置" class="headerlink" title="1 Nginx配置"></a>1 Nginx配置</h2><p>为了提高 GoAccess 分析准确度，需要配置 <code>nginx.conf</code> 的 log_format 项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_body&quot;&#39;;</span><br></pre></td></tr></table></figure><h2 id="2-安装GoAccess"><a href="#2-安装GoAccess" class="headerlink" title="2 安装GoAccess"></a>2 安装GoAccess</h2><p><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess</a> 是这个工具的站点。如图所示：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/629f3358-d5c5-4889-b24f-bc4e6a87c46b.png" alt></p><p>先看一下之前静态web资源服务器所产生的access log日志格式<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/9f36080a-71ba-4c59-82e8-226d730d87a1.png" alt></p><p>现在打开 GoAccess中的 <strong>Get started</strong>快速开始页面，依据文档下载安装。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/615f6899-491f-4f74-a245-feb5f3a9c0b3.png" alt></p><p>先下载依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y GeoIP-devel</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;maxmind&#x2F;geoip-api-c&#x2F;releases&#x2F;download&#x2F;v1.6.11&#x2F;GeoIP-1.6.11.tar.gz</span><br><span class="line">tar -zxvf GeoIP-1.16.11.tar.gz</span><br><span class="line">cd GeoIP-1.16.11</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;tar.goaccess.io&#x2F;goaccess-1.3.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.3.tar.gz</span><br><span class="line">cd goaccess-1.3&#x2F;</span><br><span class="line">.&#x2F;configure --enable-utf8 --enable-geoip&#x3D;legacy --with-openssl  &#x2F;&#x2F;此处出现错误如下 安装下面依赖后回来继续安装即可</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>出现错误：<br>configure: error: *** Missing development libraries for ncursesw</p><p>解决方法：<br>要使用–enable-utf8，你需要安装ncursesw，下面是安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun goaccess]# sudo yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>安装成功后：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/dae8664f-26c8-45d9-b7ae-957833eae1fa.png" alt></p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h2><p>安装完成后，默认将配置文件<code>goaccess.conf</code>放置于<code>/usr/local/etc</code>路径，为了统一管理，使用<code>mv /usr/local/etc/goaccess.conf /etc/</code>命令将其移动到<code>/etc</code>目录下。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/5a428874-2d04-42df-ad85-07cbbc719e50.png" alt></p><p>对配置文件做一些主要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;goaccess.conf</span><br><span class="line"></span><br><span class="line">time-format %H:%M:%S</span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br><span class="line">log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/2120efc0-f319-469d-a88e-8639b9f58a17.png" alt></p><p>其中，log-format 与 access.log 的 log_format 格式对应，每个参数以空格或者制表符分割。参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%t  匹配time-format格式的时间字段</span><br><span class="line">%d  匹配date-format格式的日期字段</span><br><span class="line">%h  host(客户端ip地址，包括ipv4和ipv6)</span><br><span class="line">%r  来自客户端的请求行</span><br><span class="line">%m  请求的方法</span><br><span class="line">%U  URL路径</span><br><span class="line">%H  请求协议</span><br><span class="line">%s  服务器响应的状态码</span><br><span class="line">%b  服务器返回的内容大小</span><br><span class="line">%R  HTTP请求头的referer字段</span><br><span class="line">%u  用户代理的HTTP请求报头</span><br><span class="line">%D  请求所花费的时间，单位微秒</span><br><span class="line">%T  请求所花费的时间，单位秒</span><br><span class="line">%^  忽略这一字段</span><br></pre></td></tr></table></figure><h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4 命令"></a>4 命令</h2><p>查看 GoAccess 命令参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -h</span><br><span class="line"># 常用参数</span><br><span class="line">-a --agent-list 启用由主机用户代理的列表。为了更快的解析，不启用该项</span><br><span class="line">-d --with-output-resolver 在HTML&#x2F;JSON输出中开启IP解析，会使用GeoIP来进行IP解析</span><br><span class="line">-f --log-file 需要分析的日志文件路径</span><br><span class="line">-p --config-file 配置文件路径</span><br><span class="line">-o --output 输出格式，支持html、json、csv</span><br><span class="line">-m --with-mouse 控制面板支持鼠标点击</span><br><span class="line">-q --no-query-string 忽略请求的参数部分</span><br><span class="line">--real-time-html 实时生成HTML报告</span><br><span class="line">--daemonize 守护进程模式，--real-time-html时使用</span><br></pre></td></tr></table></figure><h2 id="5-控制台模式"><a href="#5-控制台模式" class="headerlink" title="5 控制台模式"></a>5 控制台模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log -p &#x2F;etc&#x2F;goaccess.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/8378f7b8-273a-4740-8ceb-4d961484c9e7.png" alt></p><p>控制台下的操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F1 主帮助页面</span><br><span class="line">F5 重绘主窗口</span><br><span class="line">q 退出</span><br><span class="line">1-15 跳转到对应编号的模块位置 </span><br><span class="line">o 打开当前模块的详细视图</span><br><span class="line">j 当前模块向下滚动</span><br><span class="line">k 当前模块向上滚动</span><br><span class="line">s 对模块排序</span><br><span class="line">&#x2F; 在所有模块中搜索匹配</span><br><span class="line">n 查找下一个出现的位置</span><br><span class="line">g 移动到第一个模块顶部</span><br><span class="line">G 移动到最后一个模块底部</span><br></pre></td></tr></table></figure><h2 id="6-HTML模式"><a href="#6-HTML模式" class="headerlink" title="6 HTML模式"></a>6 HTML模式</h2><p>上游服务器（14）： /home/geek/nginx  其中的 nginx.conf 配置为 127.0.0.1:8080 即仅能本机访问。</p><p>代理服务器（16）： /usr/local/geek/openstry/nginx 其中 nginx.conf 配置了 upstream 来标明上游服务器的ip地址+端口号，同时也设置了相应的缓存，具体查看前几节文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html</span><br></pre></td></tr></table></figure><p>浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.121.100:80&#x2F;go-access.html 即可看到</span><br><span class="line"></span><br><span class="line">上述配置都是在上游nginx服务器中完成的</span><br><span class="line">此处是使用了代理服务器的80端口，由代理服务器替我们到上游服务器获取go-access.log 实时日志以html页面展示</span><br></pre></td></tr></table></figure><p>由下图可看到，确实是由 代理服务器替我们拿到的数据<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/1d80d359-8e05-421c-9637-e799599b0de8.png" alt></p><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><p>GoAccess 已经为我们考虑到这点了，它可以以 daemonize 模式运行，并提供创建实时 HTML 的功能，只需要在启动命令后追加<code>--real-time-html --daemonize</code>参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html --real-time-html --daemonize</span><br><span class="line"></span><br><span class="line"># 监听端口7890</span><br><span class="line">netstat -tunpl |grep &quot;goaccess&quot;</span><br><span class="line">tcp        0      0 0.0.0.0:7890            0.0.0.0:*               LISTEN      13212&#x2F;goaccess</span><br></pre></td></tr></table></figure><p>以守护进程启动 GoAccess 后，使用 Websocket 建立长连接，它默认监听 7890 端口，可以通过<code>--port</code>参数指定端口号。</p><blockquote><p>如果站点启用了 HTTPS, GoAccess 也需要使用 openssl，在配置文件<code>goaccess.conf</code>中配置<code>ssl-cert</code>和<code>ssl-key</code>项，并确保在安装过程中 configure 时已添加<code>--with-openssl</code>项来支持 openssl 。当使用 HTTPS 后 Websocket 通信时也应该使用 wss 协议，需要将<code>ws-url</code>项配置为<code>wss://www.domain.com</code>。</p></blockquote><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>在某些场景下，没有这样的实时性要求，可采用 crontab 机制实现定时更新 HTML 报表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 每天执行</span><br><span class="line"></span><br><span class="line">0 0 1 * * goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html 2&gt; &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;go-access.log</span><br></pre></td></tr></table></figure><p>当access 日志被切割后，怎么合理使用 GoAccess 分析日志，<code>--keep-db-files</code>这个功能倒是可以尝试，这样就可以只分析新生产的日志文件了。</p><h2 id="7-不足"><a href="#7-不足" class="headerlink" title="7 不足"></a>7 不足</h2><p>尽管 GoAccess 很强大，但是它无法制定自定义监控规则，无法满足对站点更细粒度更全面的监控需求。此时就要使用到 ELK日志平台来分析站点的访问情况和流量分析。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Tools </category>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Tools </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Nginx搭建具备缓存功能的反向代理</title>
      <link href="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经展示了<strong>Nginx</strong>如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-<strong>上游服务</strong>，再搭建一个Nginx服务，作为<strong>反向代理</strong>，演示当Nginx作为方向代理时，应该如何使用？</p><p>由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，</p><a id="more"></a><p>现在这个页面仍然是我们刚才搭建的静态资源服务器所展示的页面。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/df2a42be-0e03-4eba-b963-00566fe3011b.jpg" alt></p><p>我们需要将此Nginx服务器变更为<strong>上游服务器</strong>，而上游服务器通常对公网是不进行访问的。我们可以做一个非常简单的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim conf&#x2F;nginx.conf</span><br><span class="line">   server &#123;</span><br><span class="line">        listen      127.0.0.1:8080;</span><br><span class="line">       # server_name  localhost;</span><br><span class="line"></span><br><span class="line"># 在listen上加入IP地址：127.0.0.1:8080</span><br><span class="line">这表示只能本机的进程来访问我们打开的8080端口，</span><br><span class="line"></span><br><span class="line"># 此时我们需要先将原先的Nginx进程停掉</span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line"># 再重新打开Nginx，防止之前的端口仍然可以使用</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/ff657493-3010-44aa-8983-412cc49d08b0.png" alt></p><p>再次访问时，会发现无法访问了，因为Nginx拒绝了由浏览器发过去的请求连接。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/043e0d0a-61f5-4acc-8730-288adfb9ea29.png" alt></p><p>由此，Nginx静态资源服务器已经变成了一个上游服务器。</p><h1 id="1-开始搭建Nginx反向代理"><a href="#1-开始搭建Nginx反向代理" class="headerlink" title="1 开始搭建Nginx反向代理"></a>1 开始搭建Nginx反向代理</h1><p>之前的 <strong>Nginx</strong> 是1.14版本，而反向代理我们用openrestry的1.16版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun sbin]# .&#x2F;nginx -v</span><br><span class="line">nginx version: nginx&#x2F;1.14.2</span><br></pre></td></tr></table></figure><p>我们进入到openresty所在的nginx服务，修改其配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 在此处添加一个 upstream，即上游服务其中的一台server，它的访问地址是 127.0.0.1:8080</span><br><span class="line"># 如果我有很多上游服务，可以依次放在这里面。（命名为 local,此处可表示一批上游服务器）</span><br><span class="line">  #gzip  on;</span><br><span class="line">    upstream local&#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # 此处设置当前代理服务器的域名，由于没有，就算了</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            # proxy_set_header：因为有了一台反向代理，所以我们再去拿一些变量或者值的时  候，可能就会出错了，</span><br><span class="line">            # 比如：一个TCP连接，是有对端地址的，而有了方向代理后，我们的              反向代理与客户端是一个TCP连接，而反向代理与上游服务器又是另外一个TCP连接，因此，如果我们取 $remote_addr 这个远端地址的时候，在上游服务那里，取到的实际上师我反向代理服务器的地址，而如果我想拿浏览器的客户端地址，作为限制浏览器访问速度功能的一个依据时，其实是拿不到的。因此，proxy_set_header可以把一些值添加为新的header发送给上游服务器，</span><br><span class="line">            # 比如说 X-Real-IP 将它的值设置为我们从TCP连接中拿到的远端IP地址，Host同样道理，因为用户直接访问的域名，是在他的浏览器中输入的，即可由上游服务器处理此域名，也可由反向代理服务器处理此域名，这些所有的配置特性，都可在官网的 http_proxy_module模块中找到。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            # http_proxy_module提供了非常丰富的特性+内置变量，而最重要之一特性就是 proxy_cache。</span><br><span class="line">            # 因为当我们的Nginx作为方向代理时，通常只有动态的请求，即不同的用户访问同一个URL时，看到的内容是不同的，此时才会交由上游服务处理。</span><br><span class="line">            # 但是有一些内容可能是一段时间不会发生变化的。此时，为了减轻上游服务的压力，我们就会让Nginx将上游返回来的内容缓存一段时间，如缓存一天等。在一天之内，即使上游服务器对这个内容的响应发生了变化，也不管，只会去拿已缓存的内容向浏览器发出响应。</span><br><span class="line">            # 因为 Nginx的性能远远领先于上游服务器的性能，所以使用此特性后，对我们一些小的站点，会有非常大的性能提升。</span><br><span class="line">            #proxy_cache my_cache;</span><br><span class="line">            #proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            #proxy_cache_valid 200 304 302 1d;</span><br><span class="line">            # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2ab4b5f1-508b-47c5-af66-188ff2a9c828.png" alt></p><p>此时再去访问我们的代理服务器的IP地址，<strong>如果配置里域名，则用域名访问即可</strong>，因为监听的80端口，所以使用192.168.121.100:80/dangdang/book.html访问即可。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/14217284-3db6-4e6e-86ce-c6b7271843ef.jpg" alt></p><p>由下图可看出，我们的请求是由反向代理服务器发给我们的。其中的 <strong>server:nginx/1.16.0</strong>证明了它的身份。</p><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/06774664-cc31-4dbb-b5f5-bf44b60829d2.png" alt></p><h1 id="2-开始搭建Nginx缓存服务器"><a href="#2-开始搭建Nginx缓存服务器" class="headerlink" title="2 开始搭建Nginx缓存服务器"></a>2 开始搭建Nginx缓存服务器</h1><p>首先，我们需要<strong>proxy_cache_path</strong>来设置我们的缓存 文件写在那个目录下，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    proxy_cache_path &#x2F;tmp&#x2F;nginxcache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m max_size&#x3D;10g</span><br><span class="line">            inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            .....</span><br></pre></td></tr></table></figure><p>此处写在了 <code>/tmp/nginxcache</code>,以及这些文件的命名方式，这些文件的关键字是要放在共享内存中的，此处开了一个10m的共享内存，命名为my_cache，这些参数都在控制我们的缓存。</p><p>缓存如何使用呢？就是在我们需要做缓存的路径下添加<code>proxy_cache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       #server_name  haoraunsun.pub;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location &#x2F; &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">           proxy_set_header Host $host;</span><br><span class="line">           proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">           # 就在此处</span><br><span class="line">           # proxy_cache 后面跟的就是我们刚才开辟的共享内存</span><br><span class="line">           proxy_cache my_cache;</span><br><span class="line">           # 共享内存中的key设置的是 同一个url 访问时 对不同的用户可能展示的内容不一样。因此，用户这样一个变量就要放在共享内存中。</span><br><span class="line">           # 此处只是简单的放置了 host+资源+参数,这些作为一个整体的Key。</span><br><span class="line">           proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">           # 对于哪些响应不返回，这里做了一些简单处理。</span><br><span class="line">           proxy_cache_valid 200 304 302 1d;</span><br><span class="line">           </span><br><span class="line">           # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dbb3164a-c86b-45cd-97c4-4d0d228aeb3a.png" alt></p><p>加完这些参数后，需要重载配置文件，重新启用方向代理服务的配置。<br>再次直接访问站点，然后将上游服务停掉，看是否能获得同样的结果。</p><p>首先，我们再次访问，让其响应内容刷到缓存文件中。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/f116bae7-d1df-4716-9f3f-a5c461f0eb37.png" alt></p><p>查看进程<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/9733b5f7-3813-4f02-bf20-eda96a4c0ed0.png" alt></p><p>将上游服务停掉。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dfc0abce-1988-43f5-a4df-ae755de9af93.png" alt></p><p>再次访问，实际上读的是缓存系统中的内容作为响应返回给客户端。</p><p>此时，上游服务已经停掉了<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/a3d4faab-fcc5-4ce4-956f-7e75e52d8662.png" alt></p><p>再次访问<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/6f1b4d43-8144-49ac-8676-201d87902b4c.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Nginx搭建静态资源Web服务器</title>
      <link href="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font>`</p><h2 id="1-上传静态资源到Nginx目录中"><a href="#1-上传静态资源到Nginx目录中" class="headerlink" title="1 上传静态资源到Nginx目录中"></a>1 上传静态资源到Nginx目录中</h2><p>如这里新建了一个dlib目录，里面存放静态资源<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/534bed34-738b-47df-9819-997373f35987.png" alt></p><a id="more"></a><h2 id="2-修改-nginx-conf"><a href="#2-修改-nginx-conf" class="headerlink" title="2 修改 nginx.conf"></a>2 修改 nginx.conf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;  # 监听端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        # 现在的请求比较简单，所有的请求都去访问我们 dlib&#x2F; 目录下面的文件，所以此处建立一个location &#x2F;  这个 “斜杠”表示所有的请求，</span><br><span class="line">        # 然后要去指定 url的后缀 要与我文件目录下的后缀一一对应（文件名），此处有两种写法：1.route，有个问题，会将URL中的一些路径，带到我们的文件目录中来。所以通常使用  2 alias：即 Nginx安装目录中的 dlib目录下，后面的路径与我们的URL路径是一一对应的。</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">做完这些后，再去启动Nginx。</span><br><span class="line">.&#x2F;nginx -c ..&#x2F;conf&#x2F;nginx.conf 会发现找不到这个文件</span><br><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 即可</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/ec1f7e9f-05a4-41a8-9105-f636ec985a7b.jpg" alt></p><p><strong>192.168.121.100 为Nginx的服务器地址，8080是刚才配置的端口号，/dangdang/book.html是  dlib 目录下的 dangdang/book.html 。</strong></p><p><font color="red"><strong>但是此处有一个问题，打开访问页面的抓包查看</strong></font><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/324fabe1-d3b4-4f0a-aeae-5fbe99099406.jpg" alt></p><p>*<em>这里的book.html文件大小是3.0kB,与文件本身的大小是一致的。<font color="red">但是所有的文本文件是可以做 gzip 压缩的</font>，做完 gzip 压缩后，传递的字节数会大幅度减少，因此通常是 打开 gzip压缩功能。 *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 打开 gzip开关</span><br><span class="line">gzip  on;</span><br><span class="line"></span><br><span class="line"># 小于 1字节的内容就不再行压缩了（1是可以配置的，不带单位为字节，可带单位：5K 5M 5G）</span><br><span class="line">因为对于特表小的文本内容。在TCP一个报文中就可以全部发送出来。此时再进行压缩，去消耗CPU资源，意义不大，此处是为了显示 gzip压缩效果，将其设置为1。</span><br><span class="line">gzip_min_length  1;</span><br><span class="line"></span><br><span class="line"># 表示 gzip的压缩级别</span><br><span class="line">gzip_comp_level  2;</span><br><span class="line"></span><br><span class="line"># 表示针对列举的类型才进行gzip压缩。比如 已经做过压缩的文件是没有必要再做gzip压缩的（zip文件等）</span><br><span class="line">gzip_types  text&#x2F;plain application&#x2F;x-javascript test&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php  image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line"></span><br><span class="line">加好这些配置后 reload</span><br><span class="line">sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/81b273e2-ff17-4686-b7d4-9ff0c3a0e0d8.png" alt></p><p><strong>再次访问此文件：</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/63cef855-efb9-4663-8018-804306a4f37f.jpg" alt></p><p>此时传输的字节数只有1.6KB了，从响应头中也可看出使用了  gzip压缩。<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/d5decbbd-d47c-4472-a1ec-96b2d251f146.png" alt></p><p><strong>因此使用了 gzip 压缩后，整个静态资源 WEB服务，传输效率会提升很多。</strong></p><h2 id="3-Nginx常用功能"><a href="#3-Nginx常用功能" class="headerlink" title="3 Nginx常用功能"></a>3 Nginx常用功能</h2><h3 id="3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"><a href="#3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？" class="headerlink" title="3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"></a>3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？</h3><p><strong>Nginx 提供了 官方模块 <font color="red">auto_index_module</font>在官方网站<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a> 提供了使用说明</strong>。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on; # 加入此模块</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">执行 reload即可。</span><br><span class="line"></span><br><span class="line">192.168.121.100:8080&#x2F;</span><br><span class="line">192.168.121.100:8080&#x2F;dangdang&#x2F;</span><br><span class="line">即可看到如下页面，则成功。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/6e4bca87-3437-42e4-bef5-df5592e3e6df.png" alt></p><hr><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/69254aad-1999-4d64-ab86-4c5cae6cacb7.png" alt></p><p>这样会显示 指定层级下 所有的目录及文件。<strong>提供了共享静态资源的功能.</strong></p><h3 id="3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"><a href="#3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。" class="headerlink" title="3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"></a>3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。</h3><p>使用 set命令+内置变量即可达到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on;</span><br><span class="line">           set $limit_rate 1k;</span><br><span class="line">          # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">set $limit_rate 1k; # 限制Nginx向浏览器发送响应的一个速度。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/396f4ca5-45fe-4926-8719-e22866f50bc2.png" alt></p><p>limit_rate：在 Nginx官网中的 <strong>ngx_http_core_module中 提供了 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="noopener">Embedded Variables</a>，在这其中有一个内置的变量，$limit_rate ,来限制我们的访问速度</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/936fe133-af26-413a-beb9-8555e4b397ce.png" alt></p><p><strong>用法：set $limit_rate N； 是空间单位的；意义是：每秒传输 N 字节到浏览器中。<br>再去访问大页面，发现变得很慢了</strong>。</p><h3 id="3-3-记录access-log日志"><a href="#3-3-记录access-log日志" class="headerlink" title="3.3 记录access.log日志"></a>3.3 记录access.log日志</h3><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/2339d20c-675f-4197-a127-8dda272a9a06.png" alt></p><p><strong>nginx.conf 中的 log_format指令在定义日志的格式。</strong></p><p>这里的日志格式使用了许多变量，比如 $remote_addr<br>等等，具体见 00-Nginx访问日志详解。</p><p>这样的日志格式给他明明为 main , 因为我们可能对不同的域名下做不同格式的日志记录，或者对一些大文件，做反向代理等不同的用途时，记录不同日志格式。</p><p>配好 <strong>log_format</strong>之后，需要去设定 日志 记录在哪里</p><p><strong>access_log指令：决定日志记录在什么地方。access_log指令的位置决定了它所属的这样一类请求，会被记录到 当前指令所指定的路径中，采用 main这样的一种格式来记录。</strong></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxx;</span><br><span class="line">    acccess_log logs&#x2F;access.log main；</span><br><span class="line"># 这里access_log放在了 server下，即所有发送我这个域名或者请求端口的都会被记录到这个文件中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx内置的所有变量都可以被记录到 日志中。</p><p>官方内置变量在上面提过了</p><p>第三方模块变量，如 ngx_http_gzip_module 中的 内置变量 $gzip_ratio：记录了压缩级别</p><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/88b697fd-76d2-4960-8fe3-0567add181a7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Nginx命令行演示-重载-热部署-切割</title>
      <link href="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/"/>
      <url>/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-检查80端口是否被占用"><a href="#1-检查80端口是否被占用" class="headerlink" title="1 检查80端口是否被占用"></a>1 检查80端口是否被占用</h1><p>yum install net-tools<br>netstat -ano | grep 80</p><h1 id="2-Nginx命令行"><a href="#2-Nginx命令行" class="headerlink" title="2 Nginx命令行"></a>2 Nginx命令行</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg" alt></p><a id="more"></a><h1 id="3-重载配置文件"><a href="#3-重载配置文件" class="headerlink" title="3 重载配置文件"></a>3 重载配置文件</h1><p>此时在 nginx的安装目录下执行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">将Nginx启动了起来。</span><br></pre></td></tr></table></figure><p><font color="red">注意：<br>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：<br>ln -s /usr/local/lib/libpcre.so.1 /lib64/</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">再次修改了 Nginx配置文件中的一些值</span><br><span class="line">[root@haoransun nginx]# vim conf&#x2F;nginx.conf</span><br><span class="line">如需要将 #tcp_nopush这个注释去掉。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/098162e9-ca47-4da3-a22c-b0e1de51a776.png" alt></p><ul><li><p><strong><font color="red">mac</font>：当修改完成后，保存退出后，可以直接执行 <font color="red"> ./nginx -s reload </font>指令。这样是在Nginx在不停止对客户服务的情况下，使用了 tcp_nopush这个新的配置项，</strong></p></li><li><p>**<font color="red">CentOS</font>：<br>cd sbin<br>[root@haoransun sbin]# ./nginx -s reload即可</p></li><li><p><strong>ps -ef | grep nginx 可以看到正在运行的Nginx</strong></p></li></ul><h1 id="4-热部署"><a href="#4-热部署" class="headerlink" title="4 热部署"></a>4 热部署</h1><p><strong>即对Nginx在不停机的情况下做版本升级</strong>。<br><font color="red">对现有的Nginx的运行目录中的二进制可执行文件做一次备份：<strong>因为我们更换的只是二进制文件，并不会对其他文件做更换。</strong></font><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/1069c513-57b6-4f14-bf86-e72dc898eacf.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx nginx.old</span><br></pre></td></tr></table></figure><p>先下载一个最新版本的Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line">tar -zxvf 此版本Nginx</span><br><span class="line">编译生成二进制可执行文件</span><br><span class="line">进入新版本Nginx目录中，</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx</span><br><span class="line"></span><br><span class="line">上述命令会在Nginx最新版本目录中生成objs中间文件。</span><br><span class="line">make</span><br><span class="line">上述命令会生成Makerfile文件</span><br><span class="line">make install</span><br><span class="line">上述命令会在 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx目录下生成最新版本Nginx的运行目录文件，里面包含了最新版本的Nginx二进制可执行文件</span><br></pre></td></tr></table></figure><p>将我们编译好的<strong>最新版本的二进制文件</strong>拷贝到旧版本的二进制那个可执行文件目录中，替换掉当前Nginx进程正在使用的旧版本二进制文件。<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/daf5c361-5f4f-42c3-a7b0-26c0f1339f06.png" alt><br><font color="red"><strong>复制成功后，看到新版本的Nginx二进制可执行文件的size与旧版本是不一样的。</strong></font></p><p>现在，需要给<strong>正在运行的Nginx的Master进程发送一个信号，告诉它，我们要进行热部署了，做一次版本升级</strong><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/c1c96e01-89b4-4df0-8302-d5594b0ab572.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 6655 ## master进程号</span><br><span class="line">ps -ef |grep nginx</span><br></pre></td></tr></table></figure><p>接下来会看到，<strong>Nginx Master进程会新起一个Nginx Master进程，新的Nginx Master进程使用了刚刚复制过来的最新的Nginx二级制文件，老的Worker也在运行，新的Master会生成新的Worker，它们会平滑的将所有的请求过渡到新的二进制文件所起的Nginx进程中，由此实现了平滑过度-热部署</strong>，如下所示：<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/086e0e3b-a68e-4e18-b5ca-2d2e14362e01.png" alt><br>我们看到，新老都存在，且新的Master进程父ID 为老的Master进程ID，由此看出新的是由老的新起的。</p><p>但是老的Master进程已经<strong>不再监听80或者443这样的Web端口</strong>，所以，新的连接，都会进入新的Nginx进程中。</p><p>这是，我们需要向老的Nginx进程发生一个信号，告诉它，优雅的关闭所有的 Worker进程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 6655 ## 老的Master 进程号</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/5a48e9e0-f3dc-410c-89d2-bc7de1124ecd.png" alt></p><p>老的Worker进程已经优雅的退出了，但是老的Master进程 6655 还存在，但是它手下已经没有Worker进程了，这说明了一件事情：所有的请求已经去全部切换到我们新升级好的Nginx中了。</p><p>./nginx -v :已经是最新的版本了</p><p><strong>如果升级过程完成后，没有任何问题，需要关闭老的master进程的话，使用以下命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill  -QUIT old_master_pid</span><br></pre></td></tr></table></figure><p><strong>但是 想要版本回退呢？只需要向老的Master进程 6655发送 reload 命令，让它重新拉起Worker进程，再把新的Master进程关掉。<font color="red"> 因此：老的Master进程是不会退出的，保留以允许我们做版本回退</font>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v   # 此时这里是新的nginx版本号</span><br><span class="line"></span><br><span class="line">mv nginx nginx-1.16.0 # 将新的nginx文件命名为它的版本号</span><br><span class="line"></span><br><span class="line">mv nginx.old nginx # 将老的nginx命名为nginx</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">kill -USR1 6728(新的nginx的master的id)</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;nginx -v # 已经是老版本的nginx了</span><br></pre></td></tr></table></figure><h1 id="5-切割日志文件"><a href="#5-切割日志文件" class="headerlink" title="5 切割日志文件"></a>5 切割日志文件</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/e7955fcb-062b-424e-8db2-3f4cf82ba1ad.png" alt></p><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/ce22072b-b74f-4910-a13b-bc1a2407f577.png" alt></p><p>可以看到，haoransun_access.log日志文件已经有接近16M了，假设它此时已经很大了，想要将当前日志备份到另外一个文件中，而当前Nginx仍然正常运行，该如何做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reopen即可</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/d7da2cf6-25f5-4fc5-b3bd-3618ecaea6a1.png" alt></p><p><strong>./nginx -s  reopen 命令即可做到，但是太麻烦了</strong></p><p><font color="red">具体的便捷做法参考000-Nginx访问日志配置及信息详解.。。。。</font></p><h2 id="5-1-日志切割-bash脚本demo"><a href="#5-1-日志切割-bash脚本demo" class="headerlink" title="5.1 日志切割 bash脚本demo"></a>5.1 日志切割 bash脚本demo</h2><p>往往会每一天或者每一周执行一次日志切割。</p><p>可以先写成一个<strong>bash脚本</strong>，在此脚本中，先将 haoransun.log复制一下，在执行 -s reopen命令。<br>最后将此脚本放在<strong>crontab</strong>中，比如：</p><p>在logs目录下新建 history文件夹：用于存放历史日志文件。</p><p><strong>在logs目录下新建rotate.sh脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Rotate the Nginx logs to prevent a single logfile from consuming too much disk space.</span><br><span class="line"># 此处 日志存放目录可以自定义，但一般存放在nginx相关的目录下</span><br><span class="line"># LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line"># CUR_LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs</span><br><span class="line">CUR_LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs</span><br><span class="line">YESTERDAY&#x3D;$(date -d &quot;yesterday&quot;+%Y-%m-%d )</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;haoransun_access.log $(LOGS_PATH)&#x2F;haoransun_access_$(YESTERDAY).log</span><br><span class="line"># 此处可以指定多个日志文件到指定目录下</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;error.log $(LOGS_PATH)&#x2F;error_$(YESTERDAY).log</span><br><span class="line">## 向 Nginx 主进程发送 USR1 信号 USR1 信号是重新打开日志文件</span><br><span class="line">kill -USR1 $(cat &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin)</span><br></pre></td></tr></table></figure><p><strong>查看当前周期任务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">crontab -e</span><br><span class="line">59 23 * * * root &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logx&#x2F;rotate.sh</span><br><span class="line">:wq</span><br><span class="line">再次 crontab -l 即可查看该脚本在每天的23点59分执行。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Nginx配置语法</title>
      <link href="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-Nginx-配置语法"><a href="#1-Nginx-配置语法" class="headerlink" title="1 Nginx 配置语法"></a>1 Nginx 配置语法</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg" alt></p><a id="more"></a><h1 id="2-Nginx配置参数：时间单位"><a href="#2-Nginx配置参数：时间单位" class="headerlink" title="2 Nginx配置参数：时间单位"></a>2 Nginx配置参数：时间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/4440df2c-e938-4f44-9a0e-2a9a1b44b32c.jpg" alt></p><h1 id="3-Nginx配置参数：空间单位"><a href="#3-Nginx配置参数：空间单位" class="headerlink" title="3 Nginx配置参数：空间单位"></a>3 Nginx配置参数：空间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/2a8c6624-55b3-4554-b84c-8c448dc319b6.jpg" alt></p><h1 id="4-Nginx-语法示例"><a href="#4-Nginx-语法示例" class="headerlink" title="4 Nginx 语法示例"></a>4 Nginx 语法示例</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7a40655-721d-4edb-b990-9d4ef7b60470.jpg" alt></p><ul><li><p><strong>http{} 就是一个指令块</strong></p></li><li><p><strong>include            mime.types; 这是一条指令</strong></p></li><li><p><strong>指令后 可以跟多个参数</strong></p></li><li><p><strong>指令间以;为分隔符，可以将多条指令放在一行</strong></p></li><li><p><strong>指令块可以有名字，如：upstream指令块 thwp,有些指令块是没有名字的，如： http、server等。<font color="red">有名与否是由提供这个指令块的Nginx 模块来决定的</font></strong></p></li><li><p><strong>3m:表示3分钟</strong></p></li><li><p><strong>limit_req_zone 10m 开启10MB大小的共享内存空间，给不同的Worker使用</strong></p></li></ul><hr><h1 id="5-http配置的指令块"><a href="#5-http配置的指令块" class="headerlink" title="5 http配置的指令块"></a>5 http配置的指令块</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7901424-0375-4abf-869b-7a62ddb552b8.jpg" alt></p><ul><li><p><strong>http模块有四个大的指令块：http、server、location、upstream</strong></p></li><li><p><strong>http{}：表示 大括号内的所有指令都是由<font color="red">http模块去解析、执行。一个非 http模块：stream等是没有办法被解析的</font>。</strong></p></li><li><p><strong>upstream：表示<font color="red">上游服务</font> ，当Nginx需要与Tomcat/DJango等企业内网的其他应用服务交互时，可以定义此 upstream.</strong></p></li><li><p><strong>server：对应一个组域名</strong></p></li><li><p><strong>location：一个URL表达式</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Nginx的前世今生</title>
      <link href="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><a href="http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">章亦春文档</a></p><h1 id="1-Nginx的三个主要应用场景"><a href="#1-Nginx的三个主要应用场景" class="headerlink" title="1 Nginx的三个主要应用场景"></a>1 Nginx的三个主要应用场景</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg" alt></p><p><font color="red">流程解析：</font><br>一个<strong>Web</strong>请求从红色的线走下来后，会先经过<strong>Nginx</strong>,再到<strong>应用服务（Tomcat/Django）</strong>，再去访问<strong>Redis/MySQL</strong>这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有<strong>反向代理</strong>功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，<strong>反向代理</strong>必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于<strong>企业内网的边缘节点</strong>，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来<strong>在一段时间内不变的动态内容缓存到Nginx</strong>中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 <strong>缓存，加速我们的访问</strong>。（<strong>反向代理</strong>）</p><p>一些<strong>css/js/png</strong>等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（<strong>静态资源</strong>）</p><p>如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（<strong>API服务</strong>）</p><a id="more"></a><h1 id="2-Nginx出现的缘由"><a href="#2-Nginx出现的缘由" class="headerlink" title="2 Nginx出现的缘由"></a>2 Nginx出现的缘由</h1><h2 id="2-1-互联网的数据量急速增长"><a href="#2-1-互联网的数据量急速增长" class="headerlink" title="2.1 互联网的数据量急速增长"></a>2.1 互联网的数据量急速增长</h2><p>互联网的快速普及<br>全球化<br>物联网</p><h2 id="2-2-摩尔定律：性能提升"><a href="#2-2-摩尔定律：性能提升" class="headerlink" title="2.2 摩尔定律：性能提升"></a>2.2 摩尔定律：性能提升</h2><h2 id="2-3-低效的Apache-：一个连接对应一个进程"><a href="#2-3-低效的Apache-：一个连接对应一个进程" class="headerlink" title="2.3 低效的Apache ：一个连接对应一个进程"></a>2.3 低效的Apache ：一个连接对应一个进程</h2><p>当有百万个连接时，Apache并不会建造出百万个进程，就算生成了，进程间的切换会损耗极大的性能。而Nginx可以轻松应对百万级的连接。</p><h1 id="3-Nginx的优点"><a href="#3-Nginx的优点" class="headerlink" title="3 Nginx的优点"></a>3 Nginx的优点</h1><p>高并发、高性能<br><strong>高并发</strong>往往需要我们对每个连接所使用的内存尽量的少即可达到，具有高并发的同时又能达到<strong>高性能</strong>，需要非常好的设计。Nginx可以达到什么样的标准呢？如现在的主流服务器（32核，64G）可以轻松地达到数千万并发连接，如果是处理简单的静态资源请求，可以达到100W的RPS(REQUEST PER SECOND)<br>可扩展性好<br>主要体现在<strong>模块化设计</strong>，非常的稳定。使其的第三方模块-生态圈非常稳定、丰富。甚至是有Tengene（淘宝修改了Nginx的源源码，做了定制化开发）/OpenResty（Lua语言开发）这样的第三方插件在他们之上，又生成了一套生态圈。<br>高可靠性<br>Nginx可以在服务器上持续不间断的运行数年。对于Nginx这样的一个高并发、高性能的反向代理服务器而言，往往运行在企业内网的边缘节点上，此时，若企业想提供<strong>5个9</strong>或更高的服务时，Nginx的宕机可能1年就1s的时间间隙。<br>热部署<br>在不停止服务的情况下，升级Nginx,此功能<strong>非常重要</strong>，因为在Nginx上可能跑了数百万的并发连接。如果是普通服务，则直接kill掉进程再重启即可。但对于Nginx而言，kill掉Nginx进程，会导致操作系统为所有的已建立连接的客户端发送<strong>TCP中的reset复位包</strong>，然而很多客户端是没有办法，很好的处理复位请求的，<strong>在大并发场景下，一些偶然事件就会导致非常恶劣的结果，因此热部署极其重要</strong><br>BSD许可证<br>开源且可商用</p><h1 id="4-Nginx的组成"><a href="#4-Nginx的组成" class="headerlink" title="4 Nginx的组成"></a>4 Nginx的组成</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/e604a666-da3c-4a91-9866-53e81c4ff90f.jpg" alt></p><h2 id="4-1-Nginx二进制可执行文件"><a href="#4-1-Nginx二进制可执行文件" class="headerlink" title="4.1 Nginx二进制可执行文件"></a>4.1 Nginx二进制可执行文件</h2><p>由Nginx自身的官方模块+我们编译的第三方模块一起构建的文件，相当于汽车本身（有完整的系统，所有的功能都由它提供）</p><h2 id="4-2-Nginx-conf配置文件"><a href="#4-2-Nginx-conf配置文件" class="headerlink" title="4.2 Nginx.conf配置文件"></a>4.2 Nginx.conf配置文件</h2><p>相当于汽车的驾驶员。</p><h2 id="4-3-access-log访问日志"><a href="#4-3-access-log访问日志" class="headerlink" title="4.3 access.log访问日志"></a>4.3 access.log访问日志</h2><p>汽车经过所形成的GPS轨迹。</p><h2 id="4-4-error-log错误日志"><a href="#4-4-error-log错误日志" class="headerlink" title="4.4 error.log错误日志"></a>4.4 error.log错误日志</h2><p>黑匣子：定位问题。</p><h1 id="5-Nginx的版本（nginx-org-开源-nginx-com-商业）"><a href="#5-Nginx的版本（nginx-org-开源-nginx-com-商业）" class="headerlink" title="5 Nginx的版本（nginx.org:开源 nginx.com:商业）"></a>5 Nginx的版本（nginx.org:开源 nginx.com:商业）</h1><p>单数号：最新按本（新功能有待考验）<br>偶数号：稳定版本（一般选择此版本）<br>版本号-feature-bugfix-change<br>openresty.com openresty.org</p><h1 id="6-编译出适合自己的Nginx"><a href="#6-编译出适合自己的Nginx" class="headerlink" title="6 编译出适合自己的Nginx"></a>6 编译出适合自己的Nginx</h1><p>nginx.org网址 —–&gt; 选择download<br>在选中的版本上 —–&gt; 右键选择复制链接地址<br>在linux系统中  —–&gt; wget 下载地址即可<br><font color="red">ps:Nginx依赖一些第三方软件包，如gcc、gcc-c++、openssl、pcre、zlib,详细见0-Nginx安装过程</font></p><h1 id="7-目录解析"><a href="#7-目录解析" class="headerlink" title="7 目录解析"></a>7 目录解析</h1><p>解压压缩包： tar -zxvf nginx-xxx.tar.gz<br>进入解压源码包： cd nginx-xxx<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f08f5668-a4bd-4fe4-a790-c25c437b69e3.png" alt></p><p><strong>auto：</strong> 其中主要有四个子目录（cc:用于编译，lib库、os库对操作系统的判断，types），其他的文件是为了辅助<strong>config</strong>脚本执行时判定 当前的Nginx支持哪些模块、当前的操作系统有哪些特性供Nginx使用。</p><p><strong>CHANGES：</strong> Nginx每一个版本提供了哪些 Features、BugFix、Changes这三类特性。</p><p><strong>CHANGES.ru：</strong> 因为作者是 俄罗斯人，所以提供了一个俄罗斯语言的变更说明书。</p><p><strong>conf：</strong> 示例文件，将Nginx安装好后，为了方便运维去配置，会将此目录中的示例文件拷贝到安装目录。</p><p><strong>configure：</strong>这个脚本是用来生成中间文件、执行编译前的一个必备动作。</p><p><strong>contrib：</strong>提供了两个pl脚本和vim的工具，在没有使用vim工具时去打开nginx配置文件，会发现色彩没有什么变化（nginx语法没有在vim），此时，需要将contrib文件夹下的所有文件拷贝到我们自己的vim目录中，即：</p><p><strong>（mac:cp -r contrib/vim/* ~/.vim/ ）</strong></p><p>（ <font color="red">centos:自定义安装vim的话，使用 whereis vim查看vim的安装路径，vimfiles就在 /usr/share/vim/下<br>所以：cp -r contrib/vim/* /usr/share/vim/vimfiles/<br>此时再次打开nginx.conf文件，发现语法高亮显示</font>）<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/a11a6806-0bf0-4908-9f46-2dcb2b590271.png" alt></p><p><strong>html：</strong> 提供了两个标准的html文件。如图：<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ae1df995-18a4-4490-97e6-93aa397516f7.png" alt><br>一个是发现500错误的时候重定向到当前指定文件。<br>一个是默认的Nginx的欢迎页面。</p><p><strong>man：</strong>Nginx的帮助文件<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f5e50c6d-0b16-4494-9580-169a0fe8e3c3.png" alt></p><p><strong>src：</strong>Nginx的源代码。<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5d35e8e4-1b4c-482c-ad22-1b7af2a3d92f.png" alt>。即Nginx的框架都在这些源代码中。</p><h1 id="8开始编译"><a href="#8开始编译" class="headerlink" title="8开始编译"></a>8开始编译</h1><h2 id="8-1-编译前首先观察configure都支持哪些参数？"><a href="#8-1-编译前首先观察configure都支持哪些参数？" class="headerlink" title="8.1 编译前首先观察configure都支持哪些参数？"></a>8.1 编译前首先观察configure都支持哪些参数？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/b42567c1-87be-482a-86b1-b3779ec76e2c.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/727a8526-4163-4ed7-9c65-72dcaf6cf2ce.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/bdf16353-460a-49e4-9991-85b84e615d49.png" alt><br><strong>此处主要分为3大块参数内容</strong>：</p><ul><li><p>确定Nginx执行中会去找哪些目录下的文件作为它的辅助文件；如：使用动态模块，则 –modules-path=PATH 就会起作用；确定Nginx.log文件放在那里，则 –lock-path=PATH会起作用；然而，<font color="red">如果没有任何变动的话，只需要指定 –prefix=PATH即可,所有的其他的文件会在prefix目录下建立相应的文件夹</font>。</p></li><li><p>确定使用那些模块，而不使用那些模块。如 –with 与 –without, –with ：需要显示指定的时候，意味着Nginx默认是不会加载此模块的。 –without: 意味着默认会编译到Nginx中，如果加上了，则是显示取消编译的，移出默认的Nginx模块中。</p></li><li><p>确定Nginx编译时所需要的一些特殊参数。如 –with-cc=Path –with-cpp=Path 就是使用gcc编译时需要加一些什么样的优化参数；–with-debug 打印debug级别的日志，–with-pcre –with-zlib 这是需要加一些第三方的模块等等。</p></li></ul><h2 id="8-2-编译前的依赖包的安装"><a href="#8-2-编译前的依赖包的安装" class="headerlink" title="8.2 编译前的依赖包的安装"></a>8.2 编译前的依赖包的安装</h2><p>参看 附件 + 0篇内容，此处省略。。。。</p><h2 id="8-3-生成指定目录下的-Makefile，为下一步编译做准备"><a href="#8-3-生成指定目录下的-Makefile，为下一步编译做准备" class="headerlink" title="8.3 生成指定目录下的 Makefile，为下一步编译做准备"></a>8.3 生成指定目录下的 Makefile，为下一步编译做准备</h2><p>配置 Nginx的安装目录   /home/geek/nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标目录不存在，会自动创建</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx</span><br><span class="line">如果没有任何报错，则Nginx编译成功，如下图</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/30d9368f-43a9-4413-bef9-08f8311a1657.png" alt></p><p>在 ./configure 成功后，会生成一些中间文件，存储在 /objs 文件夹下。<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/14168daf-02ec-4203-812a-efc660721862.png" alt><br><strong>最重要的是会生成<font color="red"> ngx_modules.c：它决定了我们执行编译时有哪些模块，会被编译到Nginx中</font></strong>。</p><p><strong>所有被编译的模块都会列出来，最后形成一份 ngx_modules[] 数组</strong> <img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/20212437-7463-4e77-9fc2-de2c6a5b5700.png" alt></p><h2 id="8-4-编译"><a href="#8-4-编译" class="headerlink" title="8.4 编译"></a>8.4 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make</span><br><span class="line">编译完成后，如果没有错误，就可以看到生成了大量的中间文件，如下图，他们都在 objs文件夹下。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/afa43e4b-c314-4481-a329-a1515a83f24b.jpg" alt></p><h2 id="8-5-为什么要知道Nginx的目标文件是放在objs下呢？"><a href="#8-5-为什么要知道Nginx的目标文件是放在objs下呢？" class="headerlink" title="8.5 为什么要知道Nginx的目标文件是放在objs下呢？"></a>8.5 为什么要知道Nginx的目标文件是放在objs下呢？</h2><p>如果是做<font color="red">Nginx版本升级</font>，此时不能执行** make install** ，而是需要从这里将目标文件 Nginx<br>拷贝到安装目录中，</p><p>C语言编译时生成的所有重要文件，都会存放在 *<em>objs/src目录 *</em>中。</p><p>如果使用了动态模块，则动态模块编译生成的<strong>so</strong>动态文件，也会放在<strong>objs 目录</strong>中。</p><h1 id="9-安装（首次安装时，可以使用此命令）"><a href="#9-安装（首次安装时，可以使用此命令）" class="headerlink" title="9 安装（首次安装时，可以使用此命令）"></a>9 安装（首次安装时，可以使用此命令）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make install</span><br></pre></td></tr></table></figure><h1 id="10-安装目录下的目录解析"><a href="#10-安装目录下的目录解析" class="headerlink" title="10 安装目录下的目录解析"></a>10 安装目录下的目录解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# cd &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;</span><br><span class="line">ll</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 conf</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 html</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 logs</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 sbin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-Nginx访问日志配置及信息详解</title>
      <link href="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过访问日志，可以知晓用户的地址，网站的哪些部分最受欢迎。用户的浏览时间，对大多数用户的浏览器做出针对性优化。</p><p>Nginx会把每个用户访问的日志信息记录到指定的日志文件里，供网站管理员分析用户浏览行为等，此功能又ngx_http_log_module 模块负责。</p><a id="more"></a><h2 id="1-访问日志参数"><a href="#1-访问日志参数" class="headerlink" title="1 访问日志参数"></a>1 访问日志参数</h2><p>Nginx访问日志主要有两个参数控制</p><ul><li><strong><font color="red">log_format</font></strong>：用来定义记录日志的格式（可以定义多种日志格式，取不同名字即可）。</li><li><strong><font color="red">access_log</font></strong>：用来指定日至文件的路径及使用的何种日志格式记录日志。</li></ul><h3 id="1-1-log-format与-access-log的默认值"><a href="#1-1-log-format与-access-log的默认值" class="headerlink" title="1.1 log_format与 access_log的默认值"></a>1.1 log_format与 access_log的默认值</h3><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/10c95625-1ad9-4c6a-b66e-30822bc362a3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log logs&#x2F;access.log main;</span><br></pre></td></tr></table></figure><p><strong>logs/access.log:这个为日志文件的存放路径，从安装目录开始，意思绝对路径为：/home/geek/nginx/logs/access.log</strong></p><p><strong>main：日志格式，通常为 combined</strong><br>若不想记录Nginx的日志：access_log off;</p><h3 id="1-2-log-format语法格式及参数语法说明"><a href="#1-2-log-format语法格式及参数语法说明" class="headerlink" title="1.2 log_format语法格式及参数语法说明"></a>1.2 log_format语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    log_format    &lt;NAME&gt;    &lt;Strin­­­g&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         格式标签   日志格式</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    格式标签：格式标签是给一套日志格式设置一个独特的名字</span><br><span class="line"></span><br><span class="line">    日志格式：给日志设置格式</span><br><span class="line"></span><br><span class="line">log_format格式变量：</span><br><span class="line"></span><br><span class="line">    $remote_addr  #记录访问网站的客户端地址</span><br><span class="line"></span><br><span class="line">    $remote_user  #远程客户端用户名</span><br><span class="line"></span><br><span class="line">    $time_local  #记录访问时间与时区</span><br><span class="line"></span><br><span class="line">    $request  #用户的http请求起始行信息</span><br><span class="line"></span><br><span class="line">    $status  #http状态码，记录请求返回的状态码，例如：200、301、404等</span><br><span class="line"></span><br><span class="line">    $body_bytes_sent  #服务器发送给客户端的响应body字节数</span><br><span class="line"></span><br><span class="line">    $http_referer  #记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。</span><br><span class="line"></span><br><span class="line">    $http_user_agent  #记录客户端访问信息，例如：浏览器、手机客户端等</span><br><span class="line"></span><br><span class="line">    $http_x_forwarded_for  #当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</span><br></pre></td></tr></table></figure><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/4b4b4565ebf3424cb0c325dbd6bbcfd1.png" alt></p><h3 id="1-3-x-forwarded-for"><a href="#1-3-x-forwarded-for" class="headerlink" title="1.3 x_forwarded_for"></a>1.3 x_forwarded_for</h3><p>通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_addr拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端请求的服务器地址。</p><p>注意：<br>在定义日志目录中要注意的是，nginx进程设置的用户和组必须有对该路径创建文件的权限，<br>假设nginx的usr指令设置的用户名 和用户组都是www，而logs 目录的用户名和组是root，那么日志文件将无法被创建。</p><p>用nginx做前端代理后，我们发HTTP_X_FORWARDED_FOR 无法获取到客户端真实的IP地址了。</p><p>原因 nginx 默认并不会增加 X_FORWARDED_FOR 头信息，我们给他加上就好了。简单配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass          http:&#x2F;&#x2F;www.xxx.com;</span><br><span class="line">    proxy_set_header    Host             $host;</span><br><span class="line">    proxy_set_header    X-Real-IP        $remote_addr;</span><br><span class="line">    proxy_set_header    X-Forwarded-For  $proxy_add_x_forwarded_for;    &#x2F;&#x2F;别忘了这一句</span><br><span class="line">    proxy_set_header    HTTP_X_FORWARDED_FOR $remote_addr;              &#x2F;&#x2F;或是加上这一句</span><br><span class="line">    proxy_redirect      default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx 加载新的配置文件，就可以获取客户端真实的IP地址了。</p><p><strong>通常情况下用以上配置即可，可以将main换成combined(默认的日志格式)，其他不变即可。</strong></p><h3 id="1-4-access-log语法格式及参数语法说明"><a href="#1-4-access-log语法格式及参数语法说明" class="headerlink" title="1.4 access_log语法格式及参数语法说明"></a>1.4 access_log语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  access_log    &lt;FILE&gt;    &lt;NAME&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         日志文件   格式标签</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    日志文件：可以指定任意存放日志的目录</span><br><span class="line"></span><br><span class="line">    格式标签：给日志文件套用指定的日志格式</span><br><span class="line"></span><br><span class="line">其他语法：</span><br><span class="line"></span><br><span class="line">    access_log    off;  #关闭access_log，即不记录访问日志</span><br><span class="line"></span><br><span class="line">    access_log path [format [buffer&#x3D;size [flush&#x3D;time]] [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    access_log path format gzip[&#x3D;level] [buffer&#x3D;size] [flush&#x3D;time] [if&#x3D;condition];</span><br><span class="line"></span><br><span class="line">    access_log syslog:server&#x3D;address[,parameter&#x3D;value] [format [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    说明：</span><br><span class="line"></span><br><span class="line">    buffer&#x3D;size  #为存放访问日志的缓冲区大小</span><br><span class="line"></span><br><span class="line">    flush&#x3D;time  #为缓冲区的日志刷到磁盘的时间</span><br><span class="line"></span><br><span class="line">    gzip[&#x3D;level]  #表示压缩级别</span><br><span class="line"></span><br><span class="line">    [if &#x3D; condition]  #表示其他条件</span><br></pre></td></tr></table></figure><p><strong>一般场景这些参数都无需配置，极端优化才有可能会<br>考虑这些参数</strong>。</p><h4 id="1-5-设置刷盘策略："><a href="#1-5-设置刷盘策略：" class="headerlink" title="1.5 设置刷盘策略："></a>1.5 设置刷盘策略：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;access.log buffer&#x3D;32k flush&#x3D;5s;</span><br></pre></td></tr></table></figure><p><strong>buffer 满32k才刷盘；假如buffer不满5s强制刷盘。</strong></p><h3 id="1-6-其他："><a href="#1-6-其他：" class="headerlink" title="1.6 其他："></a>1.6 其他：</h3><p>error_log：配置错误日志，例如上例。</p><p>open_log_file_cache：<br>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。语法:</p><p>open_log_file_cache max=N [inactive= time] [min_uses=N] [valid= time];</p><p>参数注释如下：</p><ul><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</li></ul><h2 id="2-日志分析："><a href="#2-日志分析：" class="headerlink" title="2 日志分析："></a>2 日志分析：</h2><p>通过对日志格式的定义，就可以使用常见的 Linux 命令行工具进行分析了：</p><p>查找访问频率最高的 URL 和次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; print $10&#125;’ | sort | uniq -c</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | wc -l</span><br></pre></td></tr></table></figure><p>查找某一分钟内 500 错误访问的数量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | grep ’09:00’ | wc -l</span><br></pre></td></tr></table></figure><p>查找耗时超过 1s 的慢请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f access.log | awk -F ‘^A’ ‘&#123; if( $6&gt;1) print $0&#125;’</span><br></pre></td></tr></table></figure><h2 id="3-日志切割"><a href="#3-日志切割" class="headerlink" title="3 日志切割"></a>3 日志切割</h2><p>为了使Nginx的日志文件存储更合理、有序，我们需要将日志文件进行分开存储。</p><p>可以按时间来分开存储。今天的日志文件存储到一个文件中，明天的日志文件则存储到另一个新的文件中等等。</p><p>有两种方式：</p><ul><li><strong>1 手动切割</strong><br>（1）进入 logs目录，执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv access.log xxx(随便起个名).log</span><br></pre></td></tr></table></figure>即将以前的日志文件重命名为一个新的名字的日志文件。<br>（2）执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR1 主进程号（需要先用 ps -ef| grep nginx命令找到master的进程号）</span><br></pre></td></tr></table></figure>kill -USR1 主进程号 ：</li></ul><p>在logs目录ls一个，会发现又自动多出了一个日志文件(这个日志文件的命名来源于nginx.conf文件里的access_log的路径)，并且里面无内容。这个文件就是切割出来的新文件，再有日志会往这里面写，而不会操作老日志文件。</p><ul><li><strong>2 自动进行切割</strong><br>（1）首先创建个sh文件（称为批处理日志文件），进入nginx的logs目录运行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch cutlog.sh（文件名自定义，后缀.sh即可）</span><br></pre></td></tr></table></figure>（2）编辑cutlog.sh文件。输入如下内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim cutlog.sh</span><br><span class="line"></span><br><span class="line">D&#x3D;$(date +%Y%m%d)</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log &#x2F;$&#123;LOGS_PATH&#125;&#x2F;$&#123;D&#125;.log</span><br><span class="line">kill -USR1 $(cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid)</span><br></pre></td></tr></table></figure><p>说明：<br>D=$(date +%Y%m%d)，声明个变量，名为D（自定义）,值为date（Linux自带的，类似于函数，用于获取当前时间，并且格式为年月日）</p><p>${D}：引用上面变量名为D的变量</p><p>$(cat /usr/local/nginx/nginx.pid)：cat命令意思是查看。nginx.pid：存储的是nginx的主进程号。连起来的意思就是查看nginx主进程号，带上$(xx)就是说拿到xx</p><p>（3）定时执行某个文件，输入如下命令：(注意：运行crontab命令需要先用yum进行安装crontab，否则会出现command not found)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">crontab：定时执行某个文件</span><br><span class="line">crontab -e：编辑定时执行的内容</span><br></pre></td></tr></table></figure><p>（4）执行完（3）后会出现编辑器，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 59 *** &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;cutlog.sh</span><br></pre></td></tr></table></figure><p>即：在每天23点59分定时执行cutlog.sh文件，这样就实现了每天定时切割日志文件了。</p><p>原理：只是将手动切割写成个脚本。</p><p>如有需要每隔1个月就备份日志到其他地方并删除原位置的日志等类似需求都可以写个shell脚本，然后用linux的crontab来定时执行。</p><h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4 实例"></a>4 实例</h2><p>往往需要要对access_log、error_log日志进行切割。切割日志一般利用USR1信号让nginx产生新的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bashlogdir&#x3D;&quot;&#x2F;data&#x2F;logs&#x2F;nginx&quot; pid&#x3D;&#96;cat $logdir&#x2F;nginx.pid&#96; DATE&#x3D;&#96;date -d &quot;1 hours ago&quot; +%Y%m%d%H&#96; DATE_OLD&#x3D;&#96;date -d &quot;7 days ago&quot; +%Y%m%d&#96; for i in &#96;ls $logdir&#x2F;*access.log&#96;; do mv $i $i. $DATE done for i in &#96;ls $logdir&#x2F;*error.log&#96;; do mv $i $i. $DATE done kill -s USR1 $pid rm -v $logdir &quot;&#x2F;access.log.&quot; $DATE_OLD*rm -v $logdir&quot;&#x2F;error.log.&quot; $DATE_OLD*</span><br></pre></td></tr></table></figure><p><strong>1、分析：</strong>将上面的脚本放到crontab中，每小时执行一次（0 ），这样每小时会把当前日志重命名成一个新文件；然后发送USR1这个信号让Nginx 重新生成一个新的日志。（相当于备份日志）将前7天的日志删除；</p><p><strong>2、说明：</strong>在没有执行kill -USR1 $pid之前，即便已经对文件执行了mv命令而改变了文件名称，nginx还是会向新命名的文件”*access.log.2016032623”照常写入日志数据的。原因在于：linux系统中，内核是根据文件描述符来找文件的。</p><p><strong>3、logrotates：</strong>使用系统自带的logrotates，也可以实现nginx的日志分割，查看其bash源码，发现也是发送USR1这个信号。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger2学习与集成</title>
      <link href="/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/"/>
      <url>/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-Swagger2介绍"><a href="#1-Swagger2介绍" class="headerlink" title="1 Swagger2介绍"></a>1 Swagger2介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在都奉行<strong>前后端分离</strong>和<strong>微服务</strong>大行其道，分微服务及前后端分离后，前后端开发的沟通成本就增加了。所以一款强大的<strong>RestFul API</strong> 文档则十分重要，而目前在后端领域，基本上就是<font color="red">Swagger</font>的天下了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Swagger</strong>是一款RestFul接口的文档在线自动生成、功能测试功能框架。一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的Web服务，加上Swagger-ui，可以有很好的呈现。</p><a id="more"></a><h1 id="2-Spring-Boot-集成"><a href="#2-Spring-Boot-集成" class="headerlink" title="2 Spring Boot 集成"></a>2 Spring Boot 集成</h1><p>这里选用的Swagger版本：2.8.0</p><h2 id="2-1-POM依赖"><a href="#2-1-POM依赖" class="headerlink" title="2.1 POM依赖"></a>2.1 POM依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--swagger--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-编写配置文件-Swagger2Config-java"><a href="#2-2-编写配置文件-Swagger2Config-java" class="headerlink" title="2.2 编写配置文件(Swagger2Config.java)"></a>2.2 编写配置文件(Swagger2Config.java)</h2><p>主要是添加注解 <strong>@EnableSwagger2</strong> 和定义 <strong>Docket</strong> 的 <strong>bean</strong>类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableSwagger2</span><br><span class="line">@Configuration</span><br><span class="line">public class SwaggerConfig&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否开启Swagger,正式环境一般是需要关闭的，可根据SpringBoot的多环境配置进行设置</span><br><span class="line">    @Value(value&#x3D;&quot;$&#123;swagger.enabled&#125;&quot;)</span><br><span class="line">    Boolean swaggerEnabled;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">              return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">              &#x2F;&#x2F;是否开启</span><br><span class="line">             .enable(swaggerEnabled).select()</span><br><span class="line">             &#x2F;&#x2F;扫描的路径包</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))</span><br><span class="line">            &#x2F;&#x2F;指定路径处理 PathSelectors.any()代表所有的路径</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .pathMapping(&quot;&#x2F;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private ApiInfo apiInfo()&#123;</span><br><span class="line">             return new ApiInfoBuilder()</span><br><span class="line">            .title(&quot;SpringBoot-Swagger2集成Demo &quot;)</span><br><span class="line">            .description(&quot;Allen&quot;)</span><br><span class="line">            &#x2F;&#x2F; 作者信息</span><br><span class="line">            .contact(new Contact(&quot;haoransun&quot;,&quot;demo.com&quot;,&quot;Wechat: SHR---97&quot;))</span><br><span class="line">            .version(&quot;1.0.0&quot;)</span><br><span class="line">            .build();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-添加文档内容-一般是在Controller，-请求参数上进行注解"><a href="#2-3-添加文档内容-一般是在Controller，-请求参数上进行注解" class="headerlink" title="2.3 添加文档内容(一般是在Controller， 请求参数上进行注解)"></a>2.3 添加文档内容(一般是在Controller， 请求参数上进行注解)</h2><p><img src="/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/ef7d3999287f12ba39cc345681993e8d.png" alt><br><strong>常用的注解<code>@Api</code>、<code>@ApiOperation</code>、<code>@ApiModel</code>、<code>@ApiModelProperty</code>示例中有进行标注，对于其他注解，大家可自动谷歌，毕竟常用的就这几个了。有了<code>swagger</code>之后，原本一些<code>post</code>请求需要<code>postman</code>这样的调试工具来进行发起，而现在直接在页面上就可以进行调试了，是不是很爽！对于服务的调用者而已，有了这份api文档也是一目了然，不需要和后端多少沟通成本，按着api说明进行前端开发即可。</strong></p><p>@ApilmplicatParams(name = “”,value=””,dataType=””,paramType=””)</p><p>paramType:<br>     query—@RequestParam<br>     header—@RequestHeader<br>     path —@PathVariable (RestFul风格)</p><p>ParameterBuilder tokenPar = new ParameterBuilder();<br>List<Parameter> pars = new ArrayList<Parameter>();<br>tokenPar.name(“Authorization”).description(“令牌”)<br>    .modelRef(new ModelRef(“string”)).parameterType(“header”)<br>    //header中的token参数非必填，传空也可以<br>    .required(false).build();<br>//根据每个方法名也知道当前方法在设置什么参数<br>pars.add(tokenPar.build());</Parameter></Parameter></p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Swagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法第四阶段学习图</title>
      <link href="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/"/>
      <url>/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>第四阶段学习知识点汇总。</p><a id="more"></a><p><img src="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/52788574ceabff1adbdebfe69d3debce.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法第三阶段学习图</title>
      <link href="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/"/>
      <url>/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>第三阶段学习知识点汇总。</p><a id="more"></a><p><img src="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/9cb3a84ee91d8f8c1849e1bd7bc4a8fe.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法第二阶段学习图</title>
      <link href="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/"/>
      <url>/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>第二阶段学习知识点汇总。</p><a id="more"></a><p><img src="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/d37136dd9b2341abf5a41167d3e50c79.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法第一阶段学习图</title>
      <link href="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/"/>
      <url>/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>第一阶段学习知识点汇总。</p><a id="more"></a><p><img src="/2019/09/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E5%9B%BE/84645c7329fe66d311e4ae4c4920618f.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-2019工作总结</title>
      <link href="/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-判断一个点是否在不规则多边形内部"><a href="#1-判断一个点是否在不规则多边形内部" class="headerlink" title="1  判断一个点是否在不规则多边形内部"></a>1  判断一个点是否在不规则多边形内部</h1><p>用途：<br>用于判断企业是否落在指定区域内</p><p>以一个点做射线，计算它与多边形边界的交点个数<br>       奇数个：在多边形内部<br>       偶数个：在多边形外部<br>推论：<br>如果点在多边形内部，射线第一次穿越边界一定是穿出多边形。<br>如果点在多边形外部，射线第一次穿越边界一定是进入多边形。</p><a id="more"></a><p>当射线穿越多边形边界的次数为偶数时，所有第偶数次（包括最后一次）穿越都是穿出，<br>因此所有第奇数次（包括第一次）穿越为穿入，由此可推断点在多边形外部。</p><p>当射线穿越多边形边界的次数为奇数时，所有第奇数次（包括第一次和最后一次）穿越都是穿出<br>由此可推断点在多边形内部。</p><p>判断难点：<br>点在多边形边上：                     点在线上，计算点与两个多边形顶点的连线斜率是否相等。<br>点和多边形的顶点重合：           比较坐标。<br>射线经过多边形顶点：              射线经过的点都属于射线以上的一侧<br>射线经过多边形的一条边：       射线连续经过多边形的两个相邻顶点。</p><p>需要客户提前给出待落区域的经纬度。</p><p>射线法： （java）<br>代码位置：com.aliyun.fin.rebengine.manager.job.task.AnalysisRegionOfEntDataTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 方法1   射线法：判断某一个点(经纬度)是否在一个多边形内  奇数个交点证明在多边形内部，偶数个交点在多边形外部</span><br><span class="line"> * @param longitude</span><br><span class="line"> * @param latitude</span><br><span class="line"> * @param points</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean judgeDom(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line">    int iSum, iCount, iIndex;</span><br><span class="line">    double dLon1 &#x3D; 0, dLon2 &#x3D; 0, dLat1 &#x3D; 0, dLat2 &#x3D; 0, dLon;</span><br><span class="line">    iSum&#x3D;0;</span><br><span class="line">    iCount &#x3D; points.size();</span><br><span class="line">    for(iIndex &#x3D; 0;iIndex&lt;iCount;iIndex++)&#123;</span><br><span class="line">        if(iIndex &#x3D;&#x3D; iCount-1)&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(0).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(0).getLatitude();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(iIndex+1).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(iIndex+1).getLatitude();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断给定点的纵坐标 是否在边的两端点的水平平行线之间，在则可能有交点，继续判断交点是否在左射线上</span><br><span class="line">        boolean isInArea &#x3D; ((latitude&gt;&#x3D;dLat1)&amp;&amp;(latitude&lt;dLat2))|| (latitude&gt;&#x3D;dLat2)&amp;&amp;(latitude&lt;dLat1);</span><br><span class="line">        if(isInArea)&#123;</span><br><span class="line">            &#x2F;&#x2F;因为要做分母，所以判断不能为0,</span><br><span class="line">            if(Math.abs(dLat1-dLat2)&gt;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;得到给定点向左射线与边的  交点  的  经度坐标</span><br><span class="line">                dLon &#x3D; dLon1 - ((dLon1-dLon2)*(dLat1-latitude))&#x2F;(dLat1-dLat2);</span><br><span class="line">                &#x2F;&#x2F;比较交点 经度坐标，如果交点在给定点的左侧：则当前交点是射线与边的交点</span><br><span class="line">                if(dLon&lt;longitude)&#123;</span><br><span class="line">                    iSum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if((iSum%BASE_EVEN)!&#x3D;0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li><p>方法2   判断某一个点(经纬度)是否在一个多边形内  点在线内、线外、线上、面内、面外 来进行多层判断</p></li><li><p>@param longitude</p></li><li><p>@param latitude</p></li><li><p>@param points</p></li><li><p>@return</p></li><li><p>/</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public boolean judgeDom2(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line"></span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0, l&#x3D;points.size(),j&#x3D;l-1;i&lt;l;j&#x3D;i,i++)&#123;</span><br><span class="line"></span><br><span class="line">        double sx &#x3D; points.get(i).getLongitude();</span><br><span class="line"></span><br><span class="line">        double sy &#x3D; points.get(i).getLatitude();</span><br><span class="line"></span><br><span class="line">        double tx &#x3D; points.get(j).getLongitude();</span><br><span class="line"></span><br><span class="line">        double ty &#x3D; points.get(j).getLatitude();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;点与多边形顶点重合</span><br><span class="line"></span><br><span class="line">        boolean isCoincide &#x3D; (sx&#x3D;&#x3D;longitude&amp;&amp;sy&#x3D;&#x3D;latitude)||(tx&#x3D;&#x3D;longitude&amp;&amp;ty&#x3D;&#x3D;latitude);</span><br><span class="line"></span><br><span class="line">        if(isCoincide)&#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断线段两端点是否在射线两侧</span><br><span class="line"></span><br><span class="line">        boolean isTwoSide &#x3D; (sy&lt;latitude&amp;&amp;ty&gt;&#x3D;latitude)||(sy&gt;&#x3D;latitude&amp;&amp;ty&lt;latitude);</span><br><span class="line"></span><br><span class="line">        if(isTwoSide)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 线段上与坐标 Y 相同的 点 X 的坐标</span><br><span class="line"></span><br><span class="line">            double x &#x3D; sx+(latitude-sy)*(tx-sx)&#x2F;(ty-sy);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;点在多边形边上</span><br><span class="line"></span><br><span class="line">            if(x&#x3D;&#x3D;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;射线穿过多边形边界</span><br><span class="line"></span><br><span class="line">            if(x&gt;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                flag &#x3D; !flag;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return  flag?true:false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-聚类经纬度"><a href="#2-聚类经纬度" class="headerlink" title="2 聚类经纬度"></a>2 聚类经纬度</h1><p>聚类经纬度数据（全景洞察-全景概览 五角星、实心圆）<br>从reb_ent_location中取出经纬度、企业信息等数据。</p><p>企业经纬度各分10等份（汇总各个区域的最大最小值）。<br>分别统计出 企业经纬度的最大最小值。</p><p>等分公式：对经纬度的 最大最小值分别计算<br>Quadrant:  (minLongitude,minLatitude)—à  (maxLongitude,maxLatitude)<br>在逻辑上勾画出一个象限经纬系。</p><p>勾画出10等份区域：[(max-min)/10]*i+min  i: 0-10</p><p>投射每一个企业对应的经纬度落在所画区域上<br>min + |(当前企业经度-min)/(max-min)/10|<em>(max-min)/10<br>min + |(当前企业维度-min)/(max-min)/10)|</em>(max-min)/10</p><p>| | ：是对其中的数据向下取整</p><p>返回100个左右的点，每一个点所对应的坐标是它周围点的坐标均值。<br>即：每一个点都可以想象成是一个 “黑洞”，吸收它附近的相近点<br>页面上：每一个点 都有它所对应的企业列表集合。</p><p>代码位置：com.aliyun.fin.rebengine.manager.job.task.ClusterEntLocationDataTask</p><h1 id="3-NLP分词。文章相似度"><a href="#3-NLP分词。文章相似度" class="headerlink" title="3 NLP分词。文章相似度"></a>3 NLP分词。文章相似度</h1><p>NLP分词、政策相似度判断<br>（依托于 hanlp jar包，具体用法靠参考官网 <a href="https://github.com/hankcs/HanLP）" target="_blank" rel="noopener">https://github.com/hankcs/HanLP）</a><br>A：政策关键词 + 政策重合度（onecompany提供政策数据）<br> B：热词云 + 舆情数据[公司品牌+企业高管…]（onecompany提供舆情数据）<br> C：自建停分词词典（需要积累）+ 客户自定义词词典。<br>D：舆情数据需要进行：公司品牌+企业高管+产品品质+服务质量+其他风险 的 摘选。</p><p>舆情分词分模块难点：<br>停分词词典需要积累数据，每天都会有新的舆情数据进来，会有新的热词产生，同时也需要追加新的停分词到词典中。（目前是每次对新舆情数据分词，人工过滤掉无意义词）<br>如何分辨当条舆情数据是当前所属公司的哪一类的舆情：（高管、品牌、产品、质量）（产品品质与服务质量没有明显的区分度）<br>特征词数据表：<br>reb_data_db-àpublic_custom  (舆情分类特征词样本太少，目标区分度不明显)<br>读取舆情正文+标题，只要正文中出现特征词，就将当前舆情分类。<br>政策相似度判断：（即：政策分词后的词列表A 与 词列表B 相似度分值）<br>相似度算法位置： com.aliyun.fin.rebengine.nlp.util.algorithm<br>  两两地区的政策进行相似度判断。需要自己进行阈值的调参。</p><h1 id="4-文章分类"><a href="#4-文章分类" class="headerlink" title="4 文章分类"></a>4 文章分类</h1><p>政策分类、扶持对象<br>临港项目： onecompany 对政策进行分类+扶持对象的判别。</p><p>   非临港项目：可能需要自己训练一个政策分类器。此处写自己的思路：<br>利用分布式爬虫框架 从网上抓取各省市县以往的各项政策，需要抓取的内容包含：<br>政策标题+政策正文+该项政策的分类（金融、农业、工业..等）+政策扶持对象。</p><p>利用已有的这些数据 “喂养” 自己的 分类器，（我个人觉得这不是一个线性问题，不是二分逻辑[0/1的问题]，是一个多分类问题，可能需要算法同学在隐藏层的激活函数设置的极好。[说的话都会说，关键在实现] ）<br>训练好分类器之后，就可以对现有的政策进行判别。</p><p>或者像 舆情分模块一样：生硬的将政策分类的特征词、政策扶持对象的特征词提取到表中：只要待判别的政策正文中出现了这些特征词，就给当前政策打上分类标记、扶持对象标记。</p><h1 id="5-Python脚本（参考）"><a href="#5-Python脚本（参考）" class="headerlink" title="5 Python脚本（参考）"></a>5 Python脚本（参考）</h1><p>python脚本（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import pymysql</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as  np</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">#数据库配置</span><br><span class="line">mysql_config &#x3D; &#123;</span><br><span class="line">    # 规则中心</span><br><span class="line">    &#39;rule&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    # 数据来源</span><br><span class="line">    &#39;data&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx1&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据处理类</span><br><span class="line">class DataDict:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 最值数据的枚举KEY</span><br><span class="line">        self._max_min &#x3D; &#39;max_min&#39;</span><br><span class="line">        self._conn_rule &#x3D; pymysql.connect(**mysql_config[&#39;rule&#39;])</span><br><span class="line">        self._conn_data &#x3D; pymysql.connect(**mysql_config[&#39;data&#39;])</span><br><span class="line"></span><br><span class="line">    # DataFrame转换字典</span><br><span class="line">    def _get_data_dict(self, v):</span><br><span class="line">        if len(v) &#x3D;&#x3D; 1:</span><br><span class="line">            return &#123;col: None if v.iloc[0][col] &#x3D;&#x3D; np.nan else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        elif not v.empty and len(v) &gt; 1:</span><br><span class="line">            min_max &#x3D; &#123;&#125;</span><br><span class="line">            for row in v.iterrows():</span><br><span class="line">                temp &#x3D; &#123;col: row[1][col] for col in v.columns&#125;</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]] &#x3D; temp</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;id&#39;)</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;index_name&#39;)</span><br><span class="line">            min_max_temp &#x3D; &#123;&#125;</span><br><span class="line">            for key in min_max.keys():</span><br><span class="line">                min_max_temp.update(&#123;</span><br><span class="line">                    &#39;min_&#39; + key: min_max[key].get(&#39;min_value&#39;),</span><br><span class="line">                    &#39;max_&#39; + key: min_max[key].get(&#39;max_value&#39;),</span><br><span class="line">                &#125;)</span><br><span class="line">            return min_max_temp</span><br><span class="line">        elif v.empty and len(v) &lt;&#x3D; 0:</span><br><span class="line">            return None</span><br><span class="line">            # return &#123;col: 0.0 if v.empty else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    # 最值数据获取（用于归一化处理）</span><br><span class="line">    def _get_min_max_data(self, conn_data, sql_max_min):</span><br><span class="line">        _v &#x3D; pd.read_sql_query(sql_max_min, con&#x3D;conn_data)</span><br><span class="line">        _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">        return self._get_data_dict(_v)</span><br><span class="line"></span><br><span class="line">    # 获取评分项处理后的数据</span><br><span class="line">    def get_process_data(self, ent_name):</span><br><span class="line">        data_dict &#x3D; dict()</span><br><span class="line">        rts &#x3D; dict()</span><br><span class="line">        _s &#x3D; pd.read_sql_query(&quot;SELECT * FROM data_config &quot;, con&#x3D;self._conn_rule)</span><br><span class="line">        _s.set_index([&#39;index&#39;], inplace&#x3D;True)</span><br><span class="line">        raw_sqls &#x3D; _s.to_dict()[&#39;index_sql&#39;]</span><br><span class="line">        for k in raw_sqls:</span><br><span class="line">            if k in self._max_min:</span><br><span class="line">                data_dict[&#39;min_max&#39;] &#x3D; self._get_min_max_data(self._conn_data, raw_sqls[self._max_min])</span><br><span class="line">            else:</span><br><span class="line">                if &#39;%&#39; in raw_sqls[k]:</span><br><span class="line">                    raw_sqls[k] &#x3D; raw_sqls[k].replace(&quot;%&quot;, &quot;%%&quot;)</span><br><span class="line">                sql &#x3D; raw_sqls[k].replace(&#39;&#123;ent_name&#125;&#39;, &#39;%(ent_name)s&#39;)</span><br><span class="line">                _v &#x3D; pd.read_sql(sql, params&#x3D;&#123;&#39;ent_name&#39;: ent_name&#125;, con&#x3D;self._conn_data)</span><br><span class="line">                # _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">                rts[k] &#x3D; self._get_data_dict(_v)</span><br><span class="line">        for k in rts:</span><br><span class="line">            if rts[k] is not None:</span><br><span class="line">                data_dict.update(rts[k])</span><br><span class="line">        return data_dict</span><br><span class="line"></span><br><span class="line">    # 评分卡数据</span><br><span class="line">    def get_score_card(self):</span><br><span class="line">        sql &#x3D; &#39;&#39;&#39;</span><br><span class="line">        SELECT</span><br><span class="line">   A.score_name,</span><br><span class="line">   A.default_value,</span><br><span class="line">   B.express,</span><br><span class="line">   B.score_value,</span><br><span class="line">   B.default_score</span><br><span class="line">FROM</span><br><span class="line">   base_score_card A,</span><br><span class="line">   base_score_card_item B</span><br><span class="line">WHERE</span><br><span class="line">   A.id &#x3D; B.card_id</span><br><span class="line">ORDER BY</span><br><span class="line">   A.id, B.order_no DESC</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        score_card_df &#x3D; pd.read_sql_query(sql, self._conn_rule)</span><br><span class="line">        score_card_df_dict &#x3D; dict(list(score_card_df.groupby([&#39;score_name&#39;])))</span><br><span class="line">        score_card &#x3D; &#123;&#125;</span><br><span class="line">        for k in score_card_df_dict:</span><br><span class="line">            score_card[k] &#x3D; []</span><br><span class="line">            for index, row in score_card_df_dict[k].iterrows():</span><br><span class="line">                score_card[k].append((row[&#39;express&#39;], row[&#39;score_value&#39;], row[&#39;default_value&#39;], row[&#39;default_score&#39;]))</span><br><span class="line">        return score_card</span><br><span class="line"></span><br><span class="line">    # 获取自定义公式分数节点</span><br><span class="line">    def get_score_node(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM model_score_node&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        sn_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            sn_dict[row[&#39;score_node_id&#39;]] &#x3D; row[&#39;expression&#39;]</span><br><span class="line">        return sn_dict</span><br><span class="line"></span><br><span class="line">    # 获取分数层级数据字典</span><br><span class="line">    def get_socre_level(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM dimensional_score_define&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        level_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            level_dict[row[&#39;node_name&#39;]] &#x3D; &#123;col: row[col] for col in _dim_score_define_df.columns&#125;</span><br><span class="line">        return level_dict</span><br><span class="line"></span><br><span class="line">    def close_all_conn(self):</span><br><span class="line">        self._conn_rule.close()</span><br><span class="line">        self._conn_data.close()</span><br><span class="line"></span><br><span class="line"># 规则执行器</span><br><span class="line">class RuleExecutor:</span><br><span class="line">    def __init__(self, ent_name):</span><br><span class="line">        data_dict &#x3D; DataDict()</span><br><span class="line">        self._original_data_dict &#x3D; data_dict.get_process_data(ent_name)</span><br><span class="line">        self._score_card &#x3D; data_dict.get_score_card()</span><br><span class="line">        self._sn_dict &#x3D; data_dict.get_score_node()</span><br><span class="line">        self._level_dict &#x3D; data_dict.get_socre_level()</span><br><span class="line">        self._tree_node &#x3D; &#123;&#125;</span><br><span class="line">        self._temp &#x3D; []</span><br><span class="line">        self._re_pattern &#x3D; r&#39;(?&lt;&#x3D;\&#123;)[^&#125;]*(?&#x3D;\&#125;)&#39;</span><br><span class="line">        self._result_dict &#x3D; &#123;&#125;</span><br><span class="line">        data_dict.close_all_conn()</span><br><span class="line"></span><br><span class="line">    def _add_node(self, p, node):</span><br><span class="line">        # 节点list</span><br><span class="line">        p[&quot;children&quot;] &#x3D; []</span><br><span class="line">        for n in node:</span><br><span class="line">            if n.get(&quot;pid&quot;) &#x3D;&#x3D; p.get(&quot;id&quot;):</span><br><span class="line">                p[&quot;children&quot;].append(n)</span><br><span class="line">        # 递归子节点，查找子节点的子节点</span><br><span class="line">        for t in p[&quot;children&quot;]:</span><br><span class="line">            if not t.get(&quot;children&quot;):</span><br><span class="line">                t[&quot;children&quot;] &#x3D; []</span><br><span class="line">            t[&quot;children&quot;].append(self._add_node(t, node))</span><br><span class="line">        # 退出递归的条件</span><br><span class="line">        if len(p[&quot;children&quot;]) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def init_score_tree(self):</span><br><span class="line">        root &#x3D; []</span><br><span class="line">        node &#x3D; []</span><br><span class="line">        # 获取根节点 和 其他子节点 list</span><br><span class="line">        for k in self._level_dict:</span><br><span class="line">            if self._level_dict[k][&#39;pid&#39;] &#x3D;&#x3D; 0:</span><br><span class="line">                root.append(self._level_dict[k])</span><br><span class="line">            else:</span><br><span class="line">                node.append(self._level_dict[k])</span><br><span class="line">        # 查找子节点</span><br><span class="line">        for p in root:</span><br><span class="line">            self._add_node(p, node)</span><br><span class="line">        self._tree_node.update(root[0])</span><br><span class="line"></span><br><span class="line">    def _get_card_score(self, sn_id):</span><br><span class="line">        score_list &#x3D; self._score_card[sn_id]</span><br><span class="line"></span><br><span class="line">        for bds in score_list:</span><br><span class="line">            express &#x3D; bds[0]</span><br><span class="line">            score_value &#x3D; bds[1]</span><br><span class="line">            default_value &#x3D; None if np.isnan(bds[2]) else bds[2]</span><br><span class="line">            default_score &#x3D; None if np.isnan(bds[3]) else bds[3]</span><br><span class="line"></span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, express)</span><br><span class="line">            str_list &#x3D; list(set(str_list))</span><br><span class="line">            _data_dict &#x3D; &#123;&#125;</span><br><span class="line">            for c in str_list:</span><br><span class="line">                if c not in self._original_data_dict:</span><br><span class="line">                    return 0</span><br><span class="line">                _data_dict[c] &#x3D; default_score if self._original_data_dict[c] is None  else self._original_data_dict[c]</span><br><span class="line">            express_replaced &#x3D; express.format(**_data_dict)</span><br><span class="line"></span><br><span class="line">            try:</span><br><span class="line">                if eval(express_replaced):</span><br><span class="line">                    if &#39;&#123;&#39; in score_value:</span><br><span class="line">                        sv_express &#x3D; score_value.format(**self._original_data_dict)</span><br><span class="line">                        score_value &#x3D; float(eval(sv_express))</span><br><span class="line">                        score_value &#x3D; score_value if score_value !&#x3D; 0 else abs(score_value)</span><br><span class="line">                    break</span><br><span class="line">            except BaseException:</span><br><span class="line">                return default_value</span><br><span class="line">        return float(score_value)</span><br><span class="line"></span><br><span class="line">    # 执行sn表达式</span><br><span class="line">    def _get_sn_express_value(self, sn_id):</span><br><span class="line">        sn_node_express &#x3D; self._sn_dict[sn_id]</span><br><span class="line">        str_list &#x3D; re.findall(self._re_pattern, sn_node_express)</span><br><span class="line">        v_dict &#x3D; &#123;&#125;</span><br><span class="line">        for new_sn_id in str_list:</span><br><span class="line">            if new_sn_id in self._sn_dict.keys():</span><br><span class="line">                v_dict[new_sn_id] &#x3D; self._get_sn_express_value(new_sn_id)</span><br><span class="line">            else:</span><br><span class="line">                card_score &#x3D; self._get_card_score(new_sn_id)</span><br><span class="line">                v_dict[new_sn_id] &#x3D; card_score</span><br><span class="line">        score &#x3D; eval(sn_node_express.format(**v_dict))</span><br><span class="line">        # print(&quot;sn_id:%s,  %s    %s &#x3D; %s&quot; % (sn_id, sn_node_express, sn_node_express.format(**v_dict) ,score))</span><br><span class="line">        return score</span><br><span class="line"></span><br><span class="line">    # 执行dimensional_score_define的表达式</span><br><span class="line">    def _get_expression_value(self, node_name, level_dict):</span><br><span class="line">        self._temp.append(node_name)</span><br><span class="line"></span><br><span class="line">        item &#x3D; level_dict[node_name]</span><br><span class="line"></span><br><span class="line">        if item[&#39;expression&#39;] is None or item[&#39;expression&#39;] &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">            sn_id &#x3D; item[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line">        else:</span><br><span class="line">            expression &#x3D; item[&#39;expression&#39;]</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for var in str_list:</span><br><span class="line">                v_dict[var] &#x3D; self._get_expression_value(var, level_dict)[1]</span><br><span class="line">            score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line"></span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line"></span><br><span class="line">    def _computer_node_score(self, tree_node&#x3D;&#123;&#125;):</span><br><span class="line">        if tree_node[&#39;node_name&#39;] in self._temp:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        dis_name &#x3D; tree_node[&#39;node_display_name&#39;]</span><br><span class="line">        expression &#x3D; tree_node[&#39;expression&#39;]</span><br><span class="line">        result &#x3D; &#123;&quot;name&quot;: dis_name, &#39;score&#39;: 0&#125;</span><br><span class="line">        if expression is None:</span><br><span class="line">            sn_id &#x3D; tree_node[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            result[&#39;score&#39;] &#x3D; score</span><br><span class="line">        else:</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for score_id in str_list:</span><br><span class="line">                score_info &#x3D; self._get_expression_value(score_id, self._level_dict)</span><br><span class="line">                score &#x3D; score_info[1]</span><br><span class="line">                v_dict[score_id] &#x3D; score</span><br><span class="line">            total_score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line">            result[&#39;score&#39;] &#x3D; total_score</span><br><span class="line">        self._result_dict[tree_node[&#39;node_name&#39;]] &#x3D; &#123;&#39;formula_id&#39;: tree_node[&#39;formula_id&#39;], &#39;value&#39;: result[&#39;score&#39;],</span><br><span class="line">                                                     &#39;dis_name&#39;: tree_node[&#39;node_display_name&#39;]&#125;</span><br><span class="line"></span><br><span class="line">    def _computer_score(self, tree_node):</span><br><span class="line">        children &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        self._computer_node_score(tree_node)</span><br><span class="line">        if len(children) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line">        for child_node in children:</span><br><span class="line">            self._computer_score(child_node)</span><br><span class="line"></span><br><span class="line">    def process_score(self):</span><br><span class="line">        self._computer_score(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def _get_standard_score(self, value, fid, df_value&#x3D;0):</span><br><span class="line">        min_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;min_&#39; + fid]</span><br><span class="line">        max_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;max_&#39; + fid]</span><br><span class="line">        std_score &#x3D; df_value if max_score - min_score &#x3D;&#x3D; 0 else pow((value - min_score) &#x2F; (max_score - min_score), 2) * 100</span><br><span class="line">        # print( &#39;fid:%s \t (%s - %s) &#x2F; (%s - %s ) x2 * 100 &#x3D; %s&#39; % (fid,value,min_score,max_score,min_score,std_score))</span><br><span class="line">        return std_score</span><br><span class="line"></span><br><span class="line">    def _rebuild_node_tree(self, tree_node):</span><br><span class="line">        for v in [&#39;id&#39;, &#39;model_id&#39;, &#39;pid&#39;, &#39;default_value&#39;, &#39;expression&#39;, &#39;sn_id&#39;, &#39;formula_id&#39;]:</span><br><span class="line">            tree_node.pop(v)</span><br><span class="line">        tree_node[&#39;score&#39;] &#x3D; self._get_standard_score(self._result_dict[tree_node[&#39;node_name&#39;]][&#39;value&#39;],</span><br><span class="line">                                                      self._result_dict[tree_node[&#39;node_name&#39;]][&#39;formula_id&#39;])</span><br><span class="line">        child_node &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        if len(child_node) &gt; 0:</span><br><span class="line">            for node in child_node:</span><br><span class="line">                self._rebuild_node_tree(node)</span><br><span class="line">        else:</span><br><span class="line">            tree_node.pop(&#39;children&#39;)</span><br><span class="line">        return tree_node</span><br><span class="line"></span><br><span class="line">    def get_result(self):</span><br><span class="line">        return self._rebuild_node_tree(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def print_data(self):</span><br><span class="line">        print(self._level_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init(context):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calc_ent(ent_info, context):</span><br><span class="line"></span><br><span class="line">    rule_executor &#x3D; RuleExecutor(ent_info[&quot;ent_name&quot;])</span><br><span class="line"></span><br><span class="line">    # 初始化层级树</span><br><span class="line">    rule_executor.init_score_tree()</span><br><span class="line"></span><br><span class="line">    # 计算处理</span><br><span class="line">    rule_executor.process_score()</span><br><span class="line"></span><br><span class="line">    # 获取结果</span><br><span class="line">    result &#x3D; rule_executor.get_result()</span><br><span class="line"></span><br><span class="line">    return json.dumps(result,ensure_ascii&#x3D; False)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ent_info &#x3D; calc_ent(&#123;&quot;ent_name&quot;:&quot;东方成安资产管理有限公司&quot;&#125;,None)</span><br><span class="line">    print(ent_info)</span><br></pre></td></tr></table></figure><h1 id="6-SQL语句-拼接SQL"><a href="#6-SQL语句-拼接SQL" class="headerlink" title="6 SQL语句-拼接SQL"></a>6 SQL语句-拼接SQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select TABLE_NAME,</span><br><span class="line">concat( &#39;insert into &#39;, table_name, &#39;(&#39;, GROUP_CONCAT(COLUMN_NAME) , &#39;) select &#39;, GROUP_CONCAT(COLUMN_NAME),</span><br><span class="line">&#39;from reb_lingang_db.&#39;, TABLE_NAME,&#39;;&#39;)</span><br><span class="line">from information_schema.columns where table_schema &#x3D; &#39;reb_lingang_db&#39; and table_name regexp &#39;^dw_bc*&#39; and COLUMN_NAME not in (&#39;id&#39;)</span><br><span class="line">GROUP BY TABLE_NAME;</span><br></pre></td></tr></table></figure><h1 id="7-MySql导出表结构"><a href="#7-MySql导出表结构" class="headerlink" title="7 MySql导出表结构"></a>7 MySql导出表结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">COLUMN_NAME 字段,</span><br><span class="line">COLUMN_TYPE 数据类型,</span><br><span class="line">DATA_TYPE 字段类型,</span><br><span class="line">CHARACTER_MAXIMUM_LENGTH 长度,</span><br><span class="line">IS_NULLABLE 是否为空,</span><br><span class="line">COLUMN_KEY 是否为主键,</span><br><span class="line">COLUMN_DEFAULT 默认值,</span><br><span class="line">COLUMN_COMMENT 备注</span><br><span class="line">FROM</span><br><span class="line">INFORMATION_SCHEMA.COLUMNS</span><br><span class="line">where</span><br><span class="line">-- database为数据库名称，到时候只需要修改成你要导出表结构的数据库即可</span><br><span class="line">table_schema &#x3D;&#39;reb_db&#39;</span><br><span class="line">AND</span><br><span class="line">-- table_name为表名</span><br><span class="line">table_name &#x3D; &#39;reb_overview_comp_index_month&#39;;</span><br></pre></td></tr></table></figure><h1 id="8-多数据源（只是用来作为参考）"><a href="#8-多数据源（只是用来作为参考）" class="headerlink" title="8 多数据源（只是用来作为参考）"></a>8 多数据源（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; EngineDataSourceConfig.PACKAGE, sqlSessionFactoryRef &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">public class EngineDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.engine&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.engine&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource engineDatasource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory engineSqlSessionFactory(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(</span><br><span class="line">            new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;engine&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineTransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager engineTransactionManager(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate engineSqlSessionTemplate(</span><br><span class="line">        @Qualifier(&quot;engineSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; RebDataSourceConfig.PACKAGE,sqlSessionFactoryRef &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">public class RebDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.reb&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.reb&quot;)</span><br><span class="line">    public DataSource rebDatasource() &#123;</span><br><span class="line">        DataSource dataSource &#x3D; DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory rebSqlSessionFactory(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;reb&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebTransactionManager&quot;)</span><br><span class="line">    public DataSourceTransactionManager rebTransactionManager(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionTemplate&quot;)</span><br><span class="line">    public SqlSessionTemplate rebSqlSessionTemplate(@Qualifier(&quot;rebSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    reb:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_lingang_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    engine:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_data_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  thymeleaf:</span><br><span class="line">     cache: false</span><br><span class="line">     encoding: utf-8</span><br><span class="line">     mode: HTML5</span><br><span class="line">     servlet:</span><br><span class="line">       content-type: text&#x2F;html</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line"># 日志配置</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org:</span><br><span class="line">      springframework:</span><br><span class="line">        web: info</span><br><span class="line">        transaction: info</span><br><span class="line">    com:</span><br><span class="line">      aliyun:</span><br><span class="line">        fin:</span><br><span class="line">          rebengine:</span><br><span class="line">              manager:</span><br><span class="line">                mapper: error</span><br></pre></td></tr></table></figure><h1 id="9-JWTUtil（只是用来作为参考）"><a href="#9-JWTUtil（只是用来作为参考）" class="headerlink" title="9 JWTUtil（只是用来作为参考）"></a>9 JWTUtil（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line">    &#x2F;**过期时间30分钟*&#x2F;</span><br><span class="line">    private static final long EXPIRE_TIME &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成签名(生成token字符串)</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param secret 密码</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String sign(String username, String secret)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            return JWT.create()</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得token中的信息无需secret解密也能获得</span><br><span class="line">     * @return token中包含的用户名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getUsername(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DecodedJWT jwt &#x3D; JWT.decode(token);</span><br><span class="line">            return jwt.getClaim(&quot;username&quot;).asString();</span><br><span class="line">        &#125; catch (JWTDecodeException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 校验token是否正确</span><br><span class="line">     * @param token 密钥</span><br><span class="line">     * @param secret 用户的密码</span><br><span class="line">     * @return 是否正确</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean verify(String token, String username, String secret) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            JWTVerifier verifier &#x3D; JWT.require(algorithm)</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .build();</span><br><span class="line">            DecodedJWT jwt &#x3D; verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-JWTFilterConfig（只是用来作为参考）"><a href="#10-JWTFilterConfig（只是用来作为参考）" class="headerlink" title="10 JWTFilterConfig（只是用来作为参考）"></a>10 JWTFilterConfig（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class JWTFilterConfig implements Filter&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest &#x3D; (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse httpResponse &#x3D; (HttpServletResponse) servletResponse;</span><br><span class="line">        String url &#x3D; httpRequest.getRequestURI().substring(httpRequest.getContextPath().length());</span><br><span class="line">        ServletContext sc &#x3D; httpRequest.getServletContext();</span><br><span class="line">        WebApplicationContext cxt &#x3D; WebApplicationContextUtils.getWebApplicationContext(sc);</span><br><span class="line">        if(cxt !&#x3D; null &amp;&amp; cxt.getBean(&quot;redisTemplate&quot;) !&#x3D; null &amp;&amp; redisTemplate &#x3D;&#x3D; null) &#123;</span><br><span class="line">            redisTemplate &#x3D; (RedisTemplate) cxt.getBean(&quot;redisTemplate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 跨域请求</span><br><span class="line">         *&#x2F;</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, httpRequest.getHeader(&quot;Origin&quot;));</span><br><span class="line">&#x2F;&#x2F;        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Content-Disposition&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin&quot;);</span><br><span class="line">        &#x2F;&#x2F;是否支持cookie跨域</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);</span><br><span class="line">        &#x2F;&#x2F;允许在请求头里存放token</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Authorization,Content-Disposition&quot;);</span><br><span class="line"></span><br><span class="line">        String method &#x3D; httpRequest.getMethod();</span><br><span class="line">&#x2F;&#x2F;        filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line"></span><br><span class="line">        if (&quot;OPTIONS&quot;.equals(method)) &#123;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String authorization &#x3D; httpRequest.getHeader(&quot;Authorization&quot;);</span><br><span class="line">            &#x2F;&#x2F;不需要拦截的路径</span><br><span class="line">            if (!url.contains(&quot;&#x2F;swagger&quot;) &amp;&amp; !url.contains(&quot;&#x2F;login&quot;) &amp;&amp; !url.contains(&quot;&#x2F;registerDepartmentSelected&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;getSecurityCode&quot;) &amp;&amp; !url.contains(&quot;&#x2F;register&quot;) &amp;&amp; !url.contains(&quot;&#x2F;downLoadExcel&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;exportEntRelation&quot;) &amp;&amp; !url.contains(&quot;&#x2F;exportCompanyList&quot;) &amp;&amp; !url.contains(&quot;&#x2F;api&#x2F;merchantsradar&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;.ico&quot;) &amp;&amp; !url.contains(&quot;.json&quot;) &amp;&amp; !url.contains(&quot;&#x2F;statics&quot;) &amp;&amp; !url.contains(&quot;.js&quot;) &amp;&amp; !url.contains(&quot;.css&quot;) &amp;&amp; !url.contains(&quot;&#x2F;static&quot;) &amp;&amp; !url.contains(&quot;&#x2F;media&quot;) &amp;&amp; !url.contains(&quot;&#x2F;synchronization&quot;)) &#123;</span><br><span class="line">                if (StringUtils.isNotBlank(authorization))&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String token &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F;避免redis为空报错，先一步校验key是否存在</span><br><span class="line">                        Boolean aBoolean &#x3D; redisTemplate.hasKey(&quot;reb_backend_&quot; + authorization);</span><br><span class="line">                        if (!aBoolean)&#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            token &#x3D; redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + authorization).toString();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">                            redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + authorization, authorization, TokenUtil.getToken(), TimeUnit.SECONDS);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                        jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                        jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                        jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                        httpResponse.setStatus(200);</span><br><span class="line">                        httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                        httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                    jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                    jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                    jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                    httpResponse.setStatus(200);</span><br><span class="line">                    httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                    httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-Login（只是用来作为参考）"><a href="#11-Login（只是用来作为参考）" class="headerlink" title="11 Login（只是用来作为参考）"></a>11 Login（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags &#x3D; &#123;&quot;后台管理&quot;&#125;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(UserController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rebBackend.token.expirationDate&#125;&quot;)</span><br><span class="line">    private long tokenExpirationDate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户登录</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;10&#x2F;10 18:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户登录&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;account&quot;,value &#x3D; &quot;用户账号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public JSONObject login(String account, String password,HttpServletRequest request)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if(StringUtils.isBlank(password) )&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(account))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;account&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String userStatus &#x3D; (String) redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + account);</span><br><span class="line">            String index &#x3D; &quot;3&quot;;</span><br><span class="line">            if (StringUtils.equals(userStatus,index))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误次数过多,请5分钟之后重试&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            if (null&#x3D;&#x3D;user)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户不存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index2 &#x3D; &quot;2&quot;;</span><br><span class="line">            if (user.getStatus().equals(index2))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户已被锁定&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index3 &#x3D; &quot;3&quot;;</span><br><span class="line">            if (user.getStatus().equals(index3))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户正在审批中&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password,&quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            if (user.getPassword().equals(md5Password))&#123;</span><br><span class="line">                &#x2F;&#x2F;登录成功之后保存用户操作日志</span><br><span class="line">                UserLogger userLogger &#x3D; new UserLogger()&#123;&#123;</span><br><span class="line">                    setUserAccount(account);</span><br><span class="line">                    setUserName(user.getUsername());</span><br><span class="line">                    setLoggerType(&quot;1&quot;);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                userService.saveUserLogger(userLogger);</span><br><span class="line">                &#x2F;&#x2F;登录成功之后将token缓存到redis</span><br><span class="line">                String token &#x3D; JwtUtil.sign(account,user.getPassword());</span><br><span class="line">                RedisModel redisModel &#x3D; new RedisModel()&#123;&#123;</span><br><span class="line">                    setKey(&quot;reb_backend_&quot; + token);</span><br><span class="line">                    setValue(token);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                redisTemplate.opsForValue().set(redisModel.getKey(),redisModel.getValue(),tokenExpirationDate,TimeUnit.SECONDS);</span><br><span class="line">                jsonObject.put(&quot;token&quot;,token);</span><br><span class="line">                jsonObject.put(&quot;username&quot;,user.getUsername());</span><br><span class="line">                jsonObject.put(&quot;userId&quot;,user.getId());</span><br><span class="line">                List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">                &#x2F;&#x2F;获取用户所属部门</span><br><span class="line">                Integer departmentId &#x3D; userService.findDepartmentIdByUserId(user.getId());</span><br><span class="line">                jsonObject.put(&quot;role&quot;,roleList.get(0));</span><br><span class="line">                jsonObject.put(&quot;departmentId&quot;,departmentId);</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                userStatus &#x3D; userStatus&#x3D;&#x3D;null ? &quot;1&quot; : Integer.parseInt(userStatus)  + 1 + &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                if (userStatus.equals(index3))&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300, TimeUnit.SECONDS);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300,TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-用户登录&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-登出接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;23 11:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @GetMapping(&quot;exit&quot;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-登出接口&quot;)</span><br><span class="line">    public JSONObject exit(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            redisTemplate.delete(&quot;reb_backend_&quot; + token);</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            userService.exit(user);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-登出接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户注册</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;11&#x2F;20 10:05</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册&quot;)</span><br><span class="line">    @GetMapping(&quot;register&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;code&quot;,value &#x3D; &quot;验证码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject register(String username,String phone,Integer departmentId,String password,String code,HttpServletRequest request) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        String checkCode &#x3D; (String) request.getSession().getAttribute(&quot;code&quot;);</span><br><span class="line">        String newCheckCode &#x3D; checkCode.toLowerCase();</span><br><span class="line">        String newCode &#x3D; code.toLowerCase();</span><br><span class="line">        if (!newCode.equals(newCheckCode)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;验证码错误&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(username)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(phone)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(password)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">        User user &#x3D; userService.findUserByAccount(phone);</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;该手机号已被注册&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password, &quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            userService.register(username, phone, departmentId, md5Password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 后台管理-用户登录首次加载列表</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;10 13:53</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;后台管理-用户登录首次加载列表&quot;)</span><br><span class="line">    @GetMapping(&quot;userLoginFirstLoadList&quot;)</span><br><span class="line">    public JSONObject userLoginFirstLoadList(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            jsonObject &#x3D; userService.userLoginFirstLoadList(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;后台管理-用户登录首次加载列表&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-模块授权下拉</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;11 16:10</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-模块授权下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;authorizationModuleSelected&quot;)</span><br><span class="line">    public JSONObject authorizationModuleSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject &#x3D; userService.authorizationModuleSelected();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-模块授权下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;12 10:55</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readUserListShow&quot;)</span><br><span class="line">    public JSONObject readUserListShow(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;UserVO&gt; list &#x3D; userService.readUserListShow(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户列表展示&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-角色下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 10:06</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-角色下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readRoleSelected&quot;)</span><br><span class="line">    public JSONObject readRoleSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            JSONArray jsonArray &#x3D; userService.readRoleSelected(roleList.get(0));</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,jsonArray);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-角色下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号删除&#x2F;拒绝通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:26</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号删除&#x2F;拒绝通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;delAndRefuseUser&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    public JSONObject delAndRefuseUser(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delAndRefuseUser(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号删除&#x2F;拒绝通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号启用&#x2F;禁用通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:43</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号启用&#x2F;禁用通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;enableAndDisabledUser&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userStatus&quot;,value &#x3D; &quot;用户状态 1：启用 2：禁用 3：申请中&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject enableAndDisabledUser(Integer userId,Integer userStatus)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.enableAndDisabledUser(userId,userStatus);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号启用&#x2F;禁用通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户通过申请</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 14:41</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户通过申请&quot;)</span><br><span class="line">    @GetMapping(&quot;adoptUser&quot;)</span><br><span class="line">    public JSONObject adoptUser(Integer userId,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.adoptUser(userId,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户通过申请&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-管理员添加用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;14 17:08</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-管理员添加用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;adminAddUser&quot;)</span><br><span class="line">    public JSONObject adminAddUser(String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,0);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.adminAddUser(username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-管理员添加用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;17 14:45</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updateUser&quot;)</span><br><span class="line">    public JSONObject updateUser(Integer id,String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验手机号是否已存在</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,id);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updateUser(id,username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-添加部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 10:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-添加部门&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentName&quot;, value &#x3D; &quot;部门名称&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;addDepartment&quot;)</span><br><span class="line">    public JSONObject addDepartment(String departmentName,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (StringUtils.isBlank(departmentName))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;departmentName&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(model))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;model&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验部门名称是否已存在</span><br><span class="line">            Integer id &#x3D; userService.findDepartmentByDepartmentName(departmentName);</span><br><span class="line">            if (id !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;部门名称已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.addDepartment(departmentName,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;部门管理-添加部门&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-部门列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 11:00</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-部门列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentShow&quot;)</span><br><span class="line">    public JSONObject readDepartmentShow(@RequestHeader(&quot;Authorization&quot;) String token) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentShow(roleList.get(0), user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;, list);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;部门管理-部门列表展示&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-删除部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;29 9:52</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-删除部门&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;delDepartment&quot;)</span><br><span class="line">    public JSONObject delDepartment(Integer departmentId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delDepartment(departmentId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-删除部门&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-授权模块</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 16:31</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-授权模块&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;authorizationModule&quot;)</span><br><span class="line">    public JSONObject authorizationModule(Integer departmentId,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.authorizationModule(departmentId,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-授权模块&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-部门下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject readDepartmentSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentSelected(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @Description: 用户管理-用户注册部门下拉框</span><br><span class="line">     * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">     * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">     **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;registerDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject registerDepartmentSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.registerDepartmentSelected();</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-获取验证码</span><br><span class="line">      * @return void</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;26 14:58</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-获取验证码&quot;)</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;getSecurityCode&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public void getSecurityCode(HttpServletResponse response, HttpServletRequest request,Integer random)&#123;</span><br><span class="line">        &#x2F;&#x2F; 设置响应的类型格式为图片格式</span><br><span class="line">        response.setContentType(&quot;image&#x2F;jpeg&quot;);</span><br><span class="line">        &#x2F;&#x2F; 通知浏览器不要缓存</span><br><span class="line">        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;, &quot;-1&quot;);</span><br><span class="line">        SecurityUtil util &#x3D; SecurityUtil.instance();</span><br><span class="line">        &#x2F;&#x2F; 将验证码输入到session中，用来验证</span><br><span class="line">        String code &#x3D; util.getString();</span><br><span class="line">        request.getSession().setAttribute(&quot;code&quot;, code);</span><br><span class="line">        &#x2F;&#x2F; 输出打web页面</span><br><span class="line">        try &#123;</span><br><span class="line">            ImageIO.write(util.getImage(), &quot;jpg&quot;, response.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:21</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改密码&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updatePassword&quot;)</span><br><span class="line">    public JSONObject updatePassword(Integer userId,String password)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updatePassword(userId,password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-校验原密码是否正确</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:36</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-校验原密码是否正确&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;checkPassword&quot;)</span><br><span class="line">    public JSONObject checkPassword(String password,Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean check &#x3D; userService.checkPassword(userId,password);</span><br><span class="line">            if (!check)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-校验原密码是否正确&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-重置密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:57</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-重置密码&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;resetPassword&quot;)</span><br><span class="line">    public JSONObject resetPassword(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.resetPassword(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-重置密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12 Pom配置（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;reb_backend&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;reb_service&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;reb_service&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&#39;s website --&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;www.example.com&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;shiro.version&gt;1.4.0&lt;&#x2F;shiro.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Spring Boot中使用Swagger2构建强大的RESTful API文档--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 连接池  --&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;version&gt;1.1.5&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- esay poi --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- guava --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;18.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- shiro 配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- json --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 缓存 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.sf.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reb_common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--easypoi--&gt;</span><br><span class="line">        &lt;!--easypoi导出excel --&gt;</span><br><span class="line">        &lt;!--easypoi-base 导入导出的工具包,可以完成Excel导出,导入,Word的导出,Excel的导出功能 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- springboot整合redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;!-- 指定该Main Class为全局的唯一入口 --&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.aliyun.finintell.rebbackend.RebBackendApplication&lt;&#x2F;mainClass&gt;</span><br><span class="line">                    &lt;layout&gt;ZIP&lt;&#x2F;layout&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-clean-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;!-- see http:&#x2F;&#x2F;maven.apache.org&#x2F;ref&#x2F;current&#x2F;maven-core&#x2F;default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.7.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.20.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-install-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.5.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-deploy-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.8.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;&#x2F;pluginManagement&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搬砖结晶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>52-算法实战（五）_如何用学过的数据结构和算法实现一个短网址系统</title>
      <link href="/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>短网址服务你用过吗？如果我们在微博里发布一条带网址的信息，微博会把里面的网址转化成一个更短的网址。我们只要访问这个短网址，就相当于访问原始的网址。比如下面这两个网址，尽管长度不同，但是都可以跳转到我的一个 GitHub 开源项目里。其中，第二个网址就是通过新浪提供的短网址服务生成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始网址：https:&#x2F;&#x2F;github.com&#x2F;wangzheng0822&#x2F;ratelimiter4j</span><br><span class="line">短网址：http:&#x2F;&#x2F;t.cn&#x2F;EtR9QEG</span><br></pre></td></tr></table></figure><p>从功能上讲，短网址服务其实非常简单，就是把一个长的网址转化成一个短的网址。作为一名软件工程师，你是否思考过，这样一个简单的功能，是如何实现的呢？底层都依赖了哪些数据结构和算法呢？短网址服务整体介绍</p><a id="more"></a><h2 id="短网址服务整体介绍"><a href="#短网址服务整体介绍" class="headerlink" title="短网址服务整体介绍"></a>短网址服务整体介绍</h2><p>短网址服务的一个核心功能，就是把原始的长网址转化成短网址。除了这个功能之外，短网址服务还有另外一个必不可少的功能。那就是，当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址。这个过程是如何实现的呢？</p><p>为了方便你理解，我画了一张对比图，你可以看下。</p><p><img src="/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/440acdc8-6b30-4ff0-a3e6-00081314ccfe.jpg" alt></p><p>从图中我们可以看出，浏览器会先访问短网址服务，通过短网址获取到原始网址，再通过原始网址访问到页面。不过这部分功能并不是我们今天要讲的重点。我们重点来看，如何将长网址转化成短网址？</p><h2 id="如何通过哈希算法生成短网址？"><a href="#如何通过哈希算法生成短网址？" class="headerlink" title="如何通过哈希算法生成短网址？"></a>如何通过哈希算法生成短网址？</h2><p>我们前面学过哈希算法。哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。我们可以利用哈希算法，来生成短网址。</p><p>前面我们已经提过一些哈希算法了，比如 MD5、SHA 等。但是，实际上，我们并不需要这些复杂的哈希算法。在生成短网址这个问题上，毕竟，我们不需要考虑反向解密的难度，所以我们只需要关心哈希算法的计算速度和冲突概率。</p><p>能够满足这样要求的哈希算法有很多，其中比较著名并且应用广泛的一个哈希算法，那就是 <strong>MurmurHash 算法</strong> 。尽管这个哈希算法在 2008 年才被发明出来，但现在它已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p><p>MurmurHash 算法提供了两种长度的哈希值，一种是 32bits，一种是 128bits。为了让最终生成的短网址尽可能短，我们可以选择 32bits 的哈希值。对于开头那个 GitHub 网址，经过 MurmurHash 计算后，得到的哈希值就是 181338494。我们再拼上短网址服务的域名，就变成了最终的短网址 <a href="http://t.cn/181338494（其中，http://t.cn" target="_blank" rel="noopener">http://t.cn/181338494（其中，http://t.cn</a> 是短网址服务的域名）。</p><h3 id="1-如何让短网址更短？"><a href="#1-如何让短网址更短？" class="headerlink" title="1. 如何让短网址更短？"></a>1. 如何让短网址更短？</h3><p>不过，你可能已经看出来了，通过 MurmurHash 算法得到的短网址还是很长啊，而且跟我们开头那个网址的格式好像也不一样。别着急，我们只需要稍微改变一个哈希值的表示方法，就可以轻松把短网址变得更短些。</p><p>我们可以将 10 进制的哈希值，转化成更高进制的哈希值，这样哈希值就变短了。我们知道，16 进制中，我们用 A～E，来表示 10～15。在网址 URL 中，常用的合法字符有 0～9、a～z、A～Z 这样 62 个字符。为了让哈希值表示起来尽可能短，我们可以将 10 进制的哈希值转化成 62 进制。具体的计算过程，我写在这里了。最终用 62 进制表示的短网址就是<a href="http://t.cn/cgSqq。" target="_blank" rel="noopener">http://t.cn/cgSqq。</a></p><p><img src="/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/a928e86d-84c9-491b-8fda-b1daff21b02e.jpg" alt></p><h3 id="2-如何解决哈希冲突问题？"><a href="#2-如何解决哈希冲突问题？" class="headerlink" title="2. 如何解决哈希冲突问题？"></a>2. 如何解决哈希冲突问题？</h3><p>不过，我们前面讲过，哈希算法无法避免的一个问题，就是哈希冲突。尽管 MurmurHash 算法，冲突的概率非常低。但是，一旦冲突，就会导致两个原始网址被转化成同一个短网址。当用户访问短网址的时候，我们就无从判断，用户想要访问的是哪一个原始网址了。这个问题该如何解决呢？</p><p>一般情况下，我们会保存短网址跟原始网址之间的对应关系，以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。存储这种对应关系的方式有很多，比如我们自己设计存储系统或者利用现成的数据库。前面我们讲到的数据库有 MySQL、Redis。我们就拿 MySQL 来举例。假设短网址与原始网址之间的对应关系，就存储在 MySQL 数据库中。</p><p>当有一个新的原始网址需要生成短网址的时候，我们先利用 MurmurHash 算法，生成短网址。然后，我们拿这个新生成的短网址，在 MySQL 数据库中查找。</p><p>如果没有找到相同的短网址，这也就表明，这个新生成的短网址没有冲突。于是我们就将这个短网址返回给用户（请求生成短网址的用户），然后将这个短网址与原始网址之间的对应关系，存储到 MySQL 数据库中。</p><p>如果我们在数据库中，找到了相同的短网址，那也并不一定说明就冲突了。我们从数据库中，将这个短网址对应的原始网址也取出来。如果数据库中的原始网址，跟我们现在正在处理的原始网址是一样的，这就说明已经有人请求过这个原始网址的短网址了。我们就可以拿这个短网址直接用。如果数据库中记录的原始网址，跟我们正在处理的原始网址不一样，那就说明哈希算法发生了冲突。不同的原始网址，经过计算，得到的短网址重复了。这个时候，我们该怎么办呢？</p><p>我们可以给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后跟再重新计算哈希值，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，我们可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 MySQL 数据库中。</p><p>当用户访问短网址的时候，短网址服务先通过短网址，在数据库中查找到对应的原始网址。如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），我们就先将特殊字符去掉，然后再将不包含特殊字符的原始网址返回给浏览器。</p><h3 id="3-如何优化哈希算法生成短网址的性能？"><a href="#3-如何优化哈希算法生成短网址的性能？" class="headerlink" title="3. 如何优化哈希算法生成短网址的性能？"></a>3. 如何优化哈希算法生成短网址的性能？</h3><p>为了判断生成的短网址是否冲突，我们需要拿生成的短网址，在数据库中查找。如果数据库中存储的数据非常多，那查找起来就会非常慢，势必影响短网址服务的性能。那有没有什么优化的手段呢？</p><p>还记得我们之前讲的 MySQL 数据库索引吗？我们可以给短网址字段添加 B+ 树索引。这样通过短网址查询原始网址的速度就提高了很多。实际上，在真实的软件开发中，我们还可以通过一个小技巧，来进一步提高速度。</p><p>在短网址生成的过程中，我们会跟数据库打两次交道，也就是会执行两条 SQL 语句。第一个 SQL 语句是通过短网址查询短网址与原始网址的对应关系，第二个 SQL 语句是将新生成的短网址和原始网址之间的对应关系存储到数据库。</p><p>我们知道，一般情况下，数据库和应用服务（只做计算不存储数据的业务逻辑部分）会部署在两个独立的服务器或者虚拟服务器上。那两条 SQL 语句的执行就需要两次网络通信。这种 IO 通信耗时以及 SQL 语句的执行，才是整个短网址服务的性能瓶颈所在。所以，为了提高性能，我们需要尽量减少 SQL 语句。那又该如何减少 SQL 语句呢？</p><p>我们可以给数据库中的短网址字段，添加一个唯一索引（不止是索引，还要求表中不能有重复的数据）。当有新的原始网址需要生成短网址的时候，我们并不会先拿生成的短网址，在数据库中查找判重，而是直接将生成的短网址与对应的原始网址，尝试存储到数据库中。如果数据库能够将数据正常写入，那说明并没有违反唯一索引，也就是说，这个新生成的短网址并没有冲突。</p><p>当然，如果数据库反馈违反唯一性索引异常，那我们还得重新执行刚刚讲过的“查询、写入”过程，SQL 语句执行的次数不减反增。但是，在大部分情况下，我们把新生成的短网址和对应的原始网址，插入到数据库的时候，并不会出现冲突。所以，大部分情况下，我们只需要执行一条写入的 SQL 语句就可以了。所以，从整体上看，总的 SQL 语句执行次数会大大减少。</p><p>实际上，我们还有另外一个优化 SQL 语句次数的方法，那就是借助布隆过滤器。</p><p>我们把已经生成的短网址，构建成布隆过滤器。我们知道，布隆过滤器是比较节省内存的一种存储结构，长度是 10 亿的布隆过滤器，也只需要 125MB 左右的内存空间。</p><p>当有新的短网址生成的时候，我们先拿这个新生成的短网址，在布隆过滤器中查找。如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突。这个时候，我们只需要再执行写入短网址和对应原始网页的 SQL 语句就可以了。通过先查询布隆过滤器，总的 SQL 语句的执行次数减少了。</p><p>到此，利用哈希算法来生成短网址的思路，我就讲完了。实际上，这种解决思路已经完全满足需求了，我们已经可以直接用到真实的软件开发中。不过，我们还有另外一种短网址的生成算法，那就是利用自增的 ID 生成器来生成短网址。我们接下来就看一下，这种算法是如何工作的？对于哈希算法生成短网址来说，它又有什么优势和劣势？</p><h2 id="如何通过-ID-生成器生成短网址？"><a href="#如何通过-ID-生成器生成短网址？" class="headerlink" title="如何通过 ID 生成器生成短网址？"></a>如何通过 ID 生成器生成短网址？</h2><p>我们可以维护一个 ID 自增生成器。它可以生成 1、2、3…这样自增的整数 ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码，然后将其转化成 62 进制表示法，拼接到短网址服务的域名（比如<a href="http://t.cn/）" target="_blank" rel="noopener">http://t.cn/）</a> 后面，就形成了最终的短网址。最后，我们还是会把生成的短网址和对应的原始网址存储到数据库中。</p><p>理论非常简单好理解。不过，这里有几个细节问题需要处理。</p><h3 id="1-相同的原始网址可能会对应不同的短网址"><a href="#1-相同的原始网址可能会对应不同的短网址" class="headerlink" title="1. 相同的原始网址可能会对应不同的短网址"></a>1. 相同的原始网址可能会对应不同的短网址</h3><p>每次新来一个原始网址，我们就生成一个新的短网址，这种做法就会导致两个相同的原始网址生成了不同的短网址。这个该如何处理呢？实际上，我们有两种处理思路。</p><p>第一种处理思路是<strong>不做处理</strong>。听起来有点无厘头，我稍微解释下你就明白了。实际上，相同的原始网址对应不同的短网址，这个用户是可以接受的。在大部分短网址的应用场景里，用户只关心短网址能否正确地跳转到原始网址。至于短网址长什么样子，他其实根本就不关心。所以，即便是同一个原始网址，两次生成的短网址不一样，也并不会影响到用户的使用。</p><p>第二种处理思路是<strong>借助哈希算法生成短网址的处理思想</strong>，当要给一个原始网址生成短网址的时候，我们要先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址了。如果数据库中存在，那我们就取出对应的短网址，直接返回给用户。</p><p>不过，这种处理思路有个问题，我们需要给数据库中的短网址和原始网址这两个字段，都添加索引。短网址上加索引是为了提高用户查询短网址对应的原始网页的速度，原始网址上加索引是为了加快刚刚讲的通过原始网址查询短网址的速度。这种解决思路虽然能满足“相同原始网址对应相同短网址”这样一个需求，但是是有代价的：一方面两个索引会占用更多的存储空间，另一方面索引还会导致插入、删除等操作性能的下降。</p><h3 id="2-如何实现高性能的-ID-生成器？"><a href="#2-如何实现高性能的-ID-生成器？" class="headerlink" title="2. 如何实现高性能的 ID 生成器？"></a>2. 如何实现高性能的 ID 生成器？</h3><p>实现 ID 生成器的方法有很多，比如利用数据库自增字段。当然我们也可以自己维护一个计数器，不停地加一加一。但是，一个计数器来应对频繁的短网址生成请求，显然是有点吃力的（因为计数器必须保证生成的 ID 不重复，笼统概念上讲，就是需要加锁）。如何提高 ID 生成器的性能呢？关于这个问题，实际上，有很多解决思路。我这里给出两种思路。</p><p>第一种思路是借助前文中讲的方法。我们可以给 ID 生成器装多个前置发号器。我们批量地给每个前置发号器发送 ID 号码。当我们接受到短网址生成请求的时候，就选择一个前置发号器来取号码。这样通过多个前置发号器，明显提高了并发发号的能力。</p><p><img src="/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/3b81b168-dea9-42a9-8bc3-b78b824a3cf8.jpg" alt></p><p>第二种思路跟第一种差不多。不过，我们不再使用一个 ID 生成器和多个前置发号器这样的架构，而是，直接实现多个 ID 生成器同时服务。为了保证每个 ID 生成器生成的 ID 不重复。我们要求每个 ID 生成器按照一定的规则，来生成 ID 号码。比如，第一个 ID 生成器只能生成尾号为 0 的，第二个只能生成尾号为 1 的，以此类推。这样通过多个 ID 生成器同时工作，也提高了 ID 生成的效率。</p><p><img src="/2019/09/14/52-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%94%EF%BC%89-%E5%A6%82%E4%BD%95%E7%94%A8%E5%AD%A6%E8%BF%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F/3e107be5-2967-4b91-87f6-5c3944168be0.jpg" alt></p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲了短网址服务的两种实现方法。我现在来稍微总结一下。</p><p>第一种实现思路是通过哈希算法生成短网址。我们采用计算速度快、冲突概率小的 MurmurHash 算法，并将计算得到的 10 进制数，转化成 62 进制表示法，进一步缩短短网址的长度。对于哈希算法的哈希冲突问题，我们通过给原始网址添加特殊前缀字符，重新计算哈希值的方法来解决。</p><p>第二种实现思路是通过 ID 生成器来生成短网址。我们维护一个 ID 自增的 ID 生成器，给每个原始网址分配一个 ID 号码，并且同样转成 62 进制表示法，拼接到短网址服务的域名之后，形成最终的短网址。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 如果我们还要额外支持用户自定义短网址功能（http//t.cn/{用户自定部分}）， 我们又该如何改造刚刚的算法呢?</p><p>2 我们在讲通过 ID 生成器生成短网址这种实现思路的时候，讲到相同的原始网址可能会对应不同的短网址。针对这个问题，其中一个解决思路就是，不做处理。但是，如果每个请求都生成一个短网址，并且存储在数据库中，那这样会不会撑爆数据库呢？我们又该如何解决呢？</p><p><strong>回答1：</strong><br>问题一:</p><ul><li>尝试将用户 自定义后的短网址 和 原网址的映射关系 存入数据库<ul><li>插入成功, 则提示用户短网址生成成功</li><li>若插入失败, 说明存在冲突, 则进行判重处理<ul><li>若数据库中短网址对应的原网址与当前正在处理的相同, 提示该短网址有效</li><li>若数据库中短网址对应的原网址与当前正在处理的不相同, 提示该短网址已被占用</li></ul></li></ul></li></ul><p><strong>回答2：</strong><br>可以使用布隆过滤器进行判重验证, 通过之后再插入</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51-算法实战（四）_剖析微服务接口鉴权限流背后的数据结构和算法</title>
      <link href="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://github.com/wangzheng0822/ratelimiter4j" target="_blank" rel="noopener">限流开发库/框架-java</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微服务是最近几年才兴起的概念。简单点讲，就是把复杂的大应用，解耦拆分成几个小的应用。这样做的好处有很多。比如，这样有利于团队组织架构的拆分，毕竟团队越大协作的难度越大；再比如，每个应用都可以独立运维，独立扩容，独立上线，各个应用之间互不影响。不用像原来那样，一个小功能上线，整个大应用都要重新发布。</p><p>不过，有利就有弊。大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、debug 问题的难度都高了好几个数量级。所以，为了解决这些问题，<strong>服务治理</strong>便成了微服务的一个技术重点。</p><p>所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如鉴权、限流、降级、熔断、监控告警等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。今天，就拿其中的鉴权和限流这两个功能，看看它们的实现过程中都要用到哪些数据结构和算法。</p><a id="more"></a><h2 id="鉴权背景介绍"><a href="#鉴权背景介绍" class="headerlink" title="鉴权背景介绍"></a>鉴权背景介绍</h2><p>以防你之前可能对微服务没有太多了解，所以这里对鉴权的背景做了简化。</p><p>假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，也并不是每个有访问权限的应用，都可以访问用户服务的所有接口。</p><p>我举了一个例子给你讲解一下，你可以看我画的这幅图。这里面，只有 A、B、C、D 四个应用可以访问用户服务，并且，每个应用只能访问用户服务的部分接口。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/a65d577d-42b9-481f-913c-d33d6331e344.jpg" alt></p><p>要实现接口鉴权功能，我们需要事先将应用对接口的访问权限规则设置好。当某个应用访问其中一个接口的时候，我们就可以拿应用的请求 URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。</p><h2 id="如何实现快速鉴权？"><a href="#如何实现快速鉴权？" class="headerlink" title="如何实现快速鉴权？"></a>如何实现快速鉴权？</h2><p>接口的格式有很多，有类似 Dubbo 这样的 RPC 接口，也有类似 Spring Cloud 这样的 HTTP 接口。不同接口的鉴权实现方式是类似的，这里主要拿 HTTP 接口讲解。</p><p>鉴权的原理比较简单、好理解。那具体到实现层面，我们该用什么数据结构来存储规则呢？用户请求 URL 在规则中快速匹配，又该用什么样的算法呢？</p><p>际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。所以，关于这个问题，继续细化为三个更加详细的需求给你讲解。</p><h3 id="1-如何实现精确匹配规则？"><a href="#1-如何实现精确匹配规则？" class="headerlink" title="1. 如何实现精确匹配规则？"></a>1. 如何实现精确匹配规则？</h3><p>我们先来看最简单的一种匹配模式。只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理。为了方便你理解，我举了一个例子，你可以看一下。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/19355363fa47c116edfd7d2ea57af4d1.jpg" alt></p><p>不同的应用对应不同的规则集合。我们可以采用散列表来存储这种对应关系。这里着重讲下，每个应用对应的规则集合，该如何存储和匹配。</p><p>针对这种匹配模式，我们可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，我们拿用户的请求 URL，在这个字符串数组中逐一匹配，匹配的算法就是我们之前学过的字符串匹配算法（比如 KMP、BM、BF 等）。</p><p>规则不会经常变动，所以，为了加快匹配速度，我们可以按照字符串的大小给规则排序，把它组织成有序数组这种数据结构。当要查找某个 URL 能否匹配其中某条规则的时候，我们可以采用二分查找算法，在有序数组中进行匹配。</p><p>而二分查找算法的时间复杂度是 O(logn)（n 表示规则的个数），这比起时间复杂度是 O(n) 的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的 。</p><h3 id="2-如何实现前缀匹配规则？"><a href="#2-如何实现前缀匹配规则？" class="headerlink" title="2. 如何实现前缀匹配规则？"></a>2. 如何实现前缀匹配规则？</h3><p>我们再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求 URL 的前缀，我们就说这条规则能够跟这个请求 URL 匹配。同样，为了方便你理解这种匹配模式，我还是举一个例子说明一下。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/37e94179-1f47-4c93-8d38-eff6e7406953.jpg" alt></p><p>不同的应用对应不同的规则集合。我们采用散列表来存储这种对应关系。着重讲一下，每个应用的规则集合，最适合用什么样的数据结构来存储。</p><p>在 <strong>Trie 树</strong> 那节，我们讲到，Trie 树非常适合用来做前缀匹配。所以，针对这个需求，我们可以将每个用户的规则集合，组织成 Trie 树这种数据结构。</p><p>不过，Trie 树中的每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录（比如“/user/name”被分割为“user”“name”两个子目录）。因为规则并不会经常变动，所以，在 Trie 树中，我们可以把每个节点的子节点们，组织成有序数组这种数据结构。当在匹配的过程中，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/1f0097ab-040b-4f16-83da-eaf1399977a7.jpg" alt></p><h3 id="3-如何实现模糊匹配规则？"><a href="#3-如何实现模糊匹配规则？" class="headerlink" title="3. 如何实现模糊匹配规则？"></a>3. 如何实现模糊匹配规则？</h3><p>如果我们的规则更加复杂，规则中包含通配符，比如“**”表示匹配任意多个子目录，“*”表示匹配任意一个子目录。只要用户请求 URL 可以跟某条规则模糊匹配，我们就说这条规则适用于这个请求。为了方便你理解，我举一个例子来解释一下。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/aaf68f8b-35fd-46d6-bb25-fa28a4c0a347.jpg" alt></p><p>不同的应用对应不同的规则集合。我们还是采用散列表来存储这种对应关系。这点我们刚才讲过了，这里不再重复说了。我们着重看下，每个用户对应的规则集合，该用什么数据结构来存储？针对这种包含通配符的模糊匹配，我们又该使用什么算法来实现呢？</p><p>还记得我们在 <strong>回溯算法</strong> 那节讲的正则表达式的例子吗？我们可以借助正则表达式那个例子的解决思路，来解决这个问题。我们采用回溯算法，拿请求 URL 跟每条规则逐一进行模糊匹配。可用回溯算法进行模糊匹配</p><p>不过，这个解决思路的时间复杂度是非常高的。我们需要拿每一个规则，跟请求 URL 匹配一遍。那有没有办法可以继续优化一下呢？</p><p>实际上，我们可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，我们可以把不包含通配符的规则和包含通配符的规则分开处理。</p><p>我们把不包含通配符的规则，组织成有序数组或者 Trie 树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成 Trie 树），而这一部分匹配就会非常高效。剩下的是少数包含通配符的规则，我们只要把它们简单存储在一个数组中就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。</p><p>当接收到一个请求 URL 之后，我们可以先在不包含通配符的有序数组或者 Trie 树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。</p><h2 id="限流背景介绍"><a href="#限流背景介绍" class="headerlink" title="限流背景介绍"></a>限流背景介绍</h2><p>限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过 100 次调用，超过之后，我们就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双 11、618 等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。</p><p>按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。</p><p>不同粒度的限流功能的实现思路都差不多，下面主要针对限制所有接口总的访问频率这样一个限流需求来讲解。其他粒度限流需求的实现思路，可以自己思考。</p><h2 id="如何实现精准限流？"><a href="#如何实现精准限流？" class="headerlink" title="如何实现精准限流？"></a>如何实现精准限流？</h2><p>最简单的限流算法叫 <strong>固定时间窗口限流算法</strong> 。这种算法是如何工作的呢？首先我们需要选定一个时间起点，之后每当有接口请求到来，我们就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，我们就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/92355a50-a18d-43bb-8c8c-c5b86c1fa4d9.jpg" alt></p><p>这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。这是怎么回事呢？举一个例子解释一下。</p><p>假设我们的限流规则是，每秒钟不能超过 100 次接口请求。第一个 1s 时间窗口内，100 次接口请求都集中在最后 10ms 内。在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内。虽然两个时间窗口内流量都符合限流要求（≤100 个请求），但在两个时间窗口临界的 20ms 内，会集中有 200 次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 20ms 内的 200 次请求就有可能压垮系统。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/18995718-7045-442c-bf0e-e31ddf1479e8.jpg" alt></p><p>为了解决这个问题，我们可以对固定时间窗口限流算法稍加改造。我们可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）。因此，相对于固定时间窗口限流算法，这个算法叫<strong>滑动时间窗口限流算法</strong>。</p><p>流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 1s 的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。那具体到实现层面，我们该如何来做呢？</p><p>我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。我们就维护一个大小为 K+1 的循环队列，用来记录 1s 内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为循环队列存储数据时会浪费一个存储单元。</p><p>当有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务。</p><p>为了方便你理解，我举一个例子，给你解释一下。在这个例子中，我们假设限流的规则是，任意 1s 内，接口的请求次数都不能大于 6 次。</p><p><img src="/2019/09/09/51-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E5%9B%9B%EF%BC%89-%E5%89%96%E6%9E%90%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/748a2b39a068563d48837677016b8c79.jpg" alt></p><p>即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。</p><p>比如我刚刚举的那个例子，第一个 1s 的时间窗口内，100 次请求都集中在最后 10ms 中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。</p><p>实际上，针对这个问题，还有很多更加平滑的限流算法，比如令牌桶算法、漏桶算法等。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>关于鉴权，我们讲了三种不同的规则匹配模式。不管是哪种匹配模式，我们都可以用散列表来存储不同应用对应的不同规则集合。对于每个应用的规则集合的存储，三种匹配模式使用不同的数据结构。</p><p>对于第一种精确匹配模式，我们利用有序数组来存储每个应用的规则集合，并且通过二分查找和字符串匹配算法，来匹配请求 URL 与规则。对于第二种前缀匹配模式，我们利用 Trie 树来存储每个应用的规则集合。对于第三种模糊匹配模式，我们采用普通的数组来存储包含通配符的规则，通过回溯算法，来进行请求 URL 与规则的匹配。</p><p>关于限流，我们讲了两种限流算法，第一种是固定时间窗口限流算法，第二种是滑动时间窗口限流算法。对于滑动时间窗口限流算法，我们用了之前学习过的循环队列来实现。比起固定时间窗口限流算法，它对流量的整形效果更好，流量更加平滑。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 除了用循环队列来实现滑动时间窗口限流算法之外，我们是否还可以用其他数据结构来实现呢？请对比一下这些数据结构跟循环队列在解决这个问题时的优劣之处。</p><p>2 分析一下鉴权那部分内容中，前缀匹配算法的时间复杂度和空间复杂度。</p><p><strong>回答1：</strong></p><p>可以用优先级队列（根据请求时间构建小顶堆），最早的请求时间的放在堆顶。然后每次进来一个请求，就判断这个时间跟堆顶的时间差是否小于1S，并且堆的大小小于请求限制的次数，如果是就插入队列，如果不是，就限制。</p><p>还可以采用双向链表，每次请求往链表尾插入一个时间，插入之前先从链表头删除一秒之前的节点，之后看下链表的size是否大于等于N，大于等于N则拒绝本次访问，否则允许本次访问并插入链表尾；占用的空间比循环链表要大</p><p><strong>回答2：</strong></p><p>假设有n个规则，每个规则的单词个数平均为m，则时间复杂度为O(m<em>logn), 空间复杂度O(n</em>m)<br>时间复杂度分析下：平均搜索m层，每一层最多有n个单词，由于是采用有序数组存储，查找时间复杂度为O(logn),所以总的时间复杂度为O(m*logn)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50-算法实战（三）_剖析高性能队列Disruptor背后的数据结构和算法</title>
      <link href="/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">Disruptor源码</a>。</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Disruptor 你是否听说过呢？它是一种内存消息队列。从功能上讲，它其实有点儿类似 Kafka。不过，和 Kafka 不同的是，Disruptor 是线程之间用于消息传递的队列。它在 Apache Storm、Camel、Log4j 2 等很多知名项目中都有广泛应用。</p><p>之所以如此受青睐，主要还是因为它的性能表现非常优秀。它比 Java 中另外一个非常常用的内存消息队列 ArrayBlockingQueue（ABS）的性能，要高一个数量级，可以算得上是最快的内存消息队列了。它还因此获得过 Oracle 官方的 Duke 大奖。</p><p>如此高性能的内存消息队列，在设计和实现上，必然有它独到的地方。今天，我们就来一块儿看下，<font color="red">Disruptor 是如何做到如此高性能的？其底层依赖了哪些数据结构和算法？</font></p><a id="more"></a><h2 id="基于循环队列的“生产者-消费者模型”"><a href="#基于循环队列的“生产者-消费者模型”" class="headerlink" title="基于循环队列的“生产者 - 消费者模型”"></a>基于循环队列的“生产者 - 消费者模型”</h2><p>什么是内存消息队列？对很多业务工程师或者前端工程师来说，可能会比较陌生。不过，如果我说“生产者 - 消费者模型”，估计大部分人都知道。在这个模型中，“生产者”生产数据，并且将数据放到一个中心存储容器中。之后，“消费者”从中心存储容器中，取出数据消费。</p><p>这个模型非常简单、好理解，那你有没有思考过，这里面存储数据的中心存储容器，是用什么样的数据结构来实现的呢？</p><p>实际上，实现中心存储容器最常用的一种数据结构，就是我们在前文讲的队列。队列支持数据的先进先出。正是这个特性，使得数据被消费的顺序性可以得到保证，也就是说，早被生产的数据就会早被消费。</p><p>队列有两种实现思路。一种是基于链表实现的链式队列，另一种是基于数组实现的顺序队列。不同的需求背景下，我们会选择不同的实现方式。</p><p>如果我们要实现一个无界队列，也就是说，队列的大小事先不确定，理论上可以支持无限大。这种情况下，我们适合选用链表来实现队列。因为链表支持快速地动态扩容。如果我们要实现一个有界队列，也就是说，队列的大小事先确定，当队列中数据满了之后，生产者就需要等待。直到消费者消费了数据，队列有空闲位置的时候，生产者才能将数据放入</p><p>实际上，相较于无界队列，有界队列的应用场景更加广泛。毕竟，我们的机器内存是有限的。而无界队列占用的内存数量是不可控的。对于实际的软件开发来说，这种不可控的因素，就会有潜在的风险。在某些极端情况下，无界队列就有可能因为内存持续增长，而导致 OOM（Out of Memory）错误。</p><p>我们还讲过一种特殊的顺序队列，循环队列。我们讲过，非循环的顺序队列在添加、删除数据的工程中，会涉及数据的搬移操作，导致性能变差。而循环队列正好可以解决这个数据搬移的问题，所以，性能更加好。所以，大部分用到顺序队列的场景中，我们都选择用顺序队列中的循环队列。</p><p>实际上，<strong>循环队列这种数据结构，就是我们今天要讲的内存消息队列的雏形</strong>。我借助循环队列，实现了一个最简单的“生产者 - 消费者模型”。对应的代码我贴到这里，你可以看看。</p><p>为了方便你理解，对于生产者和消费者之间操作的同步，我并没有用到线程相关的操作。而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Queue &#123;</span><br><span class="line">  private Long[] data;</span><br><span class="line">  private int size &#x3D; 0, head &#x3D; 0, tail &#x3D; 0;</span><br><span class="line">  public Queue(int size) &#123;</span><br><span class="line">    this.data &#x3D; new Long[size];</span><br><span class="line">    this.size &#x3D; size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean add(Long element) &#123;</span><br><span class="line">    if ((tail + 1) % size &#x3D;&#x3D; head) return false;</span><br><span class="line">    data[tail] &#x3D; element;</span><br><span class="line">    tail &#x3D; (tail + 1) % size;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public Long poll() &#123;</span><br><span class="line">    if (head &#x3D;&#x3D; tail) return null;</span><br><span class="line">    long ret &#x3D; data[head];</span><br><span class="line">    head &#x3D; (head + 1) % size;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Producer &#123;</span><br><span class="line">  private Queue queue;</span><br><span class="line">  public Producer(Queue queue) &#123;</span><br><span class="line">    this.queue &#x3D; queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void produce(Long data) throws InterruptedException &#123;</span><br><span class="line">    while (!queue.add(data)) &#123;</span><br><span class="line">      Thread.sleep(100);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Consumer &#123;</span><br><span class="line">  private Queue queue;</span><br><span class="line">  public Consumer(Queue queue) &#123;</span><br><span class="line">    this.queue &#x3D; queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void comsume() throws InterruptedException &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      Long data &#x3D; queue.poll();</span><br><span class="line">      if (data &#x3D;&#x3D; null) &#123;</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO:...消费数据的业务逻辑...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于加锁的并发“生产者-消费者模型”"><a href="#基于加锁的并发“生产者-消费者模型”" class="headerlink" title="基于加锁的并发“生产者 - 消费者模型”"></a>基于加锁的并发“生产者 - 消费者模型”</h2><p>实际上，刚刚的“生产者 - 消费者模型”实现代码，是不完善的。为什么这么说呢？</p><p>如果我们只有一个生产者往队列中写数据，一个消费者从队列中读取数据，那上面的代码是没有问题的。但是，如果有多个生产者在并发地往队列中写入数据，或者多个消费者并发地从队列中消费数据，那上面的代码就不能正确工作了。我来给你讲讲为什么。</p><p>在多个生产者或者多个消费者并发操作队列的情况下，刚刚的代码主要会有下面两个问题：</p><ul><li><p>多个生产者写入的数据可能会互相覆盖；</p></li><li><p>多个消费者可能会读取重复的数据。</p></li></ul><p>因为第一个问题和第二个问题产生的原理是类似的。所以，着重讲解第一个问题是如何产生的以及该如何解决。对于第二个问题，你可以类比对第一个问题的解决思路自己来想一想。</p><p>两个线程同时往队列中添加数据，也就相当于两个线程同时执行类 Queue 中的 add() 函数。我们假设队列的大小 size 是 10，当前的 tail 指向下标 7，head 指向下标 3，也就是说，队列中还有空闲空间。这个时候，线程 1 调用 add() 函数，往队列中添加一个值为 12 的数据；线程 2 调用 add() 函数，往队列中添加一个值为 15 的数据。在极端情况下，本来是往队列中添加了两个数据（12 和 15），最终可能只有一个数据添加成功，另一个数据会被覆盖。这是为什么呢？</p><p><img src="/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/58260f4d-c9df-4d55-89e7-4c862c4f0f66.jpg" alt></p><p>为了方便你查看队列 Queue 中的 add() 函数，我把它从上面的代码中摘录出来，贴在这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(Long element) &#123;</span><br><span class="line">  if ((tail + 1) % size &#x3D;&#x3D; head) return false;</span><br><span class="line">  data[tail] &#x3D; element;</span><br><span class="line">  tail &#x3D; (tail + 1) % size;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段代码中，我们可以看到，第 3 行给 data[tail]赋值，然后第 4 行才给 tail 的值加一。赋值和 tail 加一两个操作，并非原子操作。这就会导致这样的情况发生：当线程 1 和线程 2 同时执行 add() 函数的时候，线程 1 先执行完了第 3 行语句，将 data[7]（tail 等于 7）的值设置为 12。在线程 1 还未执行到第 4 行语句之前，也就是还未将 tail 加一之前，线程 2 执行了第 3 行语句，又将 data[7]的值设置为 15，也就是说，那线程 2 插入的数据覆盖了线程 1 插入的数据。原本应该插入两个数据（12 和 15）的，现在只插入了一个数据（15）。</p><p><img src="/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/bc2149a7-52ab-4f02-9b7d-57361d5e3bf4.jpg" alt></p><p><img src="/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/89759d48-5929-4c87-aa64-75dbd3ab8f8c.jpg" alt></p><p>那如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题呢？</p><p>最简单的处理方法就是给这段代码加锁，同一时间只允许一个线程执行 add() 函数。这就相当于将这段代码的执行，由并行改成了串行，也就不存在我们刚刚说的问题了。</p><p>不过，天下没有免费的午餐，加锁将并行改成串行，必然导致多个生产者同时生产数据的时候，执行效率的下降。当然，我们可以继续优化代码，用 <strong>CAS</strong>（compare and swap，比较并交换）操作等减少加锁的粒度，但是，这不是我们的重点。我们直接看 Disruptor 的处理方法。</p><h2 id="基于无锁的并发“生产者-消费者模型”"><a href="#基于无锁的并发“生产者-消费者模型”" class="headerlink" title="基于无锁的并发“生产者 - 消费者模型”"></a>基于无锁的并发“生产者 - 消费者模型”</h2><p>尽管 Disruptor 的源码读起来很复杂，但是基本思想其实非常简单。实际上，它是换了一种队列和“生产者 - 消费者模型”的实现思路。</p><p>之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的 add() 函数和 poll() 函数，而 Disruptor 采用了另一种实现思路。</p><p>对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的 n 个（n≥1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，从刚刚的描述中，我们可以看出，申请存储单元的过程是需要加锁的。</p><p>对于消费者来说，处理的过程跟生产者是类似的。它先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了。</p><p>不过，还有一个需要特别注意的地方，那就是，如果生产者 A 申请到了一组连续的存储单元，假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，那在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的。这个也是 Disruptor 实现思路的一个弊端。</p><p>文字描述不好理解，我画了一个图，给你展示一下这个操作过程。</p><p><img src="/2019/09/06/50-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89-%E5%89%96%E6%9E%90%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/a2c0d268070ed7cc11a5d22eb223f3ba.jpg" alt></p><p>实际上，Disruptor 采用的是 RingBuffer 和 AvailableBuffer 这两个结构，来实现刚刚讲的功能。不过，因为我们主要聚焦在数据结构和算法上，所以我对这两种结构做了简化，但是基本思想是一致的。如果你对 Disruptor 感兴趣，可以去阅读一下它的<br><a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">源码</a>。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>讲了如何实现一个高性能的并发队列。这里的“并发”两个字，实际上就是多线程安全的意思。</p><p>为了在保证逻辑正确的前提下，尽可能地提高队列在并发情况下的性能，Disruptor 采用了“两阶段写入”的方法。在写入数据之前，先加锁申请批量的空闲存储单元，之后往队列中写入数据的操作就不需要加锁了，写入的性能因此就提高了。Disruptor 对消费过程的改造，跟对生产过程的改造是类似的。它先加锁申请批量的可读取的存储单元，之后从队列中读取数据的操作也就不需要加锁了，读取的性能因此也就提高了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>为了提高存储性能，我们往往通过分库分表的方式设计数据库表。假设我们有 8 张表用来存储用户信息。这个时候，每张用户表中的 ID 字段就不能通过自增的方式来产生了。因为这样的话，就会导致不同表之间的用户 ID 值重复。</p><p>为了解决这个问题，我们需要实现一个 ID 生成器，可以为所有的用户表生成唯一的 ID 号。那现在问题是，如何设计一个高性能、支持并发的、能够生成全局唯一 ID 的 ID 生成器呢？</p><p><strong>回答1：</strong></p><p>1） 分库分表也可以使用自增主键，可以设置增加的步长。8台机器分别从1、2、3…开始，步长8，从1开始的下一个id是9，与其他的不重复就可以了。</p><p>2） redis或者zk应该也能生成自增主键，不过他们的写性能可能不能支持真正的高并发。</p><p>3） 开放独立的id生成服务。最有名的算法应该是snowflake吧。snowflake的好处是基本有序，每秒钟可以生成很大的量，容易水平扩展。</p><p>4)  也可以把今天的disrupt用上，用自己生成id算法，提前生成id存入disrupt，预估一下峰值时业务需要的id量，比如提前生成50万；</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49-算法实战（二）_剖析搜索引擎背后的经典数据结构和算法</title>
      <link href="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://github.com/kkzfl22/searchEngine" target="_blank" rel="noopener">搜索引擎微代码-java实现</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>像百度、Google 这样的搜索引擎，在我们平时的工作、生活中，几乎天天都会用到。如果我们把搜索引擎也当作一个互联网产品的话，那它跟社交、电商这些类型的产品相比，有一个非常大的区别，那就是，它是一个技术驱动的产品。所谓技术驱动是指，搜索引擎实现起来，技术难度非常大，技术的好坏直接决定了这个产品的核心竞争力。</p><p>在搜索引擎的设计与实现中，会用到大量的算法。有很多针对特定问题的算法，也有很多我们之前讲到的基础算法。所以，百度、Google 这样的搜索引擎公司，在面试的时候，会格外重视考察候选人的算法能力。</p><p><font color="red">今天借助搜索引擎，这样一个非常有技术含量的产品，来给你展示一下，数据结构和算法是如何应用在其中的。</font></p><a id="more"></a><h2 id="整体系统介绍"><a href="#整体系统介绍" class="headerlink" title="整体系统介绍"></a>整体系统介绍</h2><p>像 Google 这样的大型商用搜索引擎，有成千上万的工程师，十年如一日地对它进行优化改进，所以，它所包含的技术细节非常多。个人很难、也没有这个能力，通过一篇文章把所有细节都讲清楚。</p><p>所以，接下来的讲解，主要给你展示，如何在一台机器上（假设这台机器的内存是 8GB， 硬盘是 100 多 GB），通过少量的代码，实现一个小型搜索引擎。不过，麻雀虽小，五脏俱全。跟大型搜索引擎相比，实现这样一个小型搜索引擎所用到的理论基础是相通的。</p><p>搜索引擎大致可以分为四个部分：<strong>搜集</strong>、<strong>分析</strong>、<strong>索引</strong>、<strong>查询</strong>。其中，搜集，就是我们常说的利用爬虫爬取网页。分析，主要负责网页内容抽取、分词，构建临时索引，计算 PageRank 值这几部分工作。索引，主要负责通过分析阶段得到的临时索引，构建倒排索引。查询，主要负责响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户。</p><h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><p>现在，互联网越来越发达，网站越来越多，对应的网页也就越来越多。对于搜索引擎来说，它事先并不知道网页都在哪里。打个比方来说就是，我们只知道海里面有很多鱼，但却并不知道鱼在哪里。那搜索引擎是如何爬取网页的呢？</p><p>搜索引擎把整个互联网看作数据结构中的<strong>有向图</strong>每个页面看作一个顶点。如果某个页面中包含另外一个页面的链接，那我们就在两个顶点之间连一条有向边。我们可以利用图的遍历搜索算法，来遍历整个互联网中的网页。</p><p>我们前文介绍过两种图的遍历方法，深度优先和广度优先。搜索引擎采用的是广度优先搜索策略。具体点讲的话，那就是，我们先找一些比较知名的网页（专业的叫法是权重比较高）的链接（比如新浪主页网址、腾讯主页网址等），作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停地从队列中取出链接，然后去爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。</p><p>基本的原理就是这么简单。但落实到实现层面，还有很多技术细节。下面借助搜集阶段涉及的几个重要文件，来给你解释一下搜集工程都有哪些关键技术细节。</p><h3 id="1-待爬取网页链接文件：links-bin"><a href="#1-待爬取网页链接文件：links-bin" class="headerlink" title="1. 待爬取网页链接文件：links.bin"></a>1. 待爬取网页链接文件：links.bin</h3><p>在广度优先搜索爬取页面的过程中，爬虫会不停地解析页面链接，将其放到队列中。于是，队列中的链接就会越来越多，可能会多到内存放不下。所以，我们用一个存储在磁盘中的文件（links.bin）来作为广度优先搜索中的队列。爬虫从 links.bin 文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到 links.bin 文件中。</p><p>这样用文件来存储网页链接的方式，还有其他好处。比如，支持断点续爬。也就是说，当机器断电之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。</p><p>关于如何解析页面获取链接，我额外多说几句。我们可以把整个页面看作一个大的字符串，然后利用字符串匹配算法，在这个大字符串中，搜索 &lt;link&gt; 这样一个网页标签，然后顺序读取 &lt;link&gt;&lt;/link&gt; 之间的字符串。这其实就是网页链接。</p><h3 id="2-网页判重文件：bloom-filter-bin"><a href="#2-网页判重文件：bloom-filter-bin" class="headerlink" title="2. 网页判重文件：bloom_filter.bin"></a>2. 网页判重文件：bloom_filter.bin</h3><p>如何避免重复爬取相同的网页呢？这个问题我们在 <strong>位图</strong> 那一节已经讲过了。使用布隆过滤器，我们就可以快速并且非常节省内存地实现网页的判重。</p><p>不过，还是刚刚那个问题，如果我们把布隆过滤器存储在内存中，那机器宕机重启之后，布隆过滤器就被清空了。这样就可能导致大量已经爬取的网页会被重复爬取。</p><p>这个问题该怎么解决呢？我们可以定期地（比如每隔半小时）将布隆过滤器持久化到磁盘中，存储在 bloom_filter.bin 文件中。这样，即便出现机器宕机，也只会丢失布隆过滤器中的部分数据。当机器重启之后，我们就可以重新读取磁盘中的 bloom_filter.bin 文件，将其恢复到内存中。</p><h3 id="3-原始网页存储文件：doc-raw-bin"><a href="#3-原始网页存储文件：doc-raw-bin" class="headerlink" title="3. 原始网页存储文件：doc_raw.bin"></a>3. 原始网页存储文件：doc_raw.bin</h3><p>爬取到网页之后，我们需要将其存储下来，以备后面离线分析、索引之用。那如何存储海量的原始网页数据呢？</p><p>如果我们把每个网页都存储为一个独立的文件，那磁盘中的文件就会非常多，数量可能会有几千万，甚至上亿。常用的文件系统显然不适合存储如此多的文件。所以，我们可以把多个网页存储在一个文件中。每个网页之间，通过一定的标识进行分隔，方便后续读取。具体的存储格式，如下图所示。其中，doc_id 这个字段是网页的编号，我们待会儿再解释。</p><p><img src="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/9e9ba03b-7a4e-440b-aca0-a3a70a3fab59.jpg" alt></p><p>当然，这样的一个文件也不能太大，因为文件系统对文件的大小也有一定的限制。所以，我们可以设置每个文件的大小不能超过一定的值（比如 1GB）。随着越来越多的网页被添加到文件中，文件的大小就会越来越大，当超过 1GB 的时候，我们就创建一个新的文件，用来存储新爬取的网页。</p><p>假设一台机器的硬盘大小是 100GB 左右，一个网页的平均大小是 64KB。那在一台机器上，我们可以存储 100 万到 200 万左右的网页。假设我们的机器的带宽是 10MB，那下载 100GB 的网页，大约需要 10000 秒。也就是说，爬取 100 多万的网页，也就是只需要花费几小时的时间。</p><h3 id="4-网页链接及其编号的对应文件：doc-id-bin"><a href="#4-网页链接及其编号的对应文件：doc-id-bin" class="headerlink" title="4. 网页链接及其编号的对应文件：doc_id.bin"></a>4. 网页链接及其编号的对应文件：doc_id.bin</h3><p>刚刚我们提到了网页编号这个概念，我现在解释一下。网页编号实际上就是给每个网页分配一个唯一的 ID，方便我们后续对网页进行分析、索引。那如何给网页编号呢？</p><p>我们可以按照网页被爬取的先后顺序，从小到大依次编号。具体是这样做的：我们维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，我们将网页链接跟编号之间的对应关系，存储在另一个 doc_id.bin 文件中。</p><p><strong>爬虫在爬取网页的过程中，涉及的四个重要的文件，我就介绍完了。其中，links.bin 和 bloom_filter.bin 这两个文件是爬虫自身所用的。另外的两个（doc_raw.bin、doc_id.bin）是作为搜集阶段的成果，供后面的分析、索引、查询用的。</strong></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-抽取网页文本信息"><a href="#1-抽取网页文本信息" class="headerlink" title="1. 抽取网页文本信息"></a>1. 抽取网页文本信息</h3><p>网页是半结构化数据，里面夹杂着各种标签、JavaScript 代码、CSS 样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是，网页显示在浏览器中时，能被用户肉眼看到的那部分信息。我们如何从半结构化的网页中，抽取出搜索引擎关系的文本信息呢？</p><p>我们之所以把网页叫作半结构化数据，是因为它本身是按照一定的规则来书写的。这个规则就是 <strong>HTML 语法规范</strong>。我们依靠 HTML 标签来抽取网页中的文本信息。这个抽取的过程，大体可以分为两步。</p><p>第一步是去掉 JavaScript 代码、CSS 格式以及下拉框中的内容（因为下拉框在用户不操作的情况下，也是看不到的）。也就是&lt;style&gt;&lt;/style&gt;，&lt;script&gt;&lt;/script&gt;，&lt;option&gt;&lt;/option&gt;这三组标签之间的内容。我们可以利用 AC 自动机这种多模式串匹配算法，在网页这个大字符串中，一次性查找&lt;style&gt;&lt;script&gt;&lt;option&gt; ,这三个关键词。当找到某个关键词出现的位置之后，我们只需要依次往后遍历，直到对应结束标签(&lt;/style&gt;,&lt;/script&gt;,&lt;/option&gt;)为止。而这期间遍历到的字符串连带着标签就应该从网页中删除。</p><p>第二步是去掉所有 HTML 标签。这一步也是通过字符串匹配算法来实现的。过程跟第一步类似，我就不重复讲了。</p><h3 id="2-分词并创建临时索引"><a href="#2-分词并创建临时索引" class="headerlink" title="2. 分词并创建临时索引"></a>2. 分词并创建临时索引</h3><p>经过上面的处理之后，我们就从网页中抽取出了我们关心的文本信息。接下来，我们要对文本信息进行分词，并且创建临时索引。</p><p>对于英文网页来说，分词非常简单。我们只需要通过空格、标点符号等分隔符，将每个单词分割开来就可以了。但是，对于中文来说，分词就复杂太多了。我这里介绍一种比较简单的思路，基于字典和规则的分词方法。</p><p>其中，字典也叫词库，里面包含大量常用的词语（我们可以直接从网上下载别人整理好的）。我们借助词库并采用最长匹配规则，来对文本进行分词。所谓最长匹配，也就是匹配尽可能长的词语。我举个例子解释一下。</p><p>比如要分词的文本是“中国人民解放了”，我们词库中有“中国”“中国人”“中国人民”“中国人民解放军”这几个词，那我们就取最长匹配，也就是“中国人民”划为一个词，而不是把“中国”、“中国人“划为一个词。具体到实现层面，我们可以将词库中的单词，构建成 Trie 树结构，然后拿网页文本在 Trie 树中匹配。</p><p>每个网页的文本信息在分词完成之后，我们都得到一组单词列表。我们把单词与网页之间的对应关系，写入到一个临时索引文件中（tmp_Index.bin），这个临时索引文件用来构建倒排索引文件。临时索引文件的格式如下：</p><p><img src="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/cbdc2c0f-749f-431a-9012-92fc063924b2.jpg" alt></p><p>在临时索引文件中，我们存储的是单词编号，也就是图中的 term_id，而非单词本身。这样做的目的主要是为了节省存储的空间。那这些单词的编号是怎么来的呢？</p><p>给单词编号的方式，跟给网页编号类似。我们维护一个计数器，每当从网页文本信息中分割出一个新的单词的时候，我们就从计数器中取一个编号，分配给它，然后计数器加一。</p><p>在这个过程中，我们还需要使用散列表，记录已经编过号的单词。在对网页文本信息分词的过程中，我们拿分割出来的单词，先到散列表中查找，如果找到，那就直接使用已有的编号；如果没有找到，我们再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。</p><p>当所有的网页处理（分词及写入临时索引）完成之后，我们再将这个单词跟编号之间的对应关系，写入到磁盘文件中，并命名为 term_id.bin。</p><p><strong>经过分析阶段，我们得到了两个重要的文件。它们分别是临时索引文件（tmp_index.bin）和单词编号文件（term_id.bin）。</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引。倒排索引（ Inverted index）中记录了每个单词以及包含它的网页列表。文字描述比较难理解，我画了一张倒排索引的结构图，你一看就明白。</p><p><img src="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/3d6d960a-641f-443e-bec7-cc6c5f4cd196.jpg" alt></p><p>我们刚刚讲到，在临时索引文件中，记录的是单词跟每个包含它的文档之间的对应关系。那如何通过临时索引文件，构建出倒排索引文件呢？这是一个非常典型的算法问题。</p><p>解决这个问题的方法有很多。考虑到临时索引文件很大，无法一次性加载到内存中，搜索引擎一般会选择使用<strong>多路归并排序</strong>的方法来实现。</p><p>我们先对临时索引文件，按照单词编号的大小进行排序。因为临时索引很大，所以一般基于内存的排序算法就没法处理这个问题了。我们可以用之前讲到的归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。当然，实际的软件开发中，我们其实可以直接利用 MapReduce 来处理。</p><p>临时索引文件排序完成之后，相同的单词就被排列到了一起。我们只需要顺序地遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把它们存储在倒排索引文件中。具体的处理过程，我画成了一张图。通过图，你应该更容易理解。</p><p><img src="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/951f8a8e-a55b-44e2-b045-c3cac51913a9.jpg" alt></p><p>除了倒排文件之外，我们还需要一个文件，来记录每个单词编号在倒排索引文件中的偏移位置。我们把这个文件命名为 term_offset.bin。这个文件的作用是，帮助我们快速地查找某个单词编号在倒排索引中存储的位置，进而快速地从倒排索引中读取单词编号对应的网页编号列表。</p><p><img src="/2019/09/02/49-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%89%96%E6%9E%90%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/716db7db-6c26-4acf-9a44-4c57bbc0f879.jpg" alt></p><p><strong>经过索引阶段的处理，我们得到了两个有价值的文件，它们分别是倒排索引文件（index.bin）和记录单词编号在索引文件中的偏移位置的文件（term_offset.bin）。</strong></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>前面三个阶段的处理，只是为了最后的查询做铺垫。因此，现在我们就要利用之前产生的几个文件，来实现最终的用户搜索功能。</p><ul><li><p>doc_id.bin：记录网页链接和编号之间的对应关系。</p></li><li><p>term_id.bin：记录单词和编号之间的对应关系。</p></li><li><p>index.bin：倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表。</p></li><li><p>term_offsert.bin：记录每个单词编号在倒排索引文件中的偏移位置。</p></li></ul><p>这四个文件中，除了倒排索引文件（index.bin）比较大之外，其他的都比较小。为了方便快速查找数据，我们将其他三个文件都加载到内存中，并且组织成散列表这种数据结构。</p><p>当用户在搜索框中，输入某个查询文本的时候，我们先对用户输入的文本进行分词处理。假设分分词之后，我们得到 k 个单词。</p><p>我们拿这 k 个单词，去 term_id.bin 对应的散列表中，查找对应的单词编号。经过这个查询之后，我们得到了这 k 个单词对应的单词编号。</p><p>我们拿这 k 个单词编号，去 term_offset.bin 对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置。经过这个查询之后，我们得到了 k 个偏移位置。</p><p>我们拿这 k 个偏移位置，去倒排索引（index.bin）中，查找 k 个单词对应的包含它的网页编号列表。经过这一步查询之后，我们得到了 k 个网页编号列表。</p><p>我们针对这 k 个网页编号列表，统计每个网页编号出现的次数。具体到实现层面，我们可以借助散列表来进行统计。统计得到的结果，我们按照出现次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词（用户输入的搜索文本，经过分词之后的单词）。</p><p>经过这一系列查询，我们就得到了一组排好序的网页编号。我们拿着网页编号，去 doc_id.bin 文件中查找对应的网页链接，分页显示给用户就可以了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，仅仅展示了一个小型搜索引擎的设计思路。这只是一个搜索引擎设计的基本原理，有很多优化、细节我们并未涉及，比如计算网页权重的 <strong>PageRank</strong> 算法、计算查询结果排名的 <strong>tf-idf</strong> 模型等等。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 图的遍历方法有两种，深度优先和广度优先。我们讲到，搜索引擎中的爬虫是通过广度优先策略来爬取网页的。搜索引擎为什么选择广度优先策略，而不是深度优先策略呢？</p><p>2 大部分搜索引擎在结果显示的时候，都支持摘要信息和网页快照。实际上，只需要的设计思路，稍加改造，就可以支持这两项功能。你知道如何改造吗？</p><p><strong>回答1：</strong><br>因为搜索引擎要优先爬取权重较高的页面，离种子网页越近，较大可能权重更高，广度优先更合适。</p><p><strong>回答2：</strong><br>摘要信息和网页快照，都是与网页链接相关的东西，可以爬取时，将网页链接 快照 摘要信息放在一起，或者分开来存，使用同一个doc_id</p><p>摘要信息：<br>增加 summary.bin 和 summary_offset.bin。在抽取网页文本信息后，取出前 80-160 个字作为摘要，写入到 summary.bin，并将偏移位置写入到 summary_offset.bin。<br>summary.bin 格式：<br>doc_id \t summary_size \t summary \r\n\r\n<br>summary_offset.bin 格式：<br>doc_id \t offset \r\n<br>Google 搜索结果中显示的摘要是搜索词附近的文本。如果要实现这种效果，可以保存全部网页文本，构建搜索结果时，在网页文本中查找搜索词位置，截取搜索词附近文本。</p><p>网页快照：<br>可以把 doc_raw.bin 当作快照，增加 doc_raw_offset.bin 记录 doc_id 在 doc_raw.bin 中的偏移位置。<br>doc_raw_offset.bin 格式：<br>doc_id \t offset \r\n</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>正排-》文档包含哪些单词</strong></p><p><strong>倒排-》单词被哪些文档包含</strong></p><hr><p><strong>搜集</strong>：将广度优先搜索的优先队列存储在磁盘文件links.bin（如何解析网页内的链接？），有布隆过滤器判重并定期写入磁盘文件bloom_filter.bin，将访问到的原始网页数据存入磁盘文件doc_raw.bin，计数分配网页编号并与其链接对应关系存入磁盘文件doc_id.bin。</p><p><strong>分析</strong>：首先抽取网页文本信息，依据HTML语法规范，通过AC自动机多模式串匹配算法，去除网页中格式化部分，提取文本内容。然后分词并创建临时索引，分词的目的是找到能够标识网页文本“身份”的特征，可借助词库（通过Trie树实现）搜索文本中与词库匹配的最长词语，因为一般情况下越长信息越多，越剧有表征能力（为什么英文简单？）。分词完成后得到一组用于表征网页的单词列表，与其对应的网页编号存入磁盘文件tmp_index.bin作为临时索引，为节省空间单词是以单词编号的形式写入，单词文本与编号的对应关系写入磁盘文本term_id.bin。</p><p><strong>索引</strong>：通过临时索引构建倒排索引文件index.bin。倒排索引其实是以单词为主键，将临时索引中的多个相同单词行合并为一行。通过以单词为主键的排序算法，可以将相同单词的行连续排列在一起，之后只要将单词相同的连续行合并为一行即可。由于数据量大，应采用分治策略。最后建立所有单词在倒排索引文件中位置的索引文件term_offset.bin，以方便快速查找。</p><p><strong>查询</strong>：先对搜索条件文本做分词处理，然后去term_id.bin查单词们的编号，再查term_offset.bin找到单词们在倒排索引中的位置，到index.bin找到每个单词对应的网页编号，通过网页出现次数、预评权重和统计算法（如pagerank、tf-idf）计算网页的优先次序并输出。最后在doc_in.bin中找到网页链接按序输出显示给用户。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-算法实战（一）_剖析Redis常用数据类型对应的数据结构</title>
      <link href="/2019/08/25/48-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%96%E6%9E%90Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2019/08/25/48-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%96%E6%9E%90Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://github.com/antirez/redis" target="_blank" rel="noopener">Redis-源码</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h2><p>Redis 是一种键值（Key-Value）数据库。相对于关系型数据库（比如 MySQL），Redis 也被叫作<strong>非关系型数据库</strong>。</p><p>像 MySQL 这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过 SQL 语句，来实现非常复杂的查询需求。而 Redis 中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让 Redis 的读写效率非常高。</p><p>除此之外，Redis 主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。这一点，我们后面会介绍。</p><p>Redis 中，键的数据类型是字符串，但是为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。</p><p>“字符串（string）”这种数据类型非常简单，对应到数据结构里，就是<strong>字符串</strong>。你应该非常熟悉，这里我就不多介绍了。我们着重看下，其他四种比较复杂点的数据类型，看看它们底层都依赖了哪些数据结构。</p><a id="more"></a><h2 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h2><p>我们先来看列表。列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是<strong>压缩列表</strong>（ziplist），另一种是双向循环链表。</p><p>当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ul><li><p>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；</p></li><li><p>列表中数据个数少于 512 个。</p></li></ul><p>关于压缩列表，这里稍微解释一下。它并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。具体的存储结构也非常简单，你可以看我下面画的这幅图。</p><p><img src="/2019/08/25/48-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%96%E6%9E%90Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/bf0c8bed-c363-4101-baac-a21ea839f9a5.jpg" alt></p><p>现在，我们来看看，压缩列表中的“压缩”两个字该如何理解？</p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是 20 个字节）。那当我们存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间。听起来有点儿拗口，我画个图解释一下。</p><p><img src="/2019/08/25/48-%E7%AE%97%E6%B3%95%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89-%E5%89%96%E6%9E%90Redis%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/696c999c-00cd-452f-ac0d-8e937217d9d4.jpg" alt></p><p>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，通过键来获取值为列表类型的数据，读取的效率也非常高。</p><p>当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过双向循环链表来实现了。</p><p>在<strong>链表</strong>里，我们已经讲过双向循环链表这种数据结构了，如果不记得了，你可以先回去复习一下。这里我们着重看一下 Redis 中双向链表的编码实现方式。</p><p>Redis 的这种双向链表的实现方式，非常值得借鉴。它额外定义一个 list 结构体，来组织链表的首、尾指针，还有长度等信息。这样，在使用的时候就会非常方便。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下是C语言代码，因为Redis是用C语言实现的。</span><br><span class="line">typedef struct listnode &#123;</span><br><span class="line">  struct listNode *prev;</span><br><span class="line">  struct listNode *next;</span><br><span class="line">  void *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef struct list &#123;</span><br><span class="line">  listNode *head;</span><br><span class="line">  listNode *tail;</span><br><span class="line">  unsigned long len;</span><br><span class="line">  &#x2F;&#x2F; ....省略其他定义</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><h2 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a>字典（hash）</h2><p>字典类型用来存储一组数据对。每个数据对又包含键值两部分。字典类型也有两种实现方式。一种是我们刚刚讲到的<strong>压缩列表</strong>，另一种是<strong>散列表</strong>。</p><p>同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><ul><li><p>字典中保存的键和值的大小都要小于 64 字节；</p></li><li><p>字典中键值对的个数要小于 512 个。</p></li></ul><p>当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用<strong>MurmurHash2</strong>这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。</p><p>当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右（具体值需要计算才能得到，如果感兴趣，你可以去阅读<a href="https://github.com/antirez/redis/blob/unstable/src/dict.c" target="_blank" rel="noopener">源码</a>）。</p><p>当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小（这个值也是计算得到的，如果感兴趣，你也可以去阅读<a href="https://github.com/antirez/redis/blob/unstable/src/dict.c" target="_blank" rel="noopener">源码</a>）。</p><p>我们前面讲过，扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis 使用我们在<strong>散列表（中）</strong>讲的渐进式扩容缩容策略，将数据的搬移分批进行，避免了大量数据一次性搬移导致的服务停顿。</p><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于有序数组，另一种是基于散列表。</p><p>当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型。</p><ul><li><p>存储的数据都是整数；</p></li><li><p>存储的数据元素个数不超过 512 个</p></li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h2 id="有序集合（sortedset）"><a href="#有序集合（sortedset）" class="headerlink" title="有序集合（sortedset）"></a>有序集合（sortedset）</h2><p>有序集合这种数据类型，我们在<strong>跳表</strong>里已经详细讲过了。它用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。</p><p>实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。当数据量比较小的时候，Redis 会用压缩列表来实现有序集合。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><ul><li><p>所有数据的大小都要小于 64 字节；</p></li><li><p>元素个数要小于 128 个。</p></li></ul><h2 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h2><p>尽管 Redis 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在 Redis 中的数据也不会丢失。在机器重新启动之后，Redis 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。</p><p>刚刚我们讲到，Redis 的数据格式由“键”和“值”两部分组成。而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那 Redis 是如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中的呢？</p><p>实际上，Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作<strong>数据结构的持久化问题</strong>，或者<strong>对象的持久化问题</strong>。这里的“持久化”，你可以笼统地可以理解为“存储到磁盘”。</p><p>如何将数据结构持久化到硬盘？我们主要有两种解决思路。</p><p>第一种是清除原有的存储结构，只将数据存储到磁盘中。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。</p><p>不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了。</p><p>第二种方式是保留原来的存储格式，将数据按照原有的格式存储在磁盘中。我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>Redis 中常用数据类型底层依赖的数据结构，大概有这五种：<strong>压缩列表</strong>（可以看作一种特殊的数组）、<strong>有序数组</strong>、<strong>链表</strong>、<strong>散列表</strong>、<strong>跳表</strong>。实际上，Redis 就是这些常用数据结构的封装。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 你有没有发现，在数据量比较小的情况下，Redis 中的很多数据类型，比如字典、有序集合等，都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？</p><p>2 我们讲到数据结构持久化有两种方法。对于二叉查找树这种数据结构，我们如何将它持久化到磁盘中呢？</p><p><strong>回答1：</strong><br>Redis的数据结构由多种数据结构来实现，主要是出于时间和空间的考虑，当数据量小的时候通过数组下标访问最快、占用内存最小，而压缩列表只是数组的升级版；</p><p>因为数组需要占用连续的内存空间，所以当数据量大的时候，就需要使用链表了，同时为了保证速度又需要和数组结合，也就有了散列表。</p><p>对于数据的大小和多少采用哪种数据结构，相信redis团队一定是根据大多数的开发场景而定的。</p><p><strong>回答2：</strong><br>二叉查找树的存储，个人倾向于存储方式一，通过填充叶子节点形成完全二叉树，然后以数组的形式存储到硬盘，数据还原过程也是非常高效的。如果用存储方式二就比较复杂了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47-并行算法_如何利用并行处理提高算法的执行效率</title>
      <link href="/2019/08/20/47-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/"/>
      <url>/2019/08/20/47-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率。毕竟，对于实际的软件开发来说，即便是像 10%、20% 这样微小的性能提升，也是非常可观的。</p><p>算法的目的就是为了提高代码执行的效率。那<strong>当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢？</strong>我们今天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。今天，我就通过几个例子，给你展示一下，<font color="red">如何借助并行计算的处理思想对算法进行改造？</font></p><a id="more"></a><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>假设我们要给大小为 8GB 的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。对于排序来说，最常用的就是时间复杂度为 O(nlogn) 的三种排序算法，归并排序、快速排序、堆排序。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，我们可以很轻松地将这个给 8GB 数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种。</p><p><strong>第一种是对归并排序并行化处理。</strong>我们可以将这 8GB 的数据划分成 16 个小的数据集合，每个集合包含 500MB 的数据。我们用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。这 16 个小集合分别排序完成之后，我们再将这 16 个有序集合合并。</p><p><strong>第二种是对快速排序并行化处理。</strong>我们通过扫描一遍数据，找到数据所处的范围区间。我们把这个区间从小到大划分成 16 个小区间。我们将 8GB 的数据划分到对应的区间中。针对这 16 个小区间的数据，我们启动 16 个线程，并行地进行排序。等到 16 个线程都执行结束之后，得到的数据就是有序数据了。</p><p>对比这两种处理思路，它们利用的都是分治的思想，对数据进行分片，然后并行处理。它们的区别在于，第一种处理思路是，先随意地对数据分片，排序之后再合并。第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处理了。这个跟归并和快排的区别如出一辙。</p><p>这里还要多说几句，如果要排序的数据规模不是 8GB，而是 1TB，那问题的重点就不是算法的执行效率了，而是数据的读取效率。因为 1TB 的数据肯定是存在硬盘中，无法一次性读取到内存中，这样在排序的过程中，就会有频繁地磁盘数据的读取和写入。如何减少磁盘的 IO 操作，减少磁盘数据读取和写入的总量，就变成了优化的重点。不过这个不是我们这节要讨论的重点，你可以自己思考下。</p><h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p>我们知道，散列表是一种非常适合快速查找的数据结构。</p><p>如果我们是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我们就需要对散列表进行动态扩容。对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存。比如，我们给一个 2GB 大小的散列表进行扩容，扩展到原来的 1.5 倍，也就是 3GB 大小。这个时候，实际存储在散列表中的数据只有不到 2GB，所以内存的利用率只有 60%，有 1GB 的内存是空闲的。</p><p>实际上，我们可以将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1/k，然后我们针对这 k 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了。当某个小散列表的装载因子过大的时候，我们可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容。</p><p>还是刚才那个例子，假设现在有 2GB 的数据，我们放到 16 个散列表中，每个散列表中的数据大约是 150MB。当某个散列表需要扩容的时候，我们只需要额外增加 150*0.5=75MB 的内存（假设还是扩容到原来的 1.5 倍）。不管从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。</p><p>当我们要查找某个数据的时候，我们只需要通过 16 个线程，并行地在这 16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。</p><p>当往散列表中添加数据的时候，我们可以选择将这个新数据放入装载因子最小的那个散列表中，这样也有助于减少散列冲突。</p><h2 id="并行字符串匹配"><a href="#并行字符串匹配" class="headerlink" title="并行字符串匹配"></a>并行字符串匹配</h2><p>我们前面学过，在文本中查找某个关键词这样一个功能，可以通过字符串匹配算法来实现。我们之前学过的字符串匹配算法有 KMP、BM、RK、BF 等。当在一个不是很长的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得非常高效。但是，如果我们处理的是超级大的文本，那处理的时间可能就会变得很长，那有没有办法加快匹配速度呢？</p><p>我们可以把大的文本，分割成 k 个小文本。假设 k 是 16，我们就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍。16 倍效率的提升，从理论的角度来说并不多。但是，对于真实的软件开发来说，这显然是一个非常可观的优化。</p><p>不过，这里还有一个细节要处理，那就是原本包含在大文本中的关键词，被一分为二，分割到两个小文本中，这就会导致尽管大文本中包含这个关键词，但在这 16 个小文本中查找不到它。实际上，这个问题也不难解决，我们只需要针对这种特殊情况，做一些特殊处理就可以了。</p><p>我们假设关键词的长度是 m。我们在每个小文本的结尾和开始各取 m 个字符串。前一个小文本的末尾 m 个字符和后一个小文本的开头 m 个字符，组成一个长度是 2m 的字符串。我们再拿关键词，在这个长度为 2m 的字符串中再重新查找一遍，就可以补上刚才的漏洞了。</p><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>前面我们学习过好几种搜索算法，它们分别是广度优先搜索、深度优先搜索、Dijkstra 最短路径算法、A* 启发式搜索算法。对于广度优先搜索算法，我们也可以将其改造成并行算法。</p><p>广度优先搜索是一种逐层搜索的搜索策略。基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点。在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点。现在，经过改造之后的并行广度优先搜索算法，我们需要利用两个队列来完成扩展顶点的工作。</p><p>假设这两个队列分别是队列 A 和队列 B。多线程并行处理队列 A 中的顶点，并将扩展得到的顶点存储在队列 B 中。等队列 A 中的顶点都扩展完成之后，队列 A 被清空，我们再并行地扩展队列 B 中的顶点，并将扩展出来的顶点存储在队列 A。这样两个队列循环使用，就可以实现并行广度优先搜索算法。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>并行计算是一个工程上的实现思路，尽管跟算法关系不大，但是，在实际的软件开发中，它确实可以非常巧妙地提高程序的运行效率，是一种非常好用的性能优化手段。</p><p>别是，当要处理的数据规模达到一定程度之后，我们无法通过继续优化算法，来提高执行效率 的时候，我们就需要在实现的思路上做文章，利用更多的硬件资源，来加快执行的效率。所以，在很多超大规模数据处理中，并行处理的思想，应用非常广泛，比如 MapReduce 实际上就是一种并行计算框架。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>假设我们有 n 个任务，为了提高执行的效率，我们希望能并行执行任务，但是各个任务之间又有一定的依赖关系，如何根据依赖关系找出可以并行执行的任务？</p><p><strong>回答1：</strong><br>用一个有向图来存储任务之间的依赖关系，然后用拓扑排序的思想来执行任务，每次都找到入度为0的，放在队列里，启动线程池开始执行，队列里的任务并行执行完毕，再次调用拓扑排序找到入度为0的人，放入队列，直到所以任务跑完</p><p><strong>回答2：</strong><br>先应用有向图寻找依赖关系，再执行并行化的广度优先搜索处理任务。</p><p>先计算各个任务间的依赖关系，可以根据依赖关系构建有向图，若 A 依赖 B，则添加由 B 指向 A 的边。</p><p>找到入度为 0 的任务，放入队列中。</p><p>并行执行队列中的任务，每完成一个任务，删除该任务顶点及指出的边，当队列中的任务都执行完，再继续找入度为 0 的任务重复上述步骤，直至任务全部执行完成。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46-索引_如何在海量数据中快速查找某个数据</title>
      <link href="/2019/08/16/46-%E7%B4%A2%E5%BC%95-%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/08/16/46-%E7%B4%A2%E5%BC%95-%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E6%9F%90%E4%B8%AA%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前文我们讲了 MySQL 数据库索引的实现原理。MySQL 底层依赖的是 B+ 树这种数据结构。<font color="red">那类似 Redis 这样的 Key-Value 数据库中的索引，又是怎么实现的呢？底层依赖的又是什么数据结构呢？</font></p><p>今天，就来讲一下索引这种常用的技术解决思路，底层往往会依赖哪些数据结构。同时，通过索引这个应用场景，也带你回顾一下，之前我们学过的几种支持动态集合的数据结构。</p><a id="more"></a><h2 id="为什么需要索引？"><a href="#为什么需要索引？" class="headerlink" title="为什么需要索引？"></a>为什么需要索引？</h2><p>在实际的软件开发中，业务纷繁复杂，功能千变万化，但是，万变不离其宗。如果抛开这些业务和功能的外壳，其实它们的本质都可以抽象为“对数据的存储和计算”。对应到数据结构和算法中，那“存储”需要的就是数据结构，“计算”需要的就是算法。</p><p>对于存储的需求，功能上无外乎增删改查。这其实并不复杂。但是，一旦存储的数据很多，那性能就成了这些系统要关注的重点，特别是在一些跟存储相关的基础系统（比如 MySQL 数据库、分布式文件系统等）、中间件（比如消息中间件 RocketMQ 等）中。</p><p>“如何节省存储空间、如何提高数据增删改查的执行效率”，这样的问题就成了设计的重点。而这些系统的实现，都离不开一个东西，那就是<strong>索引</strong>。不夸张地说，索引设计得好坏，直接决定了这些系统是否优秀。</p><p>索引这个概念，非常好理解。你可以类比书籍的目录来理解。如果没有目录，我们想要查找某个知识点的时候，就要一页一页翻。通过目录，我们就可以快速定位相关知识点的页数，查找的速度也会有质的提高。</p><h2 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h2><p>索引的概念不难理解，我想你应该已经搞明白。接下来，我们就分析一下，在设计索引的过程中，需要考虑到的一些因素，换句话说就是，我们该如何定义清楚需求呢？</p><p>对于系统设计需求，我们一般可以从<strong>功能性需求</strong>和<strong>非功能性需求</strong>两方面来分析，这个我们之前也说过。因此，这个问题也不例外。</p><h3 id="1-功能性需求"><a href="#1-功能性需求" class="headerlink" title="1. 功能性需求"></a>1. 功能性需求</h3><p>对于功能性需求需要考虑的点，我把它们大致概括成下面这几点。</p><p><strong>数据是格式化数据还是非格式化数据？</strong>要构建索引的原始数据，类型有很多。我把它分为两类，一类是结构化数据，比如，MySQL 中的数据；另一类是非结构化数据，比如搜索引擎中网页。对于非结构化数据，我们一般需要做预处理，提取出查询关键词，对关键词构建索引。</p><p><strong>数据是静态数据还是动态数据？</strong>如果原始数据是一组静态数据，也就是说，不会有数据的增加、删除、更新操作，所以，我们在构建索引的时候，只需要考虑查询效率就可以了。这样，索引的构建就相对简单些。不过，大部分情况下，我们都是对动态数据构建索引，也就是说，我们不仅要考虑到索引的查询效率，在原始数据更新的同时，我们还需要动态地更新索引。支持动态数据集合的索引，设计起来相对也要更加复杂些。</p><p><strong>索引存储在内存还是硬盘？</strong>如果索引存储在内存中，那查询的速度肯定要比存储在磁盘中的高。但是，如果原始数据量很大的情况下，对应的索引可能也会很大。这个时候，因为内存有限，我们可能就不得不将索引存储在磁盘中了。实际上，还有第三种情况，那就是一部分存储在内存，一部分存储在磁盘，这样就可以兼顾内存消耗和查询效率。</p><p><strong>单值查找还是区间查找？</strong>所谓单值查找，也就是根据查询关键词等于某个值的数据。这种查询需求最常见。所谓区间查找，就是查找关键词处于某个区间值的所有数据。你可以类比 MySQL 数据库的查询需求，自己想象一下。实际上，不同的应用场景，查询的需求会多种多样。</p><p><strong>单关键词查找还是多关键词组合查找?</strong> 比如，搜索引擎中构建的索引，既要支持一个关键词的查找，比如“数据结构”，也要支持组合关键词查找，比如“数据结构 AND 算法”。对于单关键词的查找，索引构建起来相对简单些。对于多关键词查询来说，要分多种情况。像 MySQL 这种结构化数据的查询需求，我们可以实现针对多个关键词的组合，建立索引；对于像搜索引擎这样的非结构数据的查询需求，我们可以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关键词组合的查询结果。</p><p>实际上，不同的场景，不同的原始数据，对于索引的需求也会千差万别。这里只列举了一些比较有共性的需求。</p><h3 id="2-非功能性需求"><a href="#2-非功能性需求" class="headerlink" title="2. 非功能性需求"></a>2. 非功能性需求</h3><p>讲完了功能性需求，我们再来看，索引设计的非功能性需求。</p><p><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大。</strong>如果存储在内存中，索引对占用存储空间的限制就会非常苛刻。毕竟内存空间非常有限，一个中间件启动后就占用几个 GB 的内存，开发者显然是无法接受的。如果存储在硬盘中，那索引对占用存储空间的限制，稍微会放宽一些。但是，我们也不能掉以轻心。因为，有时候，索引对存储空间的消耗会超过原始数据。</p><p><strong>在考虑索引查询效率的同时，我们还要考虑索引的维护成本。</strong>索引的目的是提高查询效率，但是，基于动态数据集合构建的索引，我们还要考虑到，索引的维护成本。因为在原始数据动态增删改的同时，我们也需要动态的更新索引。而索引的更新势必会影响到增删改操作的性能。</p><h2 id="构建索引常用的数据结构有哪些？"><a href="#构建索引常用的数据结构有哪些？" class="headerlink" title="构建索引常用的数据结构有哪些？"></a>构建索引常用的数据结构有哪些？</h2><p>刚刚从很宏观的角度，总结了在索引设计的过程中，需要考虑的一些共性因素。现在，我们就来看，对于不同需求的索引结构，底层一般使用哪种数据结构。</p><p>实际上，常用来构建索引的数据结构，就是我们之前讲过的几种支持动态数据集合的数据结构。比如，散列表、红黑树、跳表、B+ 树。除此之外，位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引。</p><p>我们知道，<strong>散列表</strong>增删改查操作的性能非常好，时间复杂度是 O(1)。一些键值数据库，比如 Redis、Memcache，就是使用散列表来构建索引的。这类索引，一般都构建在内存中。</p><p><strong>红黑树</strong>作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是 O(logn)，也非常适合用来构建内存索引。Ext 文件系统中，对磁盘块的索引，用的就是红黑树。</p><p><strong>B+ 树</strong>比起红黑树来说，更加适合构建存储在磁盘中的索引。B+ 树是一个多叉树，所以，对相同个数的数据构建索引，B+ 树的高度要低于红黑树。当借助索引查询数据的时候，读取 B+ 树索引，需要的磁盘 IO 次数会更少。所以，大部分关系型数据库的索引，比如 MySQL、Oracle，都是用 B+ 树来实现的。</p><p><strong>跳表</strong>也支持快速添加、删除、查找数据。而且，我们通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。Redis 中的有序集合，就是用跳表来构建的。</p><p>除了散列表、红黑树、B+ 树、跳表之外，位图和布隆过滤器这两个数据结构，也可以用于索引中，辅助存储在磁盘中的索引，加速数据查找的效率。我们来看下，具体是怎么做的？</p><p>我们知道，<strong>布隆过滤器</strong>有一定的判错率。但是，我们可以规避它的短处，发挥它的长处。尽管对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。而且，布隆过滤器还有一个更大的特点，那就是内存占用非常少。我们可以针对数据，构建一个布隆过滤器，并且存储在内存中。当要查询数据的时候，我们可以先通过布隆过滤器，判定是否存在。如果通过布隆过滤器判定数据不存在，那我们就没有必要读取磁盘中的索引了。对于数据不存在的情况，数据查询就更加快速了。</p><p>实际上，有序数组也可以被作为索引。如果数据是静态的，也就是不会有插入、删除、更新操作，那我们可以把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>从索引这个非常常用的技术方案，给你展示了散列表、红黑树、跳表、位图、布隆过滤器、有序数组这些数据结构的应用场景。学习完这节课之后，不知道你对这些数据结构以及索引，有没有更加清晰的认识呢？</p><p>从这一节内容中，你应该可以看出，架构设计离不开数据结构和算法。要想成长为一个优秀的业务架构师、基础架构师，数据结构和算法的根基一定要打稳。因为，那些看似很惊艳的架构设计思路，实际上，都是来自最常用的数据结构和算法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45-搜索_如何用A*搜索算法实现游戏中的寻路功能</title>
      <link href="/2019/08/13/45-%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E7%94%A8A%E6%98%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/13/45-%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E7%94%A8A%E6%98%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>魔兽世界、仙剑奇侠传这类 MMRPG 游戏，不知道你有没有玩过？在这些游戏中，有一个非常重要的功能，那就是人物角色自动寻路。<font color="red">当人物处于游戏地图中的某个位置的时候，我们用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去。玩过这么多游戏，不知你是否思考过，这个功能是怎么实现的呢？</font></p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，这是一个非常典型的搜索问题。人物的起点就是他当下所在的位置，终点就是鼠标点击的位置。我们需要在地图中，找一条从起点到终点的路径。这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法。所谓“聪明”，笼统地解释就是，走的路不能太绕。理论上讲，最短路径显然是最聪明的走法，是这个问题的最优解。</p><p>不过，在前文提到优出行路线规划问题中，我们也讲过，如果图非常大，那 Dijkstra 最短路径算法的执行耗时会很多。在真实的软件开发中，我们面对的是超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的。</p><p>实际上，像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，我们都不需要非得求最优解（也就是最短路径）。在权衡路线规划质量和执行效率的情况下，我们只需要寻求一个次优解就足够了。那<strong>如何快速找出一条接近于最短路线的次优路线呢？</strong></p><p>这个快速的路径规划算法，就是我们今天要学习的<em>* A</em> 算法<em>*。实际上，A\</em> 算法是对 Dijkstra 算法的优化和改造。如何将 Dijkstra 算法改造成 A* 算法呢？</p><p>Dijkstra 算法有点儿类似 BFS 算法，它每次找到跟起点最近的顶点，往外扩展。这种往外扩展的思路，其实有些盲目。为什么这么说呢？我举一个例子来给你解释一下。下面这个图对应一个真实的地图，每个顶点在地图中的位置，我们用一个二维坐标（x，y）来表示，其中，x 表示横坐标，y 表示纵坐标。</p><p><img src="/2019/08/13/45-%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E7%94%A8A%E6%98%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD/11840cc13071fe2da67675338e46cadd.jpg" alt></p><p>在 Dijkstra 算法的实现思路中，我们用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度。顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展，从图中举的例子可以看出，尽管我们找的是从 s 到 t 的路线，但是最先被搜索到的顶点依次是 1，2，3。通过肉眼来观察，这个搜索方向跟我们期望的路线方向（s 到 t 是从西向东）是反着的，路线搜索的方向明显“跑偏”了。</p><p>之所以会“跑偏”，那是因为我们是按照顶点与起点的路径长度的大小，来安排出队列顺序的。与起点越近的顶点，就会越早出队列。我们并没有考虑到这个顶点到终点的距离，所以，在地图中，尽管 1，2，3 三个顶点离起始顶点最近，但离终点却越来越远。</p><p>如果我们综合更多的因素，把这个顶点到终点可能还要走多远，也考虑进去，综合来判断哪个顶点该先出队列，那是不是就可以避免“跑偏”呢？</p><p>当我们遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，我们记作 g(i)（i 表示顶点编号）。但是，从这个顶点到终点的路径长度，我们是未知的。虽然确切的值无法提前知道，但是我们可以用其他估计值来代替。</p><p>这里我们可以通过这个顶点跟终点之间的直线距离，也就是欧几里得距离，来近似地估计这个顶点跟终点的路径长度（注意：路径长度跟直线距离是两个概念）。我们把这个距离记作 h(i)（i 表示这个顶点的编号），专业的叫法是<strong>启发函数</strong>（heuristic function）。因为欧几里得距离的计算公式，会涉及比较耗时的开根号计算，所以，我们一般通过另外一个更加简单的距离计算公式，那就是<strong>曼哈顿距离</strong>（Manhattan distance）。<strong>曼哈顿距离是两点之间横纵坐标的距离之和</strong>。计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int hManhattan(Vertex v1, Vertex v2) &#123; &#x2F;&#x2F; Vertex表示顶点，后面有定义</span><br><span class="line">  return Math.abs(v1.x - v2.x) + Math.abs(v1.y - v2.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来只是单纯地通过顶点与起点之间的路径长度 g(i)，来判断谁先出队列，现在有了顶点到终点的路径长度估计值，我们通过两者之和 f(i)=g(i)+h(i)，来判断哪个顶点该最先出队列。综合两部分，我们就能有效避免刚刚讲的“跑偏”。这里 f(i) 的专业叫法是<strong>估价函数</strong>（evaluation function）。</p><p>从刚刚的描述，我们可以发现，A* 算法就是对 Dijkstra 算法的简单改造。实际上，代码实现方面，我们也只需要稍微改动几行代码，就能把 Dijkstra 算法的代码实现，改成 A* 算法的代码实现。</p><p>在 A* 算法的代码实现中，顶点 Vertex 类的定义，跟 Dijkstra 算法中的定义，稍微有点儿区别，多了 x，y 坐标，以及刚刚提到的 f(i) 值。图 Graph 类的定义跟 Dijkstra 算法中的定义一样。为了避免重复，这里就没有再贴出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private class Vertex &#123;</span><br><span class="line">  public int id; &#x2F;&#x2F; 顶点编号ID</span><br><span class="line">  public int dist; &#x2F;&#x2F; 从起始顶点，到这个顶点的距离，也就是g(i)</span><br><span class="line">  public int f; &#x2F;&#x2F; 新增：f(i)&#x3D;g(i)+h(i)</span><br><span class="line">  public int x, y; &#x2F;&#x2F; 新增：顶点在地图中的坐标（x, y）</span><br><span class="line">  public Vertex(int id, int x, int y) &#123;</span><br><span class="line">    this.id &#x3D; id;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">    this.f &#x3D; Integer.MAX_VALUE;</span><br><span class="line">    this.dist &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Graph类的成员变量，在构造函数中初始化</span><br><span class="line">Vertex[] vertexes &#x3D; new Vertex[this.v];</span><br><span class="line">&#x2F;&#x2F; 新增一个方法，添加顶点的坐标</span><br><span class="line">public void addVetex(int id, int x, int y) &#123;</span><br><span class="line">  vertexes[id] &#x3D; new Vertex(id, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A* 算法的代码实现的主要逻辑是下面这段代码。它跟 Dijkstra 算法的代码实现，主要有 3 点区别：</p><ul><li><p>优先级队列构建的方式不同。A* 算法是根据 f 值（也就是刚刚讲到的 f(i)=g(i)+h(i)）来构建优先级队列，而 Dijkstra 算法是根据 dist 值（也就是刚刚讲到的 g(i)）来构建优先级队列；</p></li><li><p>A* 算法在更新顶点 dist 值的时候，会同步更新 f 值；</p></li><li><p>循环结束的条件也不一样。Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void astar(int s, int t) &#123; &#x2F;&#x2F; 从顶点s到顶点t的路径</span><br><span class="line">  int[] predecessor &#x3D; new int[this.v]; &#x2F;&#x2F; 用来还原路径</span><br><span class="line">  &#x2F;&#x2F; 按照vertex的f值构建的小顶堆，而不是按照dist</span><br><span class="line">  PriorityQueue queue &#x3D; new PriorityQueue(this.v);</span><br><span class="line">  boolean[] inqueue &#x3D; new boolean[this.v]; &#x2F;&#x2F; 标记是否进入过队列</span><br><span class="line">  vertexes[s].dist &#x3D; 0;</span><br><span class="line">  vertexes[s].f &#x3D; 0;</span><br><span class="line">  queue.add(vertexes[s]);</span><br><span class="line">  inqueue[s] &#x3D; true;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    Vertex minVertex &#x3D; queue.poll(); &#x2F;&#x2F; 取堆顶元素并删除</span><br><span class="line">    for (int i &#x3D; 0; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">      Edge e &#x3D; adj[minVertex.id].get(i); &#x2F;&#x2F; 取出一条minVetex相连的边</span><br><span class="line">      Vertex nextVertex &#x3D; vertexes[e.tid]; &#x2F;&#x2F; minVertex--&gt;nextVertex</span><br><span class="line">      if (minVertex.dist + e.w &lt; nextVertex.dist) &#123; &#x2F;&#x2F; 更新next的dist,f</span><br><span class="line">        nextVertex.dist &#x3D; minVertex.dist + e.w;</span><br><span class="line">        nextVertex.f </span><br><span class="line">           &#x3D; nextVertex.dist+hManhattan(nextVertex, vertexes[t]);</span><br><span class="line">        predecessor[nextVertex.id] &#x3D; minVertex.id;</span><br><span class="line">        if (inqueue[nextVertex.id] &#x3D;&#x3D; true) &#123;</span><br><span class="line">          queue.update(nextVertex);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          queue.add(nextVertex);</span><br><span class="line">          inqueue[nextVertex.id] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (nextVertex.id &#x3D;&#x3D; t) &#123; &#x2F;&#x2F; 只要到达t就可以结束while了</span><br><span class="line">        queue.clear(); &#x2F;&#x2F; 清空queue，才能推出while循环</span><br><span class="line">        break; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 输出路径</span><br><span class="line">  System.out.print(s);</span><br><span class="line">  print(s, t, predecessor); &#x2F;&#x2F; print函数请参看Dijkstra算法的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尽管 A* 算法可以更加快速的找到从起点到终点的路线，但是它并不能像 Dijkstra 算法那样，找到最短路线。这是为什么呢？</strong></p><p>要找出起点 s 到终点 t 的最短路径，最简单的方法是，通过回溯穷举所有从 s 到达 t 的不同路径，然后对比找出最短的那个。不过很显然，回溯算法的执行效率非常低，是指数级的。</p><p><img src="/2019/08/13/45-%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E7%94%A8A%E6%98%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD/c7d81b8a-67a8-4be3-8d8c-d91e09a64b4b.jpg" alt></p><p>Dijkstra 算法在此基础之上，利用动态规划的思想，对回溯搜索进行了剪枝，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，但它实际上也考察到了所有从起点到终点的路线，所以才能得到最优解。</p><p><img src="/2019/08/13/45-%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E7%94%A8A%E6%98%9F%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E5%8A%9F%E8%83%BD/ae436f56-8f6d-4cdf-b377-7bbe73fc5c5d.jpg" alt></p><p>A* 算法之所以不能像 Dijkstra 算法那样，找到最短路径，主要原因是两者的 while 循环结束条件不一样。刚刚我们讲过，Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束。对于 Dijkstra 算法来说，当终点出队列的时候，终点的 dist 值是优先级队列中所有顶点的最小值，即便再运行下去，终点的 dist 值也不会再被更新了。对于 A* 算法来说，一旦遍历到终点，我们就结束 while 循环，这个时候，终点的 dist 值未必是最小值。</p><p>A* 算法利用贪心算法的思路，每次都找 f 值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。所以，它并没有考察所有的路线，也就不可能找出最短路径了。</p><p>搞懂了 A* 算法，我们再来看下，如何借助 A* 算法解决今天的游戏寻路问题？</p><p>要利用 A* 算法解决这个问题，我们只需要把地图，抽象成图就可以了。不过，游戏中的地图跟我们平常用的地图是不一样的。因为游戏中的地图并不像我们现实生活中那样，存在规划非常清晰的道路，更多的是宽阔的荒野、草坪等。所以，我们没法利用之前讲到的抽象方法，把岔路口抽象成顶点，把道路抽象成边。</p><p>实际上，我们可以换一种抽象的思路，把整个地图分割成一个一个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。我们可以把每个方块看作一个顶点。两个方块相邻，我们就在它们之间，连两条有向边，并且边的权值都是 1。所以，这个问题就转化成了，在一个有向有权图中，找某个顶点到另一个顶点的路径问题。将地图抽象成边权值为 1 的有向图之后，我们就可以套用 A* 算法，来实现游戏中人物的自动寻路功能了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>我们今天讲的 A* <strong>算法属于一种启发式搜索算法</strong>（Heuristically Search Algorithm）。实际上，启发式搜索算法并不仅仅只有 A* 算法，还有很多其他算法，比如 IDA* 算法、蚁群算法、遗传算法、模拟退火算法等。</p><p>启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进。这种算法找出的路线，并不是最短路线。但是，实际的软件开发中的路线规划问题，我们往往并不需要非得找最短路线。所以，鉴于启发式搜索算法能很好地平衡路线质量和执行效率，它在实际的软件开发中的应用更加广泛。实际上，在前文中，我们讲到的地图 App 中的出行路线规划问题，也可以利用启发式搜索算法来实现。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们之前讲的“迷宫问题”是否可以借助 A* 算法来更快速地找到一个走出去的路线呢？如果可以，请具体讲讲该怎么来做；如果不可以，请说说原因。</p><p><strong>回答：</strong></p><p>迷宫问题可以借助A<em>算法来更快找到一个可以出去的路线，因为A\</em>算法只是更改了试探路线的优先级，如果终止条件不变所有的路线还是会被试探到的，就比如本节的最短路线问题，如果终止条件还是终点从优先级队列中push出去，还是会找到最短路径，不对不一定，因为pop条件变了，不能保证t被pop出去时，比他里源点更近的都已经pop出去，很有可能某个到源点进但是离t远的点还没pop出去。 迷宫算法只要能出去就可以，如果能找到一个好的估价函数迷宫算法使用A*是可以更快的，但迷宫没什么规律，估价函数想不出来。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44-B+树_MySQL数据库索引是如何实现的</title>
      <link href="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
      <url>/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个软件开发工程师，你对数据库肯定再熟悉不过了。作为主流的数据存储系统，它在我们的业务开发中，有着举足轻重的地位。在工作中，为了加速数据库中数据的查找速度，我们常用的处理思路是，对表中数据创建索引。那你是否思考过，<font color="red">数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</font></p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>思考的过程比结论更重要。</p><h3 id="1-解决问题的前提是定义清楚问题"><a href="#1-解决问题的前提是定义清楚问题" class="headerlink" title="1. 解决问题的前提是定义清楚问题"></a>1. 解决问题的前提是定义清楚问题</h3><p>如何定义清楚问题呢？除了对问题进行详细的调研，还有一个办法，那就是，通过对一些模糊的需求进行假设，来限定要解决的问题的范围。</p><p>如果你对数据库的操作非常了解，针对我们现在这个问题，你就能把索引的需求定义得非常清楚。但是，对于大部分软件工程师来说，我们可能只了解一小部分常用的 SQL 语句，所以，这里我们假设要解决的问题，只包含这样两个常用的需求：</p><ul><li><p>根据某个值查找数据，比如 select * from user where id=1234；</p></li><li><p>根据区间值来查找某些数据，比如 select * from user where id &gt; 1234 and id &lt; 2345。</p></li></ul><p>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，比如安全、性能、用户体验等等。限于专栏要讨论的主要是数据结构和算法，对于非功能性需求，我们着重考虑<strong>性能方面</strong>的需求。性能方面的需求，我们主要考察时间和空间两方面，也就是<strong>执行效率</strong>和<strong>存储空间</strong>。</p><p>在执行效率方面，我们希望通过索引，查询数据的效率尽可能的高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><h3 id="2-尝试用学过的数据结构解决这个问题"><a href="#2-尝试用学过的数据结构解决这个问题" class="headerlink" title="2. 尝试用学过的数据结构解决这个问题"></a>2. 尝试用学过的数据结构解决这个问题</h3><p>问题的需求大致定义清楚了，我们现在回想一下，能否利用已经学习过的数据结构解决这个问题呢？支持快速查询、插入等操作的动态数据结构，我们已经学习过散列表、平衡二叉查找树、跳表。</p><p>我们先来看<strong>散列表</strong>。散列表的查询性能很好，时间复杂度是 O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。</p><p>我们再来看<strong>平衡二叉查找树</strong>。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。</p><p>我们再来看<strong>跳表</strong>。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/d70e82db-533d-416a-ad6e-2b38b36eb081.jpg" alt></p><p>这样看来，跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。为了给你还原发明 B+ 树的整个思考过程，所以，接下来，还会再从二叉查找树讲起，看它是如何一步一步被改造成 B+ 树的。</p><h3 id="3-改造二叉查找树来解决这个问题"><a href="#3-改造二叉查找树来解决这个问题" class="headerlink" title="3. 改造二叉查找树来解决这个问题"></a>3. 改造二叉查找树来解决这个问题</h3><p>为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。经过改造之后的二叉树，就像图中这样，看起来是不是很像跳表呢？</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/f878cca3-49ea-4c71-b295-fb66ddd924d5.jpg" alt></p><p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/6c0cf67e-691b-4a47-9c6a-b43b821dd383.jpg" alt></p><p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。</p><p>比如，我们给一亿个数据构建二叉查找树索引，那索引中会包含大约 1 亿个节点，每个节点假设占用 16 个字节，那就需要大约 1GB 的内存空间。给一张表建立索引，我们需要 1GB 的内存空间。如果我们要给 10 张表建立索引，那对内存的需求是无法满足的。如何解决这个索引占用太多内存的问题呢？</p><p>我们可以借助时间换空间的思路，把索引存储在硬盘中，而非内存中。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p><p>这种将索引存储在硬盘中的方案，尽管减少了内存消耗，但是在数据查找的过程中，需要读取磁盘中的索引，因此数据查询效率就相应降低很多。</p><p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。</p><p>我们前面讲到，比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？</p><p>我们来看下，如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（如果根节点存储在内存中，其他节点存储在磁盘中），如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 3，最多只要 3 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/32015443-1d13-4201-aea3-44d25db5a2d2.jpg" alt></p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/4d1e197f-3c1e-489b-84b9-a48fda301471.jpg" alt></p><p>如果我们将 m 叉树实现 B+ 树索引，用代码实现出来，就是下面这个样子（假设我们给 int 类型的数据库字段添加索引，所以代码中的 keywords 是 int 类型的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 这是B+树非叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * 假设keywords&#x3D;[3, 5, 8, 10]</span><br><span class="line"> * 4个键值将数据分为5个区间：(-INF,3), [3,5), [5,8), [8,10), [10,INF)</span><br><span class="line"> * 5个区间分别对应：children[0]...children[4]</span><br><span class="line"> *</span><br><span class="line"> * m值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; (m-1)*4[keywordss大小]+m*8[children大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeNode &#123;</span><br><span class="line">  public static int m &#x3D; 5; &#x2F;&#x2F; 5叉树</span><br><span class="line">  public int[] keywords &#x3D; new int[m-1]; &#x2F;&#x2F; 键值，用来划分数据区间</span><br><span class="line">  public BPlusTreeNode[] children &#x3D; new BPlusTreeNode[m];&#x2F;&#x2F;保存子节点指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这是B+树中叶子节点的定义。</span><br><span class="line"> *</span><br><span class="line"> * B+树中的叶子节点跟内部节点是不一样的,</span><br><span class="line"> * 叶子节点存储的是值，而非区间。</span><br><span class="line"> * 这个定义里，每个叶子节点存储3个数据行的键值及地址信息。</span><br><span class="line"> *</span><br><span class="line"> * k值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span><br><span class="line"> * PAGE_SIZE &#x3D; k*4[keyw..大小]+k*8[dataAd..大小]+8[prev大小]+8[next大小]</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BPlusTreeLeafNode &#123;</span><br><span class="line">  public static int k &#x3D; 3;</span><br><span class="line">  public int[] keywords &#x3D; new int[k]; &#x2F;&#x2F; 数据的键值</span><br><span class="line">  public long[] dataAddress &#x3D; new long[k]; &#x2F;&#x2F; 数据地址</span><br><span class="line"></span><br><span class="line">  public BPlusTreeLeafNode prev; &#x2F;&#x2F; 这个结点在链表中的前驱结点</span><br><span class="line">  public BPlusTreeLeafNode next; &#x2F;&#x2F; 这个结点在链表中的后继结点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微解释一下这段代码。</p><p>对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小，那 m 叉树中的 m 是不是越大越好呢？到底多大才最合适呢？</p><p>不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/ea4472fd7bb7fa948532c8c8ba334430.jpg" alt></p><p>尽管索引可以提高数据库的查询效率，但是，作为一名开发工程师，你应该也知道，索引有利也有弊，它也会让写入数据的效率下降。这是为什么呢？</p><p>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因。</p><p>对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。我们该如何解决这个问题呢？</p><p>实际上，处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解（图中的 B+ 树是一个三叉树。我们限定叶子节点中，数据的个数超过 2 个就分裂节点；非叶子节点中，子节点的个数超过 3 个就分裂节点）。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/1800bc80e1e05b32a042ff6873e6c2e0.jpg" alt></p><p>正是因为要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低。实际上，不光写入数据会变慢，删除数据也会变慢。这是为什么呢？</p><p>我们在删除某个数据的时候，也要对应的更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p><p>我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。</p><p>文字描述不是很直观，我举了一个删除操作的例子，你可以对比着看下（图中的 B+ 树是一个五叉树。我们限定叶子节点中，数据的个数少于 2 个就合并节点；非叶子节点中，子节点的个数少于 3 个就合并节点。）。</p><p><img src="/2019/08/10/44-B%E5%8A%A0%E6%A0%91-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/1730e34450dad29f062e76536622c918.jpg" alt></p><p>数据库索引以及 B+ 树的由来，到此就讲完了。你有没有发现，B+ 树的结构和操作，跟跳表非常类似。理论上讲，对跳表稍加改造，也可以替代 B+ 树，作为数据库的索引实现的。</p><p>B+ 树发明于 1972 年，跳表发明于 1989 年，我们可以大胆猜想下，跳表的作者有可能就是受了 B+ 树的启发，才发明出跳表来的。不过，这个也无从考证了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们讲解了数据库索引实现，依赖的底层数据结构，B+ 树。它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。</p><p>前面的讲解中，为了一步一步详细地给你介绍 B+ 树的由来，内容看起来比较零散。为了方便你掌握和记忆，这里再总结一下 B+ 树的特点：</p><ul><li><p>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</p></li><li><p>根节点的子节点个数可以不超过 m/2，这是一个例外；</p></li><li><p>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</p></li><li><p>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</p></li><li><p>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。</p></li></ul><p>除了 B+ 树，你可能还听说过 B 树、B- 树，我这里简单提一下。实际上，B- 树就是 B 树，英文翻译都是 B-Tree，这里的“-”并不是相对 B+ 树中的“+”，而只是一个连接符。这个很容易误解，所以我强调下。</p><p>而 B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：</p><ul><li><p>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；</p></li><li><p>B 树中的叶子节点并不需要链表来串联。</p></li></ul><p>就是说，B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 B+ 树中，将叶子节点串起来的链表，是单链表还是双向链表？为什么？</p><p>2 我们对平衡二叉查找树进行改造，将叶子节点串在链表中，就支持了按照区间来查找数据。我们在<strong>散列表</strong>讲到，散列表也经常跟链表一块使用，如果我们把散列表中的结点，也用链表串起来，能否支持按照区间查找数据呢？</p><p><strong>回答：</strong></p><p><strong>1</strong><br>第一题： 对于B+tree叶子节点，是用双向链表还是用单链表，得从具体的场景思考。我想，大部分同学在开发中遇到的数据库查询，都遇到过升序或降序问题，即类似这样的sql: select name,age, … from where uid &gt; startValue and uid &lt; endValue order by uid asc(或者desc)，此时，数据底层实现有两种做法：</p><p>1）保证查出来的数据就是用户想要的顺序</p><p>2）不保证查出来的数据的有序性，查出来之后再排序</p><p>以上两种方案，不加思考，肯定选第一种，因为第二种做法浪费了时间（如果选用内存排序，还是考虑数据的量级）。那如何能保证查询出来的数据就是有序的呢？单链表肯定做不到，只能从头往后遍历，再想想，只能选择双向链表了。此时，可能有的同学又问了：双向链表，多出来了一倍的指针，不是会多占用空间嘛？ 答案是肯定的。可是，我们再细想下，数据库索引本身都已经在磁盘中了，对于磁盘来说，这点空间已经微不足道了，用这点空间换来时间肯定划算呀。顺便提一下：在实际工程应用中，双向链表应用的场景非常广泛，毕竟能大量减少链表的遍历时间</p><p><strong>2</strong><br>答案是「肯定的」</p><p>JDK中的LinkedHashMap为了能做到保持节点的顺序（插入顺序或者访问顺序），就是用双向链表将节点串起来的。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>个人觉得B+tree理解起来真不难，抓住几个要点就可以了：</p><p>1. 理解二叉查找树</p><p>2. 理解二叉查找树会出现不平衡的问题（红黑树理解了，对于平衡性这个关键点就理解了）</p><p>3. 磁盘IO访问太耗时</p><p>4. 当然，链表知识跑不了 —— 别小瞧这个简单的数据结构，它是链式结构之母</p><p>5. 最后，要知道典型的应用场景：数据库的索引结构的设计</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43-向量空间_如何实现一个简单的音乐推荐系统</title>
      <link href="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多人都喜爱听歌，以前我们用 MP3 听歌，现在直接通过音乐 App 在线就能听歌。而且，各种音乐 App 的功能越来越强大，不仅可以自己选歌听，还可以根据你听歌的口味偏好，给你推荐可能会喜爱的音乐，而且有时候，推荐的音乐还非常适合你的口味，甚至会惊艳到你！如此智能的一个功能，你知道它是怎么实现的吗？</p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，要解决这个问题，并不需要特别高深的理论。解决思路的核心思想非常简单、直白，用两句话就能总结出来。</p><ul><li><p><strong>找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你</strong></p></li><li><p><strong>找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你</strong></p></li></ul><p>接下来，就分别讲解一下这两种思路的具体实现方法。</p><h3 id="1-基于相似用户做推荐"><a href="#1-基于相似用户做推荐" class="headerlink" title="1. 基于相似用户做推荐"></a>1. 基于相似用户做推荐</h3><p>如何找到跟你口味偏好相似的用户呢？或者说如何定义口味偏好相似呢？实际上，思路也很简单，我们把跟你听类似歌曲的人，看做口味相似的用户。你可以看我下面画的这个图。我用“1”表示“喜爱”，用“0”笼统地表示“不发表意见”。从图中我们可以看出，你跟小明共同喜爱的歌曲最多，有 5 首。于是，我们就可以说，小明跟你的口味非常相似。</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/74bf6427-a04d-4744-ab79-776c484382b9.jpg" alt></p><p>我们只需要遍历所有的用户，对比每个用户跟你共同喜爱的歌曲个数，并且设置一个阈值，如果你和某个用户共同喜爱的歌曲个数超过这个阈值，我们就把这个用户看作跟你口味相似的用户，把这个用户喜爱但你还没听过的歌曲，推荐给你。</p><p>不过，刚刚的这个解决方案中有一个问题，我们如何知道用户喜爱哪首歌曲呢？也就是说，如何定义用户对某首歌曲的喜爱程度呢？</p><p>实际上，我们可以通过用户的行为，来定义这个喜爱程度。我们给每个行为定义一个得分，得分越高表示喜爱程度越高。</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/97c0e93f-a7c8-484b-8179-a3aee391a5d6.jpg" alt></p><p>还是刚刚那个例子，我们如果把每个人对每首歌曲的喜爱程度表示出来，就是下面这个样子。图中，某个人对某首歌曲是否喜爱，我们不再用“1”或者“0”来表示，而是对应一个具体的分值。</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/510a9072-897f-49f2-941d-54c71e40fc57.jpg" alt></p><p>有了这样一个用户对歌曲的喜爱程度的对应表之后，如何来判断两个用户是否口味相似呢？</p><p>显然，我们不能再像之前那样，采用简单的计数来统计两个用户之间的相似度。还记得我们之前讲字符串相似度度量时，提到的编辑距离吗？这里的相似度度量，我们可以使用另外一个距离，那就是<strong>欧几里得距离</strong>（Euclidean distance）。<strong>欧几里得距离是用来计算两个向量之间的距离的</strong>。这个概念中有两个关键词，<strong>向量</strong>和<strong>距离</strong>，我来给你解释一下。</p><p>一维空间是一条线，我们用 1，2，3……这样单个的数，来表示一维空间中的某个位置；二维空间是一个面，我们用（1，3）（4，2）（2，2）……这样的两个数，来表示二维空间中的某个位置；三维空间是一个立体空间，我们用（1，3，5）（3，1，7）（2，4，3）……这样的三个数，来表示三维空间中的某个位置。一维、二维、三维应该都不难理解，那更高维中的某个位置该如何表示呢？</p><p>类比一维、二维、三维的表示方法，K 维空间中的某个位置，我们可以写作（X<sub>1</sub>，X<sub>2</sub>，X<sub>3</sub>，…，X<sub>K</sub>）。这种表示方法就是向量（vector）。我们知道，二维、三维空间中，两个位置之间有距离的概念，类比到高纬空间，同样也有距离的概念，这就是我们说的两个向量之间的距离。</p><p>那如何计算两个向量之间的距离呢？我们还是可以类比到二维、三维空间中距离的计算方法。通过类比，我们就可以得到两个向量之间距离的计算公式。这个计算公式就是欧几里得距离的计算公式：</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/72ceccb6-a02d-46bb-8141-04d6c9c84339.jpg" alt></p><p>我们把每个用户对所有歌曲的喜爱程度，都用一个向量表示。我们计算出两个向量之间的欧几里得距离，作为两个用户的口味相似程度的度量。从图中的计算可以看出，小明与你的欧几里得距离距离最小，也就是说，你俩在高维空间中靠得最近，所以，我们就断定，小明跟你的口味最相似。</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/4f59bb67-798d-4c68-aeff-3c479b6b3c30.jpg" alt></p><h3 id="2-基于相似歌曲做推荐"><a href="#2-基于相似歌曲做推荐" class="headerlink" title="2. 基于相似歌曲做推荐"></a>2. 基于相似歌曲做推荐</h3><p>刚刚我们讲了基于相似用户的歌曲推荐方法，但是，如果用户是一个新用户，我们还没有收集到足够多的行为数据，这个时候该如何推荐呢？我们现在再来看另外一种推荐方法，基于相似歌曲的推荐方法，也就是说，如果某首歌曲跟你喜爱的歌曲相似，我们就把它推荐给你。</p><p>如何判断两首歌曲是否相似呢？对于人来说，这个事情可能会比较简单，但是对于计算机来说，判断两首歌曲是否相似，那就需要通过量化的数据来表示了。我们应该通过什么数据来量化两个歌曲之间的相似程度呢？</p><p>最容易想到的是，我们对歌曲定义一些特征项，比如是伤感的还是愉快的，是摇滚还是民谣，是柔和的还是高亢的等等。类似基于相似用户的推荐方法，我们给每个歌曲的每个特征项打一个分数，这样每个歌曲就都对应一个特征项向量。我们可以基于这个特征项向量，来计算两个歌曲之间的欧几里得距离。欧几里得距离越小，表示两个歌曲的相似程度越大。</p><p>但是，要实现这个方案，需要有一个前提，那就是我们能够找到足够多，并且能够全面代表歌曲特点的特征项，除此之外，我们还要人工给每首歌标注每个特征项的得分。对于收录了海量歌曲的音乐 App 来说，这显然是一个非常大的工程。此外，人工标注有很大的主观性，也会影响到推荐的准确性。</p><p>既然基于歌曲特征项计算相似度不可行，那我们就换一种思路。对于两首歌，如果喜欢听的人群都是差不多的，那侧面就可以反映出，这两首歌比较相似。如图所示，每个用户对歌曲有不同的喜爱程度，我们依旧通过上一个解决方案中定义得分的标准，来定义喜爱程度。</p><p><img src="/2019/08/08/43-%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/ea9de504-d8f9-4b30-8576-3257ad357512.jpg" alt></p><p>你有没有发现，这个图跟基于相似用户推荐中的图几乎一样。只不过这里把歌曲和用户主次颠倒了一下。基于相似用户的推荐方法中，针对每个用户，我们将对各个歌曲的喜爱程度作为向量。基于相似歌曲的推荐思路中，针对每个歌曲，我们将每个用户的打分作为向量。</p><p>有了每个歌曲的向量表示，我们通过计算向量之间的欧几里得距离，来表示歌曲之间的相似度。欧几里得距离越小，表示两个歌曲越相似。然后，我们就在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲。然后，我们找出跟这些歌曲相似度很高的其他歌曲，推荐给他。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>实际上，这个问题是<strong>推荐系统</strong>（Recommendation System）里最典型的一类问题。之所以讲这部分内容，主要还是想给你展示，算法的强大之处，利用简单的向量空间的欧几里得距离，就能解决如此复杂的问题。不过，今天，只给你讲解了基本的理论，实践中遇到的问题还有很多，比如冷启动问题，产品初期积累的数据不多，不足以做推荐等等。这些更加深奥的内容，你可以之后自己在实践中慢慢探索。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>1</strong><br>推荐系统（Recommender System）是典型的机器学习应用场景。其核心就是通过算法得到用户偏好向量以及内容向量，两个向量的内积即为用户对内容的的评分预测（即用户对某内容的喜好程度）。推荐学习算法本质上就是学习这两个向量的过程。</p><p>通常有两种方法：</p><p>1. 已知内容向量，学习用户偏好向量的方法就是基于内容的推荐算法（content-based）；</p><p>2. 用户偏好向量和内容向量都未知，则适合使用联合过滤算法（collaborative filtering）同时学习两个向量。</p><p><strong>2</strong><br>个人觉得用余弦近似度来判断相似程度更合理些</p><p><strong>3</strong><br>相识图片识别技术也可以使用多维向量相似算法来分析</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42-概率统计_如何利用朴素贝叶斯算法过滤垃圾短信</title>
      <link href="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/"/>
      <url>/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://www.jianshu.com/p/5cf3a155b2f0" target="_blank" rel="noopener">参考-朴素贝叶斯分类算法</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们讲到，如何用位图、布隆过滤器，来过滤重复的数据。今天，我们再讲一个跟过滤相关的问题，如何过滤垃圾短信？</p><p>垃圾短信和骚扰电话，我想每个人都收到过吧？买房、贷款、投资理财、开发票，各种垃圾短信和骚扰电话，不胜其扰。<font color="red">如果你是一名手机应用开发工程师，让你实现一个简单的垃圾短信过滤功能以及骚扰电话拦截功能，该用什么样的数据结构和算法实现呢？</font></p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，解决这个问题并不会涉及很高深的算法。这篇文章将带你了解如何利用简单的数据结构和算法，解决这种看似非常复杂的问题。</p><h3 id="1-基于黑名单的过滤器"><a href="#1-基于黑名单的过滤器" class="headerlink" title="1. 基于黑名单的过滤器"></a>1. 基于黑名单的过滤器</h3><p>我们可以维护一个骚扰电话号码和垃圾短信发送号码的黑名单。这个黑名单的搜集，有很多途径，比如，我们可以从一些公开的网站上下载，也可以通过类似“360 骚扰电话拦截”的功能，通过用户自主标记骚扰电话来收集。对于被多个用户标记，并且标记个数超过一定阈值的号码，我们就可以定义为骚扰电话，并将它加入到我们的黑名单中。</p><p>如果黑名单中的电话号码不多的话，我们可以使用散列表、二叉树等动态数据结构来存储，对内存的消耗并不会很大。如果我们把每个号码看作一个字符串，并且假设平均长度是 16 个字节，那存储 50 万个电话号码，大约需要 10MB 的内存空间。即便是对于手机这样的内存有限的设备来说，这点内存的消耗也是可以接受的。</p><p>但是，如果黑名单中的电话号码很多呢？比如有 500 万个。这个时候，如果再用散列表存储，就需要大约 100MB 的存储空间。为了实现一个拦截功能，耗费用户如此多的手机内存，这显然有点儿不合理。</p><p>上一节我们讲了，布隆过滤器最大的特点就是比较省存储空间，所以，用它来解决这个问题再合适不过了。如果我们要存储 500 万个手机号码，我们把位图大小设置为 10 倍数据大小，也就是 5000 万，那也只需要使用 5000 万个二进制位（5000 万 bits），换算成字节，也就是不到 7MB 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。</p><p>实际上，我们还有一种时间换空间的方法，可以将内存的消耗优化到极致。</p><p>我们可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，判断这个号码是否应该被拦截，并将结果返回给手机端。</p><p>用这个解决思路完全不需要占用手机内存。不过，有利就有弊。我们知道，网络通信是比较慢的，所以，网络延迟就会导致处理速度降低。而且，这个方案还有个硬性要求，那就是只有在联网的情况下，才能正常工作。</p><p>基于黑名单的过滤器我就讲完了，不过，你可能还会说，布隆过滤器会有判错的概率呀！如果它把一个重要的电话或者短信，当成垃圾短信或者骚扰电话拦截了，对于用户来说，这是无法接受的。你说的没错，这是一个很大的问题。不过，我们现在先放一放，等三种过滤器都讲完之后，我再来解答。</p><h3 id="2-基于规则的过滤器"><a href="#2-基于规则的过滤器" class="headerlink" title="2. 基于规则的过滤器"></a>2. 基于规则的过滤器</h3><p>刚刚讲了一种基于黑名单的垃圾短信过滤方法，但是，如果某个垃圾短信发送者的号码并不在黑名单中，那这种方法就没办法拦截了。所以，基于黑名单的过滤方式，还不够完善，我们再继续看一种基于规则的过滤方式。</p><p>对于垃圾短信来说，我们还可以通过短信的内容，来判断某条短信是否是垃圾短信。我们预先设定一些规则，如果某条短信符合这些规则，我们就可以判定它是垃圾短信。实际上，规则可以有很多，比如下面这几个：</p><ul><li><p>短信中包含特殊单词（或词语），比如一些非法、淫秽、反动词语等；</p></li><li><p>短信发送号码是群发号码，非我们正常的手机号码，比如 +60389585；</p></li><li><p>短信中包含回拨的联系方式，比如手机号码、微信、QQ、网页链接等，因为群发短信的号码一般都是无法回拨的；</p></li><li><p>短信格式花哨、内容很长，比如包含各种表情、图片、网页链接等；</p></li><li><p>符合已知垃圾短信的模板。垃圾短信一般都是重复群发，对于已经判定为垃圾短信的短信，我们可以抽象成模板，将获取到的短信与模板匹配，一旦匹配，我们就可以判定为垃圾短信。</p></li></ul><p>当然，如果短信只是满足其中一条规则，如果就判定为垃圾短信，那会存在比较大的误判的情况。我们可以综合多条规则进行判断。比如，满足 2 条以上才会被判定为垃圾短信；或者每条规则对应一个不同的得分，满足哪条规则，我们就累加对应的分数，某条短信的总得分超过某个阈值，才会被判定为垃圾短信。</p><p>不过，我只是给出了一些制定规则的思路，具体落实到执行层面，其实还有很大的距离，还有很多细节需要处理。比如，第一条规则中，我们该如何定义特殊单词；第二条规则中，我们该如何定义什么样的号码是群发号码等等。限于篇幅，我就不一一详细展开来讲了。我这里只讲一下，如何定义特殊单词？</p><p>如果我们只是自己盘脑袋想，哪些单词属于特殊单词，那势必有比较大的主观性，也很容易漏掉某些单词。实际上，我们可以基于概率统计的方法，借助计算机强大的计算能力，找出哪些单词最常出现在垃圾短信中，将这些最常出现的单词，作为特殊单词，用来过滤短信。</p><p>不过这种方法的前提是，我们有大量的样本数据，也就是说，要有大量的短信（比如 1000 万条短信），并且我们还要求，每条短信都做好了标记，它是垃圾短信还是非垃圾短信。</p><p>我们对这 1000 万条短信，进行分词处理（借助中文或者英文分词算法），去掉“的、和、是”等没有意义的停用词（Stop words），得到 n 个不同的单词。针对每个单词，我们统计有多少个垃圾短信出现了这个单词，有多少个非垃圾短信会出现这个单词，进而求出每个单词出现在垃圾短信中的概率，以及出现在非垃圾短信中的概率。如果某个单词出现在垃圾短信中的概率，远大于出现在非垃圾短信中的概率，那我们就把这个单词作为特殊单词，用来过滤垃圾短信。</p><p>文字描述不好理解，举个栗子来解释一下。</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/581c32e0-d4da-49a2-a17e-d6658fd11ff2.jpg" alt></p><h3 id="3-基于概率统计的过滤器"><a href="#3-基于概率统计的过滤器" class="headerlink" title="3. 基于概率统计的过滤器"></a>3. 基于概率统计的过滤器</h3><p>基于规则的过滤器，看起来很直观，也很好理解，但是它也有一定的局限性。一方面，这些规则受人的思维方式局限，规则未免太过简单；另一方面，垃圾短信发送者可能会针对规则，精心设计短信，绕过这些规则的拦截。对此，我们再来看一种更加高级的过滤方式，基于概率统计的过滤方式。</p><p>这种基于概率统计的过滤方式，基础理论是基于朴素贝叶斯算法。为了让你更好地理解下面的内容，我们先通过一个非常简单的例子来看下，什么是朴素贝叶斯算法？</p><p>假设事件 A 是“小明不去上学”，事件 B 是“下雨了”。我们现在统计了一下过去 10 天的下雨情况和小明上学的情况，作为样本数据。</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/da6e68a0-5746-4fbe-9a1d-6ee8f66e254b.jpg" alt></p><p>我们来分析一下，这组样本有什么规律。在这 10 天中，有 4 天下雨，所以下雨的概率 P(B)=4/10。10 天中有 3 天，小明没有去上学，所以小明不去上学的概率 P(A)=3/10。在 4 个下雨天中，小明有 2 天没去上学，所以下雨天不去上学的概率 P(A|B)=2/4。在小明没有去上学的 3 天中，有 2 天下雨了，所以小明因为下雨而不上学的概率是 P(B|A)=2/3。实际上，这 4 个概率值之间，有一定的关系，这个关系就是朴素贝叶斯算法，我们用公式表示出来，就是下面这个样子。</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/d1543e13-bcfc-4f9d-a6fe-d838680237d2.jpg" alt></p><p>朴素贝叶斯算法是不是非常简单？我们用一个公式就可以将它概括。弄懂了朴素贝叶斯算法，我们再回到垃圾短信过滤这个问题上，看看如何利用朴素贝叶斯算法，来做垃圾短信的过滤。</p><p>基于概率统计的过滤器，是基于短信内容来判定是否是垃圾短信。而计算机没办法像人一样理解短信的含义。所以，我们需要把短信抽象成一组计算机可以理解并且方便计算的<strong>特征项</strong>，用这一组特征项代替短信本身，来做垃圾短信过滤。</p><p>我们可以通过分词算法，把一个短信分割成 n 个单词。这 n 个单词就是一组特征项，全权代表这个短信。因此，判定一个短信是否是垃圾短信这样一个问题，就变成了，判定同时包含这几个单词的短信是否是垃圾短信。</p><p>不过，这里我们并不像基于规则的过滤器那样，非黑即白，一个短信要么被判定为垃圾短信、要么被判定为非垃圾短息。我们使用概率，来表征一个短信是垃圾短信的可信程度。如果我们用公式将这个概率表示出来，就是下面这个样子：</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/24d6c7ff-c94e-4e3d-b757-785669f9e2e6.jpg" alt></p><p>尽管我们有大量的短信样本，但是我们没法通过样本数据统计得到这个概率。为什么不可以呢？你可能会说，我只需要统计同时包含 W1，W2，W3，…，Wn 这 n 个单词的短信有多少个（我们假设有 x 个），然后看这里面属于垃圾短信的有几个（我们假设有 y 个），那包含 W1，W2，W3，…，Wn 这 n 个单词的短信是垃圾短信的概率就是 y/x。</p><p>理想很丰满，但现实往往很骨感。你忽视了非常重要的一点，那就是样本的数量再大，毕竟也是有限的，样本中不会有太多同时包含 W1，W2，W3，…，Wn 的短信的，甚至很多时候，样本中根本不存在这样的短信。没有样本，也就无法计算概率。所以这样的推理方式虽然正确，但是实践中并不好用。</p><p>这个时候，朴素贝叶斯公式就可以派上用场了。我们通过朴素贝叶斯公式，将这个概率的求解，分解为其他三个概率的求解。你可以看我画的图。那转化之后的三个概率是否可以通过样本统计得到呢？</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/77cf9f20-c6e8-43ac-83c5-6649752954c4.jpg" alt></p><p>P（W1，W2，W3，…，Wn 同时出现在一条短信中 | 短信是垃圾短信）这个概率照样无法通过样本来统计得到。但是我们可以基于下面这条著名的概率规则来计算。</p><p>独立事件发生的概率计算公式：P(A*B) = P(A)*P(B)</p><p>如果事件 A 和事件 B 是独立事件，两者的发生没有相关性，事件 A 发生的概率 P(A) 等于 p1，事件 B 发生的概率 P(B) 等于 p2，那两个同时发生的概率 P(A*B) 就等于 P(A)*P(B)。</p><p>基于这条独立事件发生概率的计算公式，我们可以把 P（W1，W2，W3，…，Wn 同时出现在一条短信中 | 短信是垃圾短信）分解为下面这个公式：</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/187aad31-dbc2-4444-93fb-5b5428ce4041.jpg" alt></p><p>其中，P（W<sub>i</sub> 出现在短信中 | 短信是垃圾短信）表示垃圾短信中包含 W<sub>i</sub> 这个单词的概率有多大。这个概率值通过统计样本很容易就能获得。我们假设垃圾短信有 y 个，其中包含 W<sub>i</sub> 的有 x 个，那这个概率值就等于 x/y。</p><p>P（W1，W2，W3，…，Wn 同时出现在一条短信中 | 短信是垃圾短信）这个概率值，我们就计算出来了，我们再来看下剩下两个。</p><p>P（短信是垃圾短信）表示短信是垃圾短信的概率，这个很容易得到。我们把样本中垃圾短信的个数除以总样本短信个数，就是短信是垃圾短信的概率。</p><p>不过，P（W1，W2，W3，…，Wn 同时出现在一条短信中）这个概率还是不好通过样本统计得到，原因我们前面说过了，样本空间有限。不过，我们没必要非得计算这一部分的概率值。为什么这么说呢？</p><p>实际上，我们可以分别计算同时包含 W1，W2，W3，…，Wn 这 n 个单词的短信，是垃圾短信和非垃圾短信的概率。假设它们分别是 p1 和 p2。我们并不需要单纯地基于 p1 值的大小来判断是否是垃圾短信，而是通过对比 p1 和 p2 值的大小，来判断一条短信是否是垃圾短信。更细化一点讲，那就是，如果 p1 是 p2 的很多倍（比如 10 倍），我们才确信这条短信是垃圾短信。</p><p><img src="/2019/08/05/42-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1/0f0369a955ee8d15bd7d7958829d5b2a.jpg" alt></p><p>基于这两个概率的倍数来判断是否是垃圾短信的方法，我们就可以不用计算 P（W1，W2，W3，…，Wn 同时出现在一条短信中）这一部分的值了，因为计算 p1 与 p2 的时候，都会包含这个概率值的计算，所以在求解 p1 和 p2 倍数（p1/p2）的时候，我们也就不需要这个值。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>天，我们讲了基于黑名单、规则、概率统计三种垃圾短信的过滤方法，实际上，今天讲的这三种方法，还可以应用到很多类似的过滤、拦截的领域，比如垃圾邮件的过滤等等。</p><p>在讲黑名单过滤的时候，我讲到布隆过滤器可能会存在误判情况，可能会导致用户投诉。实际上，我们可以结合三种不同的过滤方式的结果，对同一个短信处理，如果三者都表明这个短信是垃圾短信，我们才把它当作垃圾短信拦截过滤，这样就会更精准。</p><p>当然，在实际的工程中，我们还需要结合具体的场景，以及大量的实验，不断去调整策略，权衡垃圾短信判定的<strong>准确率</strong>（是否会把不是垃圾的短信错判为垃圾短信）和<strong>召回率</strong>（是否能把所有的垃圾短信都找到），来实现我们的需求。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>1</strong><br>我觉得这种分类过滤，最好的可能是机器学习，通过大量的垃圾短信样本来训练特征，最后可以达到过滤短信和邮件的目的，而且这种方法应该效果更好，至于电话拦截，实际上就是电话号码黑名单的问题，我觉得用布隆过滤器可以满足通用场景，一般实际场景中，对于这种电话是提示谨慎接听，但是我们可以本地和云端结合处理，解决部分的误报问题，当判断是黑名单的时候再去云端查，确认是否是真的黑名单。这样用布隆过滤器+云端也是一种方式。</p><p><strong>2</strong><br>对于短信文本，机器学习尤其是 NLP 方向的很多算法可用于 anti-spam。文本分类任务，特征工程做得稍用心的话，判别式模型（典型如 logistic regression）的效果通常好于生成式模型（典型如 naive-bayes）。</p><p>对于电话号码数字，感觉用正则或定时拉取黑名单比 ml 模型简单可靠。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>41-位图_如何实现网页爬虫中的URL去重功能</title>
      <link href="/2019/08/02/41-%E4%BD%8D%E5%9B%BE-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/08/02/41-%E4%BD%8D%E5%9B%BE-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg" target="_blank" rel="noopener">参考-Bitmap算法</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网页爬虫是搜索引擎中的非常重要的系统，负责爬取几十亿、上百亿的网页。爬虫的工作原理是，通过解析已经爬取页面中的网页链接，然后再爬取这些链接对应的网页。而<font color="red">同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？</font></p><p>最容易想到的方法就是，我们记录已经爬取的网页链接（也就是 URL），在爬取一个新的网页之前，我们拿它的链接，在已经爬取的网页链接列表中搜索。如果存在，那就说明这个网页已经被爬取过了；如果不存在，那就说明这个网页还没有被爬取过，可以继续去爬取。等爬取到这个网页之后，我们将这个网页的链接添加到已经爬取的网页链接列表了。</p><p>思路非常简单，我想你应该很容易就能想到。不过，我们该如何记录已经爬取的网页链接呢？需要用什么样的数据结构呢？</p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>关于这个问题，我们可以先回想下，是否可以用我们之前学过的数据结构来解决呢？</p><p>这个问题要处理的对象是网页链接，也就是 URL，需要支持的操作有两个，添加一个 URL 和查询一个 URL。除了这两个功能性的要求之外，在非功能性方面，我们还要求这两个操作的执行效率要尽可能高。除此之外，因为我们处理的是上亿的网页链接，内存消耗会非常大，所以在存储效率上，我们要尽可能地高效。</p><p>我们回想一下，满足这些条件的数据结构有哪些呢？显然，散列表、红黑树、跳表这些动态数据结构，都能支持快速地插入、查找数据，但是在内存消耗方面，是否可以接受呢？</p><p>我们拿散列表来举例。假设我们要爬取 10 亿个网页（像 Google、百度这样的通用搜索引擎，爬取的网页可能会更多），为了判重，我们把这 10 亿网页链接存储在散列表中。你来估算下，大约需要多少内存？</p><p>假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间。因为散列表必须维持较小的装载因子，才能保证不会出现过多的散列冲突，导致操作的性能下降。而且，用链表法解决冲突的散列表，还会存储链表指针。所以，如果将这 10 亿个 URL 构建成散列表，那需要的内存空间会远大于 60GB，有可能会超过 100GB。</p><p>当然，对于一个大型的搜索引擎来说，即便是 100GB 的内存要求，其实也不算太高，我们可以采用分治的思想，用多台机器（比如 20 台内存是 8GB 的机器）来存储这 10 亿网页链接。这种分治的处理思路，我们讲过很多次了，这里就不详细说了。</p><p>对于爬虫的 URL 去重这个问题，刚刚讲到的分治加散列表的思路，已经是可以实实在在工作的了。不过，<strong>作为一个有追求的工程师，我们应该考虑，在添加、查询数据的效率以及内存消耗方面，是否还有进一步的优化空间呢？</strong></p><p>可能会说，散列表中添加、查找数据的时间复杂度已经是 O(1)，还能有进一步优化的空间吗？实际上，我们前面也讲过，时间复杂度并不能完全代表代码的执行时间。大 O 时间复杂度表示法，会忽略掉常数、系数和低阶，并且统计的对象是语句的频度。不同的语句，执行时间也是不同的。时间复杂度只是表示执行时间随数据规模的变化趋势，并不能度量在特定的数据规模下，代码执行时间的多少。</p><p>如果时间复杂度中原来的系数是 10，我们现在能够通过优化，将系数降为 1，那在时间复杂度没有变化的情况下，执行效率就提高了 10 倍。对于实际的软件开发来说，10 倍效率的提升，显然是一个非常值得的优化。</p><p>如果我们用基于链表的方法解决冲突问题，散列表中存储的是 URL，那当查询的时候，通过哈希函数定位到某个链表之后，我们还需要依次比对每个链表中的 URL。这个操作是比较耗时的，主要有两点原因。</p><p>一方面，链表中的结点在内存中不是连续存储的，所以不能一下子加载到 CPU 缓存中，没法很好地利用到 CPU 高速缓存，所以数据访问性能方面会打折扣。</p><p>另一方面，链表中的每个数据都是 URL，而 URL 不是简单的数字，是平均长度为 64 字节的字符串。也就是说，我们要让待判重的 URL，跟链表中的每个 URL，做字符串匹配。显然，这样一个字符串匹配操作，比起单纯的数字比对，要慢很多。所以，基于这两点，执行效率方面肯定是有优化空间的。</p><p>对于内存消耗方面的优化，除了刚刚这种基于散列表的解决方案，貌似没有更好的法子了。实际上，如果要想内存方面有明显的节省，那就得换一种解决方案，也就是我们今天要着重讲的这种存储结构，<strong>布隆过滤器</strong>（Bloom Filter）。</p><p>在讲布隆过滤器前，我要先讲一下另一种存储结构，<strong>位图</strong>（BitMap）。因为，布隆过滤器本身就是基于位图的，是对位图的一种改进。</p><p>我们先来看一个跟开篇问题非常类似、但比那个稍微简单的问题。<strong>我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？</strong></p><p>当然，这个问题还是可以用散列表来解决。不过，我们可以使用一种比较“特殊”的散列表，那就是位图。我们申请一个大小为 1 亿、数据类型为布尔类型（true 或者 false）的数组。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p><p>当我们查询某个整数 K 是否在这 1 千万个整数中的时候，我们只需要将对应的数组值 array[K]取出来，看是否等于 true。如果等于 true，那说明 1 千万整数中包含这个整数 K；相反，就表示不包含这个整数 K。</p><p>不过，很多语言中提供的布尔类型，大小是 1 个字节的，并不能节省太多内存空间。实际上，表示 true 和 false 两个值，我们只需要用一个二进制位（bit）就可以了。那如何通过编程语言，来表示一个二进制位呢？</p><p>这里就要用到位运算了。我们可以借助编程语言中提供的数据类型，比如 int、long、char 等类型，通过位运算，用其中的某个位表示某个数字。文字描述起来有点儿不好理解，我把位图的代码实现写了出来，你可以对照着代码看下，应该就能看懂了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BitMap &#123; &#x2F;&#x2F; Java中char类型占16bit，也即是2个字节</span><br><span class="line">  private char[] bytes;</span><br><span class="line">  private int nbits;</span><br><span class="line">  </span><br><span class="line">  public BitMap(int nbits) &#123;</span><br><span class="line">    this.nbits &#x3D; nbits;</span><br><span class="line">    this.bytes &#x3D; new char[nbits&#x2F;16+1];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void set(int k) &#123;</span><br><span class="line">    if (k &gt; nbits) return;</span><br><span class="line">    int byteIndex &#x3D; k &#x2F; 16;</span><br><span class="line">    int bitIndex &#x3D; k % 16;</span><br><span class="line">    bytes[byteIndex] |&#x3D; (1 &lt;&lt; bitIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean get(int k) &#123;</span><br><span class="line">    if (k &gt; nbits) return false;</span><br><span class="line">    int byteIndex &#x3D; k &#x2F; 16;</span><br><span class="line">    int bitIndex &#x3D; k % 16;</span><br><span class="line">    return (bytes[byteIndex] &amp; (1 &lt;&lt; bitIndex)) !&#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从刚刚位图结构的讲解中，你应该可以发现，位图通过数组下标来定位数据，所以，访问效率非常高。而且，每个数字用一个二进制位来表示，在数字范围不大的情况下，所需要的内存空间非常节省。</p><p>比如刚刚那个例子，如果用散列表存储这 1 千万的数据，数据是 32 位的整型数，也就是需要 4 个字节的存储空间，那总共至少需要 40MB 的存储空间。如果我们通过位图的话，数字范围在 1 到 1 亿之间，只需要 1 亿个二进制位，也就是 12MB 左右的存储空间就够了。</p><p>关于位图，我们就讲完了，是不是挺简单的？不过，这里我们有个假设，就是数字所在的范围不是很大。如果数字的范围很大，比如刚刚那个问题，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，也就是 120MB 的大小，消耗的内存空间，不降反增。</p><p>这个时候，布隆过滤器就要出场了。布隆过滤器就是为了解决刚刚这个问题，对位图这种数据结构的一种改进。</p><p>还是刚刚那个例子，数据个数是 1 千万，数据的范围是 1 到 10 亿。布隆过滤器的做法是，我们仍然使用一个 1 亿个二进制大小的位图，然后通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内。比如我们把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p><p>不过，你肯定会说，哈希函数会存在冲突的问题啊，一亿零一和 1 两个数字，经过你刚刚那个取模求余的哈希函数处理之后，最后的结果都是 1。这样我就无法区分，位图存储的是 1 还是一亿零一了。</p><p>为了降低这种冲突概率，当然我们可以设计一个复杂点、随机点的哈希函数。除此之外，还有其他方法吗？我们来看布隆过滤器的处理方法。既然一个哈希函数可能会存在冲突，那用多个哈希函数一块儿定位一个数据，是否能降低冲突的概率呢？我来具体解释一下，布隆过滤器是怎么做的。</p><p>我们使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 X1，X2，X3，…，XK。我们把这 K 个数字作为位图中的下标，将对应的 BitMap[X1]，BitMap[X2]，BitMap[X3]，…，BitMap[XK]都设置成 true，也就是说，我们用 K 个二进制位，来表示一个数字的存在。</p><p>当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y1，Y2，Y3，…，YK。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，如果有其中任意一个不为 true，那就说明这个数字不存在。</p><p><img src="/2019/08/02/41-%E4%BD%8D%E5%9B%BE-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD/f61cf83a-5949-430b-a146-f24bc416afc9.jpg" alt></p><p>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过 K 个哈希函数处理之后，K 个哈希值都相同的概率就非常低了。尽管采用 K 个哈希函数之后，两个数字哈希冲突的概率降低了，但是，这种处理方式又带来了新的问题，那就是容易误判。我们看下面这个例子。</p><p><img src="/2019/08/02/41-%E4%BD%8D%E5%9B%BE-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84URL%E5%8E%BB%E9%87%8D%E5%8A%9F%E8%83%BD/d6efe62f-a8ea-4b23-8691-aa06b0c0f92f.jpg" alt></p><p>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p><p>尽管布隆过滤器会存在误判，但是，这并不影响它发挥大作用。很多场景对误判有一定的容忍度。比如我们今天要解决的爬虫判重这个问题，即便一个没有被爬取过的网页，被误判为已经被爬取，对于搜索引擎来说，也并不是什么大事情，是可以容忍的，毕竟网页太多了，搜索引擎也不可能 100% 都爬取到。</p><p>弄懂了布隆过滤器，我们今天的爬虫网页去重的问题，就很简单了。</p><p>我们用布隆过滤器来记录已经爬取过的网页链接，假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。</p><p>那我们再来看下，利用布隆过滤器，在执行效率方面，是否比散列表更加高效呢？</p><p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的。而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别跟待判重的网页链接，进行字符串匹配。这个操作涉及很多内存数据的读取，所以是内存密集型的。我们知道 CPU 计算可能是要比内存访问更快速的，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，关于搜索引擎爬虫网页去重问题的解决，我们从散列表讲到位图，再讲到布隆过滤器。布隆过滤器非常适合这种不需要 100% 准确的、允许存在小概率误判的大规模判重场景。除了爬虫网页去重这个例子，还有比如统计一个大型网站的每天的 UV 数，也就是每天有多少用户访问了网站，我们就可以使用布隆过滤器，对重复访问的用户进行去重。</p><p>我们前面讲到，布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少了，误判率就越来越高了。所以，对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能。</p><p>当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，我们就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，如果我们要判断某个数据是否在布隆过滤器中已经存在，我们就需要查看多个位图，相应的执行效率就降低了一些。</p><p>位图、布隆过滤器应用如此广泛，很多编程语言都已经实现了。比如 Java 中的 BitSet 类就是一个位图，Redis 也提供了 BitMap 位图类，Google 的 Guava 工具包提供了 BloomFilter 布隆过滤器的实现。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 假设我们有 1 亿个整数，数据范围是从 1 到 10 亿，如何快速并且省内存地给这 1 亿个数据从小到大排序？</p><p><strong>回答：</strong></p><p>传统的做法：1亿个整数，存储需要400M空间，排序时间复杂度最优 N×log(N)</p><p>使用位图算法：数字范围是1到10亿，用位图存储125M就够了，然后将1亿个数字依次添加到位图中，然后再将位图按下标从小到大输出值为1的下标，排序就完成了，时间复杂度为 N</p><p>ps:<br>对于重复的 可以再维护一个小的散列表 记录出现次数超过1次的数据以及对应的个数</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>bloom filter: False is always false. True is maybe true.</p><p>位图代码的实现一开始没看懂，请教了下身边一位大神同事才搞懂，原来char类型存储数字的时候，只占1个字节，也就是8位。所以计算的时候都是除8或者模8。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-最短路径_地图软件是如何计算出最优出行路径的</title>
      <link href="/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/"/>
      <url>/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基础篇的时候，我们学习了图的两种搜索算法，深度优先搜索和广度优先搜索。这两种算法主要是针对无权图的搜索算法。针对有权图，也就是图中的每条边都有一个权重，我们该如何计算两点之间的最短路径（经过的边的权重和最小）呢？今天，我们就从地图软件的路线规划问题讲起，带你看看常用的<strong>最短路径算法</strong>（Shortest Path Algorithm）。</p><p>像 Google 地图、百度地图、高德地图这样的地图软件，我想你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。这里的最优，有很多种定义，比如最短路线、最少用时路线、最少红绿灯路线等等。<font color="red">作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？</font></p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>我们刚提到的最优问题包含三个：最短路线、最少用时和最少红绿灯。我们先解决最简单的，最短路线。</p><p>解决软件开发中的实际问题，最重要的一点就是<strong>建模</strong>，也就是将复杂的场景抽象成具体的数据结构。针对这个问题，我们该如何抽象成数据结构呢？</p><p>我们之前也提到过，图这种数据结构的表达能力很强，显然，把地图抽象成图最合适不过了。我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。</p><p>具体的代码实现，我放在下面了。于是，我们要求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123; &#x2F;&#x2F; 有向有权图的邻接表表示</span><br><span class="line">  private LinkedList&lt;Edge&gt; adj[]; &#x2F;&#x2F; 邻接表</span><br><span class="line">  private int v; &#x2F;&#x2F; 顶点个数</span><br><span class="line"></span><br><span class="line">  public Graph(int v) &#123;</span><br><span class="line">    this.v &#x3D; v;</span><br><span class="line">    this.adj &#x3D; new LinkedList[v];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">      this.adj[i] &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addEdge(int s, int t, int w) &#123; &#x2F;&#x2F; 添加一条边</span><br><span class="line">    this.adj[s].add(new Edge(s, t, w));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private class Edge &#123;</span><br><span class="line">    public int sid; &#x2F;&#x2F; 边的起始顶点编号</span><br><span class="line">    public int tid; &#x2F;&#x2F; 边的终止顶点编号</span><br><span class="line">    public int w; &#x2F;&#x2F; 权重</span><br><span class="line">    public Edge(int sid, int tid, int w) &#123;</span><br><span class="line">      this.sid &#x3D; sid;</span><br><span class="line">      this.tid &#x3D; tid;</span><br><span class="line">      this.w &#x3D; w;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 下面这个类是为了dijkstra实现用的</span><br><span class="line">  private class Vertex &#123;</span><br><span class="line">    public int id; &#x2F;&#x2F; 顶点编号ID</span><br><span class="line">    public int dist; &#x2F;&#x2F; 从起始顶点到这个顶点的距离</span><br><span class="line">    public Vertex(int id, int dist) &#123;</span><br><span class="line">      this.id &#x3D; id;</span><br><span class="line">      this.dist &#x3D; dist;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要解决这个问题，有一个非常经典的算法，最短路径算法，更加准确地说，是<strong>单源最短路径算法</strong>（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于 Dijkstra 算法了。所以，我们现在来看，Dijkstra 算法是怎么工作的。</p><p>这个算法的原理稍微有点儿复杂，单纯的文字描述，不是很好懂。所以，我还是结合代码来讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 因为Java提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span><br><span class="line">private class PriorityQueue &#123; &#x2F;&#x2F; 根据vertex.dist构建小顶堆</span><br><span class="line">  private Vertex[] nodes;</span><br><span class="line">  private int count;</span><br><span class="line">  public PriorityQueue(int v) &#123;</span><br><span class="line">    this.nodes &#x3D; new Vertex[v+1];</span><br><span class="line">    this.count &#x3D; v;</span><br><span class="line">  &#125;</span><br><span class="line">  public Vertex poll() &#123; &#x2F;&#x2F; TODO: 留给读者实现... &#125;</span><br><span class="line">  public void add(Vertex vertex) &#123; &#x2F;&#x2F; TODO: 留给读者实现...&#125;</span><br><span class="line">  &#x2F;&#x2F; 更新结点的值，并且从下往上堆化，重新符合堆的定义。时间复杂度O(logn)。</span><br><span class="line">  public void update(Vertex vertex) &#123; &#x2F;&#x2F; TODO: 留给读者实现...&#125; </span><br><span class="line">  public boolean isEmpty() &#123; &#x2F;&#x2F; TODO: 留给读者实现...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void dijkstra(int s, int t) &#123; &#x2F;&#x2F; 从顶点s到顶点t的最短路径</span><br><span class="line">  int[] predecessor &#x3D; new int[this.v]; &#x2F;&#x2F; 用来还原最短路径</span><br><span class="line">  Vertex[] vertexes &#x3D; new Vertex[this.v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; this.v; ++i) &#123;</span><br><span class="line">    vertexes[i] &#x3D; new Vertex(i, Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  PriorityQueue queue &#x3D; new PriorityQueue(this.v);&#x2F;&#x2F; 小顶堆</span><br><span class="line">  boolean[] inqueue &#x3D; new boolean[this.v]; &#x2F;&#x2F; 标记是否进入过队列</span><br><span class="line">  vertexes[s].dist &#x3D; 0;</span><br><span class="line">  queue.add(vertexes[s]);</span><br><span class="line">  inqueue[s] &#x3D; true;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    Vertex minVertex&#x3D; queue.poll(); &#x2F;&#x2F; 取堆顶元素并删除</span><br><span class="line">    if (minVertex.id &#x3D;&#x3D; t) break; &#x2F;&#x2F; 最短路径产生了</span><br><span class="line">    for (int i &#x3D; 0; i &lt; adj[minVertex.id].size(); ++i) &#123;</span><br><span class="line">      Edge e &#x3D; adj[minVertex.id].get(i); &#x2F;&#x2F; 取出一条minVetex相连的边</span><br><span class="line">      Vertex nextVertex &#x3D; vertexes[e.tid]; &#x2F;&#x2F; minVertex--&gt;nextVertex</span><br><span class="line">      if (minVertex.dist + e.w &lt; nextVertex.dist) &#123; &#x2F;&#x2F; 更新next的dist</span><br><span class="line">        nextVertex.dist &#x3D; minVertex.dist + e.w;</span><br><span class="line">        predecessor[nextVertex.id] &#x3D; minVertex.id;</span><br><span class="line">        if (inqueue[nextVertex.id] &#x3D;&#x3D; true) &#123;</span><br><span class="line">          queue.update(nextVertex); &#x2F;&#x2F; 更新队列中的dist值</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          queue.add(nextVertex);</span><br><span class="line">          inqueue[nextVertex.id] &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 输出最短路径</span><br><span class="line">  System.out.print(s);</span><br><span class="line">  print(s, t, predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void print(int s, int t, int[] predecessor) &#123;</span><br><span class="line">  if (s &#x3D;&#x3D; t) return;</span><br><span class="line">  print(s, predecessor[t], predecessor);</span><br><span class="line">  System.out.print(&quot;-&gt;&quot; + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 vertexes 数组，记录从起始顶点到每个顶点的距离（dist）。起初，我们把所有顶点的 dist 都初始化为无穷大（也就是代码中的 Integer.MAX_VALUE）。我们把起始顶点的 dist 值初始化为 0，然后将其放到优先级队列中。</p><p>我们从优先级队列中取出 dist 最小的顶点 minVertex，然后考察这个顶点可达的所有顶点（代码中的 nextVertex）。如果 minVertex 的 dist 值加上 minVertex 与 nextVertex 之间边的权重 w 小于 nextVertex 当前的 dist 值，也就是说，存在另一条更短的路径，它经过 minVertex 到达 nextVertex。那我们就把 nextVertex 的 dist 更新为 minVertex 的 dist 值加上 w。然后，我们把 nextVertex 加入到优先级队列中。重复这个过程，直到找到终止顶点 t 或者队列为空。</p><p>以上就是 <strong>Dijkstra 算法</strong>的核心逻辑。除此之外，代码中还有两个额外的变量，predecessor 数组和 inqueue 数组。</p><p>predecessor 数组的作用是为了还原最短路径，它记录每个顶点的前驱顶点。最后，我们通过递归的方式，将这个路径打印出来。打印路径的 print 递归代码我就不详细讲了，这个跟我们在图的搜索中讲的打印路径方法一样。</p><p>inqueue 数组是为了避免将一个顶点多次添加到优先级队列中。我们更新了某个顶点的 dist 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。</p><p>看完了代码和文字解释，你可能还是有点懵，那我就举个例子，再给你解释一下。</p><p><img src="/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/e20907173c458fac741e556c947bb9a9.jpg" alt></p><p>理解了 Dijkstra 的原理和代码实现，我们来看下，<strong>Dijkstra 算法的时间复杂度是多少？</strong></p><p>在刚刚的代码实现中，最复杂就是 while 循环嵌套 for 循环那部分代码了。while 循环最多会执行 V 次（V 表示顶点的个数），而内部的 for 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，我们分别记作 E0，E1，E2，……，E(V-1)。如果我们把这 V 个顶点的边都加起来，最大也不会超过图中所有边的个数 E（E 表示边的个数）。</p><p>for 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。我们知道，优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 O(logV)（堆中的元素个数不会超过顶点的个数 V）。</p><p>所以，综合这两部分，再利用乘法原则，整个代码的时间复杂度就是 O(E*logV)。</p><p>弄懂了 Dijkstra 算法，我们再来回答之前的问题，如何计算最优出行路线？</p><p>从理论上讲，用 Dijkstra 算法可以计算出两点之间的最短路径。但是，你有没有想过，对于一个超级大地图来说，岔路口、道路都非常多，对应到图这种数据结构上来说，就有非常多的顶点和边。如果为了计算两点之间的最短路径，在一个超级大图上动用 Dijkstra 算法，遍历所有的顶点和边，显然会非常耗时。那我们有没有什么优化的方法呢？</p><p>做工程不像做理论，一定要给出个最优解。理论上算法再好，如果执行效率太低，也无法应用到实际的工程中。<strong>对于软件开发工程师来说，我们经常要根据问题的实际背景，对解决方案权衡取舍。类似出行路线这种工程上的问题，我们没有必要非得求出个绝对最优解。很多时候，为了兼顾执行效率，我们只需要计算出一个可行的次优解就可以了。</strong></p><p>有了这个原则，你能想出刚刚那个问题的优化方案吗？</p><p>虽然地图很大，但是两点之间的最短路径或者说较好的出行路径，并不会很“发散”，只会出现在两点之间和两点附近的区块内。所以我们可以在整个大地图上，划出一个小的区块，这个小区块恰好可以覆盖住两个点，但又不会很大。我们只需要在这个小区块内部运行 Dijkstra 算法，这样就可以避免遍历整个大图，也就大大提高了执行效率。</p><p>不过你可能会说了，如果两点距离比较远，从北京海淀区某个地点，到上海黄浦区某个地点，那上面的这种处理方法，显然就不工作了，毕竟覆盖北京和上海的区块并不小。</p><p>给你点提示，你可以现在打开地图 App，缩小放大一下地图，看下地图上的路线有什么变化，然后再思考，这个问题该怎么解决。</p><p>对于这样两点之间距离较远的路线规划，我们可以把北京海淀区或者北京看作一个顶点，把上海黄浦区或者上海看作一个顶点，先规划大的出行路线。比如，如何从北京到上海，必须要经过某几个顶点，或者某几条干道，然后再细化每个阶段的小路线。</p><p>这样，最短路径问题就解决了。我们再来看另外两个问题，最少时间和最少红绿灯。</p><p>前面讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，我们只需要把边的权重，从路的长度变成经过这段路所需要的时间。不过，这个时间会根据拥堵情况时刻变化。如何计算车通过一段路的时间呢？这是一个蛮有意思的问题，你可以自己思考下。</p><p>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，实际上，我们只需要把每条边的权值改为 1 即可，算法还是不变，可以继续使用前面讲的 Dijkstra 算法。不过，边的权值为 1，也就相当于无权图了，我们还可以使用之前讲过的广度优先搜索算法。因为我们前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。</p><p>不过，这里给出的所有方案都非常粗糙，只是为了给你展示，如何结合实际的场景，灵活地应用算法，让算法为我们所用，真实的地图软件的路径规划，要比这个复杂很多。而且，比起 Dijkstra 算法，地图软件用的更多的是类似 A* 的启发式搜索算法，不过也是在 Dijkstra 算法上的优化罢了，我们后面会讲到，这里暂且不展开。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>今天，我们学习了一种非常重要的图算法，Dijkstra 最短路径算法。实际上，最短路径算法还有很多，比如 Bellford 算法、Floyd 算法等等。如果感兴趣，你可以自己去研究。</p><p>关于 Dijkstra 算法，我只讲了原理和代码实现。对于正确性，没有去证明。之所以这么做，是因为证明过程会涉及比较复杂的数学推导。这个并不是我们的重点，你只要掌握这个算法的思路就可以了。</p><p>这些算法实现思路非常经典，掌握了这些思路，我们可以拿来指导、解决其他问题。比如 Dijkstra 这个算法的核心思想，就可以拿来解决下面这个看似完全不相关的问题。这个问题是之前工作中遇到的真实的问题，为了在较短的篇幅里把问题介绍清楚，我对背景做了一些简化。</p><p>我们有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度。</p><p><img src="/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/4faf6c71-c2c0-4fcf-ac98-d7bb3663928b.jpg" alt></p><p>针对每个单词，我们从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，我们希望计算出得分最高的前 k 个翻译结果，你会怎么编程来实现呢？</p><p><img src="/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/1fa89009-40c7-4369-aebb-dac6e9909bce.jpg" alt></p><p>当然，最简单的办法还是借助回溯算法，穷举所有的排列组合情况，然后选出得分最高的前 k 个翻译结果。但是，这样做的时间复杂度会比较高，是 O(m^n)，其中，m 表示平均每个单词的可选翻译个数，n 表示一个句子中包含多少个单词。这个解决方案，你可以当作回溯算法的练习题,自己编程实现一下。</p><p>实际上，这个问题可以借助 Dijkstra 算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以 a<sub>0</sub>b<sub>0</sub>c<sub>0</sub> 肯定是得分最高组合结果。我们把 a0​b0​c0​ 及得分作为一个对象，放入到优先级队列中。</p><p>我们每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 a<sub>0</sub>b<sub>0</sub>c<sub>0</sub> 扩展后，会得到三个组合，a<sub>1</sub>b<sub>0</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>1</sub>c<sub>0</sub>、a<sub>0</sub>b<sub>0</sub>c1​。我们把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到 k 个翻译组合或者队列为空。</p><p><img src="/2019/07/28/40-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E5%9C%B0%E5%9B%BE%E8%BD%AF%E4%BB%B6%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9C%80%E4%BC%98%E5%87%BA%E8%A1%8C%E8%B7%AF%E5%BE%84%E7%9A%84/3e0da7d4-901f-496c-b165-36c094bbf097.jpg" alt></p><p>我们来看，这种实现思路的时间复杂度是多少？</p><p>假设句子包含 n 个单词，每个单词平均有 m 个可选的翻译，我们求得分最高的前 k 个组合结果。每次一个组合出队列，就对应着一个组合结果，我们希望得到 k 个，那就对应着 k 次出队操作。每次有一个组合出队列，就有 n 个组合入队列。优先级队列中出队和入队操作的时间复杂度都是 O(logX)，X 表示队列中的组合个数。所以，总的时间复杂度就是 O(k<em>n</em>logX)。那 X 到底是多少呢？</p><p>k 次出入队列，队列中的总数据不会超过 k*n，也就是说，出队、入队操作的时间复杂度是 O(log(k*n))。所以，总的时间复杂度就是 O(k*n*log(k*n))，比之前的指数级时间复杂度降低了很多。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 在计算最短时间的出行路线中，如何获得通过某条路的时间呢？这个题目很有意思，我之前面试的时候也被问到过，你可以思考看看。</p><p>2 今天讲的出行路线问题，我假设的是开车出行，那如果是公交出行呢？如果混合地铁、公交、步行，又该如何规划路线呢？</p><p><strong>回答：</strong></p><p>1：获取通过某条路的时间与下面4个因素有关（个人可以想到的）</p><p>①路长度</p><p>②路况(是否平坦等)</p><p>③拥堵情况</p><p>④红绿灯个数等因素相关。</p><p>获取这些因素后就可以建立一个回归模型(比如线性回归)来估算时间。其中①②④因素比较固定，容易获得。③是动态的，但也可以通过a.与交通部门合作获得路段拥堵情况；b.联合其他导航软件获得在该路段的在线人数；c.通过现在时间段正好在次路段的其他用户的真实情况等方式估算。</p><p>2 混合公交、地铁和步行时：地铁时刻表是固定的，容易估算。公交虽然没那么准时，大致时间是可以估计的，步行时间受路拥堵状况小，基本与道路长度成正比，也容易估算。总之，感觉公交、地铁、步行，时间估算会比开车更容易，也更准确些。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>地图软件是如何计算出最短路径的？？</p><p>我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边，这样就构成了一幅有向有权图。这个问题就转化为求一个有向有权图中，两个顶点最短路径的问题。</p><p>上述问题可以使用dijkstra算法</p><p>原理：将每个顶点到起始顶点的距离初始为无穷，然后从起始点开始，将其加入一个优先级队列中，从优先级队列中取出到源点距离最小的顶点，然后比较其周围顶点离源点的距离是否大于其到源点的距离+其到周围顶点的距离，如果大于的话，更新周围顶点到源点的距离为较小的值以及其前序节点，并将其加入优先级队列中（如果已经加入过，就不需加入了），再取出优先级队列中的距离最小值，循环往复，直到取出终止顶点t，或者优先级队列为空。此时倒序输出终止顶点t的前序节点，前序节点的前序节点。。。，直到前序节点的前序节点为s,此时路径即为最短路径。</p><p>计算最少红绿灯依然可以采用上述的思路，构造一个有向无权图。</p><p>对于地点跨度范围比较大，可以分阶段来计算，找出哪些点是必经的点，然后拆分阶段。具体到每个区域，可以找个合适的区域将源点与中点覆盖进去，来减少顶点的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39-拓扑排序_如何确定代码源文件的编译依赖关系</title>
      <link href="/2019/07/24/39-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/07/24/39-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>基础篇</strong>：开篇问题 - 知识讲解 - 回答开篇 - 总结 - 课后思考</p><p><strong>高级篇</strong>：问题阐述 - 算法解析 - 总结引申 - 课后思考</p><p><strong>如何确定代码源文件的编译依赖关系？</strong></p><p>我们知道，一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，A.cpp 依赖 B.cpp，那在编译的时候，编译器需要先编译 B.cpp，才能编译 A.cpp。</p><p>编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 Makefile 文件），来获取这种局部的依赖关系。<font color="red">那编译器又该如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？</font></p><p><img src="/2019/07/24/39-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/700bec14-3e73-4781-9d56-a809025f954f.jpg" alt></p><a id="more"></a><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>这个问题的解决思路与“图”这种数据结构的一个经典算法“拓扑排序算法”有关。那什么是拓扑排序呢？这个概念很好理解，我们先来看一个生活中的拓扑排序的例子。</p><p>我们在穿衣服的时候都有一定的顺序，我们可以把这种顺序想成，衣服与衣服之间有一定的依赖关系。比如说，你必须先穿袜子才能穿鞋，先穿内裤才能穿秋裤。假设我们现在有八件衣服要穿，它们之间的两两依赖关系我们已经很清楚了，那如何安排一个穿衣序列，能够满足所有的两两之间的依赖关系？</p><p>这就是个拓扑排序问题。从这个例子中，你应该能想到，在很多时候，拓扑排序的序列并不是唯一的。你可以看我画的这幅图，我找到了好几种满足这些局部先后关系的穿衣序列。</p><p><img src="/2019/07/24/39-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/753d077b-c190-4242-b703-14cbb5bf395a.jpg" alt></p><p>弄懂了这个生活中的例子，开篇的关于编译顺序的问题，你应该也有思路了。开篇问题跟这个问题的模型是一样的，也可以抽象成一个拓扑排序问题。</p><p>拓扑排序的原理非常简单，我们的重点应该放到拓扑排序的实现上面。</p><p>前面多次讲过，算法是构建在具体的数据结构之上的。针对这个问题，我们先来看下，如何将问题背景抽象成具体的数据结构？</p><p>我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。</p><p>如果 a 先于 b 执行，也就是说 b 依赖于 a，那么就在顶点 a 和顶点 b 之间，构建一条从 a 指向 b 的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 a-&gt;b-&gt;c-&gt;a 这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123;</span><br><span class="line">  private int v; &#x2F;&#x2F; 顶点的个数</span><br><span class="line">  private LinkedList&lt;Integer&gt; adj[]; &#x2F;&#x2F; 邻接表</span><br><span class="line"></span><br><span class="line">  public Graph(int v) &#123;</span><br><span class="line">    this.v &#x3D; v;</span><br><span class="line">    adj &#x3D; new LinkedList[v];</span><br><span class="line">    for (int i&#x3D;0; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addEdge(int s, int t) &#123; &#x2F;&#x2F; s先于t，边s-&gt;t</span><br><span class="line">    adj[s].add(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据结构定义好了，现在，我们来看，<strong>如何在这个有向无环图上，实现拓扑排序？</strong></p><p>拓扑排序有两种实现方法，都不难理解。它们分别是 <strong>Kahn 算法</strong>和** DFS 深度优先搜索算法**。我们依次来看下它们都是怎么工作的。</p><h2 id="1-Kahn-算法"><a href="#1-Kahn-算法" class="headerlink" title="1.Kahn 算法"></a>1.Kahn 算法</h2><p>Kahn 算法实际上用的是贪心算法思想，思路非常简单、好懂。</p><p>定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。所以，如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。</p><p>我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><p>将 Kahn 算法用代码实现了一下，你可以结合着文字描述一块看下。不过，你应该能发现，这段代码实现更有技巧一些，并没有真正删除顶点的操作。代码中有详细的注释，你自己来看，我就不多解释了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void topoSortByKahn() &#123;</span><br><span class="line">  int[] inDegree &#x3D; new int[v]; &#x2F;&#x2F; 统计每个顶点的入度</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      int w &#x3D; adj[i].get(j); &#x2F;&#x2F; i-&gt;w</span><br><span class="line">      inDegree[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LinkedList&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    if (inDegree[i] &#x3D;&#x3D; 0) queue.add(i);</span><br><span class="line">  &#125;</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    int i &#x3D; queue.remove();</span><br><span class="line">    System.out.print(&quot;-&gt;&quot; + i);</span><br><span class="line">    for (int j &#x3D; 0; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      int k &#x3D; adj[i].get(j);</span><br><span class="line">      inDegree[k]--;</span><br><span class="line">      if (inDegree[k] &#x3D;&#x3D; 0) queue.add(k);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS-算法"><a href="#2-DFS-算法" class="headerlink" title="2.DFS 算法"></a>2.DFS 算法</h2><p>图上的深度优先搜索我们前面已经讲过了，实际上，拓扑排序也可以用深度优先搜索来实现。不过这里的名字要稍微改下，更加确切的说法应该是深度优先遍历，遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径。</p><p>关于这个算法的实现原理，我先把代码贴在下面，下面给你具体解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void topoSortByDFS() &#123;</span><br><span class="line">  &#x2F;&#x2F; 先构建逆邻接表，边s-&gt;t表示，s依赖于t，t先于s</span><br><span class="line">  LinkedList&lt;Integer&gt; inverseAdj[] &#x3D; new LinkedList[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123; &#x2F;&#x2F; 申请空间</span><br><span class="line">    inverseAdj[i] &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123; &#x2F;&#x2F; 通过邻接表生成逆邻接表</span><br><span class="line">    for (int j &#x3D; 0; j &lt; adj[i].size(); ++j) &#123;</span><br><span class="line">      int w &#x3D; adj[i].get(j); &#x2F;&#x2F; i-&gt;w</span><br><span class="line">      inverseAdj[w].add(i); &#x2F;&#x2F; w-&gt;i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  boolean[] visited &#x3D; new boolean[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123; &#x2F;&#x2F; 深度优先遍历图</span><br><span class="line">    if (visited[i] &#x3D;&#x3D; false) &#123;</span><br><span class="line">      visited[i] &#x3D; true;</span><br><span class="line">      dfs(i, inverseAdj, visited);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs(</span><br><span class="line">    int vertex, LinkedList&lt;Integer&gt; inverseAdj[], boolean[] visited) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; inverseAdj[vertex].size(); ++i) &#123;</span><br><span class="line">    int w &#x3D; inverseAdj[vertex].get(i);</span><br><span class="line">    if (visited[w] &#x3D;&#x3D; true) continue;</span><br><span class="line">    visited[w] &#x3D; true;</span><br><span class="line">    dfs(w, inverseAdj, visited);</span><br><span class="line">  &#125; &#x2F;&#x2F; 先把vertex这个顶点可达的所有顶点都打印出来之后，再打印它自己</span><br><span class="line">  System.out.print(&quot;-&gt;&quot; + vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法包含两个关键部分。</p><p>第一部分是 <strong>通过邻接表构造逆邻接表</strong> 。邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s。在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行。为什么这么转化呢？这个跟我们这个算法的实现思想有关。</p><p>第二部分是这个算法的核心，也就是 <strong>递归处理每个顶点</strong> 。对于顶点 vertex 来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。</p><p>到这里，用 Kahn 算法和 DFS 算法求拓扑排序的原理和代码实现都讲完了。我们来看下，<strong>这两个算法的时间复杂度分别是多少呢？</strong></p><p>从 Kahn 代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn 算法的时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。</p><p>DFS 算法的时间复杂度我们之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。</p><p>注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，E 并不一定大于 V，两者的大小关系不确定。所以，在表示时间复杂度的时候，V、E 都要考虑在内。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>在基础篇中，关于“图”，我们讲了图的定义和存储、图的广度和深度优先搜索。今天，我们又讲了一个关于图的算法，拓扑排序。</p><p>拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。</p><p>关于图中环的检测，我们在 <strong>递归</strong> 那一节讲过一个例子，在查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户 A 推荐了用户 B，用户 B 推荐了用户 C，用户 C 又推荐了用户 A。如何避免这种脏数据导致的无限递归？这个问题，我当时留给你思考了，现在是时候解答了。</p><p>实际上，这就是环的检测问题。因为我们每次都只是查找一个用户的最终推荐人，所以，我们并不需要动用复杂的拓扑排序算法，而只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环，也就说明存在脏数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; hashTable &#x3D; new HashSet&lt;&gt;(); &#x2F;&#x2F; 保存已经访问过的actorId</span><br><span class="line">long findRootReferrerId(long actorId) &#123;</span><br><span class="line">  if (hashTable.contains(actorId)) &#123; &#x2F;&#x2F; 存在环</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  hashTable.add(actorId);</span><br><span class="line">  Long referrerId &#x3D; </span><br><span class="line">       select referrer_id from [table] where actor_id &#x3D; actorId;</span><br><span class="line">  if (referrerId &#x3D;&#x3D; null) return actorId;</span><br><span class="line">  return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把这个问题改一下，我们想要知道，数据库中的所有用户之间的推荐关系了，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。我们把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构，再利用拓扑排序，就可以快速检测出是否存在环了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 在今天的讲解中，我们用图表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边；反过来，如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a，那今天讲的 Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？</p><p>2 我们今天讲了两种拓扑排序算法的实现思路，Kahn 算法和 DFS 深度优先搜索算法，如果换做 BFS 广度优先搜索算法，还可以实现吗？</p><p><strong>回答：</strong></p><p>1  a先于b执行，也就说b依赖于a，b指向a，这样构建有向无环图时，要找到出度为0的顶点，然后删除</p><p>2  BFS也能实现，因为遍历只是实现拓扑排序的一个“辅助手段”，本质上是帮助找到优先执行的顶点</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>38-动态规划实战_如何实现搜索引擎中的拼写纠错功能</title>
      <link href="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<strong>Trie 树</strong>那节我们讲过，利用 Trie 树，可以实现搜索引擎的关键词提示功能，这样可以节省用户输入搜索关键词的时间。实际上，搜索引擎在用户体验方面的优化还有很多，比如你可能经常会用的拼写纠错功能。</p><p>当你在搜索框中，一不小心输错单词时，搜索引擎会非常智能地检测出你的拼写错误，并且用对应的正确单词来进行搜索。作为一名软件开发工程师，你是否想过，这个功能是怎么实现的呢？</p><p><img src="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/77e66acb-3e4a-45d0-bb19-067b0061ebf7.jpg" alt></p><a id="more"></a><h2 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h2><p>计算机只认识数字，所以要解答开篇的问题，我们就要先来看，如何量化两个字符串之间的相似程度呢？有一个非常著名的量化方法，那就是编辑距离（Edit Distance）。</p><p>顾名思义，<strong>编辑距离</strong>指的就是，将一个字符串转化成另一个字符串，需要的最少编辑操作次数（比如增加一个字符、删除一个字符、替换一个字符）。编辑距离越大，说明两个字符串的相似程度越小；相反，编辑距离就越小，说明两个字符串的相似程度越大。对于两个完全相同的字符串来说，编辑距离就是 0。</p><p>根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<strong>莱文斯坦距离</strong>（Levenshtein distance）和<strong>最长公共子串长度</strong>（Longest common substring length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><p>而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小。</p><p>关于这两个计算方法，此处举个例子给你说明一下。这里面，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4。</p><p><img src="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/b38589ea-f8ea-4c59-a9c6-ab6e5a09613f.jpg" alt></p><p>了解了编辑距离的概念之后，我们来看，如何快速计算两个字符串之间的编辑距离？</p><h2 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h2><p>之前反复强调过，思考过程比结论更重要，所以，现在就给你展示一下，解决这个问题的完整的思考过程。</p><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合<strong>多阶段决策最优解模型</strong>。</p><p>我们前面讲了，贪心、回溯、动态规划可以解决的问题，都可以抽象成这样一个模型。要解决这个问题，我们可以先看一看，用最简单的回溯算法，该如何来解决。</p><p>回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：</p><ul><li><p>可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；</p></li><li><p>可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；</p></li><li><p>可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察 a[i]和 b[j+1];</p></li><li><p>可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；</p></li><li><p>可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]</p></li></ul><p>我们将上面的回溯算法的处理思路，翻译成代码，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private char[] a &#x3D; &quot;mitcmu&quot;.toCharArray();</span><br><span class="line">private char[] b &#x3D; &quot;mtacnu&quot;.toCharArray();</span><br><span class="line">private int n &#x3D; 6;</span><br><span class="line">private int m &#x3D; 6;</span><br><span class="line">private int minDist &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 存储结果</span><br><span class="line">&#x2F;&#x2F; 调用方式 lwstBT(0, 0, 0);</span><br><span class="line">public lwstBT(int i, int j, int edist) &#123;</span><br><span class="line">  if (i &#x3D;&#x3D; n || j &#x3D;&#x3D; m) &#123;</span><br><span class="line">    if (i &lt; n) edist +&#x3D; (n-i);</span><br><span class="line">    if (j &lt; m) edist +&#x3D; (m - j);</span><br><span class="line">    if (edist &lt; minDist) minDist &#x3D; edist;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (a[i] &#x3D;&#x3D; b[j]) &#123; &#x2F;&#x2F; 两个字符匹配</span><br><span class="line">    lwstBT(i+1, j+1, edist);</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F; 两个字符不匹配</span><br><span class="line">    lwstBT(i + 1, j, edist + 1); &#x2F;&#x2F; 删除a[i]或者b[j]前添加一个字符</span><br><span class="line">    lwstBT(i, j + 1, edist + 1); &#x2F;&#x2F; 删除b[j]或者a[i]前添加一个字符</span><br><span class="line">    lwstBT(i + 1, j + 1, edist + 1); &#x2F;&#x2F; 将a[i]和b[j]替换为相同字符</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。</p><p><img src="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/864f25506eb3db427377bde7bb4c9589.jpg" alt></p><p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i]和 b[j]时，已经执行的编辑操作的次数。</p><p>在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i]和 b[j]，已经执行的最少编辑次数。</p><p>看到这里，你有没有觉得，这个问题跟上两节讲的动态规划例子非常相似？不过，这个问题的状态转移方式，要比之前两节课中讲到的例子都要复杂很多。上一节我们讲的矩阵最短路径问题中，到达状态 (i, j) 只能通过 (i-1, j) 或 (i, j-1) 两个状态转移过来，而今天这个问题，状态 (i, j) 可能从 (i-1, j)，(i, j-1)，(i-1, j-1) 三个状态中的任意一个转移过来。</p><p><img src="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/dd5859ee-b690-42eb-838c-e600215b9324.jpg" alt></p><p>基于刚刚的分析，我们可以尝试着将把状态转移的过程，用公式写出来。这就是我们前面讲的状态转移方程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果：a[i]!&#x3D;b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-1,j)+1, min_edist(i,j-1)+1, min_edist(i-1,j-1)+1)</span><br><span class="line"></span><br><span class="line">如果：a[i]&#x3D;&#x3D;b[j]，那么：min_edist(i, j)就等于：</span><br><span class="line">min(min_edist(i-1,j)+1, min_edist(i,j-1)+1，min_edist(i-1,j-1))</span><br><span class="line"></span><br><span class="line">其中，min表示求三数中的最小值。</span><br></pre></td></tr></table></figure><p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值。</p><p><img src="/2019/07/20/38-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%8B%BC%E5%86%99%E7%BA%A0%E9%94%99%E5%8A%9F%E8%83%BD/ab44eb53fad2601c19f73604747d652d.jpg" alt></p><p>我们现在既有状态转移方程，又理清了完整的填表过程，代码实现就非常简单了。我将代码贴在下面，你可以对比着文字解释，一起看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int lwstDP(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[][] minDist &#x3D; new int[n][m];</span><br><span class="line">  for (int j &#x3D; 0; j &lt; m; ++j) &#123; &#x2F;&#x2F; 初始化第0行:a[0..0]与b[0..j]的编辑距离</span><br><span class="line">    if (a[0] &#x3D;&#x3D; b[j]) minDist[0][j] &#x3D; j;</span><br><span class="line">    else if (j !&#x3D; 0) minDist[0][j] &#x3D; minDist[0][j-1]+1;</span><br><span class="line">    else minDist[0][j] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123; &#x2F;&#x2F; 初始化第0列:a[0..i]与b[0..0]的编辑距离</span><br><span class="line">    if (a[i] &#x3D;&#x3D; b[0]) minDist[i][0] &#x3D; i;</span><br><span class="line">    else if (i !&#x3D; 0) minDist[i][0] &#x3D; minDist[i-1][0]+1;</span><br><span class="line">    else minDist[i][0] &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F; 按行填表</span><br><span class="line">    for (int j &#x3D; 1; j &lt; m; ++j) &#123;</span><br><span class="line">      if (a[i] &#x3D;&#x3D; b[j]) minDist[i][j] &#x3D; min(</span><br><span class="line">          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]);</span><br><span class="line">      else minDist[i][j] &#x3D; min(</span><br><span class="line">          minDist[i-1][j]+1, minDist[i][j-1]+1, minDist[i-1][j-1]+1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return minDist[n-1][m-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int min(int x, int y, int z) &#123;</span><br><span class="line">  int minv &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  if (x &lt; minv) minv &#x3D; x;</span><br><span class="line">  if (y &lt; minv) minv &#x3D; y;</span><br><span class="line">  if (z &lt; minv) minv &#x3D; z;</span><br><span class="line">  return minv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会说，我虽然能看懂你讲的思路，但是遇到新的问题的时候，我还是会感觉到无从下手。这种感觉是非常正常的。关于复杂算法问题的解决思路，我还有一些经验、小技巧，可以分享给你。</p><p>当我们拿到一个问题的时候，<strong>我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题</strong>。人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题。所以，我们需要把抽象问题具象化。那如何具象化呢？我们可以实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律，再尝试套用学过的算法，看是否能够解决。</p><p>除此之外，我还有一个非常有效、但也算不上技巧的东西，我也反复强调过，那就是<strong>多练</strong>。实际上，等你做多了题目之后，自然就会有感觉，看到问题，立马就能想到能否用动态规划解决，然后直接就可以寻找最优子结构，写出动态规划方程，然后将状态转移方程翻译成代码。</p><h2 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h2><p>前面我们讲到，最长公共子串作为编辑距离中的一种，只允许增加、删除字符两种编辑操作。从名字上，你可能觉得它看起来跟编辑距离没什么关系。实际上，从本质上来说，它表征的也是两个字符串之间的相似程度。</p><p>这个问题的解决思路，跟莱文斯坦距离的解决思路非常相似，也可以用动态规划解决。我刚刚已经详细讲解了莱文斯坦距离的动态规划解决思路，所以，针对这个问题，我直接定义状态，然后写状态转移方程。</p><p>每个状态还是包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i]和 b[0…j]的最长公共子串长度。那 (i, j) 这个状态都是由哪些状态转移过来的呢？</p><p>我们先来看回溯的处理思路。我们从 a[0]和 b[0]开始，依次考察两个字符串中的字符是否匹配。</p><ul><li><p>如果 a[i]与 b[j]互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1]和 b[j+1]。</p></li><li><p>如果 a[i]与 b[j]不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：</p></li><li><p>删除 a[i]，或者在 b[j]前面加上一个字符 a[i]，然后继续考察 a[i+1]和 b[j]；</p></li><li><p>删除 b[j]，或者在 a[i]前面加上一个字符 b[j]，然后继续考察 a[i]和 b[j+1]。</p></li></ul><p>反过来也就是说，如果我们要求 a[0…i]和 b[0…j]的最长公共长度 max_lcs(i, j)，我们只有可能通过下面三个状态转移过来：</p><ul><li><p>(i-1, j-1, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j-1]的最长公共子串长度；</p></li><li><p>(i-1, j, max_lcs)，其中 max_lcs 表示 a[0…i-1]和 b[0…j]的最长公共子串长度；</p></li><li><p>(i, j-1, max_lcs)，其中 max_lcs 表示 a[0…i]和 b[0…j-1]的最长公共子串长度。</p></li></ul><p>如果我们把这个转移过程，用状态转移方程写出来，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果：a[i]&#x3D;&#x3D;b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-1,j-1)+1, max_lcs(i-1, j), max_lcs(i, j-1))；</span><br><span class="line"></span><br><span class="line">如果：a[i]!&#x3D;b[j]，那么：max_lcs(i, j)就等于：</span><br><span class="line">max(max_lcs(i-1,j-1), max_lcs(i-1, j), max_lcs(i, j-1))；</span><br><span class="line"></span><br><span class="line">其中max表示求三数中的最大值。</span><br></pre></td></tr></table></figure><p>有了状态转移方程，代码实现就简单多了。把代码贴到了下面，你可以对比着文字一块儿看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public int lcs(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[][] maxlcs &#x3D; new int[n][m];</span><br><span class="line">  for (int j &#x3D; 0; j &lt; m; ++j) &#123;&#x2F;&#x2F;初始化第0行：a[0..0]与b[0..j]的maxlcs</span><br><span class="line">    if (a[0] &#x3D;&#x3D; b[j]) maxlcs[0][j] &#x3D; 1;</span><br><span class="line">    else if (j !&#x3D; 0) maxlcs[0][j] &#x3D; maxlcs[0][j-1];</span><br><span class="line">    else maxlcs[0][j] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123;&#x2F;&#x2F;初始化第0列：a[0..i]与b[0..0]的maxlcs</span><br><span class="line">    if (a[i] &#x3D;&#x3D; b[0]) maxlcs[i][0] &#x3D; 1;</span><br><span class="line">    else if (i !&#x3D; 0) maxlcs[i][0] &#x3D; maxlcs[i-1][0];</span><br><span class="line">    else maxlcs[i][0] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F; 填表</span><br><span class="line">    for (int j &#x3D; 1; j &lt; m; ++j) &#123;</span><br><span class="line">      if (a[i] &#x3D;&#x3D; b[j]) maxlcs[i][j] &#x3D; max(</span><br><span class="line">          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]+1);</span><br><span class="line">      else maxlcs[i][j] &#x3D; max(</span><br><span class="line">          maxlcs[i-1][j], maxlcs[i][j-1], maxlcs[i-1][j-1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return maxlcs[n-1][m-1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int max(int x, int y, int z) &#123;</span><br><span class="line">  int maxv &#x3D; Integer.MIN_VALUE;</span><br><span class="line">  if (x &gt; maxv) maxv &#x3D; x;</span><br><span class="line">  if (y &gt; maxv) maxv &#x3D; y;</span><br><span class="line">  if (z &gt; maxv) maxv &#x3D; z;</span><br><span class="line">  return maxv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户。</p><p>这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。</p><p><strong>针对纠错效果不好的问题</strong>，我们有很多种优化思路，这里介绍几种。</p><ul><li><p>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 TOP 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词。</p></li><li><p>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 TOP 10，然后求交集，用交集的结果，再继续优化处理。</p></li><li><p>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好。</p></li><li><p>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词。</p></li></ul><p><strong>针对纠错性能方面</strong>，我们也有相应的优化方式。我讲两种分治的优化思路。</p><ul><li><p>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词。</p></li><li><p>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词。</p></li></ul><p>真正的搜索引擎的拼写纠错优化，肯定不止我讲的这么简单，但是万变不离其宗。掌握了核心原理，就是掌握了解决问题的方法，剩下就靠你自己的灵活运用和实战操练了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>动态规划的三节内容到此就全部讲完了，不知道你掌握得如何呢？</p><p>动态规划的理论尽管并不复杂，总结起来就是“一个模型三个特征”。但是，要想灵活应用并不简单。要想能真正理解、掌握动态规划，你只有多练习。</p><p>这三节中，加上课后思考题，总共有 8 个动态规划问题。这 8 个问题都非常经典，很多动态规划问题其实都可以抽象成这几个问题模型，所以，你一定要多看几遍，多思考一下，争取真正搞懂它们。</p><p>只要弄懂了这几个问题，一般的动态规划问题，你应该都可以应付。对于动态规划这个知识点，你就算是入门了，再学习更加复杂的就会简单很多。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>补充一下，中文纠错很多时候是通过拼音进行的，比如 “刘得花”-&gt;”liudehua”-&gt;”刘德华”. 拼音检索方法也有很多，比如可以把热门词汇的拼音字母组织成Trie树，每个热词的结尾汉字的最后一个拼音字母就是叶子，整体性能就是O(n)的，n为query的拼音总长度. 除了拼音外也有根据字形（二维文字版的编辑距离？）甚至语义等做的纠错策略。<br>传统搜索引擎中的查询词智能提示、纠错、同义词、近义词、同好词、相关搜索、知识图谱等系列功能统称为用户的意图识别模块。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37-动态规划理论_一篇文章带你彻底搞懂最优子结结构_无后效性_重复子问题</title>
      <link href="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节，通过两个非常经典的问题，向你展示了用动态规划解决问题的过程。现在你对动态规划应该有了一个初步的认识。</p><p>今天，主要讲动态规划的一些理论知识。学完这节内容，可以帮你解决这样几个问题：什么样的问题可以用动态规划解决？解决动态规划问题的一般思考过程是什么样的？贪心、分治、回溯、动态规划这四种算法思想又有什么区别和联系？</p><p>理论的东西都比较抽象，不过你不用担心，本文会结合具体的例子来讲解，争取让你这次就能真正理解这些知识点，也为后面的应用和实战做好准备。</p><a id="more"></a><h2 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h2><p>什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？实际上，动态规划作为一个非常成熟的算法思想，很多人对此已经做了非常全面的总结。我把这部分理论总结为“一个模型三个特征”。</p><p>首先，我们来看，什么是“<strong>一个模型</strong>”？它指的是动态规划适合解决的问题的模型。我把这个模型定义为“<strong>多阶段决策最优解模型</strong>”。下面我具体来给你讲讲。</p><p>我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>现在，我们再来看，什么是“<strong>三个特征</strong>”？它们分别是<strong>最优子结构</strong>、<strong>无后效性</strong>和<strong>重复子问题</strong>。这三个概念比较抽象，我来逐一详细解释一下。</p><h3 id="1-最优子结构"><a href="#1-最优子结构" class="headerlink" title="1. 最优子结构"></a>1. 最优子结构</h3><p>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。</p><h3 id="2-无后效性"><a href="#2-无后效性" class="headerlink" title="2. 无后效性"></a>2. 无后效性</h3><p>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。</p><h3 id="3-重复子问题"><a href="#3-重复子问题" class="headerlink" title="3. 重复子问题"></a>3. 重复子问题</h3><p>这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。</p><h2 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h2><p>“一个模型三个特征”这部分是理论知识，比较抽象，你看了之后可能还是有点懵，有种似懂非懂的感觉，没关系，这个很正常。接下来，结合一个具体的动态规划问题，来给你详细解释。</p><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢？</p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/856d7a00-c98a-4c30-a252-ea7e3ef2aa0e.jpg" alt></p><p>我们先看看，这个问题是否符合“一个模型”？</p><p>从 (0, 0) 走到 (n-1, n-1)，总共要走 2<em>(n-1) 步，也就对应着 2</em>(n-1) 个阶段。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。</p><p>我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型。</p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/d1ae7e3e-9924-4d21-a2cf-43cadd4a68d2.jpg" alt></p><p>我们再来看，这个问题是否符合“三个特征”？</p><p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。重复的节点表示，从左上角到节点对应的位置，有多种路线，这也能说明这个问题中存在重复子问题。</p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/7336e066-4302-4abf-b050-b5e6c4c467a1.jpg" alt></p><p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，前面阶段的状态确定之后，不会被后面阶段的决策所改变，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来。这就说明，这个问题符合“最优子结构”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure><h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><p>刚刚讲了，如何鉴别一个问题是否可以用动态规划来解决。现在，再总结一下，动态规划解题的一般思路，让你面对动态规划问题的时候，能够有章可循，不至于束手无策。</p><p>个人觉得，解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。</p><h3 id="1-状态转移表法"><a href="#1-状态转移表法" class="headerlink" title="1. 状态转移表法"></a>1. 状态转移表法</h3><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路，第一种是直接用<strong>回溯加“备忘录”</strong>的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别。第二种是使用动态规划的解决方法，<strong>状态转移表法</strong>。第一种思路，我就不讲了，你可以看看上一节的两个例子。我们重点来看状态转移表法是如何工作的。</p><p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为人脑确实很不擅长思考高维的东西。</p><p>现在，我们来看一下，如何套用这个状态转移表法，来解决之前那个矩阵最短路径的问题？</p><p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。不过如何才能无重复又不遗漏地穷举出所有走法呢？我们可以用回溯算法这个比较有规律的穷举算法。</p><p>回溯算法的代码实现如下所示。代码很短，而且我前面也分析过很多回溯算法的例题，这里我就不多做解释了，你自己来看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int minDist &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; 全局变量或者成员变量</span><br><span class="line">&#x2F;&#x2F; 调用方式：minDistBacktracing(0, 0, 0, w, n);</span><br><span class="line">public void minDistBT(int i, int j, int dist, int[][] w, int n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 到达了n-1, n-1这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span><br><span class="line">  if (i &#x3D;&#x3D; n &amp;&amp; j &#x3D;&#x3D; n) &#123;</span><br><span class="line">    if (dist &lt; minDist) minDist &#x3D; dist;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (i &lt; n) &#123; &#x2F;&#x2F; 往下走，更新i&#x3D;i+1, j&#x3D;j</span><br><span class="line">    minDistBT(i + 1, j, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">  if (j &lt; n) &#123; &#x2F;&#x2F; 往右走，更新i&#x3D;i, j&#x3D;j+1</span><br><span class="line">    minDistBT(i, j+1, dist+w[i][j], w, n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)，其中 i，j 分别表示行和列，dist 表示从起点到达 (i, j) 的路径长度。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点，继续递归求解，其他节点就可以舍弃了。</p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/2c3ec820fa8f8cc7df838c0304b030e2.jpg" alt></p><p>既然存在重复子问题，我们就可以尝试看下，是否可以用动态规划来解决呢？</p><p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们按照决策过程，通过不断状态递推演进，将状态表填好。为了方便代码实现，我们按行来进行依次填充。</p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/aabf47b1-3a67-485e-9a3e-626e675f9371.jpg" alt></p><p><img src="/2019/07/13/37-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA-%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E7%BB%93%E6%9E%84-%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7-%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/aa604b73-9f3d-45af-9de0-2d670c7b68f3.jpg" alt></p><p>弄懂了填表的过程，代码实现就简单多了。我们将上面的过程，翻译成代码，就是下面这个样子。结合着代码、图和文字描述，应该更容易理解我讲的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int minDistDP(int[][] matrix, int n) &#123;</span><br><span class="line">  int[][] states &#x3D; new int[n][n];</span><br><span class="line">  int sum &#x3D; 0;</span><br><span class="line">  for (int j &#x3D; 0; j &lt; n; ++j) &#123; &#x2F;&#x2F; 初始化states的第一行数据</span><br><span class="line">    sum +&#x3D; matrix[0][j];</span><br><span class="line">    states[0][j] &#x3D; sum;</span><br><span class="line">  &#125;</span><br><span class="line">  sum &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123; &#x2F;&#x2F; 初始化states的第一列数据</span><br><span class="line">    sum +&#x3D; matrix[i][0];</span><br><span class="line">    states[i][0] &#x3D; sum;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">    for (int j &#x3D; 1; j &lt; n; ++j) &#123;</span><br><span class="line">      states[i][j] &#x3D; </span><br><span class="line">            matrix[i][j] + Math.min(states[i][j-1], states[i-1][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return states[n-1][n-1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-状态转移方程法"><a href="#2-状态转移方程法" class="headerlink" title="2. 状态转移方程法"></a>2. 状态转移方程法</h3><p>状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法，一种是<strong>递归加“备忘录”</strong>，另一种是<strong>迭代递推</strong>。</p><p>我们还是拿刚才的例子来举例。最优子结构前面已经分析过了，你可以回过头去再看下。为了方便你查看，我把状态转移方程放到这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) &#x3D; w[i][j] + min(min_dist(i, j-1), min_dist(i-1, j))</span><br></pre></td></tr></table></figure><p>这里我强调一下，<strong>状态转移方程是解决动态规划的关键</strong>。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。</p><p>下面我用递归加“备忘录”的方式，将状态转移方程翻译成来代码，你可以看看。对于另一种实现方式，跟状态转移表法的代码实现是一样的，只是思路不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private int[][] matrix &#x3D; </span><br><span class="line">         &#123;&#123;1，3，5，9&#125;, &#123;2，1，3，4&#125;，&#123;5，2，6，7&#125;，&#123;6，8，4，3&#125;&#125;;</span><br><span class="line">private int n &#x3D; 4;</span><br><span class="line">private int[][] mem &#x3D; new int[4][4];</span><br><span class="line">public int minDist(int i, int j) &#123; &#x2F;&#x2F; 调用minDist(n-1, n-1);</span><br><span class="line">  if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0) return matrix[0][0];</span><br><span class="line">  if (mem[i][j] &gt; 0) return mem[i][j];</span><br><span class="line">  int minLeft &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  if (j-1 &gt;&#x3D; 0) &#123;</span><br><span class="line">    minLeft &#x3D; minDist(i, j-1);</span><br><span class="line">  &#125;</span><br><span class="line">  int minUp &#x3D; Integer.MAX_VALUE;</span><br><span class="line">  if (i-1 &gt;&#x3D; 0) &#123;</span><br><span class="line">    minUp &#x3D; minDist(i-1, j);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int currMinDist &#x3D; matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">  mem[i][j] &#x3D; currMinDist;</span><br><span class="line">  return currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种动态规划解题思路到这里就讲完了。要强调一点，不是每个问题都同时适合这两种解题思路。有的问题可能用第一种思路更清晰，而有的问题可能用第二种思路更清晰，所以，你要结合具体的题目来看，到底选择用哪种解题思路。</p><h2 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h2><p>到今天为止，我们已经学习了四种算法思想，贪心、分治、回溯和动态规划。今天的内容主要讲些理论知识，正好一块儿也分析一下这四种算法，看看它们之间有什么区别和联系。</p><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p>贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。</p><p>其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>首先讲了什么样的问题适合用动态规划解决。这些问题可以总结概括为“一个模型三个特征”。其中，“一个模型”指的是，问题可以抽象成分阶段决策最优解模型。“三个特征”指的是最优子结构、无后效性和重复子问题。</p><p>然后，讲了两种动态规划的解题思路。它们分别是状态转移表法和状态转移方程法。其中，状态转移表法解题思路大致可以概括为，<strong>回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码</strong>。状态转移方程法的大致思路可以概括为，<strong>找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码</strong>。</p><p>最后，我们对比了之前讲过的四种算法思想。贪心、回溯、动态规划可以解决的问题模型类似，都可以抽象成多阶段决策最优解模型。尽管分治算法也能解决最优问题，但是大部分问题的背景都不适合抽象成多阶段决策模型。</p><p>今天的内容比较偏理论，可能会不好理解。很多理论知识的学习，单纯的填鸭式讲给你听，实际上效果并不好。要想真的把这些理论知识理解透，化为己用，还是需要你自己多思考，多练习。等你做了足够多的题目之后，自然就能自己悟出一些东西，这样再回过头来看理论，就会非常容易看懂。</p><p>所以，在今天的内容中，如果有哪些地方你还不能理解，那也没关系，先放一放。下一节，会运用今天讲到的理论，再解决几个动态规划的问题。等你学完下一节，可以再回过头来看下今天的理论知识，可能就会有一种顿悟的感觉。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币。比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）。</p><p><strong>回答：</strong></p><p>可以看做爬阶梯问题，分别可以走1.3.5步，怎么最少走到9步，动态转移方程为f(9)=1+min(f(8),f(6),f(4))</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36-初识动态规划_如何巧妙解解决“双十一”购物时的凑单问题</title>
      <link href="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/"/>
      <url>/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>淘宝的“双十一”购物节有各种促销活动，比如“满 200 元减 50 元”。假设你女朋友的购物车中有 n 个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），这样就可以极大限度地“薅羊毛”。作为程序员的你，能不能编个代码来帮她搞定呢？</p><p>要想高效地解决这个问题，就要用到我们今天讲的动态规划（Dynamic Programming）。</p><a id="more"></a><h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><p>动态规划比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。它的主要学习难点跟递归类似，那就是，求解问题的过程不太符合人类常规的思维方式。对于新手来说，要想入门确实不容易。不过，等你掌握了之后，你会发现，实际上并没有想象中那么难。</p><p>为了让你更容易理解动态规划，分了三节讲解。这三节分别是，初识动态规划、动态规划理论、动态规划实战。</p><p>第一节，会通过两个非常经典的动态规划问题模型，向你展示我们为什么需要动态规划，以及动态规划解题方法是如何演化出来的。实际上，你只要掌握了这两个例子的解决思路，对于其他很多动态规划问题，你都可以套用类似的思路来解决。</p><p>第二节，会总结动态规划适合解决的问题的特征，以及动态规划解题思路。除此之外，还会将贪心、分治、回溯、动态规划这四种算法思想放在一起，对比分析它们各自的特点以及适用的场景。</p><p>第三节，会教你应用第二节讲的动态规划理论知识，实战解决三个非常经典的动态规划问题，加深你对理论的理解。弄懂了这三节中的例子，对于动态规划这个知识点，你就算是入门了。</p><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>在讲贪心算法、回溯算法的时候，多次讲到背包问题。今天，我们依旧拿这个问题来举例。</p><p>对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢？</p><p>关于这个问题，我们上一节讲了回溯的解决方法，也就是穷举搜索所有可能的装法，然后找出满足条件的最大值。不过，回溯算法的复杂度比较高，是指数级别的。那有没有什么规律，可以有效降低时间复杂度呢？我们一起来看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 回溯算法实现。注意：我把输入的变量都定义成了成员变量。</span><br><span class="line">private int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxW中</span><br><span class="line">private int[] weight &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品重量</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">public void f(int i, int cw) &#123; &#x2F;&#x2F; 调用f(0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cw &gt; maxW) maxW &#x3D; cw;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw + weight[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规律是不是不好找？那我们就举个例子、画个图看看。我们假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2，2，4，6，3。如果我们把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：</p><p><img src="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/42ca6cec4ad034fc3e5c0605fbacecea.jpg" alt></p><p>递归树中的每个节点表示一种状态，我们用（i, cw）来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，（2，2）表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2。</p><p>从递归树中，你应该能会发现，有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3,4) 都被重复计算了两次。我们可以借助<strong>递归</strong>那一节讲的“备忘录”的解决方式，记录已经计算好的 f(i, cw)，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxW中</span><br><span class="line">private int[] weight &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品重量</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">private boolean[][] mem &#x3D; new boolean[5][10]; &#x2F;&#x2F; 备忘录，默认值false</span><br><span class="line">public void f(int i, int cw) &#123; &#x2F;&#x2F; 调用f(0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cw &gt; maxW) maxW &#x3D; cw;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  if (mem[i][cw]) return; &#x2F;&#x2F; 重复状态</span><br><span class="line">  mem[i][cw] &#x3D; true; &#x2F;&#x2F; 记录(i, cw)这个状态</span><br><span class="line">  f(i+1, cw); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw + weight[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方法非常好。实际上，它已经跟动态规划的执行效率基本上没有差别。但是，多一种方法就多一种解决思路，我们现在来看看动态规划是怎么做的。</p><p>我们把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个物品决策（放入或者不放入背包）完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。</p><p>我们把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，我们就成功避免了每层状态个数的指数级增长。</p><p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。</p><p>第 0 个（下标从 0 开始编号）物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。</p><p>第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0)，2(0+2 or 2+0)，4(2+2)。我们用 states[1][0]=true，states[1][2]=true，states[1][4]=true 来表示这三种状态。</p><p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w（这里是 9）的值，就是背包中物品总重量的最大值。</p><p><img src="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/aaf51df520ea6b8056f4e62aed81a5b5.jpg" alt></p><p><img src="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/bbbb934247219db8299bd46dba9dd47e.jpg" alt></p><p>文字描述可能还不够清楚。我把上面的过程，翻译成代码，你可以结合着一块看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">weight:物品重量，n:物品个数，w:背包可承载重量</span><br><span class="line">public int knapsack(int[] weight, int n, int w) &#123;</span><br><span class="line">  boolean[][] states &#x3D; new boolean[n][w+1]; &#x2F;&#x2F; 默认值false</span><br><span class="line">  states[0][0] &#x3D; true;  &#x2F;&#x2F; 第一行的数据要特殊处理，可以利用哨兵优化</span><br><span class="line">  if (weight[0] &lt;&#x3D; w) &#123;</span><br><span class="line">    states[0][weight[0]] &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F; 动态规划状态转移</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; w; ++j) &#123;&#x2F;&#x2F; 不把第i个物品放入背包</span><br><span class="line">      if (states[i-1][j] &#x3D;&#x3D; true) states[i][j] &#x3D; states[i-1][j];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; w-weight[i]; ++j) &#123;&#x2F;&#x2F;把第i个物品放入背包</span><br><span class="line">      if (states[i-1][j]&#x3D;&#x3D;true) states[i][j+weight[i]] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; w; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 输出结果</span><br><span class="line">    if (states[n-1][i] &#x3D;&#x3D; true) return i;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。这也是动态规划这个名字的由来，你可以自己体会一下，是不是还挺形象的？</p><p>前面我们讲到，用回溯算法解决这个问题的时间复杂度 O(2^n)，是指数级的。那动态规划解决方案的时间复杂度是多少呢？我来分析一下。</p><p>这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。</p><p>从理论上讲，指数级的时间复杂度肯定要比 O(n*w) 高很多，但是为了让你有更加深刻的感受，我来举一个例子给你比较一下。</p><p>我们假设有 10000 个物品，重量分布在 1 到 15000 之间，背包可以承载的总重量是 30000。如果我们用回溯算法解决，用具体的数值表示出时间复杂度，就是 2^10000，这是一个相当大的一个数字。如果我们用动态规划解决，用具体的数值表示出时间复杂度，就是 10000*30000。虽然看起来也很大，但是和 2^10000 比起来，要小太多了。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，动态规划是一种空间换时间的解决思路。你可能要问了，有什么办法可以降低空间消耗吗？</p><p>实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。具体的代码实现我贴在这里，你可以仔细看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int knapsack2(int[] items, int n, int w) &#123;</span><br><span class="line">  boolean[] states &#x3D; new boolean[w+1]; &#x2F;&#x2F; 默认值false</span><br><span class="line">  states[0] &#x3D; true;  &#x2F;&#x2F; 第一行的数据要特殊处理，可以利用哨兵优化</span><br><span class="line">  if (items[0] &lt;&#x3D; w) &#123;</span><br><span class="line">    states[items[0]] &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F; 动态规划</span><br><span class="line">    for (int j &#x3D; w-items[i]; j &gt;&#x3D; 0; --j) &#123;&#x2F;&#x2F;把第i个物品放入背包</span><br><span class="line">      if (states[j]&#x3D;&#x3D;true) states[j+items[i]] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; w; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 输出结果</span><br><span class="line">    if (states[i] &#x3D;&#x3D; true) return i;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我特别强调一下代码中的第 8 行，j 需要从大到小来处理。如果我们按照 j 从小到大处理的话，会出现 for 循环重复计算的问题。你可以自己想一想，这里我就不详细说了。</p><h2 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h2><p>我们继续升级难度。我改造了一下刚刚的背包问题。你看这个问题又该如何用动态规划解决？</p><p>我们刚刚讲的背包问题，只涉及背包重量和物品重量。我们现在引入物品价值这一变量。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢？</p><p>这个问题依旧可以用回溯算法来解决。这个问题并不复杂，所以具体的实现思路，我就不用文字描述了，直接给你看代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int maxV &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F; 结果放到maxV中</span><br><span class="line">private int[] items &#x3D; &#123;2，2，4，6，3&#125;;  &#x2F;&#x2F; 物品的重量</span><br><span class="line">private int[] value &#x3D; &#123;3，4，8，9，6&#125;; &#x2F;&#x2F; 物品的价值</span><br><span class="line">private int n &#x3D; 5; &#x2F;&#x2F; 物品个数</span><br><span class="line">private int w &#x3D; 9; &#x2F;&#x2F; 背包承受的最大重量</span><br><span class="line">public void f(int i, int cw, int cv) &#123; &#x2F;&#x2F; 调用f(0, 0, 0)</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了，i&#x3D;&#x3D;n表示物品都考察完了</span><br><span class="line">    if (cv &gt; maxV) maxV &#x3D; cv;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, cv); &#x2F;&#x2F; 选择不装第i个物品</span><br><span class="line">  if (cw + weight[i] &lt;&#x3D; w) &#123;</span><br><span class="line">    f(i+1,cw+weight[i], cv+value[i]); &#x2F;&#x2F; 选择装第i个物品</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的代码，我们还是照例画出递归树。在递归树中，每个节点表示一个状态。现在我们需要 3 个变量（i, cw, cv）来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值。</p><p><img src="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/bf0aa18f367db1b8dfd392906cb5693f.jpg" alt></p><p>我们发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2,2,4) 和 f(2,2,3)。在背包中物品总重量一样的情况下，f(2,2,4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2,2,3) 这种状态，只需要沿着 f(2,2,4) 这条决策路线继续往下决策就可以。</p><p>也就是说，对于 (i, cw) 相同的不同状态，那我们只需要保留 cv 值最大的那个，继续递归处理，其他状态不予考虑。</p><p>思路说完了，但是代码如何实现呢？如果用回溯算法，这个问题就没法再用“备忘录”解决了。所以，我们就需要换一种思路，看看动态规划是不是更容易解决这个问题？</p><p>我们还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。</p><p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态。</p><p>我们把这个动态规划的过程翻译成代码，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public static int knapsack3(int[] weight, int[] value, int n, int w) &#123;</span><br><span class="line">  int[][] states &#x3D; new int[n][w+1];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123; &#x2F;&#x2F; 初始化states</span><br><span class="line">    for (int j &#x3D; 0; j &lt; w+1; ++j) &#123;</span><br><span class="line">      states[i][j] &#x3D; -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  states[0][0] &#x3D; 0;</span><br><span class="line">  if (weight[0] &lt;&#x3D; w) &#123;</span><br><span class="line">    states[0][weight[0]] &#x3D; value[0];</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F;动态规划，状态转移</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; w; ++j) &#123; &#x2F;&#x2F; 不选择第i个物品</span><br><span class="line">      if (states[i-1][j] &gt;&#x3D; 0) states[i][j] &#x3D; states[i-1][j];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; w-weight[i]; ++j) &#123; &#x2F;&#x2F; 选择第i个物品</span><br><span class="line">      if (states[i-1][j] &gt;&#x3D; 0) &#123;</span><br><span class="line">        int v &#x3D; states[i-1][j] + value[i];</span><br><span class="line">        if (v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">          states[i][j+weight[i]] &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 找出最大值</span><br><span class="line">  int maxvalue &#x3D; -1;</span><br><span class="line">  for (int j &#x3D; 0; j &lt;&#x3D; w; ++j) &#123;</span><br><span class="line">    if (states[n-1][j] &gt; maxvalue) maxvalue &#x3D; states[n-1][j];</span><br><span class="line">  &#125;</span><br><span class="line">  return maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个问题的时间、空间复杂度的分析，跟上一个例子大同小异，所以我就不赘述了。我直接给出答案，时间复杂度是 O(n<em>w)，空间复杂度也是 O(n</em>w)。跟上一个例子类似，空间复杂度也是可以优化的，你可以自己写一下。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>掌握了今天讲的两个问题之后，你是不是觉得，开篇的问题很简单？</p><p>对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 200 并且最接近 200 的组合是哪一个？但是，这样效率太低了点，时间复杂度非常高，是指数级的。当 n 很大的时候，可能“双十一”已经结束了，你的代码还没有运行出结果，这显然会让你在女朋友心中的形象大大减分。</p><p>实际上，它跟第一个例子中讲的 0-1 背包问题很像，只不过是把“重量”换成了“价格”而已。购物车中有 n 个商品。我们针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。我们还是用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。不过，这里的 x 值是多少呢？</p><p>0-1 背包问题中，我们找的是小于等于 w 的最大值，x 就是背包的最大承载重量 w+1。对于这个问题来说，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。就这个实际的问题而言，如果要购买的物品的总价格超过 200 太多，比如 1000，那这个羊毛“薅”得就没有太大意义了。所以，我们可以限定 x 值为 1001。</p><p>不过，这个问题不仅要求大于等于 200 的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们可以利用 states 数组，倒推出这个被选择的商品序列。我先把代码写出来，待会再照着代码给你解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; items商品价格，n商品个数, w表示满减条件，比如200</span><br><span class="line">public static void double11advance(int[] items, int n, int w) &#123;</span><br><span class="line">  boolean[][] states &#x3D; new boolean[n][3*w+1];&#x2F;&#x2F;超过3倍就没有薅羊毛的价值了</span><br><span class="line">  states[0][0] &#x3D; true;  &#x2F;&#x2F; 第一行的数据要特殊处理</span><br><span class="line">  if (items[0] &lt;&#x3D; 3*w) &#123;</span><br><span class="line">    states[0][items[0]] &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123; &#x2F;&#x2F; 动态规划</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; 3*w; ++j) &#123;&#x2F;&#x2F; 不购买第i个商品</span><br><span class="line">      if (states[i-1][j] &#x3D;&#x3D; true) states[i][j] &#x3D; states[i-1][j];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; 3*w-items[i]; ++j) &#123;&#x2F;&#x2F;购买第i个商品</span><br><span class="line">      if (states[i-1][j]&#x3D;&#x3D;true) states[i][j+items[i]] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int j;</span><br><span class="line">  for (j &#x3D; w; j &lt; 3*w+1; ++j) &#123; </span><br><span class="line">    if (states[n-1][j] &#x3D;&#x3D; true) break; &#x2F;&#x2F; 输出结果大于等于w的最小值</span><br><span class="line">  &#125;</span><br><span class="line">  if (j &#x3D;&#x3D; 3*w+1) return; &#x2F;&#x2F; 没有可行解</span><br><span class="line">  for (int i &#x3D; n-1; i &gt;&#x3D; 1; --i) &#123; &#x2F;&#x2F; i表示二维数组中的行，j表示列</span><br><span class="line">    if(j-items[i] &gt;&#x3D; 0 &amp;&amp; states[i-1][j-items[i]] &#x3D;&#x3D; true) &#123;</span><br><span class="line">      System.out.print(items[i] + &quot; &quot;); &#x2F;&#x2F; 购买这个商品</span><br><span class="line">      j &#x3D; j - items[i];</span><br><span class="line">    &#125; &#x2F;&#x2F; else 没有购买这个商品，j不变。</span><br><span class="line">  &#125;</span><br><span class="line">  if (j !&#x3D; 0) System.out.print(items[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的前半部分跟 0-1 背包问题没有什么不同，我们着重看后半部分，看它是如何打印出选择购买哪些商品的。</p><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j]或者 states[i-1][j-value[i]]是否是 true。</p><p>如果 states[i-1][j]可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]]可达，那就说明我们选择了购买第 i 个商品。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>动态规划的第一节到此就讲完了。内容比较多，你可能需要多一点时间来消化。为了帮助你有的放矢地学习，来强调一下，今天你应该掌握的重点内容。</p><p>今天的内容不涉及动态规划的理论，通过两个例子，给你展示了动态规划是如何解决问题的，并且一点一点详细给你讲解了动态规划解决问题的思路。这两个例子都是非常经典的动态规划问题，只要你真正搞懂这两个问题，基本上动态规划已经入门一半了。所以，你要多花点时间，真正弄懂这两个问题。</p><p>从例子中，你应该能发现，大部分动态规划能解决的问题，都可以通过回溯算法来解决，只不过回溯算法解决起来效率比较低，时间复杂度是指数级的。动态规划算法，在执行效率方面，要高很多。尽管执行效率提高了，但是动态规划的空间复杂度也提高了，所以，很多时候，我们会说，动态规划是一种空间换时间的算法思想。</p><p>我前面也说了，今天的内容并不涉及理论的知识。这两个例子的分析过程，我并没有涉及任何高深的理论方面的东西。而且，个人觉得，贪心、分治、回溯、动态规划，这四个算法思想有关的理论知识，大部分都是“后验性”的，也就是说，在解决问题的过程中，我们往往是先想到如何用某个算法思想解决问题，然后才用算法理论知识，去验证这个算法思想解决问题的正确性。所以，你大可不必过于急于寻求动态规划的理论知识。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>“杨辉三角”不知道你听说过吗？我们现在对它进行一些改造。每个位置的数字可以随意填写，经过某个数字只能到达下面一层相邻的两个数字。</p><p>假设你站在第一层，往下移动，我们把移动到最底层所经过的所有数字之和，定义为路径的长度。请你编程求出从最高层移动到最底层的最短路径长度。</p><p><img src="/2019/07/09/36-%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A6%82%E4%BD%95%E5%B7%A7%E5%A6%99%E8%A7%A3%E8%A7%A3%E5%86%B3%E2%80%9C%E5%8F%8C%E5%8D%81%E4%B8%80%E2%80%9D%E8%B4%AD%E7%89%A9%E6%97%B6%E7%9A%84%E5%87%91%E5%8D%95%E9%97%AE%E9%A2%98/49a52b81-98a3-405b-ae1b-7f65c6036856.jpg" alt></p><p><strong>回答：</strong></p><p>杨辉三角的动态规划转移方程是：S[i][j] = min(S[i-1][j],S[i-1][j-1]) + a[i][j]。<br>其中a表示到这个点的value值，S表示到a[i][j]这个点的最短路径值。<br>这里没有做边界条件限制，只是列出一个方程通式。边界条件需要在代码里具体处理。个人感觉动态规划的思想关键在于如何列出动态规划方程，有了方程，代码基本就是水到渠成了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35-回溯算法_从电影《蝴蝶效应》中学习回溯算法的核心思想</title>
      <link href="/2019/07/06/35-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BB%8E%E7%94%B5%E5%BD%B1%E3%80%8A%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94%E3%80%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/2019/07/06/35-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BB%8E%E7%94%B5%E5%BD%B1%E3%80%8A%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94%E3%80%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们前面的文章提到，深度优先搜索算法利用的是回溯算法思想。这个算法思想非常简单，但是应用却非常广泛。它除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。</p><p>除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。既然应用如此广泛，我们今天就来学习一下这个算法思想，看看它是如何指导我们解决问题的。</p><a id="more"></a><h2 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h2><p>在我们的一生中，会遇到很多重要的岔路口。在岔路口上，每个选择都会影响我们今后的人生。有的人在每个岔路口都能做出最正确的选择，最后生活、事业都达到了一个很高的高度；而有的人一路选错，最后碌碌无为。如果人生可以量化，那如何才能在岔路口做出最正确的选择，让自己的人生“最优”呢？</p><p>我们可以借助前面学过的贪心算法，在每次面对岔路口的时候，都做出看起来最优的选择，期望这一组选择可以使得我们的人生达到“最优”。但是，我们前面也讲过，贪心算法并不一定能得到最优解。那有没有什么办法能得到最优解呢？</p><p>2004 年上映了一部非常著名的电影《蝴蝶效应》，讲的就是主人公为了达到自己的目标，一直通过回溯的方法，回到童年，在关键的岔路口，重新做选择。当然，这只是科幻电影，我们的人生是无法倒退的，但是这其中蕴含的思想其实就是回溯算法。</p><p>笼统地讲，回溯算法很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是在一组可能的解中，搜索满足期望的解。</p><p>回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程分为多个阶段。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><p>理论的东西还是过于抽象，老规矩，我还是举例说明一下。我举一个经典的回溯例子，我想你可能已经猜到了，那就是八皇后问题。</p><p>我们有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。你可以看我画的图，第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式。</p><p><img src="/2019/07/06/35-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E4%BB%8E%E7%94%B5%E5%BD%B1%E3%80%8A%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94%E3%80%8B%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/c32861d9-bf35-4b6f-8a3b-cd42204701be.jpg" alt></p><p>我们把这个问题划分成 8 个阶段，依次将 8 个棋子放到第一行、第二行、第三行……第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。</p><p>回溯算法非常适合用递归代码实现，所以，我把八皇后的算法翻译成代码。我在代码里添加了详细的注释，你可以对比着看下。如果你之前没有接触过八皇后问题，建议你自己用熟悉的编程语言实现一遍，这对你理解回溯思想非常有帮助。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int[] result &#x3D; new int[8];&#x2F;&#x2F;全局或成员变量,下标表示行,值表示queen存储在哪一列</span><br><span class="line">public void cal8queens(int row) &#123; &#x2F;&#x2F; 调用方式：cal8queens(0);</span><br><span class="line">  if (row &#x3D;&#x3D; 8) &#123; &#x2F;&#x2F; 8个棋子都放置好了，打印结果</span><br><span class="line">    printQueens(result);</span><br><span class="line">    return; &#x2F;&#x2F; 8行棋子都放好了，已经没法再往下递归了，所以就return</span><br><span class="line">  &#125;</span><br><span class="line">  for (int column &#x3D; 0; column &lt; 8; ++column) &#123; &#x2F;&#x2F; 每一行都有8中放法</span><br><span class="line">    if (isOk(row, column)) &#123; &#x2F;&#x2F; 有些放法不满足要求</span><br><span class="line">      result[row] &#x3D; column; &#x2F;&#x2F; 第row行的棋子放到了column列</span><br><span class="line">      cal8queens(row+1); &#x2F;&#x2F; 考察下一行</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isOk(int row, int column) &#123;&#x2F;&#x2F;判断row行column列放置是否合适</span><br><span class="line">  int leftup &#x3D; column - 1, rightup &#x3D; column + 1;</span><br><span class="line">  for (int i &#x3D; row-1; i &gt;&#x3D; 0; --i) &#123; &#x2F;&#x2F; 逐行往上考察每一行</span><br><span class="line">    if (result[i] &#x3D;&#x3D; column) return false; &#x2F;&#x2F; 第i行的column列有棋子吗？</span><br><span class="line">    if (leftup &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 考察左上对角线：第i行leftup列有棋子吗？</span><br><span class="line">      if (result[i] &#x3D;&#x3D; leftup) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rightup &lt; 8) &#123; &#x2F;&#x2F; 考察右上对角线：第i行rightup列有棋子吗？</span><br><span class="line">      if (result[i] &#x3D;&#x3D; rightup) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void printQueens(int[] result) &#123; &#x2F;&#x2F; 打印出一个二维矩阵</span><br><span class="line">  for (int row &#x3D; 0; row &lt; 8; ++row) &#123;</span><br><span class="line">    for (int column &#x3D; 0; column &lt; 8; ++column) &#123;</span><br><span class="line">      if (result[row] &#x3D;&#x3D; column) System.out.print(&quot;Q &quot;);</span><br><span class="line">      else System.out.print(&quot;* &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个回溯算法的经典应用"><a href="#两个回溯算法的经典应用" class="headerlink" title="两个回溯算法的经典应用"></a>两个回溯算法的经典应用</h2><p>回溯算法的理论知识很容易弄懂。不过，对于新手来说，比较难的是用递归来实现。所以，我们再通过两个例子，来练习一下回溯算法的应用和实现。</p><h3 id="1-0-1-背包"><a href="#1-0-1-背包" class="headerlink" title="1.0-1 背包"></a>1.0-1 背包</h3><p>0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有一种简单但没有那么高效的解法，那就是今天讲的回溯算法。动态规划的解法我下一节再讲，我们先来看下，如何用回溯法解决这个问题。</p><p>0-1 背包问题有很多变体，我这里介绍一种比较基础的。我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？</p><p>实际上，背包问题我们在贪心算法那一节，已经讲过一个了，不过那里讲的物品是可以分割的，我可以装某个物品的一部分到背包里面。今天讲的这个背包问题，物品是不可分割的，要么装要么不装，所以叫 0-1 背包问题。显然，这个问题已经无法通过贪心算法来解决了。我们现在来看看，用回溯算法如何来解决。</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。不过，我们如何才能不重复地穷举出这 2^n 种装法呢？</p><p>这里就可以用回溯的方法。我们可以把物品依次排列，整个问题就分解为了 n 个阶段，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。描述起来很费劲，我们直接看代码，反而会更加清晰一些。</p><p>这里还稍微用到了一点搜索剪枝的技巧，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品。你可以看我写的具体的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int maxW &#x3D; Integer.MIN_VALUE; &#x2F;&#x2F;存储背包中物品总重量的最大值</span><br><span class="line">&#x2F;&#x2F; cw表示当前已经装进去的物品的重量和；i表示考察到哪个物品了；</span><br><span class="line">&#x2F;&#x2F; w背包重量；items表示每个物品的重量；n表示物品个数</span><br><span class="line">&#x2F;&#x2F; 假设背包可承受重量100，物品个数10，物品重量存储在数组a中，那可以这样调用函数：</span><br><span class="line">&#x2F;&#x2F; f(0, 0, a, 10, 100)</span><br><span class="line">public void f(int i, int cw, int[] items, int n, int w) &#123;</span><br><span class="line">  if (cw &#x3D;&#x3D; w || i &#x3D;&#x3D; n) &#123; &#x2F;&#x2F; cw&#x3D;&#x3D;w表示装满了;i&#x3D;&#x3D;n表示已经考察完所有的物品</span><br><span class="line">    if (cw &gt; maxW) maxW &#x3D; cw;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+1, cw, items, n, w);</span><br><span class="line">  if (cw + items[i] &lt;&#x3D; w) &#123;&#x2F;&#x2F; 已经超过可以背包承受的重量的时候，就不要再装了</span><br><span class="line">    f(i+1,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h3><p>看懂了 0-1 背包问题，我们再来看另外一个例子，正则表达式匹配。</p><p>对于一个开发工程师来说，正则表达式你应该不陌生吧？在平时的开发中，或多或少都应该用过。实际上，正则表达式里最重要的一种算法思想就是回溯。</p><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个（大于等于 0 个）任意字符，“?”匹配零个或者一个任意字符。基于以上背景假设，我们看下，如何用回溯算法，判断一个给定的文本，能否跟给定的正则表达式匹配？</p><p>我们依次考察正则表达式中的每个字符，当是非通配符时，我们就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</p><p>如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符。</p><p>有了前面的基础，是不是这个问题就好懂多了呢？我把这个过程翻译成了代码，你可以结合着一块看下，应该有助于你理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Pattern &#123;</span><br><span class="line">  private boolean matched &#x3D; false;</span><br><span class="line">  private char[] pattern; &#x2F;&#x2F; 正则表达式</span><br><span class="line">  private int plen; &#x2F;&#x2F; 正则表达式长度</span><br><span class="line"></span><br><span class="line">  public Pattern(char[] pattern, int plen) &#123;</span><br><span class="line">    this.pattern &#x3D; pattern;</span><br><span class="line">    this.plen &#x3D; plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public boolean match(char[] text, int tlen) &#123; &#x2F;&#x2F; 文本串及长度</span><br><span class="line">    matched &#x3D; false;</span><br><span class="line">    rmatch(0, 0, text, tlen);</span><br><span class="line">    return matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private void rmatch(int ti, int pj, char[] text, int tlen) &#123;</span><br><span class="line">    if (matched) return; &#x2F;&#x2F; 如果已经匹配了，就不要继续递归了</span><br><span class="line">    if (pj &#x3D;&#x3D; plen) &#123; &#x2F;&#x2F; 正则表达式到结尾了</span><br><span class="line">      if (ti &#x3D;&#x3D; tlen) matched &#x3D; true; &#x2F;&#x2F; 文本串也到结尾了</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pattern[pj] &#x3D;&#x3D; &#39;*&#39;) &#123; &#x2F;&#x2F; *匹配任意个字符</span><br><span class="line">      for (int k &#x3D; 0; k &lt;&#x3D; tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+1, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (pattern[pj] &#x3D;&#x3D; &#39;?&#39;) &#123; &#x2F;&#x2F; ?匹配0个或者1个字符</span><br><span class="line">      rmatch(ti, pj+1, text, tlen);</span><br><span class="line">      rmatch(ti+1, pj+1, text, tlen);</span><br><span class="line">    &#125; else if (ti &lt; tlen &amp;&amp; pattern[pj] &#x3D;&#x3D; text[ti]) &#123; &#x2F;&#x2F; 纯字符匹配才行</span><br><span class="line">      rmatch(ti+1, pj+1, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>回溯算法的思想非常简单，大部分情况下，都是用来解决广义的搜索问题，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。</p><p>尽管回溯算法的原理非常简单，但是却可以解决很多问题，比如我们开头提到的深度优先搜索、八皇后、0-1 背包问题、图的着色、旅行商问题、数独、全排列、正则表达式匹配等等。如果感兴趣的话，你可以自己搜索研究一下，最好还能用代码实现一下。如果这几个问题都能实现的话，你基本就掌握了回溯算法。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>回溯算法本质上就是枚举，优点在于其类似于摸着石头过河的查找策略，且可以通过剪枝少走冤枉路。它可能适合应用于缺乏规律，或我们还不了解其规律的搜索场景中。</p><p>0-1背包问题理解：</p><p>假设三个物品，每个物品在考虑时有两种选择，1-放进包，0-不放<br>11行代码表示不放进包里。13行代码表示放进包里。<br>三个物品遍历过程如下：</p><p>0 0 0 update maxW</p><p>0 0 1 update maxW</p><p>0 1 0 update maxW</p><p>0 1 1 update maxW</p><p>1 0 0 update maxW</p><p>1 0 1 update maxW</p><p>1 1 0 update maxW</p><p>1 1 1 update maxW</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>现在我们对今天讲到的 0-1 背包问题稍加改造，如果每个物品不仅重量不同，价值也不同。如何在不超过背包重量的情况下，让背包中的总价值最大？</p><p>可能思路：</p><p>价值/重量。算出比最大的，然后排序。然后再有选择的穷举？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34-分治算法_谈一谈大规模计算框架MapReduce中的分治思想</title>
      <link href="/2019/07/04/34-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/"/>
      <url>/2019/07/04/34-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 GFS 和 Bigtable。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p><p>尽管开发一个 MapReduce 看起来很高深，感觉跟我们遥不可及。实际上，万变不离其宗，它的本质就是我们今天要学的这种算法思想，分治算法。</p><a id="more"></a><h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p>为什么说 MapRedue 的本质就是分治算法呢？我们先来看，什么是分治算法？</p><p>分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>这个定义看起来有点类似递归的定义。关于分治和递归的区别，我们在排序（下）的时候讲过，<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li><p>分解：将原问题分解成一系列子问题；</p></li><li><p>解决：递归地求解各个子问题，若子问题足够小，则直接求解；</p></li><li><p>合并：将子问题的结果合并成原问题。</p></li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li><p>原问题与分解成的小问题具有相同的模式；</p></li><li><p>原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别，等我们讲到动态规划的时候，会详细对比这两种算法；</p></li><li><p>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</p></li><li><p>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。</p></li></ul><h2 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h2><p>理解分治算法的原理并不难，但是要想灵活应用并不容易。所以，接下来，会带你用分治算法解决我们在讲排序的时候涉及的一个问题，加深你对分治算法的理解。</p><p>还记得我们在排序算法里讲的数据的有序度、逆序度的概念吗？我当时讲到，我们用有序度来表示一组数据的有序程度，用逆序度表示一组数据的无序程度。</p><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度。</p><p><img src="/2019/07/04/34-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/4d611ab1-7066-43c0-a20a-bd377f7214df.jpg" alt></p><p>现在的问题是，<strong>如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong>因为有序对个数和逆序对个数的求解方式是类似的，所以你可以只思考逆序对个数的求解方法。</p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。那有没有更加高效的处理方法呢？</p><p>我们用分治算法来试试。我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p>我们前面讲过，使用分治算法其中一个要求是，子问题合并的代价不能太大，否则就起不了降低时间复杂度的效果了。那回到这个问题，如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？</p><p>这里就要借助归并排序算法了。你可以先试着想想，如何借助归并排序算法来解决呢？</p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</p><p><img src="/2019/07/04/34-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-%E8%B0%88%E4%B8%80%E8%B0%88%E5%A4%A7%E8%A7%84%E6%A8%A1%E8%AE%A1%E7%AE%97%E6%A1%86%E6%9E%B6MapReduce%E4%B8%AD%E7%9A%84%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/e835cab502bec3ebebab92381c667532.jpg" alt></p><p>尽管我画了张图来解释，但是我个人觉得，对于工程师来说，看代码肯定更好理解一些，所以我们把这个过程翻译成了代码，你可以结合着图和文字描述一起看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private int num &#x3D; 0; &#x2F;&#x2F; 全局变量或者成员变量</span><br><span class="line"></span><br><span class="line">public int count(int[] a, int n) &#123;</span><br><span class="line">  num &#x3D; 0;</span><br><span class="line">  mergeSortCounting(a, 0, n-1);</span><br><span class="line">  return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void mergeSortCounting(int[] a, int p, int r) &#123;</span><br><span class="line">  if (p &gt;&#x3D; r) return;</span><br><span class="line">  int q &#x3D; (p+r)&#x2F;2;</span><br><span class="line">  mergeSortCounting(a, p, q);</span><br><span class="line">  mergeSortCounting(a, q+1, r);</span><br><span class="line">  merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void merge(int[] a, int p, int q, int r) &#123;</span><br><span class="line">  int i &#x3D; p, j &#x3D; q+1, k &#x3D; 0;</span><br><span class="line">  int[] tmp &#x3D; new int[r-p+1];</span><br><span class="line">  while (i&lt;&#x3D;q &amp;&amp; j&lt;&#x3D;r) &#123;</span><br><span class="line">    if (a[i] &lt;&#x3D; a[j]) &#123;</span><br><span class="line">      tmp[k++] &#x3D; a[i++];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      num +&#x3D; (q-i+1); &#x2F;&#x2F; 统计p-q之间，比a[j]大的元素个数</span><br><span class="line">      tmp[k++] &#x3D; a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while (i &lt;&#x3D; q) &#123; &#x2F;&#x2F; 处理剩下的</span><br><span class="line">    tmp[k++] &#x3D; a[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  while (j &lt;&#x3D; r) &#123; &#x2F;&#x2F; 处理剩下的</span><br><span class="line">    tmp[k++] &#x3D; a[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  for (i &#x3D; 0; i &lt;&#x3D; r-p; ++i) &#123; &#x2F;&#x2F; 从tmp拷贝回a</span><br><span class="line">    a[p+i] &#x3D; tmp[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很多同学经常说，某某算法思想如此巧妙，我是怎么也想不到的。实际上，确实是的。有些算法确实非常巧妙，并不是每个人短时间都能想到的。比如这个问题，并不是每个人都能想到可以借助归并排序算法来解决，不夸张地说，如果之前没接触过，绝大部分人都想不到。但是，如果我告诉你可以借助归并排序算法来解决，那你就应该要想到如何改造归并排序，来求解这个问题了，只要你能做到这一点，我觉得就很棒了。</p><p>关于分治算法，我这还有两道比较经典的问题，你可以自己练习一下。</p><ul><li><p>二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p></li><li><p>有两个 n<em>n 的矩阵 A，B，如何快速求解两个矩阵的乘积 C=A</em>B？</p></li></ul><h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>分治算法思想的应用是非常广泛的，并不仅限于指导编程和算法设计。它还经常用在海量数据处理的场景中。我们前面讲的数据结构和算法，大部分都是基于内存存储和单机处理。但是，如果要处理的数据量非常大，没法一次性放到内存中，这个时候，这些数据结构和算法就无法工作了。</p><p>比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2、3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p>要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>比如刚刚举的那个例子，给 10GB 的订单排序，我们就可以先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是数据的存储与计算所在的机器是同一个或者在网络中靠的很近（比如一个局域网内，数据存取速度很快），否则就会因为数据访问的速度，导致整个处理过程不但不会变快，反而有可能变慢。</p><p>你可能还有印象，这个就是我在讲线性排序的时候举的例子。实际上，在前面已经学习的课程中，我还讲了很多利用分治思想来解决的问题。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>分治算法到此就讲完了，我们现在来看下开篇的问题，为什么说 MapReduce 的本质就是分治思想？</p><p>我们刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据（比如网页）。所以，利用集群并行处理显然是大势所趋。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。这不就是分治思想吗？</p><p>实际上，MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p><p>尽管 MapReduce 的模型非常简单，但是在 Google 内部应用非常广泛。它除了可以用来处理这种数据与数据之间存在关系的任务，比如 MapReduce 的经典例子，统计文件中单词出现的频率。除此之外，它还可以用来处理数据与数据之间没有关系的任务，比如对网页分析、分词等，每个网页可以独立的分析、分词，而这两个网页之间并没有关系。网页几十亿、上百亿，如果单机处理，效率低下，我们就可以利用 MapReduce 提供的高可靠、高性能、高容错的并行计算框架，并行地处理这几十亿、上百亿的网页。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了一种应用非常广泛的算法思想，分治算法。</p><p>分治算法用四个字概括就是“分而治之”，将原问题划分成 n 个规模较小而结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。这个思想非常简单、好理解。</p><p>今天我们讲了两种分治算法的典型的应用场景，一个是用来指导编码，降低问题求解的时间复杂度，另一个是解决海量数据处理问题。比如 MapReduce 本质上就是利用了分治思想。</p><p>我们也时常感叹 Google 的创新能力如此之强，总是在引领技术的发展。实际上，<strong>创新并非离我们很远，创新的源泉来自对事物本质的认识。无数优秀架构设计的思想来源都是基础的数据结构和算法，这本身就是算法的一个魅力所在</strong>。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>应用场景：</p><p>在统计方面比较多，比如统计我国人口，要知道我国人口就要先知道每个省人口，要知道省人口就要知道每个市人口，要知道市人口就要知道每个区县人口，直到村社区，然后汇总求的总人数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33-贪心算法_如何用贪心算法实现Huffman压缩编码</title>
      <link href="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"/>
      <url>/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基础的数据结构和算法我们基本上学完了，接下来几节，会讲几种更加基本的算法。它们分别是贪心算法、分治算法、回溯算法、动态规划。更加确切地说，它们应该是算法思想，并不是具体的算法，常用来指导我们设计具体的算法和编码等。</p><p>贪心、分治、回溯、动态规划这 4 个算法思想，原理解释起来都很简单，但是要真正掌握且灵活应用，并不是件容易的事情。所以，接下来的这 4 个算法思想的讲解，依旧不会长篇大论地去讲理论，而是结合具体的问题，让你自己感受这些算法是怎么工作的，是如何解决问题的，带你在问题中体会这些算法的本质。个人觉得，这比单纯记忆原理和定义要更有价值。</p><p>今天，我们先来学习一下贪心算法（greedy algorithm）。贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。最小生成树算法和最短路径算法我们后面会讲到，所以我们今天讲下霍夫曼编码，看看<strong>它是如何利用贪心算法来实现对数据压缩编码，有效节省数据存储空间的</strong>。</p><a id="more"></a><h2 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h2><p>关于贪心算法，我们先看一个例子。</p><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢？</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/1420210e-70e5-4349-a179-71ffb4af5e20.jpg" alt></p><p>实际上，这个问题很简单，我估计你一下子就能想出来，没错，我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。</p><p>这个问题的解决思路显而易见，它本质上借助的就是贪心算法。结合这个例子，我总结一下贪心算法解决问题的步骤，我们一起来看看。</p><p><strong>第一步，当我们看到这类问题的时候，首先要联想到贪心算法</strong>：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。</p><p>类比到刚刚的例子，限制值就是重量不能超过 100kg，期望值就是物品的总价值。这组数据就是 5 种豆子。我们从中选出一部分，满足重量不超过 100kg，并且总价值最大。</p><p><strong>第二步，我们尝试看下这个问题是否可以用贪心算法解决：</strong>每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。</p><p>类比到刚刚的例子，我们每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子。</p><p><strong>第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。</strong>大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。</p><p>实际上，用贪心算法解决问题的思路，并不总能给出最优解。</p><p>我来举一个例子。在一个有权图中，我们从顶点 S 开始，找一条到顶点 T 的最短路径（路径中边的权值和最小）。贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点 T。按照这种思路，我们求出的最短路径是 S-&gt;A-&gt;E-&gt;T，路径长度是 1+4+4=9。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/bbda6591-049b-4adf-9c58-45a435c7caff.jpg" alt></p><p>但是，这种贪心的选择方式，最终求的路径并不是最短路径，因为路径 S-&gt;B-&gt;D-&gt;T 才是最短路径，因为这条路径的长度是 2+2+2=6。为什么贪心算法在这个问题上不工作了呢？</p><p>在这个问题上，贪心算法不工作的主要原因是，前面的选择，会影响后面的选择。如果我们第一步从顶点 S 走到顶点 A，那接下来面对的顶点和边，跟第一步从顶点 S 走到顶点 B，是完全不同的。所以，即便我们第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。</p><h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><p>对于贪心算法，你是不是还有点懵？如果死抠理论的话，确实很难理解透彻。掌握贪心算法的关键是多练习。只要多练习几道题，自然就有感觉了。所以，本文带着你分析几个具体的例子，帮助你深入理解贪心算法。</p><h3 id="1-分糖果"><a href="#1-分糖果" class="headerlink" title="1. 分糖果"></a>1. 分糖果</h3><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;n)，所以糖果只能分配给一部分孩子。</p><p>每个糖果的大小不等，这 m 个糖果的大小分别是 s1，s2，s3，……，sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1，g2，g3，……，gn。</p><p>我的问题是，如何分配糖果，能尽可能满足最多数量的孩子？</p><p>我们可以把这个问题抽象成，从 n 个孩子中，抽取一部分孩子分配糖果，让满足的孩子的个数（期望值）是最大的。这个问题的限制值就是糖果个数 m。</p><p>我们现在来看看如何用贪心算法来解决。对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。</p><p>我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><h3 id="2-钱币找零"><a href="#2-钱币找零" class="headerlink" title="2. 钱币找零"></a>2. 钱币找零</h3><p>这个问题在我们的日常生活中更加普遍。假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？</p><p>在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p><p>在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少，这就是一种贪心算法的解决思路。直觉告诉我们，这种处理方法就是最好的。实际上，要严谨地证明这种贪心算法的正确性，需要比较复杂的、有技巧的数学推导，不建议你花太多时间在上面，不过如果感兴趣的话，可以自己去研究下。</p><h3 id="3-区间覆盖"><a href="#3-区间覆盖" class="headerlink" title="3. 区间覆盖"></a>3. 区间覆盖</h3><p>假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/23a7c129-5b67-47a6-ac04-41d31cd72ede.jpg" alt></p><p>这个问题的处理思路稍微不是那么好懂，不过，建议你最好能弄懂，因为这个处理思想在很多贪心算法问题中都有用到，比如任务调度、教师排课等等问题。</p><p>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。</p><p>我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/44b6386c-3b56-4a46-b851-4bab0dcaae10.jpg" alt></p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容就讲完了，我们现在来看开篇的问题，如何用贪心算法实现霍夫曼编码？</p><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits，那有没有更加节省空间的存储方式呢？</p><p>假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a、b、c、d、e、f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间。不过，还有没有更加节省空间的存储方式呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(000)、b(001)、c(010)、d(011)、e(100)、f(101)</span><br></pre></td></tr></table></figure><p>霍夫曼编码就要登场了。霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%～90% 之间。</p><p>霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。</p><p>对于等长的编码来说，我们解压缩起来很简单。比如刚才那个例子中，我们用 3 个 bit 表示一个字符。在解压缩的时候，我们每次从文本中读取 3 位二进制码，然后翻译成对应的字符。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/90a6ec87-72b7-41c5-b501-58ce2020c0ab.jpg" alt></p><p>假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/bdb23d15-fe48-4eb4-961b-04967f4e89e1.jpg" alt></p><p>尽管霍夫曼编码的思想并不难理解，但是如何根据字符出现频率的不同，给不同的字符进行不同长度的编码呢？这里的处理稍微有些技巧。</p><p>我们把每个字符看作一个节点，并且辅带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/7b6a08e7df45eac66820b959c64f877a.jpg" alt></p><p>现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。</p><p><img src="/2019/07/01/33-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E7%94%A8%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Huffman%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/2079ba0b-06e5-4cbf-a621-e005c0b675bf.jpg" alt></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了贪心算法。</p><p>实际上，贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。<strong>从我个人的学习经验来讲，不要刻意去记忆贪心算法的原理，多练习才是最有效的学习方法。</strong></p><p>贪心算法的最难的一块是如何将要解决的问题抽象成贪心算法模型，只要这一步搞定之后，贪心算法的编码一般都很简单。贪心算法解决问题的正确性虽然很多时候都看起来是显而易见的，但是要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，我们只需要多举几个例子，看一下贪心算法的解决方案是否真的能得到最优解就可以了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？</p><p>2 假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？</p><p><strong>回答：</strong></p><p>1. 非负整数，移除固定个数的数字，不管怎么移动最后剩下的位数都是固定的，只要我们保证最高位尽可能的小，就能让最后的数值最小。 那么思路如下：<br>      每次比较最高位和次高位，移除最大的那个数。这样最后的最高位总是最小的，值也就是最小的。</p><p>2. 对每个人的服务时间进行排序，每次服务需要的服务时间最小的。 原因如下，不管先服务谁，后面等待的人数都是固定的，每服务完一个人剩下等待的人就少一个，那么我们只需保证最少服务时间去匹配最大等待人数，就可以保证最终总服务时间最小</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32-AC自动机_如何用多模式串匹配实现敏感词过滤功能</title>
      <link href="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很多支持用户发表文本内容的网站，比如 BBS，大都会有敏感词过滤功能，用来过滤掉用户输入的一些淫秽、反动、谩骂等内容。你有没有想过，这个功能是怎么实现的呢？</p><p>实际上，这些功能最基本的原理就是字符串匹配算法，也就是通过维护一个敏感词的字典，当用户输入一段文字内容之后，通过字符串匹配算法，来查找用户输入的这段文字，是否包含敏感词。如果有，就用“***”把它替代掉。</p><p>我们前面讲过好几种字符串匹配算法了，它们都可以处理这个问题。但是，对于访问量巨大的网站来说，比如淘宝，用户每天的评论数有几亿、甚至几十亿。这时候，我们对敏感词过滤系统的性能要求就要很高。毕竟，我们也不想，用户输入内容之后，要等几秒才能发送出去吧？我们也不想，为了这个功能耗费过多的机器吧？<strong>那如何才能实现一个高性能的敏感词过滤系统呢？</strong>这就要用到今天的<strong>多模式串匹配算法</strong>。</p><a id="more"></a><h2 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h2><p>我们前面几节讲了好几种字符串匹配算法，有 BF 算法、RK 算法、BM 算法、KMP 算法，还有 Trie 树。前面四种算法都是单模式串匹配算法，只有 Trie 树是多模式串匹配算法。</p><p>我说过，单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。</p><p>尽管，单模式串匹配算法也能完成多模式串的匹配工作。例如开篇的思考题，我们可以针对每个敏感词，通过单模式串匹配算法（比如 KMP 算法）与用户输入的文字内容进行匹配。但是，这样做的话，每个匹配过程都需要扫描一遍用户输入的内容。整个过程下来就要扫描很多遍用户输入的内容。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p><p>与单模式匹配算法相比，多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。我们知道，Trie 树就是一种多模式串匹配算法。那如何用 Trie 树实现敏感词过滤功能呢？</p><p>我们可以对敏感词字典进行预处理，构建成 Trie 树结构。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那我们只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。</p><p>基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。我们知道，单模式串匹配算法中，KMP 算法对 BF 算法进行改进，引入了 next 数组，让匹配失败时，尽可能将模式串往后多滑动几位。借鉴单模式串的优化改进方法，能否对多模式串 Trie 树进行改进，进一步提高 Trie 树的效率呢？这就要用到 AC 自动机算法了。</p><h2 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h2><p>C 自动机算法，全称是 Aho-Corasick 算法。其实，Trie 树跟 AC 自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样，只不过前者针对的是多模式串而已。所以，<strong>AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了</strong>。如果代码表示，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class AcNode &#123;</span><br><span class="line">  public char data; </span><br><span class="line">  public AcNode[] children &#x3D; new AcNode[26]; &#x2F;&#x2F; 字符集只包含a~z这26个字符</span><br><span class="line">  public boolean isEndingChar &#x3D; false; &#x2F;&#x2F; 结尾字符为true</span><br><span class="line">  public int length &#x3D; -1; &#x2F;&#x2F; 当isEndingChar&#x3D;true时，记录模式串长度</span><br><span class="line">  public AcNode fail; &#x2F;&#x2F; 失败指针</span><br><span class="line">  public AcNode(char data) &#123;</span><br><span class="line">    this.data &#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，AC 自动机的构建，包含两个操作：</p><ul><li><p>将多个模式串构建成 Trie 树；</p></li><li><p>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）。</p></li></ul><p>关于如何构建 Trie 树，我们上一节已经讲过了。所以，这里我们就重点看下，<strong>构建好 Trie 树之后，如何在它之上构建失败指针？</strong></p><p>用一个例子给你讲解。这里有 4 个模式串，分别是 c，bc，bcd，abcd；主串是 abcd。</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/6d7081b2-c9b5-4200-9f14-582c3539fb04.jpg" alt></p><p>Trie 树中的每一个节点都有一个失败指针，它的作用和构建过程，跟 KMP 算法中的 next 数组极其相似。所以<strong>要想看懂这节内容，你要先理解 KMP 算法中 next 数组的构建过程</strong>。如果你还有点不清楚，建议你先回头去弄懂 KMP 算法。</p><p>假设我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的最长可匹配后缀子串，就是箭头指的 bc 模式串。</p><p>这里的最长可匹配后缀子串，我稍微解释一下。字符串 abc 的后缀子串有两个 bc，c，我们拿它们与其他模式串匹配，如果某个后缀子串可以匹配某个模式串的前缀，那我们就把这个后缀子串叫作<strong>可匹配后缀子串</strong>。</p><p>我们从可匹配后缀子串中，找出最长的一个，就是刚刚讲到的最长可匹配后缀子串。我们将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点。</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/b0cf3099-9c2e-4b6d-84a4-4fc13c34a7a0.jpg" alt></p><p>计算每个节点的失败指针这个过程看起来有些复杂。其实，如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。</p><p>我们可以像 KMP 算法那样，当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说，我们可以逐层依次来求解每个节点的失败指针。所以，失败指针的构建过程，是一个按层遍历树的过程。</p><p>首先 root 的失败指针为 NULL，也就是指向自己。<strong>当我们已经求得某个节点 p 的失败指针之后，如何寻找它的子节点的失败指针呢？</strong></p><p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc。</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/9b03c208-a682-4ae7-aa38-2f2efda41d2e.jpg" alt></p><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则令 q=q-&gt;fail（fail 表示失败指针，这里有没有很像 KMP 算法里求 next 的过程？），继续上面的查找，直到 q 是 root 为止，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root。</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/1b4856a4-94f8-4d1d-bf95-4b59c056a8cd.jpg" alt></p><p>我将构建失败指针的代码贴在这里，你可以对照着讲解一块看下，应该更容易理解。这里面，构建 Trie 树的代码我并没有贴出来，你可以参看上一节的代码，自己实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void buildFailurePointer() &#123;</span><br><span class="line">  Queue&lt;AcNode&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">  root.fail &#x3D; null;</span><br><span class="line">  queue.add(root);</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    AcNode p &#x3D; queue.remove();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 26; ++i) &#123;</span><br><span class="line">      AcNode pc &#x3D; p.children[i];</span><br><span class="line">      if (pc &#x3D;&#x3D; null) continue;</span><br><span class="line">      if (p &#x3D;&#x3D; root) &#123;</span><br><span class="line">        pc.fail &#x3D; root;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        AcNode q &#x3D; p.fail;</span><br><span class="line">        while (q !&#x3D; null) &#123;</span><br><span class="line">          AcNode qc &#x3D; q.children[pc.data - &#39;a&#39;];</span><br><span class="line">          if (qc !&#x3D; null) &#123;</span><br><span class="line">            pc.fail &#x3D; qc;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">          q &#x3D; q.fail;</span><br><span class="line">        &#125;</span><br><span class="line">        if (q &#x3D;&#x3D; null) &#123;</span><br><span class="line">          pc.fail &#x3D; root;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      queue.add(pc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过按层来计算每个节点的子节点的失效指针，刚刚举的那个例子，最后构建完成之后的 AC 自动机就是下面这个样子：</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/dd463ba0-6393-4238-a7ef-a8b7eaf207c8.jpg" alt></p><p>AC 自动机到此就构建完成了。我们现在来看下，<strong>如何在 AC 自动机上匹配主串？</strong></p><p>我们还是拿之前的例子来讲解。在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a。</p><ul><li><p>如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完之后，我们将 i 加一，继续这两个过程；</p></li><li><p>如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p-&gt;fail，然后继续这 2 个过程。</p></li></ul><p>关于匹配的这部分，文字描述不如代码看得清楚，所以我把代码贴了出来，非常简短，并且添加了详细的注释，你可以对照着看下。这段代码输出的就是，在主串中每个可以匹配的模式串出现的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void match(char[] text) &#123; &#x2F;&#x2F; text是主串</span><br><span class="line">  int n &#x3D; text.length;</span><br><span class="line">  AcNode p &#x3D; root;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">    int idx &#x3D; text[i] - &#39;a&#39;;</span><br><span class="line">    while (p.children[idx] &#x3D;&#x3D; null &amp;&amp; p !&#x3D; root) &#123;</span><br><span class="line">      p &#x3D; p.fail; &#x2F;&#x2F; 失败指针发挥作用的地方</span><br><span class="line">    &#125;</span><br><span class="line">    p &#x3D; p.children[idx];</span><br><span class="line">    if (p &#x3D;&#x3D; null) p &#x3D; root; &#x2F;&#x2F; 如果没有匹配的，从root开始重新匹配</span><br><span class="line">    AcNode tmp &#x3D; p;</span><br><span class="line">    while (tmp !&#x3D; root) &#123; &#x2F;&#x2F; 打印出可以匹配的模式串</span><br><span class="line">      if (tmp.isEndingChar &#x3D;&#x3D; true) &#123;</span><br><span class="line">        int pos &#x3D; i-tmp.length+1;</span><br><span class="line">        System.out.println(&quot;匹配起始下标&quot; + pos + &quot;; 长度&quot; + tmp.length);</span><br><span class="line">      &#125;</span><br><span class="line">      tmp &#x3D; tmp.fail;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>AC 自动机的内容讲完了，关于开篇的问题，你应该能解答了吧？实际上，我上面贴出来的代码，已经是一个敏感词过滤的原型代码了。它可以找到所有敏感词出现的位置（在用户输入的文本中的起始下标）。你只需要稍加改造，再遍历一遍文本内容（主串），就可以将文本中的所有敏感词替换成“***”。</p><p>所以我这里着重讲一下，<strong>AC 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效呢？</strong></p><p>首先，我们需要将敏感词构建成 AC 自动机，包括构建 Trie 树以及构建失败指针。</p><p>我们上一节讲过，Trie 树构建的时间复杂度是 O(m*len)，其中 len 表示敏感词的平均长度，m 表示敏感词的个数。那构建失败指针的时间复杂度是多少呢？我这里给出一个不是很紧确的上界。</p><p>假设 Trie 树中总的节点个数是 k，每个节点构建失败指针的时候，（你可以看下代码）最耗时的环节是 while 循环中的 q=q-&gt;fail，每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len，所以每个节点构建失败指针的时间复杂度是 O(len)。整个失败指针的构建过程就是 O(k*len)。</p><p>不过，AC 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。</p><p>我们再来看下，<strong>用 AC 自动机做匹配的时间复杂度是多少？</strong></p><p>跟刚刚构建失败指针的分析类似，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，实际情况下，可能近似于 O(n)，所以 AC 自动机做敏感词过滤，性能非常高。</p><p>你可以会说，从时间复杂度上看，AC 自动机匹配的效率跟 Trie 树一样啊。实际上，因为失效指针可能大部分情况下都指向 root 节点，所以绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度。只有在极端情况下，如图所示，AC 自动机的性能才会退化的跟 Trie 树一样。</p><p><img src="/2019/06/25/32-AC%E8%87%AA%E5%8A%A8%E6%9C%BA-%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%BB%A4%E5%8A%9F%E8%83%BD/b95a7564-706b-47fb-b238-105c56790ddb.jpg" alt></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了多模式串匹配算法，AC 自动机。单模式串匹配算法是为了快速在主串中查找一个模式串，而多模式串匹配算法是为了快速在主串中查找多个模式串。</p><p>AC 自动机是基于 Trie 树的一种改进算法，它跟 Trie 树的关系，就像单模式串中，KMP 算法与 BF 算法的关系一样。KMP 算法中有一个非常关键的 next 数组，类比到 AC 自动机中就是失败指针。而且，AC 自动机失败指针的构建过程，跟 KMP 算法中计算 next 数组极其相似。所以，要理解 AC 自动机，最好先掌握 KMP 算法，因为 AC 自动机其实就是 KMP 算法在多模式串上的改造。</p><p>整个 AC 自动机算法包含两个部分，第一部分是将多个模式串构建成 AC 自动机，第二部分是在 AC 自动机中匹配主串。第一部分又分为两个小的步骤，一个是将模式串构建成 Trie 树，另一个是在 Trie 树上构建失败指针。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>1</strong></p><p>一、单模式串匹配：</p><p>1. BF： 简单场景，主串和模式串都不太长, O(m*n)</p><p>2. KP：字符集范围不要太大且模式串不要太长， 否则hash值可能冲突，O(n)</p><p>3. naive-BM：模式串最好不要太长（因为预处理较重），比如IDE编辑器里的查找场景； 预处理O(m*m), 匹配O(n)， 实现较复杂，需要较多额外空间.</p><p>4. KMP：适合所有场景，整体实现起来也比BM简单，O(n+m)，仅需一个next数组的O(n)额外空间；但统计意义下似乎BM更快，原因不明.</p><p>5. 另外查资料的时候还看到一种比BM/KMP更快，且实现+理解起来都更容易的的Sunday算法，有兴趣的可以看这里:</p><p><a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/sundayen.htm" target="_blank" rel="noopener">http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/sundayen.htm</a></p><p><a href="https://www.jianshu.com/p/2e6eb7386cd3" target="_blank" rel="noopener">https://www.jianshu.com/p/2e6eb7386cd3</a></p><p>二、多模式串匹配：</p><p>1. naive-Trie: 适合多模式串公共前缀较多的匹配(O(n*k)) 或者 根据公共前缀进行查找(O(k))的场景，比如搜索框的自动补全提示.</p><p>2. AC自动机: 适合大量文本中多模式串的精确匹配查找, 可以到O(n).</p><p><strong>2</strong></p><p>单模式串匹配算法：</p><p>1 BF算法实现简单，但性能较差，适合主串和模式串比较小的场景</p><p>2 RK算法对BF算法进行了改进，通过构造巧妙的哈希函数减少匹配的次数。适合主串和模式串较短，且字符集合范围较小的场景</p><p>3 BM算法对BF进行了改进，性能较高，适合大部分文本查询场景。但是其中的坏字符规则比较耗费内存，当内存比较紧张时，可以仅使用好后缀规则，或者使用KMP算法</p><p>4 KMP算法空间和时间复杂度都较优，在主串较长时，应该选用kmp算法</p><p>多模字符串匹配算法：</p><p>1 Trie树：空间换时间，当各个模式串之间具有公共前缀时，空间利用率较高，适合前缀匹配。对于精确匹配，其性能低于红黑树和哈希表</p><p>2 AC自动机：基于Trie树的多模式串匹配算法，在Trie树节点引入了失效指针，使得一次遍历即可求得所有匹配的模式串。非常适用于多模式串匹配的场景</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-3-Docker容器用法</title>
      <link href="/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="1-Docker-容器"><a href="#1-Docker-容器" class="headerlink" title="1 Docker 容器"></a>1 Docker 容器</h2><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><h2 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2 启动容器"></a>2 启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><a id="more"></a><h3 id="2-1-新建并启动"><a href="#2-1-新建并启动" class="headerlink" title="2.1 新建并启动"></a>2.1 新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;</span><br><span class="line">Unable to find image &#39;ubuntu:14.04&#39; locally 14.04: Pulling from  library&#x2F;ubuntu cb56c90f0b30: Pull complete 0acc551e5716: Pull complete 8956dcd35143: Pull complete 908242721214: Pull complete b44ff14dd3bb: Pull complete Digest: sha256:5faf6cb681da2be979a177b60d8c18497f962e3d82268c49db6c74008d0c294d Status: Downloaded newer image for ubuntu:14.04 Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 &#x2F;bin&#x2F;bash root@af8bae53bdd3:&#x2F;#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@af8bae53bdd3:&#x2F;# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:&#x2F;# ps</span><br><span class="line">PID  TTY  TIME  CMD  </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="2-2-查看正在运行中的容器"><a href="#2-2-查看正在运行中的容器" class="headerlink" title="2.2 查看正在运行中的容器"></a>2.2 查看正在运行中的容器</h3><p>利用 <code>docker ps</code> 命令可以查看正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver</span><br></pre></td></tr></table></figure><h3 id="2-3-查看所有容器"><a href="#2-3-查看所有容器" class="headerlink" title="2.3 查看所有容器"></a>2.3 查看所有容器</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  25 minutes ago Exited (0) 25 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><h3 id="2-4-启动已终止的容器"><a href="#2-4-启动已终止的容器" class="headerlink" title="2.4 启动已终止的容器"></a>2.4 启动已终止的容器</h3><p>可以利用 <code>docker start</code> 命令和上面使用 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，直接将一个已经终止的容器启动运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker start relaxed_kilby</span><br><span class="line"></span><br><span class="line">relaxed_kilby</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  45 minutes ago Exited (0) 3 seconds ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><p>这里把 <strong>新建并启动</strong> 章节中的容器又启动了一次,这次这个容器和之前不一样,他启动之后就会被终止,不会输出一个 “Hello World”，之后才终止容器。可以看 <code>STATUS</code> 输出,这个容器的确被启动过.</p><h3 id="2-5-容器后台运行"><a href="#2-5-容器后台运行" class="headerlink" title="2.5 容器后台运行"></a>2.5 容器后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; </span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果(STDOUT)打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和docker run指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 命令来查看容器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">77b2dc01fe0f ubuntu:14.04 &#x2F;bin&#x2F;sh -c &#39;while tr 2 minutes ago Up 1 minute agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs [container ID  or  NAMES] hello world </span><br><span class="line">hello world </span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h3 id="2-6-终止容器"><a href="#2-6-终止容器" class="headerlink" title="2.6 终止容器"></a>2.6 终止容器</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop web2 </span><br><span class="line"></span><br><span class="line">web2</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot; About an hour ago Exited (0) 15 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Exited (0) 3  seconds ago web2 71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world &quot;&#x2F;hello&quot;  2 days ago Exited (0) 2 days ago peaceful_brown</span><br></pre></td></tr></table></figure><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止</p><h3 id="2-7-重启容器"><a href="#2-7-重启容器" class="headerlink" title="2.7 重启容器"></a>2.7 重启容器</h3><p><code>docker restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3 进入容器"></a>3 进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，有很多种方法，包括使用 <code>docker attach</code> 命令或 <code>nsenter</code> 工具等。</p><h3 id="3-1-attach-命令"><a href="#3-1-attach-命令" class="headerlink" title="3.1 attach 命令"></a>3.1 attach 命令</h3><p><code>docker attach</code> 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550  </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><p>是使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h3 id="3-2-nsenter-命令"><a href="#3-2-nsenter-命令" class="headerlink" title="3.2 nsenter 命令"></a>3.2 nsenter 命令</h3><h4 id="3-2-1-安装"><a href="#3-2-1-安装" class="headerlink" title="3.2.1 安装"></a>3.2.1 安装</h4><p><code>nsenter</code> 工具在 util-linux 包2.23版本后包含。<br>可以使用 <code>nsenter -V</code> 查看系统是否安装了 <code>nsenter</code> 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter -V</span><br><span class="line"></span><br><span class="line">nsenter from util-linux  2.23.2</span><br></pre></td></tr></table></figure><p>如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; curl https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;utils&#x2F;util-linux&#x2F;v2.24&#x2F;util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24; </span><br><span class="line">$ .&#x2F;configure --without-ncurses </span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="3-2-2-使用"><a href="#3-2-2-使用" class="headerlink" title="3.2.2 使用"></a>3.2.2 使用</h4><p><code>senter</code> 启动一个新的shell进程(默认是/bin/bash), 同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限。</p><p>为了连接到容器，你还需要找到容器的第一个进程的 PID，可以通过下面的命令获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID&#x3D;$(docker inspect --format  &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个 PID，就可以连接到这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $PID  --mount  --uts  --ipc  --net  --pid</span><br></pre></td></tr></table></figure><p>如果无法通过以上命令连接到这个容器，有可能是因为宿主的默认 shell 在容器中并不存在，比如zsh，可以使用如下命令显式地使用bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $pid  --mount  --uts  --ipc  --net  --pid  --  &#x2F;usr&#x2F;bin&#x2F;env  \  --ignore-environment  HOME&#x3D;&#x2F;root  &#x2F;bin&#x2F;bash  --login</span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubunt</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  </span><br><span class="line">243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia $ PID&#x3D;$(docker-pid 243c32535da7) 10981 </span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid </span><br><span class="line">root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><h2 id="4-导出和导入容器快照"><a href="#4-导出和导入容器快照" class="headerlink" title="4 导出和导入容器快照"></a>4 导出和导入容器快照</h2><h3 id="4-1-导出容器快照"><a href="#4-1-导出容器快照" class="headerlink" title="4.1 导出容器快照"></a>4.1 导出容器快照</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">7691a814370e ubuntu:14.04  &quot;&#x2F;bin&#x2F;bash&quot;  36 hours ago Exited (0) 21 hours ago test </span><br><span class="line">$ sudo docker export  7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="4-2-导入容器快照"><a href="#4-2-导入容器快照" class="headerlink" title="4.2 导入容器快照"></a>4.2 导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test&#x2F;ubuntu v1.0  </span><br><span class="line">9d37a6082e97 About a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure><p>*注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也$sudo docker rm trusting_newton trusting_newton要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5 删除容器"></a>5 删除容器</h2><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker rm trusting_newton trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="6-清理所有处于终止状态的容器-不建议使用"><a href="#6-清理所有处于终止状态的容器-不建议使用" class="headerlink" title="6 清理所有处于终止状态的容器(不建议使用)"></a>6 清理所有处于终止状态的容器(不建议使用)</h2><p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的 <code>docker rm</code> 默认并不会删除运行中的容器</p><h2 id="7-私有仓库"><a href="#7-私有仓库" class="headerlink" title="7 私有仓库"></a>7 私有仓库</h2><p>有时候使用阿里云这样的公共仓库可能不方便，用户可以创建一个本地仓库供自己使用。</p><h3 id="7-1-如何使用本地仓库"><a href="#7-1-如何使用本地仓库" class="headerlink" title="7.1 如何使用本地仓库"></a>7.1 如何使用本地仓库</h3><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库</p><h3 id="7-2-安装运行-docker-registry"><a href="#7-2-安装运行-docker-registry" class="headerlink" title="7.2 安装运行 docker-registry"></a>7.2 安装运行 docker-registry</h3><h4 id="7-2-1-容器中运行-docker-registry"><a href="#7-2-1-容器中运行-docker-registry" class="headerlink" title="7.2.1 容器中运行 docker-registry"></a>7.2.1 容器中运行 docker-registry</h4><p>在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 registry 镜像来启动本地的私有仓库。<br>用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run \ </span><br><span class="line">-e SETTINGS_FLAVOR&#x3D;s3 \ </span><br><span class="line">-e AWS_BUCKET&#x3D;acme-docker \ </span><br><span class="line">-e STORAGE_PATH&#x3D;&#x2F;registry \ </span><br><span class="line">-e AWS_KEY&#x3D;AKIAHSHB43HS3J92MXZ \ </span><br><span class="line">-e AWS_SECRET&#x3D;xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \ </span><br><span class="line">-e SEARCH_BACKEND&#x3D;sqlalchemy \ </span><br><span class="line">-p 5000:5000 \ </span><br><span class="line">registry</span><br></pre></td></tr></table></figure><p>此外，还可以指定本地路径（如 <code>/home/user/registry-conf</code> ）下的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;home&#x2F;user&#x2F;registry-conf:&#x2F;registry-conf  -e DOCKER_REGISTRY_CONFIG&#x3D;&#x2F;registry-conf&#x2F;config.yml registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>（v1 中是<code>/tmp/registry</code>）下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry</span><br></pre></td></tr></table></figure><h4 id="7-2-2-本地安装-docker-registry"><a href="#7-2-2-本地安装-docker-registry" class="headerlink" title="7.2.2 本地安装 docker-registry"></a>7.2.2 本地安装 docker-registry</h4><p>对于 CentOS 发行版，可以直接通过源安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel </span><br><span class="line">$ sudo python-pip install docker-registry</span><br></pre></td></tr></table></figure><p>也可以从 <a href="https://link.jianshu.com/?t=https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a> 项目下载源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev </span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-registry.git </span><br><span class="line">$ cd docker-registry </span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>然后修改配置文件，主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp config&#x2F;config_sample.yml config&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>之后启动 Web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn -c contrib&#x2F;gunicorn.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn --access-logfile  -  --error-logfile  -  -k gevent -b  0.0.0.0:5000  -w  4  --max-requests  100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功</p><p>*注：<code>config/config_sample.yml</code> 文件是示例配置文件。</p><h3 id="7-3-在私有仓库上传、下载、搜索镜像"><a href="#7-3-在私有仓库上传、下载、搜索镜像" class="headerlink" title="7.3 在私有仓库上传、下载、搜索镜像"></a>7.3 在私有仓库上传、下载、搜索镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 <code>192.168.7.26:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用<code>docker tag</code> 将 <code>ba58</code> 这个镜像标记为 <code>192.168.7.26:5000/test</code>（格式为 <code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag ba58 192.168.7.26:5000&#x2F;test</span><br><span class="line">root ~ # docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.7.26:5000&#x2F;test</span><br><span class="line">The push refers to  a repository [192.168.7.26:5000&#x2F;test] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository 192.168.7.26:5000&#x2F;test (1 tags)</span><br><span class="line">Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping</span><br><span class="line">Pushing tag for rev [ba5877dc9bec] on &#123;http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;repositories&#x2F;test&#x2F;tags&#x2F;latest&#125;</span><br></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;search</span><br><span class="line">&#123;&quot;num_results&quot;:  7, &quot;query&quot;:  &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;tomcat&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu_office&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;desktop_ubu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;dockerfile&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;test&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code>，表明镜像已经被成功上传了。</p><p>现在可以到另外一台机器去下载这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull 192.168.7.26:5000&#x2F;test</span><br><span class="line">Pulling repository 192.168.7.26:5000&#x2F;test</span><br><span class="line">ba5877dc9bec: Download complete </span><br><span class="line">511136ea3c5a: Download complete </span><br><span class="line">9bad880da3d2: Download complete </span><br><span class="line">25f11f5fb0cb: Download complete </span><br><span class="line">ebc34468f71d: Download complete </span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><h2 id="8-Docker-数据管理"><a href="#8-Docker-数据管理" class="headerlink" title="8 Docker 数据管理"></a>8 Docker 数据管理</h2><h3 id="8-1-数据卷"><a href="#8-1-数据卷" class="headerlink" title="8.1 数据卷"></a>8.1 数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li><li>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。<h3 id="8-2-创建一个数据卷"><a href="#8-2-创建一个数据卷" class="headerlink" title="8.2 创建一个数据卷"></a>8.2 创建一个数据卷</h3></li></ul><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>*注意：也可以在 Dockerfile 中使用 <code>VOLUME</code> 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="8-3-删除数据卷"><a href="#8-3-删除数据卷" class="headerlink" title="8.3 删除数据卷"></a>8.3 删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个<a href="https://github.com/moby/moby/pull/8484" target="_blank" rel="noopener">PR</a>。</p><h3 id="8-4-挂载一个主机目录作为数据卷"><a href="#8-4-挂载一个主机目录作为数据卷" class="headerlink" title="8.4 挂载一个主机目录作为数据卷"></a>8.4 挂载一个主机目录作为数据卷</h3><p>使用 <code>-v</code> 标记也可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code><br>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><p>*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>:ro</code> 之后，就挂载为只读了。</p><h3 id="8-5-查看数据卷的具体信息"><a href="#8-5-查看数据卷的具体信息" class="headerlink" title="8.5 查看数据卷的具体信息"></a>8.5 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看指定容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的<code>/var/lib/docker/volumes/</code>下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123; &quot;&#x2F;webapp&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;fac362...80535&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123; &quot;&#x2F;webapp&quot;: true &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的<code>/mnt/sda1/var/lib/docker/volumes/....</code>下面了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mounts&quot;: [ </span><br><span class="line">    &#123; </span><br><span class="line">        &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, </span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&#x2F;_data&quot;, </span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;webapp&quot;, </span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;, </span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;, </span><br><span class="line">        &quot;RW&quot;: true, </span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot; </span><br><span class="line">    &#125; </span><br><span class="line">] </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="8-6-挂载一个本地主机文件作为数据卷"><a href="#8-6-挂载一个本地主机文件作为数据卷" class="headerlink" title="8.6 挂载一个本地主机文件作为数据卷"></a>8.6 挂载一个本地主机文件作为数据卷</h3><p><code>-v</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><p>*注意：如果直接挂载一个文件，很多文件编辑工具，包括 <code>vi</code> 或者 <code>sed --in-place</code>，可能会造成文件 inode 的改变，从 Docker 1.1<br>.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h3 id="8-7-数据卷容器"><a href="#8-7-数据卷容器" class="headerlink" title="8.7 数据卷容器"></a>8.7 数据卷容器</h3><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>首先，创建一个名为 dbdata 的数据卷容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -v &#x2F;dbdata --name dbdata training&#x2F;postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure><p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training&#x2F;postgres </span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>可以使用超过一个的 <code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷。<br>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db3 --volumes-from db1 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。<br>这可以让用户在容器之间升级和移动数据卷。</p><h2 id="9-利用数据卷容器来备份、恢复、迁移数据卷"><a href="#9-利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="9 利用数据卷容器来备份、恢复、迁移数据卷"></a>9 利用数据卷容器来备份、恢复、迁移数据卷</h2><p>可以利用数据卷对其中的数据进行进行备份、恢复和迁移</p><h3 id="9-1-备份"><a href="#9-1-备份" class="headerlink" title="9.1 备份"></a>9.1 备份</h3><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 <code>backup.tar</code> 的文件。</p><h3 id="9-2-恢复"><a href="#9-2-恢复" class="headerlink" title="9.2 恢复"></a>9.2 恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</span><br></pre></td></tr></table></figure><p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run  --volumes-from dbdata2 busybox &#x2F;bin&#x2F;ls &#x2F;dbdata</span><br></pre></td></tr></table></figure><h2 id="10-Docker-中的网络功能介绍"><a href="#10-Docker-中的网络功能介绍" class="headerlink" title="10 Docker 中的网络功能介绍"></a>10 Docker 中的网络功能介绍</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id="10-1-外部访问容器"><a href="#10-1-外部访问容器" class="headerlink" title="10.1 外部访问容器"></a>10.1 外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P training&#x2F;webapp python app.py</span><br><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">bc533791f3f5 training&#x2F;webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000&#x2F;tcp nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f nostalgic_morse</span><br><span class="line">* Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F;</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F; HTTP&#x2F;1.1&quot;  200 -</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;  404 -</span><br></pre></td></tr></table></figure><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="10-2-映射所有接口地址"><a href="#10-2-映射所有接口地址" class="headerlink" title="10.2 映射所有接口地址"></a>10.2 映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-3-映射到指定地址的指定端口"><a href="#10-3-映射到指定地址的指定端口" class="headerlink" title="10.3 映射到指定地址的指定端口"></a>10.3 映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-4-映射到指定地址的任意端口"><a href="#10-4-映射到指定地址的任意端口" class="headerlink" title="10.4 映射到指定地址的任意端口"></a>10.4 映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 udp 标记来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 使用 &#96;docker port&#96; 来查看当前映射的端口配置，也可以查看到绑定的地址127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-5-查看映射端口配置"><a href="#10-5-查看映射端口配置" class="headerlink" title="10.5 查看映射端口配置"></a>10.5 查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -p  3000:80 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="11-容器互联"><a href="#11-容器互联" class="headerlink" title="11 容器互联"></a>11 容器互联</h2>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li></ul><p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p><h3 id="11-1-自定义容器命名"><a href="#11-1-自定义容器命名" class="headerlink" title="11.1 自定义容器命名"></a>11.1 自定义容器命名</h3><p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p><p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有2个好处</p><ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul><p>使用 <code>--name</code> 标记可以为容器自定义命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>使用 <code>docker ps</code> 来验证设定的命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f  &quot;&#123;&#123; .Name &#125;&#125;&quot; aed84ee21bde</span><br><span class="line">&#x2F;web</span><br></pre></td></tr></table></figure><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用<code>docker rm</code> 来删除之前创建的同名容器。</p><p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code>参数不能同时使用。</p><h3 id="11-2-容器互联"><a href="#11-2-容器互联" class="headerlink" title="11.2 容器互联"></a>11.2 容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p><p>下面先创建一个新的数据库容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>除之前创建的 web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f web</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web --link db:db training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。</p><p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p><p>使用 <code>docker ps</code> 来查看容器的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">349169744e49 training&#x2F;postgres:latest su postgres -c &#39;&#x2F;usr About a minute ago Up About a minute 5432&#x2F;tcp db, web&#x2F;db </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 16 hours ago Up 2 minutes 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p><p>Docker 通过 2 种方式为容器公开连接信息</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件<br>使用 <code>env</code> 命令来查看 web 容器的环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training&#x2F;webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME&#x3D;&#x2F;web2&#x2F;db DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP_PROTO&#x3D;tcp DB_PORT_5000_TCP_PORT&#x3D;5432 DB_PORT_5000_TCP_ADDR&#x3D;172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</li></ul><p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training&#x2F;webapp &#x2F;bin&#x2F;bash</span><br><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">. . . </span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 </p><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# apt-get install -yqq inetutils-ping root@aed84ee21bde:&#x2F;opt&#x2F;webapp# ping db  </span><br><span class="line">PING db (172.17.0.5):  48 data bytes </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.267 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.250 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.256 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试db容器，它会解析成 <code>172.17.0.5</code>。<br>*注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2-Docker镜像用法</title>
      <link href="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="1-使用-Dockerfile-定制镜像"><a href="#1-使用-Dockerfile-定制镜像" class="headerlink" title="1 使用 Dockerfile 定制镜像"></a>1 使用 Dockerfile 定制镜像</h2><p>从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><a id="more"></a><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx&#x2F;</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p><h2 id="2-FROM-指定基础镜像"><a href="#2-FROM-指定基础镜像" class="headerlink" title="2 FROM 指定基础镜像"></a>2 FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h2 id="3-RUN-执行命令"><a href="#3-RUN-执行命令" class="headerlink" title="3 RUN 执行命令"></a>3 RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 <code>RUN</code>指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每一层构建需要的命令写出来,比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make&#39;  \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y  $buildDeps  \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.5.tar.gz&quot;  \  &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1  \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="4-构建镜像"><a href="#4-构建镜像" class="headerlink" title="4 构建镜像"></a>4 构建镜像</h2><p>再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/23fb64e2-2346-432d-8f39-dad51df5c6a3.png" alt></p><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2/2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>785a648f6b86</code>，执行了所要求的命令，并最后提交了这一层 <code>3974e15fde03</code>，随后删除了所用到的这个容器 <code>785a648f6b86</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="5-镜像构建上下文（Context）"><a href="#5-镜像构建上下文（Context）" class="headerlink" title="5 镜像构建上下文（Context）"></a>5 镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，我原本以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是_相对路径_。这也是新人经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 . </span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="6-Dockerfile-指令详解"><a href="#6-Dockerfile-指令详解" class="headerlink" title="6 Dockerfile 指令详解"></a>6 Dockerfile 指令详解</h2><h3 id="6-1-COPY-复制文件"><a href="#6-1-COPY-复制文件" class="headerlink" title="6.1 COPY 复制文件"></a>6.1 COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="6-2-ADD-更高级的复制文件"><a href="#6-2-ADD-更高级的复制文件" class="headerlink" title="6.2 ADD 更高级的复制文件"></a>6.2 ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code>命令了。</p><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h3 id="6-3-CMD-容器启动命令"><a href="#6-3-CMD-容器启动命令" class="headerlink" title="6.3 CMD 容器启动命令"></a>6.3 CMD 容器启动命令</h3><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。<br><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo  $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。0</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h3 id="6-4-ENTRYPOINT-入口点"><a href="#6-4-ENTRYPOINT-入口点" class="headerlink" title="6.4 ENTRYPOINT 入口点"></a>6.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>NTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="6-4-1场景一：让镜像变成像命令一样使用"><a href="#6-4-1场景一：让镜像变成像命令一样使用" class="headerlink" title="6.4.1场景一：让镜像变成像命令一样使用"></a>6.4.1场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run myip -i </span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通 </span><br><span class="line">$ docker run myip -i </span><br><span class="line">HTTP&#x2F;1.1  200 OK </span><br><span class="line">Server: nginx&#x2F;1.8.0  </span><br><span class="line">Date: Tue, 22 Nov 2016  05:12:40 GMT </span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8 </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2 </span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6 </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Via: 1.1  cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="6-4-2-场景二：应用运行前的准备工作"><a href="#6-4-2-场景二：应用运行前的准备工作" class="headerlink" title="6.4.2 场景二：应用运行前的准备工作"></a>6.4.2 场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4  </span><br><span class="line">... </span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis </span><br><span class="line">... </span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] </span><br><span class="line"></span><br><span class="line">EXPOSE 6379 CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">... </span><br><span class="line"># allow the container to be started with &#96;--user&#96;  </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39;  -a  &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then </span><br><span class="line">chown -R redis . </span><br><span class="line">exec su-exec redis &quot;$0&quot;  &quot;$@&quot;  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec  &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h3 id="6-5-ENV-设置环境变量"><a href="#6-5-ENV-设置环境变量" class="headerlink" title="6.5 ENV 设置环境变量"></a>6.5 ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \ </span><br><span class="line">NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ </span><br><span class="line">&amp;&amp; curl -SLO  &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \ </span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ </span><br><span class="line">&amp;&amp; grep  &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c -\ </span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \ </span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ </span><br><span class="line">&amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量引用： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="6-6-ARG-构建参数"><a href="#6-6-ARG-构建参数" class="headerlink" title="6.6 ARG 构建参数"></a>6.6 ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="6-7-VOLUME-定义匿名卷"><a href="#6-7-VOLUME-定义匿名卷" class="headerlink" title="6.7 VOLUME 定义匿名卷"></a>6.7 VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v mydata:&#x2F;data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="6-8-EXPOSE-声明端口"><a href="#6-8-EXPOSE-声明端口" class="headerlink" title="6.8 EXPOSE 声明端口"></a>6.8 EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="6-9-WORKDIR-指定工作目录"><a href="#6-9-WORKDIR-指定工作目录" class="headerlink" title="6.9 WORKDIR 指定工作目录"></a>6.9 WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app </span><br><span class="line">RUN echo  &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="6-10-HEALTHCHECK-健康检查"><a href="#6-10-HEALTHCHECK-健康检查" class="headerlink" title="6.10 HEALTHCHECK 健康检查"></a>6.10 HEALTHCHECK 健康检查</h3><p>格式</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常.</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code>格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \ </span><br><span class="line">CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker  run  -d  --name  web  -p 80:80  myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  3  seconds ago Up 2  seconds (health: starting) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  18  seconds ago Up 16  seconds (healthy) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code></p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool </span><br><span class="line">&#123; </span><br><span class="line">    &quot;FailingStreak&quot;: 0, </span><br><span class="line">    &quot;Log&quot;: [ </span><br><span class="line">        &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, </span><br><span class="line">        &quot;ExitCode&quot;: 0, </span><br><span class="line">        &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;&#x2F;p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.org&#x2F;\&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;\nCommercial support is available at\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.com&#x2F;\&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&quot;, </span><br><span class="line">        &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; </span><br><span class="line">    &#125; </span><br><span class="line">], </span><br><span class="line">&quot;Status&quot;: &quot;healthy&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-11-ONBUILD-镜像复用及项目环境管理"><a href="#6-11-ONBUILD-镜像复用及项目环境管理" class="headerlink" title="6.11 ONBUILD 镜像复用及项目环境管理"></a>6.11 ONBUILD 镜像复用及项目环境管理</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F; </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。�第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新</p><p>么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">ONBUILD COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">ONBUILD COPY . &#x2F;app&#x2F;</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id="7-删除本地镜像"><a href="#7-删除本地镜像" class="headerlink" title="7 删除本地镜像"></a>7 删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker rmi</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><em>注意 <code>docker rm</code> 命令是删除容器，不要混淆</em></p><h3 id="7-1-用-ID、镜像名、摘要删除镜像"><a href="#7-1-用-ID、镜像名、摘要删除镜像" class="headerlink" title="7.1 用 ID、镜像名、摘要删除镜像"></a>7.1 用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。<br>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY  TAG  IMAGE  ID  CREATED  SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5  MB redis alpine 501ad78535f0  3 weeks ago 21.03  MB docker latest cf693ec9b5c7 3 weeks ago 105.1  MB nginx latest e43d811ce2f4 5 weeks ago 181.5  MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 501</span><br><span class="line">Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi centos </span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged:centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c </span><br><span class="line">Deleted:sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted:sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests </span><br><span class="line">REPOSITORY  TAG  DIGEST  IMAGE  ID  CREATED  SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214  MB  $ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="7-2-用-docker-images-命令来配合"><a href="#7-2-用-docker-images-命令来配合" class="headerlink" title="7.2 用 docker images 命令来配合"></a>7.2 用 docker images 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。如删除虚悬镜像的指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1-Docker用法</title>
      <link href="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/"/>
      <url>/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-开启docker服务"><a href="#1-开启docker服务" class="headerlink" title="1 开启docker服务"></a>1 开启docker服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动并加入开机启动</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line">验证安装是否成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">有 client 和 server两部分即表示安装成功。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-获取镜像命令-docker-pull"><a href="#2-获取镜像命令-docker-pull" class="headerlink" title="2 获取镜像命令 docker pull"></a>2 获取镜像命令 docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，而镜像名称的格式：</p><ul><li><p>Docker Registry地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，既 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像.一定要配置镜像加速器,不然下载速度很慢。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="2-1-pull下来的-镜像-存储在哪里呢？"><a href="#2-1-pull下来的-镜像-存储在哪里呢？" class="headerlink" title="2.1 pull下来的 镜像 存储在哪里呢？"></a>2.1 pull下来的 镜像 存储在哪里呢？</h3></li></ul><p>1 进入 docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">ls</span><br><span class="line">builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>2 进入containers,每一个序列号，都是一个镜像，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd containers&#x2F;</span><br><span class="line"></span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a</span><br><span class="line">a0356a312020a4941b257ada41d72efb041f7034a70a987ec3d0f44e9cc19402</span><br><span class="line">b81decb15c1f1f821d1c56bdadc15b62506b6cc102a6f083ec7a9b5f89c2685b</span><br><span class="line">ea1236fd8c7f4ce919c0f56b87b642487ecd2bbec243d416dd1e34b313b27b92</span><br></pre></td></tr></table></figure><p>3 进入其中一个镜像，发现目录结构如下，这就是这个镜像的内容了，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun 61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a]# ls</span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a-json.log  hostconfig.json  mounts</span><br><span class="line">checkpoints                                                                hostname         resolv.conf</span><br><span class="line">config.v2.json                                                             hosts            resolv.conf.hash</span><br></pre></td></tr></table></figure><p>4 在containers同级目录，有个叫image的文件夹，进入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd images&#x2F;aufs</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution imagedb layerdb repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br><span class="line"></span><br><span class="line">如果image没有aufs目录的，可能是这样的</span><br><span class="line"></span><br><span class="line">cd image&#x2F;overlay2&#x2F;</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution  imagedb  layerdb  repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br></pre></td></tr></table></figure><h2 id="3-查看已下载的镜像-docker-images"><a href="#3-查看已下载的镜像-docker-images" class="headerlink" title="3 查看已下载的镜像 docker images"></a>3 查看已下载的镜像 docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">列表 包含了仓库名、标签、镜像ID、创建时间、所占空间。</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><p>有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               2c5e00d77a67        3 weeks ago         188MB</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">[root@haoransun docker]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9de828f70b6d:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.6 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">root@9de828f70b6d:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令</p><ul><li><p><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:14.04</code>：这是指用<code>ubuntu:14.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 14.04.5 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="5-定制镜像"><a href="#5-定制镜像" class="headerlink" title="5 定制镜像"></a>5 定制镜像</h2><p>以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址,还要配置安全组放通对应的端口。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/749278bc-1a21-42ee-9643-a541b55dd3b5.png" alt></p><p>现在，改动这个欢迎页面，改成<code>Hello, Docker!</code>，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker exec -it webserver bash</span><br><span class="line">root@6415ebcbd369:&#x2F;# echo &#39;&lt;h1&gt;Hello,Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">root@6415ebcbd369:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e2cf02a5-8db5-451b-ad15-7144d09e93f2.png" alt></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff webserver</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/dd927ddb-c0ba-47dc-96fa-e7a5f48e5d4f.png" alt></p><h2 id="6-保存镜像"><a href="#6-保存镜像" class="headerlink" title="6 保存镜像"></a>6 保存镜像</h2><p>现在已经定制好了,那我们如何把它保存下来形成镜像?</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而<strong>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>下面的命令将容器保存为镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker commit --author &#39;haoransun&lt;xxxx@qq.com&gt;&#39; --message &#39;修改Nginx欢迎页面&#39; webserver nginx:v2</span><br><span class="line">sha256:cef47606fca7dd6a5ee72986d18641ac754973120312a7015bb228dee64cc02a</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/d21dbdd8-e230-4888-b179-46ba0b5d22fd.png" alt></p><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。</p><p>可以用 <code>docker images</code> 命令看到这个新定制的镜像：</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e168773c-e547-4d5a-86fb-d72e60cee08d.png" alt></p><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/782171db-773a-4ade-8335-092e6da4d2d6.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。否则访问 虚拟机的地址如：192.168.121.100:81。</p><p>完成了第一次定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="7-慎用-docker-commit"><a href="#7-慎用-docker-commit" class="headerlink" title="7 慎用  docker commit"></a>7 慎用  docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心没有清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p><code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制行为应该使用 <code>Dockerfile</code> 来完成。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2-Docker启动报错</title>
      <link href="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
      <url>/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>出处：<a href="https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA</a></p><h2 id="1-Docker虚拟化故障"><a href="#1-Docker虚拟化故障" class="headerlink" title="1 Docker虚拟化故障"></a>1 Docker虚拟化故障</h2><p>Docker虚拟化主要有三类故障：<br><strong>应用故障：</strong>应用执行状态与预期不一致。</p><p><strong>容器故障：</strong>无法正确创建、停止、更新容器等。</p><p><strong>集群故障：</strong>集群创建失败、更新失败、无法连接等。</p><a id="more"></a><h2 id="2-Docker-虚拟化故障排错"><a href="#2-Docker-虚拟化故障排错" class="headerlink" title="2 Docker 虚拟化故障排错"></a>2 Docker 虚拟化故障排错</h2><p>所有的Docker虚拟化故障排查诊断，都可以通过Docker命令行工具或者Web控制台来完成。</p><p>通过WEB控制台查看，需要自建控制台，对于Docker运维管理员来说，命令行工具排错是一个不错的帮手。</p><h3 id="2-1-案例1"><a href="#2-1-案例1" class="headerlink" title="2.1 案例1"></a>2.1 案例1</h3><p><strong>案例描述：</strong><br>生产环境，全新安装的Docker无法启动，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  docker.service</span><br><span class="line">Job for docker.service failed because the control process exited with  error code.See</span><br><span class="line">&quot;systemctl status docker.service&quot;  and  &quot;journalctl -xe&quot;  for details</span><br></pre></td></tr></table></figure><p>通过journalctl -xe命令查看启动的详细日志，启动daemon错误，因为Selinux不支持，Selinux阻挡了Docker引擎的启动，如图所示：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/bffe455a-b137-4cd1-b009-874dbeaaebf8.jpg" alt></p><p><strong>解决方案：</strong><br>如上问题，解决方法有两种：</p><p>1.Selinux主配置文件：</p><p>/etc/selinux/config，将配置文件中enforcing设置为disabled，然后重启系统，然后重启docker引擎即可。</p><p>2.docker主配置文件：</p><p>/etc/sysconfig/docker，将配置文件中–selinux-enabled选项为false，改成：–selinux-enabled=false即可。</p><h3 id="2-2-案例2"><a href="#2-2-案例2" class="headerlink" title="2.2 案例2"></a>2.2 案例2</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  socket at step GROUP: No such process</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/3bf44228-5466-47a3-a7fb-eae0c2c85e13.jpg" alt></p><p><strong>解决方案：</strong><br>如上错误提示是因为Docker无法找到Group组信息，docker组有可能被误删除，解决方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.创建宿主机docker组即可，命令：groupadd docker；</span><br><span class="line">2.&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket文件，SocketGroup&#x3D;修改为root也可以；</span><br></pre></td></tr></table></figure><h3 id="2-3-案例3"><a href="#2-3-案例3" class="headerlink" title="2.3 案例3"></a>2.3 案例3</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/4c8256fb-0669-4cc5-9381-30b95b45422f.jpg" alt></p><p>如上错误提示是因为Linux操作系统没有更多的Loopback 设备给Docker使用。</p><p><strong>解决方案：</strong><br>创建更多的Loopback设备即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i inseq 0 6;do mknod -m 0660 &#x2F;dev&#x2F;loop$i b 7 $i;done</span><br></pre></td></tr></table></figure><h3 id="2-4-案例4"><a href="#2-4-案例4" class="headerlink" title="2.4 案例4"></a>2.4 案例4</h3><p><strong>案例描述：</strong></p><p>Docker命令执行，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:</span><br><span class="line">&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>根据如上错误提示，该错误很明显可能是docker没有启动。</p><p><strong>解决方案：</strong></p><p>检测docker进程是否启动，ps -ef|grep docker，如果没有启动，启动Docker即可。</p><p>检测Docker进程存在，但是无法连接，可以重启一下Docker服务，检测一下Sock路径是否正确；<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/0e4560e9-3eff-484b-8da3-96e821d660ab.jpg" alt></p><h3 id="2-5-案例5"><a href="#2-5-案例5" class="headerlink" title="2.5 案例5"></a>2.5 案例5</h3><p><strong>案例描述：</strong><br>Docker获取远程镜像，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: dial tcp: lookup registry-1.docker.io</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/57f33576-3246-41b0-be58-c5382485a341.png" alt></p><p>该错误表示无法连接远程仓库Docker.io。</p><p><strong>解决方案：</strong></p><p>查看本地是否配置DNS，能否ping通docker.io；</p><p>如果能够ping通，但是下载还是比较慢，可以修改Docker仓库源为国内或者自建的仓库源；</p><p>Docker镜像修改方法，vim /etc/docker/daemon.json，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at&gt;&#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="2-6-案例6"><a href="#2-6-案例6" class="headerlink" title="2.6 案例6"></a>2.6 案例6</h3><p><strong>案例描述：</strong><br>启动Docker容器，报错信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;&#x2F;bin&#x2F;bash\&quot;: executable file not found in $PATH&quot;.</span><br></pre></td></tr></table></figure><p>如上报错，通常是由于容器启动时，不支持该命令：/bin/bash。</p><p><strong>解决方案：</strong></p><p>解决方法有如下两种：</p><p>修改启动命令为正确的Docker容器启动命令，例如修改为：/bin/sh或者sleep 99999d等；</p><p>Docker镜像自身问题或者Docker引擎版本比较低导致，可以升级Docker引擎版本服务；</p><h3 id="2-7-案例7"><a href="#2-7-案例7" class="headerlink" title="2.7 案例7"></a>2.7 案例7</h3><p><strong>案例描述：</strong><br>Docker虚拟化运行中，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br></pre></td></tr></table></figure><p>如上错误，表示Docker虚拟化引擎平台，没有多月的空间设备所使用，证明容器磁盘不足或者物理机磁盘不足。</p><p><strong>解决方案：</strong></p><p>手工删除Docker容器占用数据比较大的目录；</p><p>或者通过docker system prune自动删除一些日志目录，此种方法会停止所有容器；</p><p>或者临时增加Docker存储硬盘等；</p><h3 id="2-8-案例8"><a href="#2-8-案例8" class="headerlink" title="2.8 案例8"></a>2.8 案例8</h3><p><strong>案例描述：</strong><br>Docker push上传镜像至本地仓库报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [106.12.133.186:5000&#x2F;busybox] Get https:&#x2F;&#x2F;106.12.133.186:5000&#x2F;v1&#x2F;_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>根据如上错误提示，错误是由于客户端采用https，docker registry未采用https服务所致。一种处理方式是把客户对地址“106.12.133.186:5000”请求改为http。</p><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件。</span><br><span class="line">在文件中写入：&#123; &quot;insecure-registries&quot;:[&quot;106.12.133.186:5000&quot;] &#125; 。</span><br></pre></td></tr></table></figure><p>保存退出后，重启docker服务，问题即可解决。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-Docker安装与部署</title>
      <link href="/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-系统要求"><a href="#1-系统要求" class="headerlink" title="1 系统要求"></a>1 系统要求</h2><p>Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.</p><a id="more"></a><p><strong>centos-extras</strong> 库必须启用。默认情况下，此存储库已启用，但是如果将其禁用，则需要<strong>重启启用它</strong>。（自行搜索）</p><p>overlay2 建议使用存储驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r # 可查看内核版本</span><br></pre></td></tr></table></figure><h2 id="2-卸载旧版本"><a href="#2-卸载旧版本" class="headerlink" title="2 卸载旧版本"></a>2 卸载旧版本</h2><p>旧版本的Docker被称为 docker 或 docker-engine。如果已安装这些，请卸载它们及相关的依赖项、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">如果 yum报告没有安装这些软件包，则可以了、</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F; 保留包括图像、容器、卷和网络在内的内容。现在调用Docker CE包  docker-ce。</span><br></pre></td></tr></table></figure><h2 id="3-安裝-Docker"><a href="#3-安裝-Docker" class="headerlink" title="3 安裝 Docker"></a>3 安裝 Docker</h2><p>参考0-Docker</p><p><strong>Docker 通过运行 hello-world 映像验证是否正确安装。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令下载测试镜像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。如果你没有配置镜像加速器的话,运行 hello-world 命令来验证也是不会成功的.因为国内网络的原因,无法下载测试镜像,更别说运行测试镜像了,<font color="red">配置镜像加速器–参考0</font></p><h2 id="4-查看当前Docker版本"><a href="#4-查看当前Docker版本" class="headerlink" title="4 查看当前Docker版本"></a>4 查看当前Docker版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br><span class="line"></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO学习</title>
      <link href="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一、高并发互联网应用架构设计"><a href="#一、高并发互联网应用架构设计" class="headerlink" title="一、高并发互联网应用架构设计"></a>一、高并发互联网应用架构设计</h2><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/428003e0-81bd-46c5-9fd9-a97c25281220.jpg" alt></p><a id="more"></a><h3 id="1-架构的演变过程"><a href="#1-架构的演变过程" class="headerlink" title="1 架构的演变过程"></a>1 架构的演变过程</h3><h4 id="1-1-单一应用架构"><a href="#1-1-单一应用架构" class="headerlink" title="1.1 单一应用架构"></a>1.1 单一应用架构</h4><p>简单，维护成本高<br>ORM</p><h4 id="1-2-垂直应用架构"><a href="#1-2-垂直应用架构" class="headerlink" title="1.2 垂直应用架构"></a>1.2 垂直应用架构</h4><p>各司其职<br>MVC</p><h4 id="1-3-分布式服务架构"><a href="#1-3-分布式服务架构" class="headerlink" title="1.3 分布式服务架构"></a>1.3 分布式服务架构</h4><p>Cross JVM | Cross Machine<br>RPC (Remote Procedure Call)</p><h4 id="1-4-流动计算架构"><a href="#1-4-流动计算架构" class="headerlink" title="1.4 流动计算架构"></a>1.4 流动计算架构</h4><p>资源调度和服务治理<br>SOA (Service-Oriented Architecture)</p><h3 id="2-高并发网站的设计原则"><a href="#2-高并发网站的设计原则" class="headerlink" title="2 高并发网站的设计原则"></a>2 高并发网站的设计原则</h3><ol><li>X轴：硬件(水平扩展，比性能的垂直提升成本低-摩尔定律)、应用水平复制(应用无状态) 水平扩展</li><li>Y轴：硬件、业务垂直拆分 各司其职(泳道设计)</li><li>Z轴：X和Y轴打包之后 物理隔离</li></ol><h3 id="3-如何设计高效、高性能的应用服务？"><a href="#3-如何设计高效、高性能的应用服务？" class="headerlink" title="3 如何设计高效、高性能的应用服务？"></a>3 如何设计高效、高性能的应用服务？</h3><p>在分布式服务架构中，我们需要Cross JVM 或者 Cross Machine 传输数据，所以高效的RPC通信木星(Socket+IO) 是设计关键</p><h2 id="二、Java中网络-IO-模型"><a href="#二、Java中网络-IO-模型" class="headerlink" title="二、Java中网络(IO)模型"></a>二、Java中网络(IO)模型</h2><h3 id="1-IO模型分类"><a href="#1-IO模型分类" class="headerlink" title="1 IO模型分类"></a>1 IO模型分类</h3><h4 id="1-1-BIO"><a href="#1-1-BIO" class="headerlink" title="1.1 BIO"></a>1.1 BIO</h4><p>传统IO 或者 Blocking IO<br>特点：面向流 Input | Output</p><h4 id="1-2-NIO"><a href="#1-2-NIO" class="headerlink" title="1.2 NIO"></a>1.2 NIO</h4><p>New IO 或者 Non Blocking IO<br>特点：面向缓冲区 Buffer(基于通道)</p><h4 id="1-3-AIO-Async-Non-Blocking-IO"><a href="#1-3-AIO-Async-Non-Blocking-IO" class="headerlink" title="1.3 AIO(Async Non Blocking IO)"></a>1.3 AIO(Async Non Blocking IO)</h4><h3 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2 BIO"></a>2 BIO</h3><ol><li>方向————输入、输出流(InputStream | OutputStream)</li><li>类型————字节、字符流(Reader | Writer)</li><li>功能————节点、过滤流(BufferedInputStream |BufferedOutputStream)</li></ol><h3 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3 NIO"></a>3 NIO</h3><h4 id="3-1-Channel"><a href="#3-1-Channel" class="headerlink" title="3.1 Channel"></a>3.1 Channel</h4><p>通道、双向、可读可写<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2ffb3a8b-93fd-4ee4-bb66-9e61078a565c.jpg" alt></p><p>Channel的主要实现类有：</p><ul><li>FileChannel       —-文件IO</li><li>DatagramChannel   —-UDP</li><li>SocketChannel     —-TCP Client</li><li>ServerSocketChannel —-TCP Server</li></ul><h4 id="3-2-Buffer"><a href="#3-2-Buffer" class="headerlink" title="3.2 Buffer"></a>3.2 Buffer</h4><p>缓冲区<br>Buffer的主要实现类有：</p><ul><li>除boolean外的其余七种基本类型(ByteBuffer、ShortBuffer、IntBuffer等)</li></ul><h4 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h4><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/a3cad6d4-ec4c-46c6-b8e7-1374afcf5482.jpg" alt></p><h3 id="4-NIO-Buffer详解"><a href="#4-NIO-Buffer详解" class="headerlink" title="4 NIO Buffer详解"></a>4 NIO Buffer详解</h3><p>一个用于特定基本类型的数据容器，除数据内容外，还包含以下属性：</p><ol><li>capacity 缓冲区大小，常量不可变</li><li>limit 缓冲区允许读写操作的最大范围</li><li>position 缓冲区下一个可读写元素的索引</li></ol><p><strong>注：所有可操作的数据在position和limit之间</strong><br>操作图示：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3cbb0329-a79a-4926-903a-3f148f94acb4.jpg" alt></p><p>示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5ac188f8-dc23-4ab1-973d-3135401f0371.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/610fb173-c877-443f-b39c-224a341cdd5d.png" alt></p><p>测试结果：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/ce63f053-3583-46d2-b91a-fa4e5faa1bbf.jpg" alt></p><h3 id="5-NIO-IO操作-文件拷贝"><a href="#5-NIO-IO操作-文件拷贝" class="headerlink" title="5 NIO IO操作(文件拷贝)"></a>5 NIO IO操作(文件拷贝)</h3><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/49016de5-5e38-4d09-a159-7efc2b832248.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2bc74fd6-297d-4d5c-b7df-009a7c86a5ca.png" alt></p><h3 id="6-BIO-网络编程"><a href="#6-BIO-网络编程" class="headerlink" title="6 BIO 网络编程"></a>6 BIO 网络编程</h3><h4 id="6-1-服务器：ServerSocket"><a href="#6-1-服务器：ServerSocket" class="headerlink" title="6.1 服务器：ServerSocket"></a>6.1 服务器：ServerSocket</h4><ol><li>初始化服务器ServerSocket，绑定监听端口</li><li>等待客户端连接 ServerSocket.accept();</li><li>处理请求/响应 Socket.getInputStream(); / socket.getOutputStream();</li><li>关闭资源</li></ol><h4 id="6-2-客户端：Socket"><a href="#6-2-客户端：Socket" class="headerlink" title="6.2 客户端：Socket"></a>6.2 客户端：Socket</h4><ol><li>初始化客户端 Socket, 绑定服务器IP/端口</li><li>发起请求/获取响应 socket.getOutputStream(); /socket.getInputStream();</li><li>关闭资源</li></ol><p>客户端示例代码:<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bbfb9d5c-9766-4fe3-b51f-3500cd3356ed.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c36c47b4-7966-40b2-a434-a39c8667e2d8.jpg" alt></p><p>服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/db0236b3-4aea-47c6-a98e-f4c5da6c6a2b.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8bbcb471-fb02-4bc9-ae4c-8f247cb24bbb.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/18da21e4-9afa-4e04-be65-29c3c41596e7.jpg" alt></p><ol><li><strong>特点:</strong> accept() 是一个阻塞方法，当有客户端连接时，返回Socket对象，通过Socket对象的InputStream()或者 OutputStream() 接受请求发送响应结果。单请求服务器模型只能处理一个客户端的请求。</li><li><strong>缺点:</strong> 服务器必须能够处理多个客户端的请求和响应</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/53c62143-1d4a-4bdf-b96e-b98298b6d3f5.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/52bb442e-2f83-4bd4-a439-fd2067698169.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/78634985-5e0e-4fc7-a847-07ec068d69ae.png" alt></p><ol><li><strong>特点:</strong> 通过循环可以不断的接受客户端请求</li><li><strong>缺点:</strong> 请求的接受和IO处理在同一个线程中，客户端请求本质上是串行处理，无法支持高并发。</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/1f73e9db-1e95-49c7-b31c-b679f600d0b7.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3c1cd1d2-7b7b-4e09-bacc-caab7b0638c5.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5b2a809a-51e3-4776-802d-9acbc0d6063e.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/69989ce9-07a8-4342-b41b-5a4d44b897e0.png" alt></p><ol><li><strong>特点:</strong> 请求转发和IO处理，主线程只负责接受请求，IO的处理通过子线程完成。实现服务器的高性能</li><li><strong>缺点:</strong> 缺乏弹性伸缩能力，当客户端的访问量增加后，服务器的线程个数和客户端并发访问数量1:1正比关系，线程是宝贵的系统资源，数量过多，会造成系统性能急剧下降，导致服务器“宕机”</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bc55ffeb-ac01-4ddb-a223-ff3e4a57b0ab.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/aa445693-1c30-4853-a53c-3b4d37fb14aa.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/50c35557-c48e-4dd3-b338-fe76d919f54b.png" alt></p><ol><li><strong>特点:</strong> 通过线程池有效的管理线程，避免线程的重复创建、销毁而导致的系统资源过渡开销</li><li><strong>缺点:</strong> 限制了线程的数量，当有大量的并发请求时，超过最大线程数量的请求只能等待，直到线程池中有空闲的线程可以使用。对于BIO，当你发送一个请求的时候，你必须等待直到你获得返回结果。在服务端，这个意味着，一个线程同一时间最多只能和一个传入的连接相关联（直到这个连接被关闭)。<strong>先开线程，在线程中可能没有就绪的IO，导致线程的利用率不高。</strong></li></ol><h3 id="7-NIO-网络编程"><a href="#7-NIO-网络编程" class="headerlink" title="7 NIO 网络编程"></a>7 NIO 网络编程</h3><ul><li><strong>使用NIO API，替换BIO的多请求多线程版网络模型</strong></li></ul><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8db4046c-68c2-431c-91d3-ffcd02f72d11.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/92f0ac56-8ad0-456d-88d4-1515df43a651.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8080c448-9917-4193-aa79-f9f393884649.png" alt></p><ol><li><strong>特点:</strong> 使用NIO的API，通过面向通道的编程方式替换了BIO的编程模型</li><li><strong>缺点:</strong> 此模型跟BIO编程模型本质上没有区别(API差异)，实际上也没有解决IO的阻塞问题</li></ol><ul><li><strong>Selector</strong></li></ul><p>在NIO使用Channel管理所有的IO操作，<strong>Selector</strong>用于管理通道（注：需确保通道的操作都是非阻塞的），Channel和Selector配合使用</p><ol><li>通道需注册到选择器中（通道+关注的事件类型+附件信息）</li><li>选择器中的通道必须是非阻塞的</li><li>常用的事件类型<br>a. SelectionKey.OP_CONNECT 连接就绪<br>b. SelectionKey.OP_ACCEPT 接受就绪<br>c. SelctionKey.OP_READ 读就绪</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b26ac541-513f-4b25-adaa-f94cb240c700.jpg" alt></p><ul><li><p>NIO服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/15810dee-7cc1-429e-b4b7-a4f0d829fd3b.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/93b80458-99c0-4549-ac2a-f250076da709.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c43ce081-8600-4fae-8794-36245c068850.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8d05f649-64ab-4946-ab58-b8de71bfe6f1.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/322d23d0-d305-4dbc-b80d-ea44129accf5.png" alt></p></li><li><p>NIO客户端示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b76038c5-9207-4c33-8bc2-58e724a01935.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/23afa843-b264-4730-b742-ed428cc6420c.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/0eb2fee4-d836-469f-8d88-e62cb7557156.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/9cebd7f5-558c-4fa3-8f11-183f7206899b.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Docker缘由</title>
      <link href="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/"/>
      <url>/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>作者：雪雁<br><a href="https://www.cnblogs.com/codelove/p/10030439.html" target="_blank" rel="noopener">文章转载出自这里</a>：<a href="https://www.cnblogs.com/codelove/" target="_blank" rel="noopener">https://www.cnblogs.com/codelove/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着生产力的发展尤其是弹性架构的广泛应用（如微服务），许多一流开发者都将应用托管到了应用容器上，如Google、微软、亚马逊、阿里、京东、新浪等等。</p><a id="more"></a><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093206616-399407280.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093217472-1718656903.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093230803-632908603.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093244576-449593766.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093301329-915864692.png" alt></p><p>从未来的发展方向来看，容器引擎将会越来越成为主流，哪怕不是弹性架构，托管到应用容器也将是一种趋势——因为更低的开发运维和托管成本以及对服务器资源的优化配置，而且未来一个很大的趋势是————<strong>无服务器计算服务</strong></p><p>因为相对于软件、硬件在本地设备上的分裂，云计算的一大特性就是将服务构建在云上，供多种设备同时无缝调用。但事实上，云服务在发展的过程中还没能实现<strong>共融共通</strong>的理想————比如，各家的云服务是相对割裂的，开发者基于Google云服务构建的软件拿到亚马逊的AWS上也许就不能用了，阿里云的应用迁移到腾讯云可能就存在问题了；在任务执行层面，为防止互相干扰，云服务厂商在同一台服务器上执行多个任务时也会将他们隔离进行、很明显，这样的实例情况和云服务器的初始理念相去甚远。而利用容器技术，软件可以快速在各类云服务和基础设施上转换。而且，当割裂问题被解决后，软件也有希望在瞬间获取大量的计算能力。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093417505-465374977.png" alt></p><p>而Docker,就是容器引擎中的佼佼者，并且已经得到了广泛的实践和应用。有了Docker之后，软件的开发工作将会变得更加容易。如：开发者在笔记本电脑上写完一个软件后，可以将它转移到云服务上运行而无需做出更改；无论是自己的服务器、数据中心还是Google、微软、阿里云的云计算服务器，开发人员都可以按自己的想法在任何基础设施之间转移自己的软件。这也是未来的一个愿景——————<strong>机器和基础设施之间是可以互相替代的，整个互联网就是一个巨大的计算机</strong>。</p><p>Docker是如此的令人向往和引人深入，但是在国内，开发者普遍迁移到云端基本上也都是只用到了虚拟机等基础设施，其实大家都听过Docker,但是有一些偏见：</p><ul><li>缺乏完整的系统的教程和实践。开发者普遍认为使用Docker很麻烦，只有大公司用，门槛高‘</li><li>云端容器服务产品用户体验不多，对于初学者门槛太高——————此处是指消化这列概念和理念，并且能够掌握和可控。</li><li>对容器服务的认知还不够，对它的好处及吸引之处不太了解。</li><li>认为对现有系统、架构改造太大，成本太高；</li><li>认为Docker只是一种单纯的相对先进的技术，并不能给现有的开发带来什么概念；</li></ul><h2 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1 什么是Docker"></a>1 什么是Docker</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译通过的容器可以批量的在生产环境中部署，包括VMs(虚拟机)、bare metal、OpenStack集群和其他的基础应用平台。</p><p>简单理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093811704-1643592196.png" alt></p><p>因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器就充当着 软件部署 的标准单元，其中可以包含不同的代码和依赖项。按照这种方式的容器化软件。开发人员和IT专业人员只需要进行极少修改或者不修改，即可将其部署到不同的环境。</p><p>总而言这，Docker是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA和生产环境之间进行高效的应用程序生命周期管理。</p><h2 id="2-Docker和虚拟机的区别"><a href="#2-Docker和虚拟机的区别" class="headerlink" title="2 Docker和虚拟机的区别"></a>2 Docker和虚拟机的区别</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093906502-569967575.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093915205-139200956.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093934953-2128627412.png" alt></p><p>如上图所示，由于容器所需的资源要少很多（例如，他们不需要一个完整的OS），所以它们易于部署且可以快速启动、这使得你能够具有更高部署密度。即<strong>允许在同一硬件单元上运行更多服务，从而降低了成本。</strong></p><p>在同一内核上运行的时候，你获得的隔离比VM少。</p><p><font color="red">镜像的主要目标是使环境（依赖项）在不同的部署中保持不变。</font>，即可以在计算机上调试它，然后将其部署到保证具有相同环境的另一台计算机上。</p><p>借助容器镜像，可打包应用或者服务 并采用可靠且可重现的方式对其进行部署。可以说Docker不只是一种技术，还是一种原理和过程。</p><p>在使用Docker之前，经常听到，“这个问题在开发环境是正常的！”。而在使用Docker后，你不会听到开发人员说：“为什么它能在我的计算机上使用却不能用在生产中？”。开发人员只需要说 “它在Docker上运行”，因为打包的Docker应用程序可在任何支持的Docker环境上执行，而且它在所有部署目标（开发、QA、暂停和生产）上都按期运行。</p><h2 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3 基本概念"></a>3 基本概念</h2><h3 id="3-1-镜像：一个特殊的文件系统"><a href="#3-1-镜像：一个特殊的文件系统" class="headerlink" title="3.1 镜像：一个特殊的文件系统"></a>3.1 镜像：一个特殊的文件系统</h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂在root文件系统为其提供用户空间支持。而Docker镜像相当于是一个root文件系统。</p><p><strong>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（匿名卷、环境变量、用户等）。</strong></p><p>镜像是不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时。就充分利用 <strong>Union FS</strong>技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如：删除前一层文件的操作，实际上不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像时，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变得更为容易，甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的容器，构建新的镜像。</p><h3 id="3-2-容器：镜像运行时的实体"><a href="#3-2-容器：镜像运行时的实体" class="headerlink" title="3.2 容器：镜像运行时的实体"></a>3.2 容器：镜像运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中 类 和 实例一样，镜像时静态的定义，容器是进行运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己独立的命名空间，前面说过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按着Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态变化。</p><p>所有文件的写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094117580-274999612.png" alt></p><p><strong><font color="red">注意：</font></strong><br>容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。最重要的优点是可在开发和运营之间提供隔离。</p><h3 id="3-3-仓库：集中存放镜像文件的地方"><a href="#3-3-仓库：集中存放镜像文件的地方" class="headerlink" title="3.3 仓库：集中存放镜像文件的地方"></a>3.3 仓库：集中存放镜像文件的地方</h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。<strong>Docker Registry</strong>就是这样的服务。</p><p>一个Docker Registry 中可以包含多个仓库（Repository）:每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。</p><p>所以说，镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以latest作为默认标签。</p><p>这里补充一下：Docker Registry公开服务和私有 Docker Registry 的概念。</p><p>一般这类公共服务允许用户免费上传、下载公开镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常用的Registry 公开服务是官方的 <a href="hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>在国内访问Docker Hub可能比较慢，国内有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了公开服务外，用户还可以在本地搭建私有Docker Registry。Docker官方提供了 Docker Registry 镜像，可以直接使用作为私有Registry服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API的服务端实现，足以支持Docker命令，不影响使用，但不含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h2 id="4-Docker的主要应用场景"><a href="#4-Docker的主要应用场景" class="headerlink" title="4 Docker的主要应用场景"></a>4 Docker的主要应用场景</h2><h3 id="4-1-简化配置"><a href="#4-1-简化配置" class="headerlink" title="4.1 简化配置"></a>4.1 简化配置</h3><p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p><p>简单来说，容器镜像打包完成后，它就是个独立的个体了，丢到哪里都能跑，而无需针对各个平台去独立配置。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094246244-759574629.png" alt></p><h3 id="4-2-代码流水线（Code-Pipeline）管理"><a href="#4-2-代码流水线（Code-Pipeline）管理" class="headerlink" title="4.2 代码流水线（Code Pipeline）管理"></a>4.2 代码流水线（Code Pipeline）管理</h3><p>前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094322089-159857776.png" alt></p><h3 id="4-3-提高开发效率"><a href="#4-3-提高开发效率" class="headerlink" title="4.3 提高开发效率"></a>4.3 提高开发效率</h3><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想要快速搭建开发环境。</p><p>使用Docker非常简单的就能实现这两点，哪怕是开发环境的机器配置一般的情况下搭建多个生产服务应用。一台一般配置服务器或者开发机器也能轻松的跑起多个Docker应用，而无需额外增加机器配置。因为Docker有个非常NB的特性，<strong>拥有虚拟化的特性</strong>，而几乎没有额外的开销。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094410700-1435124978.png" alt></p><h3 id="4-4-隔离应用"><a href="#4-4-隔离应用" class="headerlink" title="4.4 隔离应用"></a>4.4 隔离应用</h3><p>很多情况下，我们需要在一台服务器上运行多个不同的应用，比如上面提到的提高开发效率的场景等。</p><p>考虑三点：一是因为要降低成本而进行服务器整合，二是讲一个整体式的应用拆分成松耦合的单个服务（如微服务架构），三是还需要考虑应用之间的兼容性。而对于Docker来说，支持起来非常简单。同一台机器，可以同时运行N个Docker Web应用，托管到不同的Web服务器（Kestrel、Nginx、Tomcat），而无需担心他们会搞起3Q大战，也不用担心开发机器跑步起来。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094456537-87357208.png" alt></p><h3 id="4-5-整合服务器"><a href="#4-5-整合服务器" class="headerlink" title="4.5 整合服务器"></a>4.5 整合服务器</h3><p>虚拟机可以整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p><p>这意味着资源得到更有效的利用——————可以做更多的衣服，而且没有边角料，成本更低。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094534267-1497649789.png" alt></p><h3 id="4-6-调试能力"><a href="#4-6-调试能力" class="headerlink" title="4.6 调试能力"></a>4.6 调试能力</h3><p>Docker提供很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多功能，包含可以设置容器检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094617391-1947396056.png" alt></p><h3 id="4-7-多租户环境"><a href="#4-7-多租户环境" class="headerlink" title="4.7 多租户环境"></a>4.7 多租户环境</h3><p>在多租户的应用中，它可以避免关键应用的重写。比如IoT(物联网)的应用中，开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间、也浪费金钱。</p><p>使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。</p><p>就如同我们现在写了一个不支持多租户的业务程序，而实际的业务中经常会出现需要支持多租户或者有新客户需要使用的场景，这时们通常的简单是——————部署一套新的代码。当站点达到一定量的适合，要么重写程序，要么维护人员Game Over。</p><h3 id="4-8-快速部署"><a href="#4-8-快速部署" class="headerlink" title="4.8 快速部署"></a>4.8 快速部署</h3><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。</p><p>你可以在服务器中或云端创建销毁资源而无需担心重新启动带来的开销。通常情况下，服务器的资源利用率只有30%，而通过使用Docker并进行有效的资源分配可以提高资源的利用率。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094717810-819940111.png" alt></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094748866-356935721.png" alt></p><p>Docker 带来的敏捷性（响应速度和灵活性）吸引了越来越多的开发者。他们不仅能知道容器内部到底跑了什么，也能进一步理解 Docker 如何加速了软件开发进程。另外，41% 的用户表示应用的可移植性是他们决定使用 Docker 的关键因素。</p><p><strong>通过 DevOps 的实践，Docker 正在给应用交付带来很多可以量化的提升</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094834979-29905994.png" alt></p><p>大约一半的受访者表示已经采用了持续集成（CI）和 DevOps，并且希望把这些实战经验应用到生产环境的持续交付中。剩下的受访者则准备尽快跟上步伐，尽快尝试 DevOps 和持续集成。另外，据调查显示，用户使用 Docker 发布应用的频率平均提升了 13 倍。</p><p><strong>Docker 对混合云策略至关重要，它使得用户可以根据需求自由选择私有和公有环境</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094910142-643670153.png" alt></p><p>通过容器来交付的应用可以在任何基础设施之上灵活迁移，同时这些基础设施又可以提供不同层次的应用管理方式，而当业务在多个服务供应商之中寻求混合云或全云模式时，又可以完美避免被平台捆绑。</p><p>对于按需部署或部署到云环境，Docker 提供了独一无二的选择。 80% 的用户表示 Docker 已经成为他们云策略的一部分，超过 35% 的用户使用 Docker 来避免被云服务供应商绑定。</p><p><strong>Docker 实现了微服务架构，也让遗留的单体应用转变为现代应用</strong></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094948673-1019599700.png" alt></p><p>Docker 使得微服务架构的快速发展成为可能，同时它也将传统的业务迁移到容器环境中，以此使得应用程序变得更加可移植。<strong>使用微服务架构进行交付是 Docker 的关键优势！</strong></p><h2 id="5-Docker改变了什么？"><a href="#5-Docker改变了什么？" class="headerlink" title="5 Docker改变了什么？"></a>5 Docker改变了什么？</h2><ul><li><p>Docker改变了云服务，使云服务的共融共通的理想逐步成为了可能。并且Docker 已经是云策略的一部分，许多开发者正在计划使用 Docker 将业务迁移到云端。另外，为了避免被云服务供应商绑定，Docker成为很多开发者的首选。</p></li><li><p>Docker改变了产品交付，为产品的整个生命周期提供了一整套的解决方案和流程。</p></li><li><p>Docker改变了开发方式，提供了简化的环境配置、封装的运行环境以及统一的环境。并且提供了快速部署的方式。</p></li><li><p>Docker改变了测试，多版本测试变得极为方便，快速构建测试环境也变得更加简单并且无需开发人员干预或者搭建。</p></li><li><p>Docker改变了运维，环境的一致性让运维变得更加简单，同时热更新的支持让运维不再需要半夜加班部署更新，更新可以随时进行。当出现重大问题时，还能快速回滚到指定版本。</p></li><li><p>Docker改变了架构，自动化扩容支持让架构变得更加简单，分布式系统也更加易于搭建和支持。同时遗留的单体应用也很易于转变为现代应用。</p></li></ul><p>总之，在某种程度上，Docker改变了产品开发中的一些游戏规则。虽然Docker是一项技术，但是它也带来了新的思维，新的流程和工作方法，Docker在推动行业的发展，Docker已经在改变世界，并且在逐步的变为事实……<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128095105560-528324521.png" alt></p><h2 id="6-Docker持续开发工作流"><a href="#6-Docker持续开发工作流" class="headerlink" title="6  Docker持续开发工作流"></a>6  Docker持续开发工作流</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203093658359-1691324108.png" alt></p><h2 id="7-DockerFile"><a href="#7-DockerFile" class="headerlink" title="7 DockerFile"></a>7 DockerFile</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094045768-1316009773.png" alt></p><p>虽然我们可以通过docker commit命令来手动创建镜像，但是通过Dockerfile文件，可以帮助我们自动创建镜像，并且能够自定义创建过程。本质上，Dockerfile就是由一系列<strong>命令</strong>和<strong>参数</strong>构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它简化了从头到尾的构建流程并极大的简化了部署工作。使用dockerfile构建镜像有以下好处：</p><ul><li><p>像编程一样构建镜像，支持分层构建以及缓存；</p></li><li><p>可以快速而精确地重新创建镜像以便于维护和升级；</p></li><li><p>便于持续集成；</p></li><li><p>可以在任何地方快速构建镜像</p></li></ul><h3 id="7-1-Dockerfile-指令"><a href="#7-1-Dockerfile-指令" class="headerlink" title="7.1 Dockerfile 指令"></a>7.1 Dockerfile 指令</h3><p>Dockerfile 指令为 Docker 引擎提供了创建容器映像所需的步骤。这些指令按顺序逐一执行。</p><h4 id="7-1-1-FROM"><a href="#7-1-1-FROM" class="headerlink" title="7.1.1 FROM"></a>7.1.1 FROM</h4><p>ROM 指令用于设置在新镜像创建过程期间将使用的容器映像。<br>格式：FROM<br>示例：<br>FROM nginx</p><h4 id="7-1-2-RUN"><a href="#7-1-2-RUN" class="headerlink" title="7.1.2 RUN"></a>7.1.2 RUN</h4><p>RUN 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。<br>格式：<br>RUN [“”, “”, “”]<br>RUN<br>示例：<br>RUN apt-get update<br>RUN mkdir -p /usr/src/redis<br>RUN apt-get update &amp;&amp; apt-get install -y libgdiplus<br>RUN [“apt-get”,”install”,”-y”,”nginx”]</p><p>注意：<font color="red">每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。使用换行符时，可能会遇到一些问题，具体可以参阅下节的转义字符</font>。</p><h4 id="7-1-3-COPY"><a href="#7-1-3-COPY" class="headerlink" title="7.1.3 COPY"></a>7.1.3 COPY</h4><p>COPY 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 Dockerfile 的路径中。<br>式：<br>COPY<br>如果源或目标包含空格，请将路径括在方括号和双引号中。<br>COPY [“”, “”]<br>示例：<br>COPY . .<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY . /usr/share/nginx/html<br>COPY hom* /mydir/</p><h4 id="7-1-4-ADD"><a href="#7-1-4-ADD" class="headerlink" title="7.1.4 ADD"></a>7.1.4 ADD</h4><p>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。<br>格式：<br>ADD<source> <destination><br>示例：<br>ADD <a href="https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe</a> /temp/python-3.5.1.exe<br>此示例会将 Python for Windows下载到容器映像的 c:\temp 目录。</destination></p><h4 id="7-1-5-WORKDIR"><a href="#7-1-5-WORKDIR" class="headerlink" title="7.1.5 WORKDIR"></a>7.1.5 WORKDIR</h4><p>WORKDIR 指令用于为其他 Dockerfile 指令（如 RUN、CMD）设置一个工作目录，并且还设置用于运行容器映像实例的工作目录。<br>格式：<br>WORKDIR<br>示例：<br>WORKDIR /app</p><h4 id="7-1-6-CMD"><a href="#7-1-6-CMD" class="headerlink" title="7.1.6 CMD"></a>7.1.6 CMD</h4><p>CMD指令用于设置部署容器映像的实例时要运行的默认命令。例如，如果该容器将承载 NGINX Web 服务器，则 CMD 可能包括用于启动Web服务器的指令，如 nginx.exe。 如果 Dockerfile 中指定了多个CMD 指令，只会计算最后一个指令。<br>格式：<br>CMD [“&lt;executable”, “<br>CMD<br>示例：<br>CMD [“c:\Apache24\bin\httpd.exe”, “-w”]<br>CMD c:\Apache24\bin\httpd.exe -w</p><h4 id="7-1-7-ENTRYPOINT"><a href="#7-1-7-ENTRYPOINT" class="headerlink" title="7.1.7 ENTRYPOINT"></a>7.1.7 ENTRYPOINT</h4><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。<br>格式：<br>ENTRYPOINT [“”, “”]<br>示例：<br>ENTRYPOINT [“dotnet”, “Magicodes.Admin.Web.Host.dll”]</p><h4 id="7-1-8-ENV"><a href="#7-1-8-ENV" class="headerlink" title="7.1.8 ENV"></a>7.1.8 ENV</h4><p>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。<br>格式：<br>ENV==…<br>示例：<br>ENV VERSION=1.0 DEBUG=on <br>NAME=”Magicodes”</p><h4 id="7-1-9-EXPOSE"><a href="#7-1-9-EXPOSE" class="headerlink" title="7.1.9 EXPOSE"></a>7.1.9 EXPOSE</h4><p>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。<br>格式：<br>EXPOSE<br>示例：<br>EXPOSE 80<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094342684-400475059.png" alt></p><h2 id="8-优化"><a href="#8-优化" class="headerlink" title="8 优化"></a>8 优化</h2><p>有几点值得注意的是：</p><ol><li><p>不能忽视dockerfile的优化，通常情况下，我们可以忽略那些细小的优化，但是我们需要知道优化的原理，为什么要优化</p></li><li><p>不能为了优化而优化。镜像的构建过程视业务情况情况不同，指令就有多到少的区别，在很多情况下，我们先要以满足业务目标为准，而不是镜像层数。如果需要减少镜像的层数，我们一定要选择合适的基础镜像，或者创建符合我们需要的基础镜像。</p></li></ol><p>优化准则：</p><ul><li><p>选择合适的基础镜像</p><p>这点相对最为重要。为什么这么说，我们结合现实社会也可以看到，在大部分情况下，一个人一生的成就更多的是看出身。很多情况下，基因和出身决定了你的高度和终点，这点拿到技术层面来说，也是有很大道理的，因此我们需要选择合适的父母——一个合适的镜像。</p><p>一个合适的基础镜像是指能满足运行应用所需要的最小的镜像，理论上是能用小的就不要用大的，能用轻量的就不要用重量级的，能用性能好的就不要用性能差的。这里有时候还需要考虑那些能够减少我们构建层数的基础镜像。</p></li><li><p>优化指令顺序</p><p>Docker会缓存Dockerfile中尚未更改的所有步骤，但是，如果更改任何指令，将重做其后的所有步骤。也就是指令3有变动，那么4、5、6就会重做。因此，我们需要将最不可能产生更改的指令放在前面，按照这个顺序来编写dockerfile指令。这样，在构建过程中，就可以节省很多时间。比如，我们可以把WORKDIR、ENV等命令放前面，COPY、ADD放后面。</p></li><li><p>合并指令</p><p>前面其实我们提到过这点，甚至还特地讲到了转义字符，其实主要是为此服务。前面我们说到了，每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p></li><li><p>删除多余文件和清理没用的中间结果</p><p>这点很易于理解，通常来讲，体积更小，部署更快！因此在构建过程中，我们需要清理那些最终不需要的代码或文件。比如说，临时文件、源代码、缓存等等。</p></li><li><p>使用 .dockerignore</p><p>.dockerignore文件用于忽略那些镜像构建时非必须的文件，这些文件可以是开发文档、日志、其他无用的文件。例如:<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094654908-278191045.png" alt></p></li></ul><h2 id="9-创建自定义Docker镜像"><a href="#9-创建自定义Docker镜像" class="headerlink" title="9 创建自定义Docker镜像"></a>9 创建自定义Docker镜像</h2><p>创建了Dockerfile之后，需为应用程序中的每项服务创建一个相关镜像。如果应用程序由单个服务或 Web 应用程序组成，则只需创建一个镜像。</p><p>我们可以使用docker build命令来创建镜像，例如：<br>docker build ./ -t {镜像名称}</p><p>镜像打包好后，我们使用docker image ls命令即可查看当前镜像。</p><p>注意：Docker镜像使用分层存储的架构，也就是说镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。因为分层存储的特征，使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。所以，当我们使用Docker images命令，会列出这么多的镜像，我们可以定期清理那些无用的镜像。</p><h2 id="10-在-docker-compose-yml中定义服务"><a href="#10-在-docker-compose-yml中定义服务" class="headerlink" title="10 在 docker-compose.yml中定义服务"></a>10 在 docker-compose.yml中定义服务</h2><h3 id="10-1-关于-Compose"><a href="#10-1-关于-Compose" class="headerlink" title="10.1 关于 Compose"></a>10.1 关于 Compose</h3><p>Compose是一个用于定义和运行多Docker应用程序的工具。使用Compose，我们可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，我们就可以从配置中创建并启动所有服务。</p><p>Compose适用于所有环境：生产环境、模拟（演示）环境、开发环境和测试环境以及CI工作流程。</p><p>主要功能和特性：</p><ul><li><p>单个主机上的多个隔离环境</p><p>Compose使用项目名称来隔离环境，因此可以根据不同的环境要求来进行定义。</p></li><li><p>创建容器时保留卷数据</p><p>Compose会保留服务使用的所有卷和数据。当使用docker-compose up命令运行时，如果发现该服务之前运行过，它会将进行增量操作，可确保在卷中创建的数据都不会丢失。</p></li><li><p>仅重新创建已更改的容器</p><p>Compose存在缓存，可用于创建容器。当重新启动未更改的服务时，Compose将重用现有容器。</p></li><li><p>可以定义变量，而且可以根据不同环境不同用户之间进行组合使用</p><p>Compose支持Compose文件的变量定义，我们可以使用这些变量为不同环境或不同用户进行自定义组合。</p></li></ul><p>另外，Compose能够通过命令管理应用程序的整个生命周期，通过命令可以：</p><ul><li><p>启动，停止和重建服务等</p></li><li><p>查看正在运行的服务的状态</p></li><li><p>通过流输出正在运行的服务的日志</p></li><li><p>对某个服务执行命令</p></li></ul><h2 id="11-常见场景"><a href="#11-常见场景" class="headerlink" title="11 常见场景"></a>11 常见场景</h2><ul><li><p>开发或本地环境运行多个服务</p><p>在开发过程时，在隔离环境中运行应用程序并与之交互的能力至关重要。Compose命令行工具可用于创建环境并与之交互。比如通过Compose文件，配置所有应用程序的服务依赖（数据库，消息队列，高速缓存，Web服务的API，等等），然后使用单个命令（docker-compose up）为每个依赖项创建和启动一个或多个容器，使整个程序能够正常运行起来。</p></li><li><p>自动化测试环境</p><p>任何持续部署或持续集成过程的一个重要部分是自动化测试套件。自动化端到端测试需要一个运行测试的环境。Compose提供了一种方便的方法来创建和销毁隔离的测试环境。我们只需要通过在Compose文件，即可定义完整环境，并且可以在几个命令中创建和销毁这些环境，如下所示：</p></li></ul><h2 id="12-使用Compose"><a href="#12-使用Compose" class="headerlink" title="12 使用Compose"></a>12 使用Compose</h2><p>使用Compose有以下三个步骤：</p><ol><li><p>使用Dockerfile定义应用环境，以便在任意地方进行复制</p></li><li><p>在 docker-compose.yml 中定义组合应用，以便它们可以在隔离的环境中一起运行</p></li><li><p>最后，执行docker-compose up命令，Compose 将启动并运行整个应用程序。</p></li></ol><h2 id="13-了解docker-compose-yml"><a href="#13-了解docker-compose-yml" class="headerlink" title="13 了解docker-compose.yml"></a>13 了解docker-compose.yml</h2><p>借助 docker-compose.yml 文件，我们可以定义一组相关服务，通过部署命令将其部署为组合应用程序。简单的说，我们可以通过docker-compose.yml来定义多个服务，以便一次执行。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094402699-10239551.png" alt></p><h2 id="14-了解YAML语言"><a href="#14-了解YAML语言" class="headerlink" title="14 了解YAML语言"></a>14 了解YAML语言</h2><p>YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p><p>这里提供一个YAML语法验证网站：<a href="http://nodeca.github.io/js-yaml/" target="_blank" rel="noopener">http://nodeca.github.io/js-yaml/</a></p><p>基本规则</p><ol><li><p>大小写敏感</p></li><li><p>使用缩进表示层级关系</p></li><li><p>禁止使用tab缩进，只能使用空格键</p></li><li><p>缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级</p></li><li><p>使用#表示注释</p></li><li><p>字符串可以不用引号标注</p></li></ol><p>YAML中允许表示三种格式，分别是常量值，对象和数组，如下所示：<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094613899-1061816782.png" alt></p><h2 id="15-docker-compose-yml文件配置项"><a href="#15-docker-compose-yml文件配置项" class="headerlink" title="15 docker-compose.yml文件配置项"></a>15 docker-compose.yml文件配置项</h2><p>docker-compose.yml 文件不仅指定正在使用的容器，还指定如何单独配置各容器。常用的配置项如下所示：</p><ul><li><p>uild：定义镜像生成，可以指定Dockerfile文件所在的目录路径，支持绝对路径和相对路径；</p></li><li><p>image：从指定的镜像中启动容器，可以是存储仓库、标签以及镜像 ID，如果镜像不存在，Compose 会自动拉去镜像；</p></li><li><p>environment：定义环境变量和配置；</p></li><li><p>ports：定义端口映射，比如上面配置中将容器上的公开端口 80 转接到主机上的外部端口 9901和9902；</p></li><li><p>depends_on，定义依赖关系。此定义会让当前服务处于等待状态，直到这些依赖服务启动。比如某个服务依赖数据库服务，那么通过此配置解决了服务的启动顺序的问题；</p></li><li><p>volumes，挂载一个目录或者一个已存在的数据卷容器，可以直接使用 HOST:CONTAINER 这样的格式，或者使用 HOST:CONTAINER:ro 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统；</p></li><li><p>context，指定Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url；</p></li><li><p>args,指定构建参数，这些参数只能在构建过程中访问；</p></li><li><p>target，定义构建指定的阶段Dockerfile，比如针对不同阶段使用不同的dockerfile，开发阶段使用支持编译调试的dockerfile，而生产环境，则使用轻量级的dockerfile；command，覆盖默认命令；</p></li><li><p>container_name，指定自定义容器名称，而不是生成的默认名称。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094653278-1319182904.png" alt></p></li></ul><p>小技巧：</p><ul><li><p>可以通过配置项depends_on来定义依赖关系，这点对于控制服务的执行顺序尤为重要，比如先启动数据库然后再启动web服务。</p></li><li><p>如何使用JSON文件进行配置？可以指定文件名称，如下所示：</p><p>docker-compose -f docker-compose.json up</p></li><li><p>如何分阶段构建？推荐使用target配置项。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-Docker配置国内免费registry_mirror</title>
      <link href="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/"/>
      <url>/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内特殊的网络环境，往往我们从 <strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></strong>中拉取镜像并不能成功，而且速度特别慢。</p><p>那么我们可以给Docker配置一个国内的registry mirror，当我们需要的镜像在mirror中则直接返回，如果没有则从Docker Hub中拉取。<font color="red">是否使用registry mirror对Docker用户来说是透明的</font>。</p><p>DaoCloud在国内提供了首个Docker Hub镜像服务，而且免费，大大提高了国内Docker用户的使用热情。</p><a id="more"></a><h2 id="1-DaoCloud使用方法"><a href="#1-DaoCloud使用方法" class="headerlink" title="1 DaoCloud使用方法"></a>1 DaoCloud使用方法</h2><p>修改Docker配置文件/etc/default/docker如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;aad0405c.m.daocloud.io&quot;</span><br></pre></td></tr></table></figure><p>使用<code>service docker restart</code>重启Docker服务即可。</p><p>在使用docker下载镜像时，在国内使用官方的Docker registry下载时速度很慢，庆幸国内还镜像加速服务。目前支持Docker镜像的有阿里云和DaoCloud两家。本文将详细讲解镜像服务的具体配置方法。</p><h2 id="2-Docker使用阿里云镜像库加速（推荐）"><a href="#2-Docker使用阿里云镜像库加速（推荐）" class="headerlink" title="2 Docker使用阿里云镜像库加速（推荐）"></a>2 Docker使用阿里云镜像库加速（推荐）</h2><p>注册阿里云开发者账号<br><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></p><p>登陆后取得专属加速器地址，类似这样 <code>https://9mpi2k3r.mirror.aliyuncs.com</code></p><h2 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3 步骤"></a>3 步骤</h2><h3 id="3-1-安装-升级Docker客户端"><a href="#3-1-安装-升级Docker客户端" class="headerlink" title="3.1 安装/升级Docker客户端"></a>3.1 安装/升级Docker客户端</h3><p>推荐安装1.10.0以上版本的Docker客户端，参考文档 <a href="https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.13be1991qOQrLG" target="_blank" rel="noopener">docker-ce</a></p><h3 id="3-2-Docker-CE镜像源站"><a href="#3-2-Docker-CE镜像源站" class="headerlink" title="3.2 Docker CE镜像源站"></a>3.2 Docker CE镜像源站</h3><p>官网下载手册</p><h3 id="3-3-CentOS7（使用yum进行安装-阿里云）"><a href="#3-3-CentOS7（使用yum进行安装-阿里云）" class="headerlink" title="3.3 CentOS7（使用yum进行安装-阿里云）"></a>3.3 CentOS7（使用yum进行安装-阿里云）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># Step 3: 更新并安装 Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"># Step 4: 开启Docker服务</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">注意：其他注意事项在下面的注释中</span><br><span class="line"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line"># vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br><span class="line">#   将 [docker-ce-test] 下方的 enabled&#x3D;0 修改为 enabled&#x3D;1</span><br><span class="line">#</span><br><span class="line"># 安装指定版本的Docker-CE:</span><br><span class="line"># Step 1: 查找Docker-CE的版本:</span><br><span class="line"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="line">#   Loading mirror speeds from cached hostfile</span><br><span class="line">#   Loaded plugins: branch, fastestmirror, langpacks</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   Available Packages</span><br><span class="line"># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span><br><span class="line"># sudo yum -y install docker-ce-[VERSION]</span><br><span class="line"># 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。</span><br><span class="line"># yum list docker-ce-selinux- --showduplicates | sort -r</span><br><span class="line"># sudo yum -y install docker-ce-selinux-[VERSION]</span><br><span class="line"></span><br><span class="line"># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令</span><br><span class="line"># 经典网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># VPC网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.could.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3-4-安装校验"><a href="#3-4-安装校验" class="headerlink" title="3.4 安装校验"></a>3.4 安装校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><h3 id="3-5-配置镜像加速器"><a href="#3-5-配置镜像加速器" class="headerlink" title="3.5 配置镜像加速器"></a>3.5 配置镜像加速器</h3><p>针对Docker客户端版本大于 1.10.0 的用户</p><p><img src="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/1f87538c-e8a2-455e-af33-8e0b3ff4a3f9.png" alt></p><p>您可以通过修改daemon配置文件（没有的话，需手动创建）<code>/etc/docker/daemon.json</code>来使用加速器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker </span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: # 此处使用自己的加速器[&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;]&#125;EOF </span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="4-daemon-json"><a href="#4-daemon-json" class="headerlink" title="4 daemon.json"></a>4 daemon.json</h2><p><strong>docker安装后默认是没有 daemon.json此配置文件的，需手动创建。</strong></p><p>daemon.json文件可配置的参数表，我们在配置的过程中，只需要设置我们需要的参数即可，不必全部写出来。详细参考官网。</p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#options</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;api-cors-header&quot;:&quot;&quot;,</span><br><span class="line">&quot;authorization-plugins&quot;:[],</span><br><span class="line">&quot;bip&quot;: &quot;&quot;,</span><br><span class="line">&quot;bridge&quot;:&quot;&quot;,</span><br><span class="line">&quot;cgroup-parent&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store-opts&quot;:&#123;&#125;,</span><br><span class="line">&quot;cluster-advertise&quot;:&quot;&quot;,</span><br><span class="line">&quot;debug&quot;: true, #启用debug的模式，启用后，可以看到很多的启动信息。默认false</span><br><span class="line">&quot;default-gateway&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-gateway-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-runtime&quot;:&quot;runc&quot;,</span><br><span class="line">&quot;default-ulimits&quot;:&#123;&#125;,</span><br><span class="line">&quot;disable-legacy-registry&quot;:false,</span><br><span class="line">&quot;dns&quot;: [&quot;192.168.1.1&quot;], # 设定容器DNS的地址，在容器的 &#x2F;etc&#x2F;resolv.conf文件中可查看。</span><br><span class="line">&quot;dns-opts&quot;: [], # 容器 &#x2F;etc&#x2F;resolv.conf 文件，其他设置</span><br><span class="line">&quot;dns-search&quot;: [], # 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜</span><br><span class="line">索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。</span><br><span class="line"> </span><br><span class="line">&quot;exec-opts&quot;: [],</span><br><span class="line">&quot;exec-root&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;graph&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃已废弃，使用data-root代替,这个主要看docker的版本</span><br><span class="line">&quot;data-root&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃Docker运行时使用的根路径,根路径下的内容稍后介绍，默认&#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line">&quot;group&quot;: &quot;&quot;, #Unix套接字的属组,仅指&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">&quot;hosts&quot;: [], #设置容器hosts</span><br><span class="line">&quot;icc&quot;: false,</span><br><span class="line">&quot;insecure-registries&quot;: [], #配置docker的私库地址</span><br><span class="line">&quot;ip&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;iptables&quot;: false,</span><br><span class="line">&quot;ipv6&quot;: false,</span><br><span class="line">&quot;ip-forward&quot;: false, #默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看</span><br><span class="line"> </span><br><span class="line">&quot;ip-masq&quot;:false,</span><br><span class="line">&quot;labels&quot;:[&quot;nodeName&#x3D;node-121&quot;], # docker主机的标签，很实用的功能,例如定义：–label nodeName&#x3D;host-121</span><br><span class="line"> </span><br><span class="line">&quot;live-restore&quot;: true,</span><br><span class="line">&quot;log-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-level&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-opts&quot;: &#123;&#125;,</span><br><span class="line">&quot;max-concurrent-downloads&quot;:3,</span><br><span class="line">&quot;max-concurrent-uploads&quot;:5,</span><br><span class="line">&quot;mtu&quot;: 0,</span><br><span class="line">&quot;oom-score-adjust&quot;:-500,</span><br><span class="line">&quot;pidfile&quot;: &quot;&quot;, #Docker守护进程的PID文件</span><br><span class="line">&quot;raw-logs&quot;: false,</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;xxxx&quot;], #镜像加速的地址，增加后在 docker info中可查看。</span><br><span class="line">&quot;runtimes&quot;: &#123;</span><br><span class="line">&quot;runc&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;runc&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;custom&quot;: &#123;</span><br><span class="line">&quot;path&quot;:&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;my-runc-replacement&quot;,</span><br><span class="line">&quot;runtimeArgs&quot;: [</span><br><span class="line">&quot;--debug&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;selinux-enabled&quot;: false, #默认 false，启用selinux支持</span><br><span class="line"> </span><br><span class="line">&quot;storage-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;storage-opts&quot;: [],</span><br><span class="line">&quot;swarm-default-advertise-addr&quot;:&quot;&quot;,</span><br><span class="line">&quot;tls&quot;: true, #默认 false, 启动TLS认证开关</span><br><span class="line">&quot;tlscacert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;ca.pem，通过CA认证过的的certificate文件路径</span><br><span class="line">&quot;tlscert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;cert.pem ，TLS的certificate文件路径</span><br><span class="line">&quot;tlskey&quot;: &quot;&quot;, #默认~&#x2F;.docker&#x2F;key.pem，TLS的key文件路径</span><br><span class="line">&quot;tlsverify&quot;: true, #默认false，使用TLS并做后台进程与客户端通讯的验证</span><br><span class="line">&quot;userland-proxy&quot;:false,</span><br><span class="line">&quot;userns-remap&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是官网docs提供的一个示例配置，我们可以参考，选择性的配置其中的部分内容。</p><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5 示例"></a>5 示例</h2><p>1、如何配置 registry 私库相关的参数<br>涉及以下2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [],  #这个私库的服务地址</span><br><span class="line">&quot;registry-mirrors&quot;: [],    #私库加速器</span><br></pre></td></tr></table></figure><p>2.配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line"># 配置阿里云镜像加速器 ：此处需使用自己个人加速器</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;],</span><br><span class="line"></span><br><span class="line"># 私库服务地址：个人一般用不到</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;https:&#x2F;&#x2F;ower.site.com&quot;]，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 重载配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"># 重启docker服务</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"># 查看状态</span><br><span class="line">sudo systemctl status docker -i</span><br><span class="line"># 查看服务</span><br><span class="line">sudo docker info</span><br><span class="line"># 当我们需要对docker服务进行调整配置时，不用去修改主文件 docker.service的参数，通过daemon.json配置文件来管理，更为安全、合理。</span><br></pre></td></tr></table></figure><h2 id="6-docker-hub官网提供国内镜像"><a href="#6-docker-hub官网提供国内镜像" class="headerlink" title="6 docker hub官网提供国内镜像"></a>6 docker hub官网提供国内镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;registry.docker-cn.com</span><br></pre></td></tr></table></figure><h2 id="7-检查加速器是否生效"><a href="#7-检查加速器是否生效" class="headerlink" title="7 检查加速器是否生效"></a>7 检查加速器是否生效</h2><p>如果 加速器太慢，可以更改加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"># 如果看到如下，则表示配置成功</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea常用插件及个性化配置</title>
      <link href="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea常用插件"><a href="#Idea常用插件" class="headerlink" title="Idea常用插件"></a>Idea常用插件</h1><h2 id="1-阿里代码规约检查"><a href="#1-阿里代码规约检查" class="headerlink" title="1 阿里代码规约检查"></a>1 阿里代码规约检查</h2><p>Alibaba Java Coding Guidelines</p><h2 id="2-lombok"><a href="#2-lombok" class="headerlink" title="2 lombok"></a>2 lombok</h2><p>一个在编译阶段修改增强Java类的工具，使用方式基于注解，常用于:</p><ul><li>为Java POJO生成属性对应的getter,setter等</li><li>为Java POJO生成builder构造器模式的实现</li><li>为Java类自动添加其他重复性代码，比如日志记录的声明代码可以通过@Slf4j注解添加</li></ul><p>项目中是否引入Lombok一直是个存在争议，它的主要优势在于消除Java类的部分臃肿代码，提高开发效率，降低代码维护成本；缺点是需要IDE插件支持，需要团队统一规范，另外某些注解生成的隐性实现可能导致问题跟踪调试困难。</p><a id="more"></a><p>第一步 下载插件<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/6b41d245-56a5-477e-9bc5-41a1b73cdf7f.png" alt></p><p>开启编译，防止编译时出错<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/963fd399-a722-4f50-b2c1-c5d6331ec897.png" alt></p><p>使用前需引入依赖<br>第二步：引入 lombok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>使用：</p><ul><li><p><strong>@Data</strong>：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法,相当于同时加上以下注解@Setter @Getter,@ToString,@EqualsAndHashCode</p></li><li><p>@Setter、@Getter：注解在类和属性上；为属性提供 setting、getting 方法</p></li><li><p>@ToString：生成toString方法，默认情况下，会输出类名、所有属性，属性按照顺序输出，以逗号分割。</p></li><li><p>@EqualsAndHashCode：实现equals()方法和hashCode()方法</p></li><li><p><strong>@Builder</strong>：构建 建造者模式</p></li><li><p><strong>@NonNull</strong>：该注解快速判断是否为空,如果为空,则抛出java.lang.NullPointerException</p></li><li><p>@Synchronized：该注解自动添加到同步机制,有趣的是,生成的代码并不是直接锁方法,而是锁代码块， 作用范围是方法上</p></li><li><p>@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象</p></li><li><p><strong>@NoArgsConstructor</strong>：注解在类上；为类提供一个无参的构造方法</p></li><li><p>@RequiredArgsConstructor：_注解在类上；为类提供一个部分参的构造方法(使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法)</p></li><li><p><strong>@AllArgsConstructor</strong>：注解在类上；为类提供一个全参的构造方法</p></li><li><p>@Cleanup：用于确保已分配的资源被释放,如IO的连接关闭</p></li><li><p>@SneakyThrows：抛异常</p></li><li><p>@Accessors(chain = true)：使用链式结构</p></li></ul><h2 id="3-Free-Mybatis-plugin"><a href="#3-Free-Mybatis-plugin" class="headerlink" title="3 Free Mybatis plugin"></a>3 Free Mybatis plugin</h2><p><strong>Free Mybatis plugin</strong> 方便于在Mapper接口与XML文件之间进行跳转。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/a3f8ca1f-fab4-4cdf-a3b1-4850634b4d17.jpg" alt></p><h2 id="4-Maven-Helper"><a href="#4-Maven-Helper" class="headerlink" title="4 Maven Helper"></a>4 Maven Helper</h2><p>手动打依赖树，使用 mvn dependency : tree 查看太过于繁琐。</p><p>Maven Helper是一个将maven依赖树可视化的插件，可以方便的查看依赖以及处理依赖冲突问题。对经常使用maven的同学来说可以说是神器。</p><p>安装好后，在 pom.xmlwe文件底部会多出一个 <strong>Dependency Analyzer</strong>选项<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/7db0ae9c-0721-424e-8ff6-ab30c72b934f.jpg" alt></p><p>点开后：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/9538d5c0-930b-462d-a2c4-ffe66d59d836.jpg" alt></p><p>找到冲突，点击右键，然后选择<strong>Exclude</strong>即可排除冲突版本的Jar包。</p><p>除此之外，还可以用Idea自带的——————Maven依赖结构图，打开Maven窗口，选择Dependencies，然后点击那个图标（Show Dependencies）或者使用快捷键（Ctrl+Alt+Shift+U），即可打开Maven依赖关系结构图</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/70199fe8-e8f3-4359-a8ea-8072b950f91e.jpg" alt></p><p>在图中，我们可以看到有一些红色的实线，这些红色实线就是依赖冲突，蓝色实线则是正常的依赖。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/3d90c5ad-10b7-47ad-9c68-6df72f2d4ac6.jpg" alt></p><h2 id="5-GsonFormat"><a href="#5-GsonFormat" class="headerlink" title="5 GsonFormat"></a>5 GsonFormat</h2><p>GsonFormat插件将JSONObject格式的字符串解析成实体，自动生成实体类。</p><p>自定义个javaBean(无任何内容，就一个空的类)</p><p>复制你要解析的json</p><p>然后alt+insert弹出如下界面 或者使用快捷键 alt+s</p><p>通过快捷键调出该插件<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/f4855842-db99-434b-8eee-634ea1e3dec3.png" alt></p><p>粘贴到如下界面：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/045a4ed2-faf5-4494-ba29-fb4f6478b63a.jpg" alt></p><p>点击ok,自动生成对应javaBean的代码：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/42f62daf-8b8d-4e72-932c-196b1e218cf9.png" alt></p><h2 id="6-GenerateAllSetter"><a href="#6-GenerateAllSetter" class="headerlink" title="6 GenerateAllSetter"></a>6 GenerateAllSetter</h2><p>方法： 在实例上 使用  alt + enter</p><p>GenerateAllSetter是一键调用一个对象的所有set方法并且赋予默认值的插件。在对象字段 多的时候非常方便，相当给力。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/cecc423d-87d8-4999-be78-947ac0090cd4.jpg" alt></p><h2 id="7-BashSupport"><a href="#7-BashSupport" class="headerlink" title="7 BashSupport"></a>7 BashSupport</h2><p>一个可以编写调试shell脚本的插件。</p><p>使用插件执行脚本<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/573c64f8-6302-451c-929c-e4e9168b1a17.png" alt></p><h2 id="8-PlantUml"><a href="#8-PlantUml" class="headerlink" title="8  PlantUml"></a>8  PlantUml</h2><p>PlantUml是一个画类图、时序图等的一个插件。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/ec4fed5a-e3b3-44d4-ba34-37cc528c43a5.jpg" alt></p><h2 id="9-Mybatis-log-plugin"><a href="#9-Mybatis-log-plugin" class="headerlink" title="9 Mybatis-log-plugin"></a>9 Mybatis-log-plugin</h2><p>开发的项目一般都少不了日志系统，而我们在书写mysql语句的时候，参数的对应，往往有时候会忽略，mybatis自己控制的参数编译对应，个人感觉有点反人类，我们可以使用这个插件变成自己比较直观的对应~</p><p>选中需要转换的mybatis log日志，然后点击右键，选择Restore sql from slection</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/01296088-a0b1-4b9b-b532-803a2a464f32.jpg" alt></p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/2cf0bc35-cadc-4257-a5b4-e48a0138bc85.jpg" alt></p><h2 id="9-Activate-power-mode或者Intellij-power-mode-II"><a href="#9-Activate-power-mode或者Intellij-power-mode-II" class="headerlink" title="9 Activate-power-mode或者Intellij_power_mode_II"></a>9 Activate-power-mode或者Intellij_power_mode_II</h2><p>个人感觉 没啥实用。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/20181029180853386.gif" alt></p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/20181029180908797.gif" alt></p><h1 id="Idea-个人习惯配置"><a href="#Idea-个人习惯配置" class="headerlink" title="Idea 个人习惯配置"></a>Idea 个人习惯配置</h1><h2 id="1-全局-默认-vs-当前"><a href="#1-全局-默认-vs-当前" class="headerlink" title="1 全局(默认) vs 当前"></a>1 全局(默认) vs 当前</h2><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/36bf81b8-0e9a-489c-b926-522f644df29f.jpg" alt></p><h2 id="2-全局JDK（默认配置）"><a href="#2-全局JDK（默认配置）" class="headerlink" title="2 全局JDK（默认配置）"></a>2 全局JDK（默认配置）</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settins -&gt; Default Project Structure -&gt; SDKs -&gt; JDK</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/88efb046-ae74-4693-9636-1052abbf1e53.jpg" alt></p><h2 id="3-全局-Maven-默认配置"><a href="#3-全局-Maven-默认配置" class="headerlink" title="3 全局 Maven(默认配置)"></a>3 全局 Maven(默认配置)</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Build &amp; Tools -&gt; Maven</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/c39b5ad9-2240-46de-a80d-238fdfa44929.jpg" alt></p><p>Maven配置文件</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/dfc2de6d-d0f3-41b5-bbfe-c4849560bc43.jpg" alt></p><p>Idea Maven神器</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/eca92eff-d2e7-4120-9a4d-e14b862e2755.jpg" alt></p><h2 id="4-配置Git"><a href="#4-配置Git" class="headerlink" title="4 配置Git"></a>4 配置Git</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Version Control -&gt; Git</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/e985cecb-db9d-4c3b-bf1a-8895cf8e7ec6.jpg" alt></p><h2 id="5-自动导包和只能移除-默认配置"><a href="#5-自动导包和只能移除-默认配置" class="headerlink" title="5 自动导包和只能移除(默认配置)"></a>5 自动导包和只能移除(默认配置)</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Auto Import</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/622053f5-c434-4650-92fa-6a76fbd17656.jpg" alt></p><h2 id="7-Tomcat-Server"><a href="#7-Tomcat-Server" class="headerlink" title="7 Tomcat Server"></a>7 Tomcat Server</h2><p>配置Tomcat方法： File -&gt; Settings -&gt; Deployment -&gt; Application Servers -&gt; Tomcat Server</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/47e4f3f2-a15e-45ea-9d24-b7bcc9cb671b.jpg" alt></p><h2 id="8-SpringBoot-在IDEA中实现热部署"><a href="#8-SpringBoot-在IDEA中实现热部署" class="headerlink" title="8 SpringBoot 在IDEA中实现热部署"></a>8 SpringBoot 在IDEA中实现热部署</h2><h3 id="1-开启Idea自动编译-静态"><a href="#1-开启Idea自动编译-静态" class="headerlink" title="1 开启Idea自动编译(静态)"></a>1 开启Idea自动编译(静态)</h3><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Auto Import</p><p>说明：开启自动编译之后，结合Ctrl+Shift+F9 会有热更新效果。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/f73b541d-257c-45c1-bf73-cf0733c268a7.jpg" alt></p><h3 id="2-开启Idea自动编译（Runtime-动态"><a href="#2-开启Idea自动编译（Runtime-动态" class="headerlink" title="2 开启Idea自动编译（Runtime)(动态)"></a>2 开启Idea自动编译（Runtime)(动态)</h3><p><strong>动态</strong><br>具体步骤： 敲击 Ctrl + Shift + Alt + /  然后双击Shift搜索进入Registry 勾选自动编译并调整延时参数。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/17bd9c5d-fdd3-4c62-8d15-8b47b54bc9ca.jpg" alt></p><ul><li><p>compiler.automake.allow.when.app.running -&gt; 自动编译</p></li><li><p>compile.document.save.trigger.delay -&gt; 自动更新文件</p></li></ul><p>第二个 它主要是针对静态文件如JS CSS的更新，将延迟时间减少后，直接按F5刷新页面就能看到效果！<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/2eee77bf-d3dd-44c9-a02a-4b7cee835e13.jpg" alt></p><h3 id="3-开启Idea热部署策略-重要"><a href="#3-开启Idea热部署策略-重要" class="headerlink" title="3 开启Idea热部署策略(重要)"></a>3 开启Idea热部署策略(重要)</h3><p>具体步骤：顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/6ea010c3-9cc3-42a8-afd7-ff16c5d935ba.jpg" alt></p><h3 id="4-在项目添加热部署插件（可选）"><a href="#4-在项目添加热部署插件（可选）" class="headerlink" title="4 在项目添加热部署插件（可选）"></a>4 在项目添加热部署插件（可选）</h3><p>如果因为旧项目十分臃肿，导致每次都自动热重启很慢而影响开发效率，笔者建议直接在POM移除<code>spring-boot-devtools</code>依赖，然后使用Control+Shift+F9进行手工免启动快速更新！！</p><p>具体步骤：在POM文件添加热部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="5-关闭浏览器缓存-重要"><a href="#5-关闭浏览器缓存-重要" class="headerlink" title="5 关闭浏览器缓存(重要)"></a>5 关闭浏览器缓存(重要)</h3><p>打开谷歌浏览器，打开F12的Network选项栏，然后勾选【✅】Disable cache 。、<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/c11b086a-4714-4bf2-8eb6-c21967514511.jpg" alt></p><h2 id="9-调整字体类型和字体大小"><a href="#9-调整字体类型和字体大小" class="headerlink" title="9 调整字体类型和字体大小"></a>9 调整字体类型和字体大小</h2><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/0a9450ae-f0f5-4e4c-9a4f-110c7011eba2.jpg" alt></p><h2 id="10-打开常用工具栏"><a href="#10-打开常用工具栏" class="headerlink" title="10 打开常用工具栏"></a>10 打开常用工具栏</h2><p>具体步骤：顶部导航栏 - View -&gt; 勾选 Toolbar &amp; Tool Buttons</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/b5d4d1d4-712a-4325-bd16-1f65b9ad88de.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT学习</title>
      <link href="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 文章出处： JSON Web Token–摘自<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>JSON Web Token</strong>(缩写 JWT)是目前最流行的跨域认证解决方案。</p><h1 id="1-跨域认证的问题"><a href="#1-跨域认证的问题" class="headerlink" title="1 跨域认证的问题"></a>1 跨域认证的问题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网离不开用户认证，一般流程是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户向服务器发送用户名和密码。</span><br><span class="line">服务器验证通过后，在当前会话（session）里面保存相关数据，比如用户角色、登录时间等。</span><br><span class="line">服务器向用户返回一个 session_id，写入用户的Cookie。</span><br><span class="line">用户随后的每一次请求，都会通过Cookie，将 session_id 回传服务器。</span><br><span class="line">服务器收到 session_id ，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的问题在于：扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例来说，A网站和B网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种解决方案是 session数据持久化，写入数据库或别的持久层。各种服务受到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种方案是服务器索性不保存 session数据了，所有数据都保存在客户端，每次请求都回传服务器。<strong>JWT</strong>就是这种方案的一个代表。</p><h1 id="2-JWT的原理"><a href="#2-JWT的原理" class="headerlink" title="2 JWT的原理"></a>2 JWT的原理</h1><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/874963-20180707150229764-2037235703.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT的原理是，服务器认证后，生成一个<strong>JSON 对象</strong>，发回给用户，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;:&quot;superadmin”</span><br><span class="line"> &quot;role&quot;:&quot;manager&quot;</span><br><span class="line"> &quot;expire_time：“2018-5-5 16:16:16”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后，用户与服务端通信的时候，都要发挥这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器再生成这个对象的时候，会家上<strong>签名</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器不再保存任何session数据了，即：服务器变成无状态了，从而较容易实现扩展。</p><h1 id="3-JWT的数据结构"><a href="#3-JWT的数据结构" class="headerlink" title="3 JWT的数据结构"></a>3 JWT的数据结构</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的JWT大概就像下面这样：<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/bg2018072304.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个很长的字符串。中间用点(.)分割成三个部分。注意。JWT内部是没有换行的，这里只是为了便与便于展示，将它写成了几行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT的三个部分依次如下：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）<br>即：Header.Payload.Signature<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/bg2018072303.jpg" alt></li></ul><h2 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Header</strong>部分就是一个JSON对象。描述了JWT的元数据，通常是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;:&quot;HS256&quot;</span><br><span class="line">  &quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，<font color="red"><strong>alg</strong>属性表示签名的算法（algorithm）,默认是HMAC SHA256(写成HS256)；<strong>typ</strong>属性标识这个令牌（Token）的类型（type），<strong>JWT</strong>令牌统一写成<strong>JWT</strong></font>。</p><h2 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Payload</strong>部分也是一个JSON对象，用来存放实际需要传递的数据。JWT官方规定了7个字段，供使用。</p><ul><li>iss（issuer) 签发人</li><li>exp(expiration time): 过期时间</li><li>sub(subject): 主体</li><li>aud(audience): 受众</li><li>nbf(Not Before): 生效时间</li><li>iat(Issued At): 签发时间</li><li>jti(JWT ID): 编号<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了官方字段，你可以在这个部分定义私有字段，如下所示：</li></ul><p>{<br> “sub” :”123456”<br> “name”:”superadmin”<br> “admin”:true</p><p>}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个JSON对象也要使用<strong>Base64URL算法</strong>转成字符串。</p><h2 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Signature</strong> 部分是对前两部分的签名。防止数据篡改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要指定一个密钥（secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。</p><p>HMACSHA256<br>(<br>       base64URLEncode(header)+”.”+<br>       base64URLEncode(payload),<br>       secret<br>)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用”点”(.)分割，即可返回给用户。</p><h2 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到，Header和Payload串行化的算法是Base64URL。这个算法跟Base64算法基本类似，但不同的是：<br><strong>JWT</strong>作为一个令牌（token)，有些场合可能会放到URL（如：api.example.com/token=xxx)。Base64有3个字符+、/和=。在URL里面有特殊含义，所以要被替换掉：=被省略、+替换成-、/换成_。这是Base64URL算法。</p><h1 id="4-JWT-的使用方式"><a href="#4-JWT-的使用方式" class="headerlink" title="4 JWT 的使用方式"></a>4 JWT 的使用方式</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端收到服务器返回的JWT，可以存储到<strong>Cookie</strong>里面，也可以存储到<strong>localStorage</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此后，客户端每次与服务器通信，都要带上这个JWT。你可以把她它放在Cookie里面自动发送，但是这样不能跨域，所以更好地做法是放在<strong>HTTP</strong>请求的头信息<font color="red">Authorrization</font>字段里面。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Authorization：Bearer<Token><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种做法是，跨域的时候，</Token></strong>JWT<strong>就放在</strong>POST**请求的数据体里面。</p><h1 id="5-JWTI的几个特点"><a href="#5-JWTI的几个特点" class="headerlink" title="5 JWTI的几个特点"></a>5 JWTI的几个特点</h1><p>（1）JWT默认是不加密，但也可以加密。生成原始Token以后，可以使用密钥再加密一次。<br>（2）JWT不加密的情况下，不能将秘密数据写入JWT。<br>（3）JWT不仅可以用于认证，也可以用户交换信息，有效使用JWT，可以降低服务器查询数据库的次数。<br>（4）JWT的最大缺点是：由于服务器不保存Session状态，因此无法再使用过程中废止某个token。<br>（5）JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置的比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用。JWT不应该使用<strong>HTTP</strong>协议明码传输，要使用<strong>HTTPS</strong>协议传输。</p><h1 id="六-SpringBoot2-0集成JWT作鉴权"><a href="#六-SpringBoot2-0集成JWT作鉴权" class="headerlink" title="六 SpringBoot2.0集成JWT作鉴权"></a>六 SpringBoot2.0集成JWT作鉴权</h1><p>项目架构：<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/5113607d-e98b-408c-ad9b-8765836fdc84.png" alt></p><p>entity   —&gt;&gt;&gt;    User:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"> private String name;</span><br><span class="line"> private String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils    —&gt;&gt;&gt;    JwtUtil:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * 过期时间为1天</span><br><span class="line">      * 正式上线更换为15分钟</span><br><span class="line">      *&#x2F;</span><br><span class="line">  private static final long EXPIRE_TIME &#x3D; 24*60*60*1000;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">    * token 私钥</span><br><span class="line">    *&#x2F;</span><br><span class="line">  private static final String TOKEN_SECRET &#x3D; &quot;joijsdfjlsjfljfljl5135313135&quot;;</span><br><span class="line"></span><br><span class="line"> public static String sign(String username,String userId)&#123;</span><br><span class="line">        &#x2F;&#x2F;过期时间</span><br><span class="line">  Date date &#x3D; new Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">  &#x2F;&#x2F;私钥及加密算法</span><br><span class="line">  Algorithm algorithm &#x3D; Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">  &#x2F;&#x2F;设置头信息</span><br><span class="line">  HashMap&lt;String,Object&gt; header &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">  header.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line">  header.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">  &#x2F;&#x2F;附带username和userId生成签名</span><br><span class="line">  return JWT.create().withHeader(header)</span><br><span class="line">                .withClaim(&quot;loginName&quot;,username)</span><br><span class="line">                .withClaim(&quot;userId&quot;,userId)</span><br><span class="line">                .withExpiresAt(date)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verity(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">  JWTVerifier verifier &#x3D; JWT.require(algorithm).build();</span><br><span class="line">  DecodedJWT jwt &#x3D; verifier.verify(token);</span><br><span class="line"> return true;  &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">  &#125; catch (JWTVerificationException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义状态码<br>utils —&gt;&gt;&gt; AjaxResult</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">public class AjaxResult extends HashMap&lt;String,Object&gt; &#123;</span><br><span class="line"> private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line"> public static final String CODE_TAG &#x3D; &quot;code&quot;;</span><br><span class="line"></span><br><span class="line"> public static final String MSG_TAG &#x3D; &quot;msg&quot;;</span><br><span class="line"></span><br><span class="line"> public static final String DATA_TAG &#x3D; &quot;data&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 状态类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public enum Type</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;** 成功 *&#x2F;</span><br><span class="line">  SUCCESS(0),</span><br><span class="line">  &#x2F;**失败*&#x2F;</span><br><span class="line">  FAIL(1),</span><br><span class="line">  &#x2F;** 警告 *&#x2F;</span><br><span class="line">  WARN(301),</span><br><span class="line">  &#x2F;** 错误 *&#x2F;</span><br><span class="line">  ERROR(500);</span><br><span class="line"> private final int value;</span><br><span class="line"></span><br><span class="line">  Type(int value)</span><br><span class="line">        &#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">        public int value()</span><br><span class="line">        &#123;</span><br><span class="line">            return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 状态类型 *&#x2F;</span><br><span class="line">  private Type type;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 状态码 *&#x2F;</span><br><span class="line">  private int code;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 返回内容 *&#x2F;</span><br><span class="line">  private String msg;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 数据对象 *&#x2F;</span><br><span class="line">  private Object data;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象</span><br><span class="line">  *</span><br><span class="line"> * @param type 状态类型</span><br><span class="line">  * @param msg 返回内容</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult(Type type, String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        super.put(CODE_TAG, type.value);</span><br><span class="line"> super.put(MSG_TAG, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象</span><br><span class="line">  *</span><br><span class="line"> * @param type 状态类型</span><br><span class="line">  * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult(Type type, String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        super.put(CODE_TAG, type.value);</span><br><span class="line"> super.put(MSG_TAG, msg);</span><br><span class="line"> super.put(DATA_TAG, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.success(&quot;操作成功&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.success(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.SUCCESS, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.fail(&quot;操作失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.fail(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.FAIL, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回警告消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult warn(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.warn(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回警告消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult warn(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.WARN, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.error(&quot;操作失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.error(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.ERROR, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Type getType()</span><br><span class="line">    &#123;</span><br><span class="line">        return type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(Type type)</span><br><span class="line">    &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(int code)</span><br><span class="line">    &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()</span><br><span class="line">    &#123;</span><br><span class="line">        return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData()</span><br><span class="line">    &#123;</span><br><span class="line">        return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 校验用户信息</span><br><span class="line">  * @param loginName</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  boolean checkUser(String loginName, String passWord);</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 查询用户信息</span><br><span class="line">  * @param loginName</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  User getUser(String loginName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service 接口实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public boolean checkUser(String loginName, String passWord) &#123;</span><br><span class="line">        return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public User getUser(String loginName) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">  user.setName(&quot;李四&quot;);</span><br><span class="line">  user.setPassword(&quot;123&quot;);</span><br><span class="line"> return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping</span><br><span class="line">public class LoginController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">  private IUserService userService;</span><br><span class="line"></span><br><span class="line">  @PostMapping(&quot;login&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">  public AjaxResult login (@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">        String loginName &#x3D; map.get(&quot;loginName&quot;);</span><br><span class="line">  String passWord &#x3D; map.get(&quot;passWord&quot;);</span><br><span class="line">  &#x2F;&#x2F;身份验证</span><br><span class="line">  boolean isSuccess &#x3D;  userService.checkUser(loginName,passWord);</span><br><span class="line"> if (isSuccess) &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟数据库查询</span><br><span class="line">  User user &#x3D; userService.getUser(loginName);</span><br><span class="line"> if (user !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;返回token</span><br><span class="line">  String token &#x3D; JwtUtil.sign(loginName, passWord);</span><br><span class="line"> if (token !&#x3D; null) &#123;</span><br><span class="line">                    return AjaxResult.success(&quot;成功&quot;,token);</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return AjaxResult.fail();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;getUser&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">  public AjaxResult getUserInfo(HttpServletRequest request, @RequestBody Map&lt;String, String&gt; map)&#123;</span><br><span class="line">        String loginName &#x3D; map.get(&quot;loginName&quot;);</span><br><span class="line">  String token &#x3D; request.getHeader(&quot;token&quot;);</span><br><span class="line"> boolean verity &#x3D; JwtUtil.verity(token);</span><br><span class="line"> if (verity) &#123;</span><br><span class="line">            User user &#x3D; userService.getUser(loginName);</span><br><span class="line"> if (user !&#x3D; null) &#123;</span><br><span class="line">                HashMap &lt;String ,Object&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  hashMap.put(&quot;name&quot;,user.getName());</span><br><span class="line">  hashMap.put(&quot;password&quot;,user.getPassword());</span><br><span class="line"> return AjaxResult.success(&quot;成功&quot;, new JSONObject(hashMap).toString());</span><br><span class="line">  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return AjaxResult.fail();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8089</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: &#x2F;milo</span><br></pre></td></tr></table></figure><p>postman进行测试<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/464b01dc-045d-4361-ac55-2e974b033a84.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/ea715e2d-70b6-456c-a225-8e25eda825c3.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/e7e93afb-69fd-4121-9641-7791116399ad.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/a19a5f87-30de-426b-bf9a-b6089c250f20.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常见200+条命令</title>
      <link href="/2019/03/28/Git%E5%B8%B8%E8%A7%81200-%E6%9D%A1%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/28/Git%E5%B8%B8%E8%A7%81200-%E6%9D%A1%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><p>创建一个新的 git 版本库。这个版本库的配置、存储等信息会被保存到.git 文件夹中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 初始化当前项目</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。</span><br><span class="line"></span><br><span class="line">$ git init --bare &lt;directory&gt;</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line"># 这个命令就是将一个版本库拷贝到另一个目录中，同时也将分支都拷贝到新的版本库中。这样就可以在新的版本库中提交到远程分支</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>更改设置。可以是版本库的设置，也可以是系统的或全局的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 输出、设置基本的全局变量</span><br><span class="line">$ git config --global user.email</span><br><span class="line">$ git config --global user.name</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;MyEmail@gmail.com&quot;</span><br><span class="line">$ git config --global user.name &quot;My Name&quot;</span><br><span class="line"></span><br><span class="line"># 定义当前用户所有提交使用的作者邮箱。</span><br><span class="line">$ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;</span><br><span class="line"></span><br><span class="line"># 为Git命令创建一个快捷方式（别名）。</span><br><span class="line">$ git config --system core.editor &lt;editor&gt;</span><br></pre></td></tr></table></figure><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>git 内置了对命令非常详细的解释，可以供我们快速查阅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查找可用命令</span><br><span class="line">$ git help</span><br><span class="line"></span><br><span class="line"># 查找所有可用命令</span><br><span class="line">$ git help -a</span><br><span class="line"></span><br><span class="line"># 在文档当中查找特定的命令</span><br><span class="line"># git help &lt;命令&gt;</span><br><span class="line">$ git help add</span><br><span class="line">$ git help commit</span><br><span class="line">$ git help init</span><br></pre></td></tr></table></figure><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>显示索引文件（也就是当前工作空间）和当前的头指针指向的提交的不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 显示分支，未跟踪文件，更改和其他不同</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 查看其他的git status的用法</span><br><span class="line">$ git help status</span><br></pre></td></tr></table></figure><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>获取某些文件，某些分支，某次提交等 git 信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"> 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 比较暂存区和版本库差异</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"># 比较暂存区和版本库差异</span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"># 仅仅比较统计信息</span><br><span class="line">$ git diff --stat</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"># 查看远程分支</span><br><span class="line">$ git br -r</span><br><span class="line"></span><br><span class="line"># 创建新的分支</span><br><span class="line">$ git br &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"># 查看各个分支最后提交信息</span><br><span class="line">$ git br -v</span><br><span class="line"></span><br><span class="line"># 查看已经被合并到当前分支的分支</span><br><span class="line">$ git br --merged</span><br><span class="line"></span><br><span class="line"># 查看尚未被合并到当前分支的分支</span><br><span class="line">$ git br --no-merged</span><br></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>添加文件到当前工作空间中。如果你不使用 <code>git add</code> 将文件添加进去，那么这些文件也不会添加到之后的提交之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个文件</span><br><span class="line">$ git add test.js</span><br><span class="line"></span><br><span class="line"># 添加一个子目录中的文件</span><br><span class="line">$ git add &#x2F;path&#x2F;to&#x2F;file&#x2F;test.js</span><br><span class="line"></span><br><span class="line"># 支持正则表达式</span><br><span class="line">$ git add .&#x2F;*.js</span><br><span class="line"></span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>rm 和上面的 add 命令相反，从工作空间中去掉某个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 移除 HelloWorld.js</span><br><span class="line">$ git rm HelloWorld.js</span><br><span class="line"></span><br><span class="line"># 移除子目录中的文件</span><br><span class="line">$ git rm &#x2F;pather&#x2F;to&#x2F;the&#x2F;file&#x2F;HelloWorld.js</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>管理分支，可以通过下列命令对分支进行增删改查切换等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有的分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 创建一个新的分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 重命名分支</span><br><span class="line"># git branch -m &lt;旧名称&gt; &lt;新名称&gt;</span><br><span class="line">$ git branch -m [branch-name] [new-branch-name]</span><br><span class="line"></span><br><span class="line"># 编辑分支的介绍</span><br><span class="line">$ git branch [branch-name] --edit-description</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br><span class="line"></span><br><span class="line"># 切换到某个分支</span><br><span class="line">$ git co &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 创建新的分支，并且切换过去</span><br><span class="line">$ git co -b &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"># 基于branch创建新的new_branch</span><br><span class="line">$ git co -b &lt;new_branch&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line">$ git co $id</span><br><span class="line"></span><br><span class="line"># 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line">$ git co $id -b &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"># 删除某个分支</span><br><span class="line">$ git br -d &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"># 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br><span class="line">$ git br -D &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="检出"><a href="#检出" class="headerlink" title="检出"></a>检出</h2><p>将当前工作空间更新到索引所标识的或者某一特定的工作空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 检出一个版本库，默认将更新到master分支</span><br><span class="line">$ git checkout</span><br><span class="line"># 检出到一个特定的分支</span><br><span class="line">$ git checkout branchName</span><br><span class="line"># 新建一个分支，并且切换过去，相当于&quot;git branch &lt;名字&gt;; git checkout &lt;名字&gt;&quot;</span><br><span class="line">$ git checkout -b newBranch</span><br></pre></td></tr></table></figure><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p>远程同步的远端分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 查看远程服务器地址和仓库名称</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 添加远程仓库地址</span><br><span class="line">$ git remote add origin git@ github:xxx&#x2F;xxx.git</span><br><span class="line"></span><br><span class="line"># 设置远程仓库地址(用于修改远程仓库地址)</span><br><span class="line">$ git remote set-url origin git@ github.com:xxx&#x2F;xxx.git</span><br><span class="line"></span><br><span class="line"># 删除远程仓库</span><br><span class="line">$ git remote rm &lt;repository&gt;</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line"># 把本地的分支更新到远端origin的master分支上</span><br><span class="line"># git push &lt;远端&gt; &lt;分支&gt;</span><br><span class="line"># git push 相当于 git push origin master</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 恢复最后一次提交的状态</span><br><span class="line">$ git revert HEAD</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"># 列所有stash</span><br><span class="line">$ git stash list</span><br><span class="line"></span><br><span class="line"># 恢复暂存的内容</span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"># 删除暂存区</span><br><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>将当前索引的更改保存为一个新的提交，这个提交包括用户做出的更改与信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区附带提交信息</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>显示当前工作空间和提交的不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示工作目录和索引的不同</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示索引和最近一次提交的不同</span><br><span class="line">$ git diff --cached</span><br><span class="line"></span><br><span class="line"># 显示工作目录和最近一次提交的不同</span><br><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>可以在版本库中快速查找</p><p>可选配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在搜索结果中显示行号</span><br><span class="line">$ git config --global grep.lineNumber true</span><br><span class="line"></span><br><span class="line"># 是搜索结果可读性更好</span><br><span class="line">$ git config --global alias.g &quot;grep --break --heading --line-number&quot;</span><br><span class="line"># 在所有的java中查找variableName</span><br><span class="line">$ git grep &#39;variableName&#39; -- &#39;*.java&#39;</span><br><span class="line"></span><br><span class="line"># 搜索包含 &quot;arrayListName&quot; 和, &quot;add&quot; 或 &quot;remove&quot; 的所有行</span><br><span class="line">$ git grep -e &#39;arrayListName&#39; --and \( -e add -e remove \)</span><br></pre></td></tr></table></figure><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>显示这个版本库的所有提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有提交</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示某几条提交信息</span><br><span class="line">$ git log -n 10</span><br><span class="line"></span><br><span class="line"># 仅显示合并提交</span><br><span class="line">$ git log --merges</span><br><span class="line"></span><br><span class="line"># 查看该文件每次提交记录</span><br><span class="line">$ git log &lt;file&gt;</span><br><span class="line"></span><br><span class="line"># 查看每次详细修改内容的diff</span><br><span class="line">$ git log -p &lt;file&gt;</span><br><span class="line"></span><br><span class="line"># 查看最近两次详细修改内容的diff</span><br><span class="line">$ git log -p -2</span><br><span class="line"></span><br><span class="line">#查看提交统计信息</span><br><span class="line">$ git log --stat</span><br></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>合并就是将外部的提交合并到自己的分支中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将其他分支合并到当前分支</span><br><span class="line">$ git merge branchName</span><br><span class="line"></span><br><span class="line"># 在合并时创建一个新的合并后的提交</span><br><span class="line"># 不要 Fast-Foward 合并，这样可以生成 merge 提交</span><br><span class="line">$ git merge --no-ff branchName</span><br></pre></td></tr></table></figure><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>重命名或移动一个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 重命名</span><br><span class="line">$ git mv test.js test2.js</span><br><span class="line"></span><br><span class="line"># 移动</span><br><span class="line">$ git mv test.js .&#x2F;new&#x2F;path&#x2F;test.js</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br><span class="line"></span><br><span class="line"># 强制重命名或移动</span><br><span class="line"># 这个文件已经存在，将要覆盖掉</span><br><span class="line">$ git mv -f myFile existingFile</span><br></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>从远端版本库合并到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 从远端origin的master分支更新版本库</span><br><span class="line"># git pull &lt;远端&gt; &lt;分支&gt;</span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"># 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line">$ git pull --no-ff</span><br></pre></td></tr></table></figure><h2 id="ci"><a href="#ci" class="headerlink" title="ci"></a>ci</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git ci &lt;file&gt;</span><br><span class="line">$ git ci .</span><br><span class="line"># 将git add, git rm和git ci等操作都合并在一起做</span><br><span class="line">$ git ci -a</span><br><span class="line">$ git ci -am &quot;some comments&quot;</span><br><span class="line"># 修改最后一次提交记录</span><br><span class="line">$ git ci --amend</span><br></pre></td></tr></table></figure><h2 id="ebase-谨慎使用"><a href="#ebase-谨慎使用" class="headerlink" title="ebase (谨慎使用)"></a>ebase (谨慎使用)</h2><p>将一个分支上所有的提交历史都应用到另一个分支上<br><em>不要在一个已经公开的远端分支上使用 rebase</em>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将experimentBranch应用到master上面</span><br><span class="line"># git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</span><br><span class="line">$ git rebase master experimentBranch</span><br></pre></td></tr></table></figure><h2 id="reset-谨慎使用"><a href="#reset-谨慎使用" class="headerlink" title="reset (谨慎使用)"></a>reset (谨慎使用)</h2><p>将当前的头指针复位到一个特定的状态。这样可以使你撤销 merge、pull、commits、add 等<br>这是个很强大的命令，但是在使用时一定要清楚其所产生的后果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 使 staging 区域恢复到上次提交时的状态，不改变现在的工作目录</span><br><span class="line">$ git reset</span><br><span class="line"></span><br><span class="line"># 使 staging 区域恢复到上次提交时的状态，覆盖现在的工作目录</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 将当前分支恢复到某次提交，不改变现在的工作目录</span><br><span class="line"># 在工作目录中所有的改变仍然存在</span><br><span class="line">$ git reset dha78as</span><br><span class="line"></span><br><span class="line"># 将当前分支恢复到某次提交，覆盖现在的工作目录</span><br><span class="line"># 并且删除所有未提交的改变和指定提交之后的所有提交</span><br><span class="line">$ git reset --hard dha78as</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br><span class="line"></span><br><span class="line"># 打补丁</span><br><span class="line">$ git apply ..&#x2F;sync.patch</span><br><span class="line"></span><br><span class="line"># 测试补丁能否成功</span><br><span class="line">$ git apply --check ..&#x2F;sync.patch</span><br><span class="line"></span><br><span class="line"># 查看Git的版本</span><br><span class="line">$ git --version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-GitLab简单操作</title>
      <link href="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-国内为什么普遍使用GitLab"><a href="#1-国内为什么普遍使用GitLab" class="headerlink" title="1 国内为什么普遍使用GitLab"></a>1 国内为什么普遍使用GitLab</h2><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">https://about.gitlab.com/</a><br>大公司有能力自己基于GitLab做二次开发，有利于将代码保存在自己手中。</p><a id="more"></a><h2 id="2-GitLab上有哪些核心功能"><a href="#2-GitLab上有哪些核心功能" class="headerlink" title="2 GitLab上有哪些核心功能"></a>2 GitLab上有哪些核心功能</h2><p>几乎包含一个项目的所有开发流程。<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/f06b4b21-3b4a-4c7b-b3a7-5ef2d7a60ce4.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/79e63bc0-48e9-4b18-bb60-1ebbc1745ace.png" alt></p><h2 id="3-GitLab如何做项目管理"><a href="#3-GitLab如何做项目管理" class="headerlink" title="3 GitLab如何做项目管理"></a>3 GitLab如何做项目管理</h2><p>主要是通过 <strong>issues</strong> 对项目进行追踪管理<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/24bbbb0d-d736-4783-90d9-c6f063636555.png" alt></p><p>也可以看仪表盘等等。</p><h2 id="4-GitLab怎样做-code-review"><a href="#4-GitLab怎样做-code-review" class="headerlink" title="4 GitLab怎样做 code review"></a>4 GitLab怎样做 code review</h2><p><strong>Merge Requests</strong></p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e0577ac-52cb-4cd8-b700-633abb8d59aa.png" alt></p><p><strong>仓库设置及变更保护</strong><br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/3f1d9ab7-f837-4b7c-a463-b3004d9a02a7.jpg" alt></p><h2 id="5-GitLab怎样保证集成质量"><a href="#5-GitLab怎样保证集成质量" class="headerlink" title="5 GitLab怎样保证集成质量"></a>5 GitLab怎样保证集成质量</h2><p>配置.gitlab-ci.yml文件 + 跑 runners</p><p><strong>GitLab</strong> 有自己的<strong>CI</strong><br>通过源文件可以查看</p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/aa33cc03-7b0f-405e-8203-8e0ea05d0644.png" alt></p><p>在自己的项目中可以看到 Runners：就是跑CI/CD的代理，类似于管家，有了它之后，GitLab自身的CI才能运行起来、<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/834dfa86-48f3-474f-a4ca-a2cfa2e1ca68.jpg" alt></p><p>跑一套之后的效果（做一个完备的检查）<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a88563d3-da82-4ecc-a297-c27baf6646c7.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/39ad396c-484a-4e12-a44a-cbfdea758b81.jpg" alt></p><h2 id="6-如何把应用部署到AWS上"><a href="#6-如何把应用部署到AWS上" class="headerlink" title="6 如何把应用部署到AWS上"></a>6 如何把应用部署到AWS上</h2><p>见 GitLab Help文档</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven打Jar包-服务器运行Spring-Boot-jar</title>
      <link href="/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/"/>
      <url>/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-推荐run方式：-前后不能有空格"><a href="#1-推荐run方式：-前后不能有空格" class="headerlink" title="1 推荐run方式：(=前后不能有空格)"></a>1 推荐run方式：(=前后不能有空格)</h1><font color="red">[root@haoransun src]# nohup java -jar -Dserver.port=8888 demo-0.0.1-SNAPSHOT.jar >config.log 2>&1 &</font><h1 id="2-查看端口、进程"><a href="#2-查看端口、进程" class="headerlink" title="2 查看端口、进程"></a>2 查看端口、进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep java</span><br><span class="line"></span><br><span class="line">netstat -anp | grep port</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="3-服务器后台运行，日志过多？"><a href="#3-服务器后台运行，日志过多？" class="headerlink" title="3 服务器后台运行，日志过多？"></a>3 服务器后台运行，日志过多？</h1><p>SpringBoot 打成的可执行jar包，想要在服务器上运行，只需要服务器有jdk即可。（<strong>SpringBoot自带Tomcat</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ***.jar  即可</span><br></pre></td></tr></table></figure><p><font color="red">仅仅如上面运行jar吗，关掉了xshell等页面，程序就会停掉。因此需要使用</font><strong>nohup</strong>对它进行后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar &amp; 即可</span><br></pre></td></tr></table></figure><p>可以在运行时指很多参数，如端口号等等。<strong>基本上在配置文件配置的参数都可以指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar --server.port&#x3D;9090 &amp;</span><br></pre></td></tr></table></figure><p>上面的程序会默认将日志打印到所在目录的nohup.out文件中。一个定时任务甚至会产生上百G的日志。我们可以指定只打印不同级别的日志。也可以利用<strong>Linux的黑洞</strong>，/dev/null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar --server.port&#x3D;9090 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>&amp;：代表在后台运行，当前ssh不会被锁定，当窗口关闭时，程序终止运行</strong></p><p><strong>nohup</strong>：不挂断运行，即使终端关闭，程序仍然运行**</p><h2 id="3-1-Shell-脚本—-dev-null-2-gt-amp-1-详解"><a href="#3-1-Shell-脚本—-dev-null-2-gt-amp-1-详解" class="headerlink" title="3.1 Shell 脚本—-/dev/null 2&gt;&amp;1 详解"></a>3.1 Shell 脚本—-/dev/null 2&gt;&amp;1 详解</h2><ul><li><strong>1</strong> 可以将/dev/null 看做“黑洞”，他等价于一个只写文件，所有写入它的文件都会永远丢失。而从他那读取内容则什么也没有，然而，/dev/null 对命令行和脚本都非常有用。</li></ul><p><strong>禁止标准输出</strong>： 1 cat $filename&gt;/dev/null #文件内容丢失，而不会输出的标准输出。<br><strong>禁止标准错误</strong>： 2&gt;/dev/null 错误信息被丢到了太平洋。</p><ul><li><strong>2</strong> 1&gt;/dev/null 2&gt;&amp;1含义<blockquote><p>代表重定向到哪里，例如：echo “123” &gt; /home/123.txt<br>1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”<br>2 表示stderr标准错误<br>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote></li></ul><h2 id="3-2-重定向"><a href="#3-2-重定向" class="headerlink" title="3.2 重定向"></a>3.2 重定向</h2><p>1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。<br>2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p><ul><li><strong>3</strong> /dev/zero文件代表一个永远输出 0的设备文件，使用它作输入可以得到全为空的文件。因此可用来创建新文件和以覆盖的方式清除旧文件。</li></ul><p>下面使用dd命令将从zero设备中创建一个10K大小（bs决定每次读写1024字节，count定义读写次数为10次），但内容全为0的文件。<br>dd if=/dev/zero of=file count=10 bs=1024</p><p>最常用的方式有：</p><p>command &gt; file 2&gt;file  与command &gt; file 2&gt;&amp;1<br>首先command &gt; file 2&gt;file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command  &gt; file 2&gt;file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道。<br>      而command &gt;file 2&gt;&amp;1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容。<br>      从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会command &gt; file 2&gt;&amp;1 这样的写法。</p><h2 id="3-3-三个文件状态"><a href="#3-3-三个文件状态" class="headerlink" title="3.3 三个文件状态"></a>3.3 三个文件状态</h2><p>总有三个文件处于打开状态：0：标准输入 1：标准输出 2：标准错误</p><h1 id="4-Maven打Jar包"><a href="#4-Maven打Jar包" class="headerlink" title="4  Maven打Jar包"></a>4  Maven打Jar包</h1><p><img src="/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/2b568ec5-912a-4f3b-93a3-ca1476e15403.png" alt></p><p>依赖<br>spring-boot-maven-plugin插件，并且指定 mainClass</p><h1 id="5-Maven-常用命令"><a href="#5-Maven-常用命令" class="headerlink" title="5 Maven 常用命令"></a>5 Maven 常用命令</h1><p>mvn dependency :tree 打印依赖树</p><p>mvn dependency :tree -Dverbose 显示详情</p><p>mvn dependency :analyze 分析依赖</p><h1 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6 生命周期"></a>6 生命周期</h1><p>清理-编译-测试-打包-安装-部署<br>mvn clean<br>mvn install<br>mvn package<br>跳过测试并安装<br>mvn install -Dmaven.test.skip=true</p>]]></content>
      
      
      <categories>
          
          <category> Jar包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jar包运行 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31-Trie树_如何实现搜索引擎的搜索关键词提示功能</title>
      <link href="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搜索引擎的搜索关键词提示功能，我想你应该不陌生吧？为了方便快速输入，当你在搜索引擎的搜索框中，输入要搜索的文字的某一部分的时候，搜索引擎就会自动弹出下拉框，里面是各种关键词提示。你可以直接从下拉框中选择你要搜索的东西，而不用把所有内容都输入进去，一定程度上节省了我们的搜索时间。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/278d4698-47ef-4675-a5a8-7866c612edfa.jpg" alt></p><p>尽管这个功能我们几乎天天在用，作为一名工程师，你是否思考过，它是怎么实现的呢？它底层使用的是哪种数据结构和算法呢？</p><p>像 Google、百度这样的搜索引擎，它们的关键词提示功能非常全面和精准，肯定做了很多优化，但万变不离其宗，底层最基本的原理就是今天要讲的这种数据结构：Trie 树。</p><a id="more"></a><h2 id="什么是“Trie-树”？"><a href="#什么是“Trie-树”？" class="headerlink" title="什么是“Trie 树”？"></a>什么是“Trie 树”？</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>当然，这样一个问题可以有多种解决方法，比如散列表、红黑树，或者我们前面几节讲到的一些字符串匹配算法，但是，Trie 树在这个问题的解决上，有它特有的优点。不仅如此，Trie 树能解决的问题也不限于此，我们一会儿慢慢分析。</p><p>现在，我们先来看下，Trie 树到底长什么样子。</p><p>我举个简单的例子来说明一下。我们有 6 个字符串，它们分别是：how，hi，her，hello，so，see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>这个时候，我们就可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。<strong>Trie 树的本质，就是利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。最后构造出来的就是下面这个图中的样子。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/896ee72c-82e8-4e14-ae67-df858b86b87e.jpg" alt></p><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：红色节点并不都是叶子节点）。</p><p>为了让你更容易理解 Trie 树是怎么构造出来的，我画了一个 Trie 树构造的分解过程。构造过程的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/fda41f44-a861-471a-b149-42dcc7c65807.jpg" alt></p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/490a487e-e96a-4ca4-931e-6cae7e92e922.jpg" alt></p><p>当我们在 Trie 树中查找一个字符串的时候，比如查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h，e，r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/f13395bb-bf6a-496e-9a59-3ca4fa9b89b5.jpg" alt></p><p>如果我们要查找的是字符串“he”呢？我们还用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串“he”匹配的路径。但是，路径的最后一个节点“e”并不是红色的。也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/ec00d970-00d8-49dc-9b3e-088ae33d76c1.jpg" alt></p><h2 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h2><p>知道了 Trie 树长什么样子，我们现在来看下，如何用代码来实现一个 Trie 树。</p><p>从刚刚 Trie 树的介绍来看，Trie 树主要有两个操作，<strong>一个是将字符串集合构造成 Trie 树</strong>。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程。<strong>另一个是在 Trie 树中查询一个字符串</strong>。</p><p>了解了 Trie 树的两个主要操作之后，我们再来看下，<strong>如何存储一个 Trie 树？</strong></p><p>从前面的图中，我们可以看出，Trie 树是一个多叉树。我们知道，二叉树中，一个节点的左右子节点是通过两个指针来存储的，如下所示 Java 代码。那对于多叉树来说，我们怎么存储一个节点的所有子节点的指针呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BinaryTreeNode &#123;</span><br><span class="line">  char data;</span><br><span class="line">  BinaryTreeNode left;</span><br><span class="line">  BinaryTreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我先介绍其中一种存储方式，也是经典的存储方式，大部分数据结构和算法书籍中都是这么讲的。还记得我们前面讲到的散列表吗？借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针。这句话稍微有点抽象，不怎么好懂，我画了一张图你可以看看。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/a1f64008-f398-4cde-b8cf-baf93bd6ee9c.jpg" alt></p><p>假设我们的字符串中只有从 a 到 z 这 26 个小写字母，我们在数组中下标为 0 的位置，存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置，存储的是指向的子节点 z 的指针。如果某个字符的子节点不存在，我们就在对应的下标的位置存储 null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">  char data;</span><br><span class="line">  TrieNode children[26];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在 Trie 树中查找字符串的时候，我们就可以通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针。比如，d 的 ASCII 码减去 a 的 ASCII 码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。</p><p>描述了这么多，有可能你还是有点懵，我把上面的描述翻译成了代码，你可以结合着一块看下，应该有助于你理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">  private TrieNode root &#x3D; new TrieNode(&#39;&#x2F;&#39;); &#x2F;&#x2F; 存储无意义字符</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 往Trie树中插入一个字符串</span><br><span class="line">  public void insert(char[] text) &#123;</span><br><span class="line">    TrieNode p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; text.length; ++i) &#123;</span><br><span class="line">      int index &#x3D; text[i] - &#39;a&#39;;</span><br><span class="line">      if (p.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">        TrieNode newNode &#x3D; new TrieNode(text[i]);</span><br><span class="line">        p.children[index] &#x3D; newNode;</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar &#x3D; true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在Trie树中查找一个字符串</span><br><span class="line">  public boolean find(char[] pattern) &#123;</span><br><span class="line">    TrieNode p &#x3D; root;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pattern.length; ++i) &#123;</span><br><span class="line">      int index &#x3D; pattern[i] - &#39;a&#39;;</span><br><span class="line">      if (p.children[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F; 不存在pattern</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    if (p.isEndingChar &#x3D;&#x3D; false) return false; &#x2F;&#x2F; 不能完全匹配，只是前缀</span><br><span class="line">    else return true; &#x2F;&#x2F; 找到pattern</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public class TrieNode &#123;</span><br><span class="line">    public char data;</span><br><span class="line">    public TrieNode[] children &#x3D; new TrieNode[26];</span><br><span class="line">    public boolean isEndingChar &#x3D; false;</span><br><span class="line">    public TrieNode(char data) &#123;</span><br><span class="line">      this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie 树的实现，你现在应该搞懂了。现在，我们来看下，<strong>在 Trie 树中，查找某个字符串的时间复杂度是多少？</strong></p><p>如果要在一组字符串中，频繁地查询某些字符串，用 Trie 树会非常高效。构建 Trie 树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n 表示所有字符串的长度和）。但是一旦构建成功之后，后续的查询操作会非常高效。</p><p>每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中查找字符串的时间复杂度是 O(k)，k 表示要查找的字符串的长度。</p><h2 id="Trie-树真的很耗内存吗？"><a href="#Trie-树真的很耗内存吗？" class="headerlink" title="Trie 树真的很耗内存吗？"></a>Trie 树真的很耗内存吗？</h2><p>前面我们讲了 Trie 树的实现，也分析了时间复杂度。现在你应该知道，Trie 树是一种非常独特的、高效的字符串匹配方法。但是，关于 Trie 树，你有没有听过这样一种说法：“Trie 树是非常耗内存的，用的是一种空间换时间的思路”。这是什么原因呢？</p><p>刚刚我们在讲 Trie 树的实现的时候，讲到用数组来存储一个节点的子节点的指针。如果字符串中包含从 a 到 z 这 26 个字符，那每个节点都要存储一个长度为 26 的数组，并且每个数组存储一个 8 字节指针（或者是 4 字节，这个大小跟 CPU、操作系统、编译器等有关）。而且，即便一个节点只有很少的子节点，远小于 26 个，比如 3、4 个，我们也要维护一个长度为 26 的数组。</p><p>我们前面讲过，Trie 树的本质是避免重复存储一组字符串的相同前缀子串，但是现在每个字符（对应一个节点）的存储远远大于 1 个字节。按照我们上面举的例子，数组长度为 26，每个元素是 8 字节，那每个节点就会额外需要 26*8=208 个字节。而且这还是只包含 26 个字符的情况。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，Trie 树不一定会节省存储空间。在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存。</p><p>当然，我们不可否认，Trie 树尽管有可能很浪费内存，但是确实非常高效。那为了解决这个内存问题，我们是否有其他办法呢？</p><p>我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。用哪种数据结构呢？我们的选择其实有很多，比如有序数组、跳表、散列表、红黑树等。</p><p>假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们为了维护数组中数据的有序性，就会稍微慢了点。</p><p>替换成其他数据结构的思路是类似的。</p><p>实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，<strong>缩点优化</strong>，就是对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并。这样可以节省空间，但却增加了编码难度。这里我就不展开详细讲解了，你如果感兴趣，可以自行研究下。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/ee43ef71-4523-46f7-87ad-7c08f3bc06cc.jpg" alt></p><h2 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h2><p>实际上，字符串的匹配问题，笼统上讲，其实就是数据的查找问题。对于支持动态数据高效操作的数据结构，我们前面已经讲过好多了，比如散列表、红黑树、跳表等等。实际上，这些数据结构也可以实现在一组字符串中查找字符串的功能。我们选了两种数据结构，散列表和红黑树，跟 Trie 树比较一下，看看它们各自的优缺点和应用场景。</p><p>在刚刚讲的这个场景，在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求。</p><p>第一，字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价。</p><p>第二，要求字符串的前缀重合比较多，不然空间消耗会变大很多。</p><p>第三，如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做。</p><p>第四，我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣。</p><p>综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。</p><p>讲到这里，你可能要疑惑了，讲了半天，我对 Trie 树一通否定，还让你用红黑树或者散列表，那 Trie 树是不是就没用了呢？是不是今天的内容就白学了呢？</p><p>实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串，也就是类似开篇问题的那种场景。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>Trie 树就讲完了，我们来看下开篇提到的问题：如何利用 Trie 树，实现搜索关键词的提示功能？</p><p>我们假设关键词库由用户的热门搜索关键词组成。我们将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。为了讲解方便，我们假设词库里只有 hello、her、hi、how、so、see 这 6 个关键词。当用户输入了字母 h 的时候，我们就把以 h 为前缀的 hello、her、hi、how 展示在搜索提示框内。当用户继续键入字母 e 的时候，我们就把以 he 为前缀的 hello、her 展示在搜索提示框内。这就是搜索关键词提示的最基本的算法原理。</p><p><img src="/2019/03/12/31-Trie%E6%A0%91-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD/3e8926b0-062a-440c-8d9b-6a428775d5cb.jpg" alt></p><p>不过，我讲的只是最基本的实现原理，实际上，搜索引擎的搜索关键词提示功能远非我讲的这么简单。如果再稍微深入一点，你就会想到，上面的解决办法遇到下面几个问题：</p><ul><li><p>我刚讲的思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢？</p></li><li><p>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢？</p></li><li><p>像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢？</p></li></ul><p>实际上，Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了一种特殊的树，Trie 树。Trie 树是一种解决字符串快速匹配问题的数据结构。如果用来构建 Trie 树的这一组字符串中，前缀重复的情况不是很多，那 Trie 树这种数据结构总体上来讲是比较费内存的，是一种空间换时间的解决问题思路。</p><p>尽管比较耗费内存，但是对内存不敏感或者内存消耗在接受范围内的情况下，在 Trie 树中做字符串匹配还是非常高效的，时间复杂度是 O(k)，k 表示要匹配的字符串的长度。</p><p>但是，Trie 树的优势并不在于，用它来做动态集合数据的查找，因为，这个工作完全可以用更加合适的散列表或者红黑树来替代。Trie 树最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，就比较适合用它来解决，也是 Trie 树比较经典的应用场景。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们今天有讲到，Trie 树应用场合对数据要求比较苛刻，比如字符串的字符集不能太大，前缀重合比较多等。如果现在给你一个很大的字符串集合，比如包含 1 万条记录，如何通过编程量化分析这组字符串集合是否比较适合用 Trie 树解决呢？也就是如何统计字符串的字符集大小，以及前缀重合的程度呢？</p><p><strong>回答：</strong></p><p>依次读取每个字符串的字符构建 Trie 树，用散列表来存储每一个节点。每一层树的所有散列表的元素用一个链表串联起来，<br>求某一长度的前缀重合，在对应树层级上遍历该层链表，求链表长度，除以字符集大小，值越小前缀重合率越高。</p><p>遍历所有树层级的链表，存入散列表，最后散列表包含元素的个数，就代表字符集的大小。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>用户单词拼写错误的情况下，可以用贝叶斯去纠错，详见Peter Norvig大牛的几十行py教做人 <a href="https://norvig.com/spell-correct.html" target="_blank" rel="noopener">https://norvig.com/spell-correct.html</a></p><p>找到了一个Trie树的开源库：Apache Commons，里面有关于Trie的实现</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-基于GitHub进行团队协作</title>
      <link href="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
      <url>/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-创建团队项目"><a href="#1-创建团队项目" class="headerlink" title="1 创建团队项目"></a>1 创建团队项目</h2><p>先在settings中创建组织类型的托管。然后在组织中创建团队的仓库。</p><a id="more"></a><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/64446d90-2b9c-449f-a087-5f965818e04e.png" alt><br>点击 Create后出现当前画面</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e2f857e9-f884-4e0c-9add-09e13a4c4d6f.png" alt></p><p>给予不同的人不同的权限</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31adef54-e872-40b9-899a-b1de0bc43a23.png" alt></p><hr><p>创建Team</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/205f2e23-e3a9-4ef3-9ead-a885002f398b.png" alt></p><h2 id="2-选择适合自己团队的工作流"><a href="#2-选择适合自己团队的工作流" class="headerlink" title="2 选择适合自己团队的工作流"></a>2 选择适合自己团队的工作流</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a8c719c7-af57-49cd-be78-22c37ef1a453.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/20094dc9-d19f-4455-bcf6-a6cd1ba16704.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/ca8f17b4-8f25-4a4b-9f72-3fa4220767c9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/86497509-61d6-475f-9e09-644a4c11269b.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fd472e76-3fdf-41d3-99f4-cfa77888cc46.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/36620676-47e4-41be-9609-c4511a38485e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/10ed3ecd-acac-457e-862b-520139270bd8.jpg" alt></p><h2 id="3-挑选合适的分支集成策略"><a href="#3-挑选合适的分支集成策略" class="headerlink" title="3 挑选合适的分支集成策略"></a>3 挑选合适的分支集成策略</h2><p>Insights &gt;&gt; Network 中可以查看版本树的演进。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/49ab1fe1-5685-40f2-aa6c-27e585533b76.jpg" alt></p><p>集成策略：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/051f3a09-38a5-4957-9510-dfcbb34c93d2.png" alt></p><p>有的团队希望最后的历史树像<strong>一条线</strong>一样，应选择 *<em>Allow rebase merging 或者 squash *</em></p><p><font color="red"><strong>Beijing为例</strong></font></p><p><strong>Merge</strong>：特性分支合并到base分支上</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a9ee48f2-74ca-4d36-9461-ff631b46c870.jpg" alt></p><p><strong>Squash</strong>: 特性分支不动，base分支自动添加特性分支的所有变更为1个（如特性分支上有5个commit，base分支会5合1）</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5b3df45b-80df-4c4c-93a8-81b8c641fa1a.jpg" alt></p><p><strong>Rebase</strong>: 不改变特性分支，base分支会自动添加特性分支的所有变更，且<strong>不会</strong>合成一个</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3010b401-fd66-4425-b675-4556c67cb407.jpg" alt></p><h2 id="4-启用issue跟踪需求和任务"><a href="#4-启用issue跟踪需求和任务" class="headerlink" title="4 启用issue跟踪需求和任务"></a>4 启用issue跟踪需求和任务</h2><p>选用 stars:&gt;100000 的开源项目来查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/16e07275-4d2b-402a-a50e-0648631716e4.png" alt></p><p>点击 Lables 以 标签的形式查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0a6cc850-3f29-4abd-b282-26daee4a2e06.png" alt></p><p>如何启用issue呢？</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfe21652-2b4e-46e1-b534-4c02ec6dd531.png" alt></p><p>建立 issue后会出现类似的文件</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/186c0666-1dfa-4ced-b588-ece60d6c9605.png" alt></p><h2 id="5-使用project管理issue"><a href="#5-使用project管理issue" class="headerlink" title="5 使用project管理issue"></a>5 使用project管理issue</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fc10fa87-3b54-48a4-9a20-1723d6b72ed3.png" alt></p><p>不同的看板类型 显示效果不一样，以bug为例：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/1ecccc60-40dd-40be-b6ed-2befb2a266ad.png" alt></p><p>可以对任务分发，项目进度把握进行观察</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/026076bc-ccd1-4208-ae96-196c3982138e.png" alt></p><h2 id="6-项目内部如何-code-review"><a href="#6-项目内部如何-code-review" class="headerlink" title="6 项目内部如何 code review"></a>6 项目内部如何 code review</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c53619b8-9fdc-4d69-8d0b-436f94468ad2.png" alt></p><p>根据需求对匹配到的不同分支做限制。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b0768be8-0078-4c68-8538-0197138b47a6.png" alt></p><p>下面做了限制，防止对远端代码造成破坏。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/2c20094b-8f8e-405c-90e5-65521154518c.png" alt></p><h2 id="7-团队协作如何做多分支的集成"><a href="#7-团队协作如何做多分支的集成" class="headerlink" title="7 团队协作如何做多分支的集成"></a>7 团队协作如何做多分支的集成</h2><p>特性分支总是有先有后的合成到base分支上，看看GitHub上是如何做</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b118050-ca7b-4d73-a633-2f02ae35ad12.jpg" alt></p><p><strong>Merge</strong>:</p><p>beijing merge 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e3a600d5-8897-42c2-bcaf-1f138379e255.jpg" alt></p><p>shanghai  也要 merge 到 base:</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/075b0539-7ff0-49aa-ba54-01f29e128bf4.jpg" alt></p><p>在线编辑解决冲突。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/770e44a3-857c-4cc6-810b-05eee2d4640c.jpg" alt></p><p>此时的代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b1137354-7eef-4570-8d51-5be16c5b72a8.jpg" alt></p><p>pull request 选择 merge 后查看代码树的变化：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfec3bde-f53e-4737-bb7a-08ff0189c793.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8d941049-4846-4bac-9876-0c50d213395a.jpg" alt></p><p>为了演示，将分支回退到之前的版本，实际上禁止这样处理</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/275f14ab-7c2e-4403-bd7b-63d28bc0ace3.jpg" alt></p><p><font color="red">此时 master 回退</font></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d645c180-1732-4ec9-a945-263f855089fa.jpg" alt></p><p><strong>Squash</strong>:</p><p>beijing  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55844bec-4ee4-4da7-aa6e-2242bf65c3db.jpg" alt></p><p>将 beijing 特性分支上做的3次变更 集成到 master分支上，且3合1<br>新生成1个commit,不会改动特性分支。</p><p>shanghai  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f7b90cae-d238-40a6-8895-fb271e1f7ab9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55521f26-e985-4afb-bbb1-5eb2375edf5e.jpg" alt></p><p>选中后就会报错 不能自动的merge,需要手动处理冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/70de5e05-2d68-44b3-9a05-ea28bf2ab4df.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d096a3d6-a46e-4b96-99f8-03635923aa0f.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c88f62c3-680b-49c3-b6f7-12777c634d2f.jpg" alt></p><hr><p>手动解决冲突后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5828e5a1-55a6-496c-a2f6-9b1e609e5eaa.jpg" alt></p><hr><p>冲突解决，但还没有接收时的代码树</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/69ea69db-7c60-424b-8a16-7eed94c30365.jpg" alt></p><hr><p>点击 Squash按钮后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9db23230-b878-4b45-acf0-7fc0f9c371a5.jpg" alt></p><hr><p>查看当前代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7d9e5cd9-21fe-4eff-9752-e8b9c2786ca1.jpg" alt></p><p><font color="red">master 再次回退</font></p><p>回到初始的状态：<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d43b9b20-2748-454c-85ba-ab06784a9b30.jpg" alt></p><p><strong>Rebase</strong>:</p><p>beijing  rebase 到 base后：<br>不改变特性分支，将 beijing分支的变更如实更新到 master分支上，不做合成。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f84fabeb-04ca-4b79-b384-3ee85c5447ec.jpg" alt></p><p>shanghai  rebase 到 base后：<br>会发生冲突，解决冲突后但还没有接收squash：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/babdf2f4-c1d6-475b-9f81-d33e8bbbfbf0.jpg" alt></p><p>此时 pull request 已经走到死胡同，不能再往下走了</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dc90bc8a-b9d6-4e46-99b9-46ff0b5d10cb.jpg" alt></p><p>此时 Github 已经无能为力，但团队还是坚持要用 rebase。<br>可以将 shanghai 回退到 s这个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av  &#x2F;&#x2F;确保本地分支在 s节点</span><br><span class="line">git push -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6a45a1fa-e5f2-4a3d-a427-beb97e84abb7.jpg" alt></p><p>我们应该回到ShangHai分支，让 ShangHai分支执行变基的操作，基于远端的master分支进行变基。</p><p><strong>繁琐处理：</strong><br>在本地做这件事，需要将远端的 master 拉取到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0dad0ce9-8fb5-49af-a819-02504d24859f.jpg" alt></p><p>切换到需要变基的分支，即 ShangHai分支，基于远端的 Master分支进行变基。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;master &#x2F;&#x2F;自然会报冲突 readme文件出了冲突</span><br><span class="line"></span><br><span class="line">vi readme &#x2F;&#x2F;解决冲突即可</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理，直到没有冲突</span><br><span class="line"></span><br><span class="line">git status &#x2F;&#x2F; 工作区是干净的即可</span><br><span class="line">gitk --all &#x2F;&#x2F; 查看分支树</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31e04eb9-1c49-4316-83be-475ed0fd6e80.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/4678ec2a-0cea-4d3d-8ff2-e2708c2d1ee0.jpg" alt></p><p>继续推送即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git push origin Shanghai &#x2F;&#x2F; 会报 非 fast-forwards</span><br><span class="line"></span><br><span class="line">同分支的本地往远端推送，必须是 fast-forwards才行</span><br><span class="line"></span><br><span class="line">除非加上 -f</span><br><span class="line"></span><br><span class="line">git push  -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9ad43201-005f-4c37-ae62-fca6815ba55e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/08d08193-5c71-429f-aeca-660996a4ebea.jpg" alt></p><p>此时，代码树发生了变化</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfde1fd2-0a28-4abe-9b15-9136dbb27095.jpg" alt></p><p>再次查看 pull request发现可以 Rebase<br>即 远端的 master分支 与 远端的 ShangHai分支处理 Fast-Forward状态，不会再有冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b46166ab-7e19-4488-aae2-a2f54768c735.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f03a16a-3dae-41f5-9247-5a348f33a90f.jpg" alt></p><hr><p>有两个头像，一个是源文件的作者，一个是该文件的提交者。<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/cf7e6f21-0886-46c1-a51a-fe2f04c70abf.jpg" alt></p><p><strong>特殊处理：</strong></p><p>Git官网：找到 Documentation —&gt;&gt; Pro Git book 选择 简体中文<br><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/df38e4ff-6c68-4d2b-bc30-46d62c978bb7.png" alt></p><p>因为经过繁琐处理已经没有冲突，需要将ShangHai版本恢复到 远端 s节点继续演示</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/95fc6d9d-5048-4e44-8358-518ccc9f6b49.jpg" alt></p><p>Master 分支也需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/965989da-0f55-4cfb-bc05-7aff3973a755.jpg" alt></p><p>开启 rerere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global rerere.enabled true</span><br><span class="line">git checkout ShangHai</span><br><span class="line">git merge master &#x2F;&#x2F;  只有看到Recorded resolution for ... 才算开始记录解决冲突的办法     当前报冲突，解决冲突</span><br><span class="line">vim readme</span><br><span class="line">git add .</span><br><span class="line">git commit -am &quot;temp&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/24000499-5018-466d-8553-0d3c12da0a50.jpg" alt></p><p>因为只是为了记录解决冲突的方法，temp 这个 commit并不需要，所以需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e0fa0fb5-c7cb-42c3-bcdb-7a4d7ec91854.jpg" alt></p><p>现在 ShangHai  等待着与 远端的 Master 做 rebase，并且使用 rerere<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8444c3f4-821d-4ea5-846e-2a784608b009.jpg" alt></p><p>基于 master(7425314) 做 rebase</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8a6e2f89-ecea-4176-ae48-843348aa2b7d.jpg" alt></p><p>虽然报了冲突，但进去 readme看后发现 冲突内容被自动解决了<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f1a0406-9d6b-4222-876d-afd6a0d9e767.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git rebase  --continue</span><br><span class="line">vi readme &#x2F;&#x2F;冲突也没有 根据提示 添加 readme</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status  &#x2F;&#x2F;一直到不再报冲突为止</span><br><span class="line"></span><br><span class="line">git log -n5  &#x2F;&#x2F; 查看commit是否如实更新上去</span><br></pre></td></tr></table></figure><h2 id="8-如何保证集成质量"><a href="#8-如何保证集成质量" class="headerlink" title="8 如何保证集成质量"></a>8 如何保证集成质量</h2><p>通过 settings 中的 各种保险设置进行控制</p><p>也可在 市场中搜索各种 插件 APP 进行集成管控自己的代码。</p><h2 id="9-产品如何发布到GitHub上"><a href="#9-产品如何发布到GitHub上" class="headerlink" title="9 产品如何发布到GitHub上"></a>9 产品如何发布到GitHub上</h2><p><strong>Release</strong><br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/83c9516e-1095-4441-adcb-fb43d32f54e9.png" alt></p><p>如果是以 travis为例，需要在 .travis.yml文件中编写deploy的各种配置<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/88dbd0f3-6076-4eb1-9195-d55b17dffd1d.jpg" alt></p><hr><p>api_key 不能暴露， 通过变量方式获取<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b822c8e-5eef-4bb5-a123-879c578f650a.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/434cac1a-1033-4a93-b1e4-2b15e43e3e99.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5a4f266e-313d-40fb-a626-d64e1f6b7996.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7cad2344-3d21-445e-a558-9cbe2cc12142.jpg" alt></p><p>name 是yml文件中的变量名称</p><p>value 在如下图中：在个人 setting 的 token中</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b568e180-66fc-4606-9fe2-891c81a305a1.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8042988e-13b1-4398-99ae-b54c5a8e7d97.jpg" alt></p><hr><p>pull request merge到主分支</p><p>经过 travis ci 各种审查后，点击 release即可看到<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6fde5cb5-4e6e-4894-8079-6426d91dd358.jpg" alt></p><p>即通过 travis ci 通过 配置 travis.yml文件 将 java 工程部署到GitHub的 release中，期间要配置Token。</p><h2 id="10-如何给项目添加详细的指导文档-Wiki"><a href="#10-如何给项目添加详细的指导文档-Wiki" class="headerlink" title="10 如何给项目添加详细的指导文档 (Wiki)"></a>10 如何给项目添加详细的指导文档 (Wiki)</h2><p><strong>GitHub提供了 Wiki 功能</strong></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0b05b38d-5d3a-49b4-a38e-82c28270a5a1.jpg" alt></p><p>挑选别的开源项目中 wiki写的比较好的 下载下来，推送到自己的项目中才能进行各种 edit。</p><p>此时远端的 wiki 中 会出现别人的 wiki<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7a33688d-e6b3-4177-9b88-0c9a405dbe47.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30-字符串匹配基础下_如何借助BM算法轻松理解KMP算法</title>
      <link href="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/"/>
      <url>/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://www.zhihu.com/question/21923021" target="_blank" rel="noopener">如何更好地理解和掌握 KMP 算法?</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们讲了 BM 算法，尽管它很复杂，也不好理解，但却是工程中非常常用的一种高效字符串匹配算法。有统计说，它是最高效、最常用的字符串匹配算法。不过，在所有的字符串匹配算法里，要说最知名的一种的话，那就非 KMP 算法莫属。很多时候，提到字符串匹配，我们首先想到的就是 KMP 算法。</p><p>尽管在实际的开发中，我们几乎不大可能自己亲手实现一个 KMP 算法。但是，学习这个算法的思想，作为让你开拓眼界、锻炼下逻辑思维，也是极好的，所以我觉得有必要拿出来给你讲一讲。不过，KMP 算法是出了名的不好懂。我会尽力把它讲清楚，但是你自己也要多动动脑子。</p><p>实际上，KMP 算法跟 BM 算法的本质是一样的。上一节，我们讲了好后缀和坏字符规则，今天，我们就看下，如何借助上一节 BM 算法的讲解思路，让你能更好地理解 KMP 算法？</p><a id="more"></a><h2 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h2><p>KMP 算法是根据三位作者（D.E.Knuth，J.H.Morris 和 V.R.Pratt）的名字来命名的，算法的全称是 Knuth Morris Pratt 算法，简称为 KMP 算法。</p><p>KMP 算法的核心思想，跟上一节讲的 BM 算法非常相近。我们假设主串是 a，模式串是 b。在模式串与主串匹配的过程中，当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况。</p><p>还记得我们上一节讲到的好后缀和坏字符吗？这里我们可以类比一下，在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<strong>坏字符</strong>，把已经匹配的那段字符串叫作<strong>好前缀</strong>。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/93bf7d3a-8f52-4831-af0b-dc2260d1060a.jpg" alt></p><p>当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较。这个比较的过程能否更高效了呢？可以不用一个字符一个字符地比较了吗？</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/f4ef2c1e6ce5915e1c6460c2e26c9469.jpg" alt></p><p>KMP 算法就是在试图寻找一种规律：在模式串和主串匹配的过程中，当遇到坏字符后，对于已经比对过的好前缀，能否找到一种规律，将模式串一次性滑动很多位？</p><p>我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/da99c0349f8fac27e193af8d801dbb8f.jpg" alt></p><p>为了表述起来方便，我把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/9e59c0973ffb965abdd3be5eafb492ad.jpg" alt></p><p>如何来求好前缀的最长可匹配前缀和后缀子串呢？我发现，这个问题其实不涉及主串，只需要通过模式串本身就能求解。所以，我就在想，能不能事先预处理计算好，在模式串和主串匹配的过程中，直接拿过来就用呢？</p><p>类似 BM 算法中的 bc、suffix、prefix 数组，KMP 算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为 <strong>next 数组</strong>，很多书中还给这个数组起了一个名字，叫<strong>失效函数</strong>（failure function）。</p><p>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标。这句话有点拗口，我举了一个例子，你一看应该就懂了。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/1661d37cb190cb83d713749ff9feaea8.jpg" alt></p><p>有了 next 数组，我们很容易就可以实现 KMP 算法了。我先假设 next 数组已经计算好了，先给出 KMP 算法的框架代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span><br><span class="line">public static int kmp(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] next &#x3D; getNexts(b, m);</span><br><span class="line">  int j &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">    while (j &gt; 0 &amp;&amp; a[i] !&#x3D; b[j]) &#123; &#x2F;&#x2F; 一直找到a[i]和b[j]</span><br><span class="line">      j &#x3D; next[j - 1] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a[i] &#x3D;&#x3D; b[j]) &#123;</span><br><span class="line">      ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &#x3D;&#x3D; m) &#123; &#x2F;&#x2F; 找到匹配模式串的了</span><br><span class="line">      return i - m + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h2><p>KMP 算法的基本原理讲完了，我们现在来看最复杂的部分，也就是 next 数组是如何计算出来的？<strong>可以去B站看有关up主的数学推导</strong></p><p>当然，我们可以用非常笨的方法，比如要计算下面这个模式串 b 的 next[4]，我们就把 b[0, 4]的所有后缀子串，从长到短找出来，依次看看，是否能跟模式串的前缀子串匹配。很显然，这个方法也可以计算得到 next 数组，但是效率非常低。有没有更加高效的方法呢？</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/d3c10b60-0f41-4474-a213-79038fc3b86f.jpg" alt></p><p>这里的处理非常有技巧，类似于动态规划。不过，动态规划我们在后面才会讲到，所以，我这里换种方法解释，也能让你听懂。</p><p>我们按照下标从小到大，依次计算 next 数组的值。当我们要计算 next[i]的时候，前面的 next[0]，next[1]，……，next[i-1]应该已经计算出来了。利用已经计算出来的 next 值，我们是否可以快速推导出 next[i]的值呢？</p><p>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1]是 b[0, i-1]的最长可匹配前缀子串。如果子串 b[0, k-1]的下一个字符 b[k]，与 b[0, i-1]的下一个字符 b[i]匹配，那子串 b[0, k]就是 b[0, i]的最长可匹配前缀子串。所以，next[i]等于 k。但是，如果 b[0, k-1]的下一字符 b[k]跟 b[0, i-1]的下一个字符 b[i]不相等呢？这个时候就不能简单地通过 next[i-1]得到 next[i]了。这个时候该怎么办呢？</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/f3c85dbb-ec4b-4c9b-b275-117c84931d22.jpg" alt></p><p>我们假设 b[0, i]的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1]肯定是 b[0, i-1]的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1]最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1]的次长可匹配后缀子串 b[x, i-1]对应的可匹配前缀子串 b[0, i-1-x]的下一个字符 b[i-x]是否等于 b[i]。如果等于，那 b[x, i]就是 b[0, i]的最长可匹配后缀子串。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/f9d82b39-fc22-4367-81ff-03bb48867c28.jpg" alt></p><p>可是，如何求得 b[0, i-1]的次长可匹配后缀子串呢？次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1]的次长可匹配后缀子串，这个问题就变成，查找 b[0, y]的最长匹配后缀子串的问题了。</p><p><img src="/2019/03/06/30-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9BM%E7%AE%97%E6%B3%95%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3KMP%E7%AE%97%E6%B3%95/f6fd30b1-2487-44e9-b551-568c965d4b3a.jpg" alt></p><p>按照这个思路，我们可以考察完所有的 b[0, i-1]的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i]就是 b[0, i]的最长可匹配后缀子串。</p><p>前面我已经给出 KMP 算法的框架代码了，现在我把这部分的代码也写出来了。这两部分代码合在一起，就是整个 KMP 算法的代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b表示模式串，m表示模式串的长度</span><br><span class="line">private static int[] getNexts(char[] b, int m) &#123;</span><br><span class="line">  int[] next &#x3D; new int[m];</span><br><span class="line">  next[0] &#x3D; -1;</span><br><span class="line">  int k &#x3D; -1;</span><br><span class="line">  for (int i &#x3D; 1; i &lt; m; ++i) &#123;</span><br><span class="line">    while (k !&#x3D; -1 &amp;&amp; b[k + 1] !&#x3D; b[i]) &#123;</span><br><span class="line">      k &#x3D; next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    if (b[k + 1] &#x3D;&#x3D; b[i]) &#123;</span><br><span class="line">      ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    next[i] &#x3D; k;</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h2><p>KMP 算法的原理和实现我们就讲完了，我们现在来分析一下 KMP 算法的时间、空间复杂度是多少？</p><p>空间复杂度很容易分析，KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以空间复杂度是 O(m)，m 表示模式串的长度。</p><p>KMP 算法包含两部分，第一部分是构建 next 数组，第二部分才是借助 next 数组匹配。所以，关于时间复杂度，我们要分别从这两部分来分析。</p><p>我们先来分析第一部分的时间复杂度。</p><p>计算 next 数组的代码中，第一层 for 循环中 i 从 1 到 m-1，也就是说，内部的代码被执行了 m-1 次。for 循环内部代码有一个 while 循环，如果我们能知道每次 for 循环、while 循环平均执行的次数，假设是 k，那时间复杂度就是 O(k*m)。但是，while 循环执行的次数不怎么好统计，所以我们放弃这种分析方法。</p><p>我们可以找一些参照变量，i 和 k。i 从 1 开始一直增加到 m，而 k 并不是每次 for 循环都会增加，所以，k 累积增加的值肯定小于 m。而 while 循环里 k=next[k]，实际上是在减小 k 的值，k 累积都没有增加超过 m，所以 while 循环里面 k=next[k]总的执行次数也不可能超过 m。因此，next 数组计算的时间复杂度是 O(m)。</p><p>我们再来分析第二部分的时间复杂度。分析的方法是类似的。</p><p>i 从 0 循环增长到 n-1，j 的增长量不可能超过 i，所以肯定小于 n。而 while 循环中的那条语句 j=next[j-1]+1，不会让 j 增长的，那有没有可能让 j 不变呢？也没有可能。因为 next[j-1]的值肯定小于 j-1，所以 while 循环中的这条语句实际上也是在让 j 的值减少。而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)。</p><p>所以，综合两部分的时间复杂度，KMP 算法的时间复杂度就是 O(m+n)。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>KMP 算法讲完了，不知道你理解了没有？如果没有，建议多看几遍，自己多思考思考。KMP 算法和上一节讲的 BM 算法的本质非常类似，都是根据规律在遇到坏字符的时候，把模式串往后多滑动几位。</p><p>BM 算法有两个规则，坏字符和好后缀。KMP 算法借鉴 BM 算法的思想，可以总结成好前缀规则。这里面最难懂的就是 next 数组的计算。如果用最笨的方法来计算，确实不难，但是效率会比较低。所以，我讲了一种类似动态规划的方法，按照下标 i 从小到大，依次计算 next[i]，并且 next[i]的计算通过前面已经计算出来的 next[0]，next[1]，……，next[i-1]来推导。</p><p>KMP 算法的时间复杂度是 O(n+m)，不过它的分析过程稍微需要一点技巧，不那么直观，你只要看懂就好了，并不需要掌握，在我们平常的开发中，很少会有这么难分析的代码。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>最难理解的地方是</strong></p><p>k = next[k]</p><p>因为前一个的最长串的下一个字符不与最后一个相等，需要找前一个的次长串，问题就变成了求0到next(k)的最长串，如果下个字符与最后一个不等，继续求次长串，也就是下一个next(k)，直到找到，或者完全没有</p><hr><p><strong>B站有关推导，可自行搜索</strong><br>关键是要搞明白k值是啥东西。<br>比如求aba 每个前缀最长可匹配前缀子串的结尾字符下标<br>这句话很容易引起歧义。<br>aba的前缀有a,ab, 后缀有ba,a 只有a与a匹配。 所以匹配的结尾下标是0.<br>abab 显然ab和ab可以匹配，所以匹配的结尾下标是1<br>abaaba 下标是2<br>ababa 下标是2<br>aaaa 下标是2</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29-字符串匹配基础中_如何实现文本编辑器中的查找功能</title>
      <link href="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文本编辑器中的查找替换功能，我想你应该不陌生吧？比如，我们在 Word 中把一个单词统一替换成另一个，用的就是这个功能。你有没有想过，它是怎么实现的呢？</p><p>当然，你用上一节讲的 BF 算法和 RK 算法，也可以实现这个功能，但是在某些极端情况下，BF 算法性能会退化的比较严重，而 RK 算法需要用到哈希算法，而设计一个可以应对各种类型字符的哈希算法并不简单。</p><p>对于工业级的软件开发来说，我们希望算法尽可能的高效，并且在极端情况下，性能也不要退化的太严重。那么，<font color="red">对于查找功能是重要功能的软件来说，比如一些文本编辑器，它们的查找功能都是用哪种算法来实现的呢？有没有比 BF 算法和 RK 算法更加高效的字符串匹配算法呢？</font></p><p>今天，我们就来学习 BM（Boyer-Moore）算法。它是一种非常高效的字符串匹配算法，有实验统计，它的性能是著名的<strong>KMP 算法</strong>的 3 到 4 倍。BM 算法的原理很复杂，比较难懂，学起来会比较烧脑，我会尽量给你讲清楚，同时也希望你做好打硬仗的准备。好，现在我们正式开始！</p><a id="more"></a><h2 id="BM-算法的核心思想"><a href="#BM-算法的核心思想" class="headerlink" title="BM 算法的核心思想"></a>BM 算法的核心思想</h2><p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，BF 算法和 RK 算法的做法是，模式串往后滑动一位，然后从模式串的第一个字符开始重新匹配。我举个例子解释一下，你可以看我画的这幅图。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/f1cc465d-44b5-4838-bd26-e89a7882bccc.jpg" alt></p><p>在这个例子里，主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/3cf279af-56f7-4567-9e1f-d142ef6f2cc4.jpg" alt></p><p>由现象找规律，你可以思考一下，当遇到不匹配的字符时，有什么固定的规律，可以将模式串往后多滑动几位呢？这样一次性往后滑动好几位，那匹配的效率岂不是就提高了？</p><p>我们今天要讲的 BM 算法，本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。</p><h2 id="BM-算法原理分析"><a href="#BM-算法原理分析" class="headerlink" title="BM 算法原理分析"></a>BM 算法原理分析</h2><p>BM 算法包含两部分，分别是<strong>坏字符规则</strong>（bad character rule）和<strong>好后缀规则</strong>（good suffix shift）。我们下面依次来看，这两个规则分别都是怎么工作的。</p><h3 id="1-坏字符规则"><a href="#1-坏字符规则" class="headerlink" title="1. 坏字符规则"></a>1. 坏字符规则</h3><p>前面两节讲的算法，在匹配的过程中，我们都是按模式串的下标从小到大的顺序，依次与主串中的字符进行匹配的。这种匹配顺序比较符合我们的思维习惯，而 BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的。我画了一张图，你可以看下。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/57e10b93-c1e2-485e-956c-3474f961bf8e.jpg" alt></p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/39c5ff34-582b-412f-8304-61b334d1b348.jpg" alt></p><p>我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作<strong>坏字符</strong>（主串中的字符）。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/673b6092-56c7-49e2-9724-1d71d8eaa9f0.jpg" alt></p><p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，字符 c 与模式串中的任何字符都不可能匹配。这个时候，我们可以将模式串直接往后滑动三位，将模式串滑动到 c 后面的位置，再从模式串的末尾字符开始比较。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/3ceb649b-6ce2-4b63-bf7d-385e2d38d15b.jpg" alt></p><p>这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，坏字符 a 在模式串中是存在的，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以将模式串往后滑动两位，让两个 a 上下对齐，然后再从模式串的末尾字符开始，重新匹配。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/c219af15-c0fd-4a53-91ad-b9660143faee.jpg" alt></p><p>第一次不匹配的时候，我们滑动了三位，第二次不匹配的时候，我们将模式串后移两位，那具体滑动多少位，到底有没有规律呢？</p><p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi。如果不存在，我们把 xi 记作 -1。那模式串往后移动的位数就等于 si-xi。（注意，我这里说的下标，都是字符在模式串的下标）。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/3e221a1f-b261-4656-8eae-6cec843a39e1.jpg" alt></p><p>这里我要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。</p><p>利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p><p>不过，单纯使用坏字符规则还是不够的。因为根据 si-xi 计算出来的移动位数，有可能是负数，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。所以，BM 算法还需要用到“好后缀规则”。</p><h3 id="2-好后缀规则"><a href="#2-好后缀规则" class="headerlink" title="2. 好后缀规则"></a>2. 好后缀规则</h3><p>好后缀规则实际上跟坏字符规则的思路很类似。你看我下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/f9756bd3-9eb0-485b-a76f-e8623998c63a.jpg" alt></p><p>这个时候该如何滑动模式串呢？当然，我们还可以利用坏字符规则来计算模式串的滑动位数，不过，我们也可以使用好后缀处理规则。两种规则到底如何选择，我稍后会讲。抛开这个问题，现在我们来看，好后缀规则是怎么工作的？</p><p>我们把已经匹配的 bc 叫作好后缀，记作{u}。我们拿它在模式串中查找，如果找到了另一个跟{u}相匹配的子串{ u<sup>*</sup> }，那我们就将模式串滑动到子串{u*}与主串中{u}对齐的位置。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/14f55532-1650-4b9c-9e5c-bdd51f24c880.jpg" alt></p><p>如果在模式串中找不到另一个等于{u}的子串，我们就直接将模式串，滑动到主串中{u}的后面，因为之前的任何一次往后滑动，都没有匹配主串中{u}的情况。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/582f0acf-1169-4730-99cf-13a3515dc4e9.jpg" alt></p><p>不过，当模式串中不存在等于{u}的子串时，我们直接将模式串滑动到主串{u}的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串{u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/9b3fa3d1cd9c0d0f914a9b1f518ad070.jpg" alt></p><p>如果好后缀在模式串中不存在可匹配的子串，那在我们一步一步往后滑动模式串的过程中，只要主串中的{u}与模式串有重合，那肯定就无法完全匹配。但是当模式串滑动到前缀与主串中{u}的后缀有部分重合的时候，并且重合的部分相等的时候，就有可能会存在完全匹配的情况。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/808d2540-06ec-4abe-9a4a-dad099f3a59a.jpg" alt></p><p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的。</p><p>所谓某个字符串 s 的后缀子串，就是最后一个字符跟 s 对齐的子串，比如 abc 的后缀子串就包括 c, bc。所谓前缀子串，就是起始字符跟 s 对齐的子串，比如 abc 的前缀子串有 a，ab。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是{v}，然后将模式串滑动到如图所示的位置。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/11f05e08-21b5-415f-b122-2c2ec9512ab1.jpg" alt></p><p>坏字符和好后缀的基本原理都讲完了，我现在回答一下前面那个问题。当模式串和主串中的某个字符不匹配的时候，如何选择用好后缀规则还是坏字符规则，来计算模式串往后滑动的位数？</p><p>我们可以分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p><h2 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h2><p>学习完了基本原理，我们再来看，如何实现 BM 算法？</p><p>“坏字符规则”本身不难理解。当遇到坏字符时，要计算往后移动的位数 si-xi，其中 xi 的计算是重点，我们如何求得 xi 呢？或者说，如何查找坏字符在模式串中出现的位置呢？</p><p>如果我们拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。有没有更加高效的方式呢？我们之前学的散列表，这里可以派上用场了。我们可以将模式串中的每个字符及其下标都存到散列表中。这样就可以快速找到坏字符在模式串的位置下标了。</p><p>关于这个散列表，我们只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/42d6df47-de32-41b7-9f4a-07866cd72556.jpg" alt></p><p>如果将上面的过程翻译成代码，就是下面这个样子。其中，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static final int SIZE &#x3D; 256; &#x2F;&#x2F; 全局变量或成员变量</span><br><span class="line">private void generateBC(char[] b, int m, int[] bc) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; SIZE; ++i) &#123;</span><br><span class="line">    bc[i] &#x3D; -1; &#x2F;&#x2F; 初始化bc</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; m; ++i) &#123;</span><br><span class="line">    int ascii &#x3D; (int)b[i]; &#x2F;&#x2F; 计算b[i]的ASCII值</span><br><span class="line">    bc[ascii] &#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掌握了坏字符规则之后，我们先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int bm(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] bc &#x3D; new int[SIZE]; &#x2F;&#x2F; 记录模式串中每个字符最后出现的位置</span><br><span class="line">  generateBC(b, m, bc); &#x2F;&#x2F; 构建坏字符哈希表</span><br><span class="line">  int i &#x3D; 0; &#x2F;&#x2F; i表示主串与模式串对齐的第一个字符</span><br><span class="line">  while (i &lt;&#x3D; n - m) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j &#x3D; m - 1; j &gt;&#x3D; 0; --j) &#123; &#x2F;&#x2F; 模式串从后往前匹配</span><br><span class="line">      if (a[i+j] !&#x3D; b[j]) break; &#x2F;&#x2F; 坏字符对应模式串中的下标是j</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; 0) &#123;</span><br><span class="line">      return i; &#x2F;&#x2F; 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位</span><br><span class="line">    i &#x3D; i + (j - bc[(int)a[i+j]]); </span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的注释已经很详细了，我就不再赘述了。不过，为了你方便理解，我画了一张图，将其中的一些关键变量标注在上面了，结合着图，代码应该更好理解。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/249e1beb-d1a5-4024-bc3d-ddbeb6d43b87.jpg" alt></p><p>至此，我们已经实现了包含坏字符规则的框架代码，只剩下往框架代码中填充好后缀规则了。现在，我们就来看看，如何实现好后缀规则。它的实现要比坏字符规则复杂一些。</p><p>在讲实现之前，我们先简单回顾一下，前面讲过好后缀的处理规则中最核心的内容：</p><ul><li><p><strong>在模式串中，查找跟好后缀匹配的另一个子串；</strong></p></li><li><p><strong>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</strong></p></li></ul><p>在不考虑效率的情况下，这两个操作都可以用很“暴力”的匹配查找方式解决。但是，如果想要 BM 算法的效率很高，这部分就不能太低效。如何来做呢？</p><p>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。这个预处理过程比较有技巧，很不好懂，应该是这节最难懂的内容了，你要认真多读几遍。</p><p>我们先来看，<strong>如何表示模式串中不同的后缀子串呢</strong>？因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，我们只需要记录长度就可以了。通过长度，我们可以确定一个唯一的后缀子串。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/bc6ff76c-ca57-42b4-b9db-9cd6b63fde16.jpg" alt></p><p>现在，我们要<strong>引入最关键的变量 suffix 数组</strong>。suffix 数组的下标 k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀{u}相匹配的子串{u*}的起始下标值。这句话不好理解，我举一个例子。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/7bfeacc2-391f-44b9-ac68-5f80e7c31fad.jpg" alt></p><p>但是，如果模式串中有多个（大于 1 个）子串跟后缀子串{u}匹配，那 suffix 数组中该存储哪一个子串的起始位置呢？为了避免模式串往后滑动得过头了，我们肯定要存储模式串中最靠后的那个子串的起始位置，也就是下标最大的那个子串的起始位置。不过，这样处理就足够了吗？</p><p>实际上，仅仅是选最靠后的子串片段来存储是不够的。我们再回忆一下好后缀规则。</p><p>我们不仅要在模式串中，查找跟好后缀匹配的另一个子串，还要在好后缀的后缀子串中，查找最长的能跟模式串前缀子串匹配的后缀子串。</p><p>如果我们只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来记录模式串的后缀子串是否能匹配模式串的前缀子串。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/ecc7ffe4-f291-495f-adb4-dc452e75348d.jpg" alt></p><p>现在，我们来看下，<strong>如何来计算并填充这两个数组的值？</strong>这个计算过程非常巧妙。</p><p>我们拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j（j 表示公共后缀子串的起始下标）。如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串，我们就记录 prefix[k]=true。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/cf37440c-075a-4a87-99ec-3985c413b2a8.jpg" alt></p><p>我们把 suffix 数组和 prefix 数组的计算过程，用代码实现出来，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; b表示模式串，m表示长度，suffix，prefix数组事先申请好了</span><br><span class="line">private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; m; ++i) &#123; &#x2F;&#x2F; 初始化</span><br><span class="line">    suffix[i] &#x3D; -1;</span><br><span class="line">    prefix[i] &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; m - 1; ++i) &#123; &#x2F;&#x2F; b[0, i]</span><br><span class="line">    int j &#x3D; i;</span><br><span class="line">    int k &#x3D; 0; &#x2F;&#x2F; 公共后缀子串长度</span><br><span class="line">    while (j &gt;&#x3D; 0 &amp;&amp; b[j] &#x3D;&#x3D; b[m-1-k]) &#123; &#x2F;&#x2F; 与b[0, m-1]求公共后缀子串</span><br><span class="line">      --j;</span><br><span class="line">      ++k;</span><br><span class="line">      suffix[k] &#x3D; j+1; &#x2F;&#x2F;j+1表示公共后缀子串在b[0, i]中的起始下标</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &#x3D;&#x3D; -1) prefix[k] &#x3D; true; &#x2F;&#x2F;如果公共后缀子串也是模式串的前缀子串</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这两个数组之后，我们现在来看，<strong>在模式串跟主串匹配的过程中，遇到不能匹配的字符时，如何根据好后缀规则，计算模式串往后滑动的位数？</strong></p><p>假设好后缀的长度是 k。我们先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1（-1 表示不存在匹配的子串），那我们就将模式串往后移动 j-suffix[k]+1 位（j 表示坏字符对应的模式串中的字符下标）。如果 suffix[k]等于 -1，表示模式串中不存在另一个跟好后缀匹配的子串片段。我们可以用下面这条规则来处理。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/5aa973ae-5b5f-4711-a131-34bf41b3d399.jpg" alt></p><p>好后缀的后缀子串 b[r, m-1]（其中，r 取值从 j+2 到 m-1）的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/7689c769-102a-439d-93e1-fd4e43731074.jpg" alt></p><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位。</p><p><img src="/2019/03/03/29-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/711efbaa-e29d-4f1c-9ef4-7384ce1086c3.jpg" alt></p><p>至此，好后缀规则的代码实现我们也讲完了。我们把好后缀规则加到前面的代码框架里，就可以得到 BM 算法的完整版代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a,b表示主串和模式串；n，m表示主串和模式串的长度。</span><br><span class="line">public int bm(char[] a, int n, char[] b, int m) &#123;</span><br><span class="line">  int[] bc &#x3D; new int[SIZE]; &#x2F;&#x2F; 记录模式串中每个字符最后出现的位置</span><br><span class="line">  generateBC(b, m, bc); &#x2F;&#x2F; 构建坏字符哈希表</span><br><span class="line">  int[] suffix &#x3D; new int[m];</span><br><span class="line">  boolean[] prefix &#x3D; new boolean[m];</span><br><span class="line">  generateGS(b, m, suffix, prefix);</span><br><span class="line">  int i &#x3D; 0; &#x2F;&#x2F; j表示主串与模式串匹配的第一个字符</span><br><span class="line">  while (i &lt;&#x3D; n - m) &#123;</span><br><span class="line">    int j;</span><br><span class="line">    for (j &#x3D; m - 1; j &gt;&#x3D; 0; --j) &#123; &#x2F;&#x2F; 模式串从后往前匹配</span><br><span class="line">      if (a[i+j] !&#x3D; b[j]) break; &#x2F;&#x2F; 坏字符对应模式串中的下标是j</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &lt; 0) &#123;</span><br><span class="line">      return i; &#x2F;&#x2F; 匹配成功，返回主串与模式串第一个匹配的字符的位置</span><br><span class="line">    &#125;</span><br><span class="line">    int x &#x3D; j - bc[(int)a[i+j]];</span><br><span class="line">    int y &#x3D; 0;</span><br><span class="line">    if (j &lt; m-1) &#123; &#x2F;&#x2F; 如果有好后缀的话</span><br><span class="line">      y &#x3D; moveByGS(j, m, suffix, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">    i &#x3D; i + Math.max(x, y);</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; j表示坏字符对应的模式串中的字符下标; m表示模式串长度</span><br><span class="line">private int moveByGS(int j, int m, int[] suffix, boolean[] prefix) &#123;</span><br><span class="line">  int k &#x3D; m - 1 - j; &#x2F;&#x2F; 好后缀长度</span><br><span class="line">  if (suffix[k] !&#x3D; -1) return j - suffix[k] +1;</span><br><span class="line">  for (int r &#x3D; j+2; r &lt;&#x3D; m-1; ++r) &#123;</span><br><span class="line">    if (prefix[m-r] &#x3D;&#x3D; true) &#123;</span><br><span class="line">      return r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM-算法的性能分析及优化"><a href="#BM-算法的性能分析及优化" class="headerlink" title="BM 算法的性能分析及优化"></a>BM 算法的性能分析及优化</h2><p>我们先来分析 BM 算法的内存消耗。整个算法用到了额外的 3 个数组，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。</p><p>如果我们处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果我们运行的环境对内存要求苛刻，可以只使用好后缀规则，不使用坏字符规则，这样就可以避免 bc 数组过多的内存消耗。不过，单纯使用好后缀规则的 BM 算法效率就会下降一些了。</p><p>对于执行效率来说，我们可以先从时间复杂度的角度来分析。</p><p>实际上，我前面讲的 BM 算法是个初级版本。为了让你能更容易理解，有些复杂的优化我没有讲。基于我目前讲的这个版本，在极端情况下，预处理计算 suffix 数组、prefix 数组的性能会比较差。</p><p>比如模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 O(m^2)。当然，大部分情况下，时间复杂度不会这么差。关于如何优化这种极端情况下的时间复杂度退化，如果感兴趣，你可以自己研究一下。</p><p>实际上，BM 算法的时间复杂度分析起来是非常复杂，这篇论文<a href="https://dl.acm.org/doi/10.1109/SFCS.1977.3" target="_blank" rel="noopener">“A new proof of the linearity of the Boyer-Moore string searching algorithm”</a>证明了在最坏情况下，BM 算法的比较次数上限是 5n。这篇论文<a href="https://dl.acm.org/doi/10.5555/127787.127830" target="_blank" rel="noopener">“Tight bounds on the complexity of the Boyer-Moore string matching algorithm”</a>证明了在最坏情况下，BM 算法的比较次数上限是 3n。你可以自己阅读看看。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>今天，我们讲了一种比较复杂的字符串匹配算法，BM 算法。尽管复杂、难懂，但匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。如果一遍看不懂的话，你就多看几遍。</p><p>BM 算法核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不能匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配的效率。BM 算法构建的规则有两类，坏字符规则和好后缀规则。好后缀规则可以独立于坏字符规则使用。因为坏字符规则的实现比较耗内存，为了节省内存，我们可以只用好后缀规则来实现 BM 算法。</p><p><strong>suffix和prefix的赋值那里有BUG，应该在每一次k的变动都要有suffix赋值。</strong></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>但对于平时工作，几乎不可能遇到，需要自己手写一个字符串匹配算法的场景。那我们还要学，图的是什么？</p><p>我认为文章中值得学习借鉴的思想有：</p><p>1、要有优化意识，前面的 BF，RK 算法已经能够满足我们需求了，为什么发明 BM 算法？是为了减少时间复杂度，但是带来的弊端是，优化代码变得复杂，维护成本变高。</p><p>2、需要查找，需要减少时间复杂度，应该想到什么？散列表。</p><p>3、如果某个表达式计算开销比较大，又需要频繁的使用怎么办？预处理，并缓存。</p><p>在工作中遇到过这样的情况，需要在一个长度为n (比如十亿级)的巨大的主串中查找长度为m(比如几百)的模式串。主串是固定的，从直观上讲，要加快搜索速度，就需要对主串建索引。BWT-FM算法是解决这类问题最经典的算法，刚接触时也是不好理解，但感觉非常神奇，可以将搜索的时间复杂度降到O(m)，是我认为最伟大的算法之一。</p><p><strong>bm算法号称最高效的 比如grep命令就是用它实现的</strong></p><p>参考：<a href="http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf" target="_blank" rel="noopener">http://www.cs.jhu.edu/~langmea/resources/lecture_notes/boyer_moore.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28-字符串匹配基础上_如何借助哈希算法实现高效字符串匹配</title>
      <link href="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从今天开始，我们来学习字符串匹配算法。字符串匹配这样一个功能，我想对于任何一个开发工程师来说，应该都不会陌生。我们用的最多的就是编程语言提供的字符串查找函数，比如 Java 中的 indexOf()，Python 中的 find() 函数等，它们底层就是依赖接下来要讲的字符串匹配算法。</p><p>字符串匹配算法很多，会分四节来讲解。今天会讲两种比较简单的、好理解的，它们分别是：BF 算法和 RK 算法。下一节，会讲两种比较难理解、但更加高效的，它们是：BM 算法和 KMP 算法。</p><p>这两节讲的都是单模式串匹配的算法，也就是一个串跟一个串进行匹配。第三节、第四节，我会讲两种多模式串匹配算法，也就是在一个串中同时查找多个串，它们分别是 Trie 树和 AC 自动机。</p><p>今天讲的两个算法中，RK 算法是 BF 算法的改进，它巧妙借助了我们前面讲过的哈希算法，让匹配的效率有了很大的提升。那<font color="red">RK 算法是如何借助哈希算法来实现高效字符串匹配的呢？</font>你可以带着这个问题，来学习今天的内容。</p><a id="more"></a><h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>算法中的 BF 是 Brute Force 的缩写，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。</p><p>在开始讲解这个算法之前，我先定义两个概念，方便我后面讲解。它们分别是<strong>主串</strong>和<strong>模式串</strong>。这俩概念很好理解，我举个例子你就懂了。</p><p>比方说，我们在字符串 A 中查找字符串 B，那字符串 A 就是主串，字符串 B 就是模式串。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p><p>作为最简单、最暴力的字符串匹配算法，BF 算法的思想可以用一句话来概括，那就是，<strong>我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</strong>。我举一个例子给你看看，你应该可以理解得更清楚。</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/f36fed972a5bdc75331d59c36eb15aa2.jpg" alt></p><p>从上面的算法思想和例子，我们可以看出，在极端情况下，比如主串是“aaaaa…aaaaaa”（省略号表示有很多重复的字符 a），模式串是“aaaaab”。我们每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的最坏情况时间复杂度是 O(n*m)。</p><p>尽管理论上，BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。为什么这么说呢？原因有两点。</p><p>第一，实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当中途遇到不能匹配的字符的时候，就可以就停止了，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多。</p><p>第二，朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，在满足性能要求的前提下，简单是首选。这也是我们常说的<strong>KISS（Keep it Simple and Stupid）</strong>设计原则。</p><p>所以，在实际的软件开发中，绝大部分情况下，朴素的字符串匹配算法就够用了。</p><h2 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h2><p>RK 算法的全称叫 Rabin-Karp 算法，是由它的两位发明者 Rabin 和 Karp 的名字来命名的。这个算法理解起来也不是很难。我个人觉得，它其实就是刚刚讲的 BF 算法的升级版。</p><p>我在讲 BF 算法的时候讲过，如果模式串长度为 m，主串长度为 n，那在主串中，就会有 n-m+1 个长度为 m 的子串，我们只需要暴力地对比这 n-m+1 个子串与模式串，就可以找出主串与模式串匹配的子串。</p><p>但是，每次检查主串与子串是否匹配，需要依次比对每个字符，所以 BF 算法的时间复杂度就比较高，是 O(n*m)。我们对朴素的字符串匹配算法稍加改造，引入哈希算法，时间复杂度立刻就会降低。</p><p>RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了（这里先不考虑哈希冲突的问题，后面我们会讲到）。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了。</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/3621ff51-c004-4644-9ec5-d30099bf9872.jpg" alt></p><p>不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高。有没有方法可以提高哈希算法计算子串哈希值的效率呢？</p><p>这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。表述起来有点抽象，我举了一个例子，看完你应该就能懂了。</p><p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。</p><p>在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成 26 就可以。</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/d5f6fad3-b456-446e-9ac8-84658c0763ec.jpg" alt></p><p>这个哈希算法你应该看懂了吧？现在，为了方便解释，在下面的讲解中，我假设字符串中只包含 a～z 这 26 个小写字符，我们用二十六进制来表示一个字符串，对应的哈希值就是二十六进制数转化成十进制的结果。</p><p>这种哈希算法有一个特点，在主串中，相邻两个子串的哈希值的计算公式有一定关系。我这有个个例子，你先找一下规律，再来看我后面的讲解。</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/e9e16677-4241-465b-819f-67e83d487b2e.jpg" alt></p><p>从这里例子中，我们很容易就能得出这样的规律：相邻两个子串 s[i-1]和 s[i]（i 表示子串在主串中的起始位置，子串的长度都为 m），对应的哈希值计算公式有交集，也就是说，我们可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。如果用公式表示的话，就是下面这个样子：</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/c47b092408ebfddfa96268037d53aa9c.jpg" alt></p><p>不过，这里有一个小细节需要注意，那就是 26^(m-1) 这部分的计算，我们可以通过查表的方法来提高效率。我们事先计算好 26^0、26^1、26^2……26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间。</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/7ea2aaa0-616b-4d8c-9c7f-71b16ec22164.jpg" alt></p><p>我们开头的时候提过，RK 算法的效率要比 BF 算法高，现在，我们就来分析一下，RK 算法的时间复杂度到底是多少呢？</p><p>整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。</p><p>模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。</p><p>这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，如果超过了计算机中整型数据可以表示的范围，那该如何解决呢？</p><p>刚刚我们设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。因为我们是基于进制来表示一个字符串的，你可以类比成十进制、十六进制来思考一下。实际上，我们为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突。这个时候哈希算法该如何设计呢？</p><p>哈希算法的设计方法有很多，我举一个例子说明一下。假设字符串中只包含 a～z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。</p><p>不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最简单的设计方法，还有很多更加优化的方法，比如将每一个字母从小到大对应一个素数，而不是 1，2，3……这样的自然数，这样冲突的概率就会降低一些。</p><p>那现在新的问题来了。之前我们只需要比较一下模式串和子串的哈希值，如果两个值相等，那这个子串就一定可以匹配模式串。但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。</p><p>实际上，解决方法很简单。当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>BF 算法是最简单、粗暴的字符串匹配算法，它的实现思路是，拿模式串与主串中是所有子串匹配，看是否有能匹配的子串。所以，时间复杂度也比较高，是 O(n*m)，n、m 表示主串和模式串的长度。不过，在实际的软件开发中，因为这种算法实现简单，对于处理小规模的字符串匹配很好用。</p><p>RK 算法是借助哈希算法对 BF 算法进行改造，即对每个子串分别求哈希值，然后拿子串的哈希值与模式串的哈希值比较，减少了比较的时间。所以，理想情况下，RK 算法的时间复杂度是 O(n)，跟 BF 算法相比，效率提高了很多。不过这样的效率取决于哈希算法的设计方法，如果存在冲突的情况下，时间复杂度可能会退化。极端情况下，哈希算法大量冲突，时间复杂度就退化为 O(n*m)。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们今天讲的都是一维字符串的匹配方法，实际上，这两种算法都可以类比到二维空间。假设有下面这样一个二维字符串矩阵（图中的主串），借助今天讲的处理思路，如何在其中查找另一个二维字符串矩阵（图中的模式串）呢？</p><p><img src="/2019/03/01/28-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/b273f700-c9ee-4b4d-892c-09c2752e8a82.jpg" alt></p><p><strong>回答：</strong></p><p>假设二维主串和模式串的维度分别是 m<em>n 和 i*j，横向在[0, m-i]，纵向在[0, n-j]取起始点，然后取同样的子串窗口对比，共有(m-i+1)</em>(n-j+1)个子串。</p><p>ps：<br>文中计算子串哈希值h[i]的公式中，第二个h[i-1]和后面的h[i+m-1]，应该是主串中的第i-1个和第i+m-1个字符的哈希值…</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-GitHub的认识与使用</title>
      <link href="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-GitHub为什么会火"><a href="#1-GitHub为什么会火" class="headerlink" title="1 GitHub为什么会火"></a>1 GitHub为什么会火</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/53d51f84-9a62-4dde-9be4-7cbb9d0b1dae.jpg" alt></p><a id="more"></a><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/fbc94ced-1d7f-4a8d-9efb-22dbc218846e.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/7dbd21e1-01d8-4279-b7dd-0b5735565315.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/68ad18d1-6b50-49fb-82cb-0c64ea04cd9d.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a0c7cf11-f98f-40e9-9a73-b965ec8584c5.jpg" alt></p><h2 id="2-GitHub都有哪些核心功能"><a href="#2-GitHub都有哪些核心功能" class="headerlink" title="2 GitHub都有哪些核心功能"></a>2 GitHub都有哪些核心功能</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/89cbfdee-4587-495e-82eb-983f400ed9cc.png" alt></p><hr><p><strong>CI/CD</strong>：持续集成Continuous Integration（CI）和持续交付Continuous Delivery（CD）</p><p><strong>安全开发</strong><br><strong>代码审查</strong><br><strong>应用程序</strong><br><strong>托管代码</strong><br><strong>项目管理</strong><br><strong>团队管理</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/3cb0ab88-815b-4ad4-9c5b-89f1b59abea5.png" alt></p><h2 id="3-怎么快速淘到感兴趣的开源项目"><a href="#3-怎么快速淘到感兴趣的开源项目" class="headerlink" title="3 怎么快速淘到感兴趣的开源项目"></a>3 怎么快速淘到感兴趣的开源项目</h2><p>通过搜索匹配<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4b02d18e-520c-411a-8f1b-3d38afb83285.png" alt></p><p>或者使用<strong>高级搜索</strong></p><p><strong>git 最好学习资料 in:readme stars:&gt;1000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a7f07365-78c6-4406-bc0e-a8badd887228.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8d66d247-f9d2-4b44-9809-f0ff9af00b91.png" alt></p><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/e0a543a9-3b11-4b7b-94e2-71cb628b8f7f.png" alt></p><p>如果不登录去搜索的话，code 后会跟着 ？ 提示必须登录后才能享受代码的功能</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/1511493f-8f4e-4be8-8bb2-e91d1313ea5c.png" alt></p><h2 id="4-怎样在GitHub上搭建个人博客"><a href="#4-怎样在GitHub上搭建个人博客" class="headerlink" title="4 怎样在GitHub上搭建个人博客"></a>4 怎样在GitHub上搭建个人博客</h2><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p>此处以 <a href="https://github.com/barryclark" target="_blank" rel="noopener">barryclark</a>/<strong><a href="https://github.com/barryclark/jekyll-now" target="_blank" rel="noopener">jekyll-now</a></strong> 为例进行搭建。</p><p>按照步骤</p><ol><li>fork 到自己的仓库中，然后修改仓库名字</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4e3677f9-8877-40b8-86bf-dfbf3e6e56c6.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/839c82a3-253a-436a-aa2c-2b8df57bc2c3.png" alt></p><ol start="2"><li>修改配置文件</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/42ba975b-f1b0-4736-ae7a-3dda0f2493ce.png" alt></p><p>根据需求自己做调整</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2d59fd09-1072-47de-bc65-8fd2e7b06287.png" alt></p><ol start="3"><li>修改_post文件</li></ol><p>可以直接修改 2014-3-3-Hello-World.md 文件<br>或者<br>Create new file 文件<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/0b11316b-70c3-40bc-91ad-6bf75f768c45.png" alt></p><ol start="4"><li>有效日期+标题 2018-12-24-HaoRan-First-Blob.md</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a8784c54-f7a4-42bf-a3e0-9499b47a336b.png" alt></p><p>5.域名在settings中查找</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/6ff2ad0f-c4c6-47da-85bd-4e5486d8b547.png" alt></p><p>6.个人Blob展示</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/71e8cffb-3861-4936-a53e-66ce6f73d2a4.png" alt></p><h2 id="5-开源项目怎么保证代码质量"><a href="#5-开源项目怎么保证代码质量" class="headerlink" title="5 开源项目怎么保证代码质量"></a>5 开源项目怎么保证代码质量</h2><p>进入GitHub主页，点击 pull request</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/5b9b398f-0281-48b8-a47e-fb6ec287203d.jpg" alt></p><p>被merge吸纳的是紫色的，被拒绝的是红色的</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4289a643-491e-4fd5-b8d0-462039459ff2.jpg" alt></p><p>可以看到，有代码审查，有智能监测，owner在做了一系列检查后，才决定是否将他人的request merge到 master上来。</p><h2 id="6-为何需要组织类型的仓库"><a href="#6-为何需要组织类型的仓库" class="headerlink" title="6 为何需要组织类型的仓库"></a>6 为何需要组织类型的仓库</h2><p>在个人 porfile中 会有组织这种类型的仓库。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8aa1d29e-38ec-447a-9442-a772f0d0ef97.jpg" alt></p><p>举一个例子：<br>现阶段，我可能在A公司工作，A公司有一些公共开源的项目在GitHub上托管。过段时间，又加入到B公司的开源项目中工作。根据组织的成员也在流动中，所以需要组织类型的仓库对成员进行管理。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/cf97a418-e69a-4362-aa8c-dd3232217ec2.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f55a9a52-345a-4102-bc92-04ef177994db.jpg" alt></p><p><strong>邀请成员</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f18431a3-248e-4591-b865-8adb5025ae98.jpg" alt></p><p><strong>Team</strong>可以对仓库进行精细化的管控</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2c3267ca-ec77-4685-a2a0-49e63e697928.jpg" alt></p><p>可以加入教师团队的人员</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/32809d24-79a6-47e3-8abe-dcafff4219d9.jpg" alt></p><p>可以给人员分配仓库不同的权限</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/142f6b99-9f3e-49e6-8dd1-fe543d886344.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Git集成使用禁忌</title>
      <link href="/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/"/>
      <url>/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-禁止向集成分支执行push-f-操作"><a href="#1-禁止向集成分支执行push-f-操作" class="headerlink" title="1.禁止向集成分支执行push -f 操作"></a>1.禁止向集成分支执行push -f 操作</h2><p><strong>git push -f：会强制推送，对团队造成危害（虽然远程仓库有特殊机制制止这种变更）</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --hard 回退到某个古老的ID号</span><br><span class="line">git push -f &#x2F;&#x2F;会销毁远端最新最近的提交，所以禁止执行这个命令</span><br></pre></td></tr></table></figure><h2 id="2-禁止向集成分支执行变更历史的操作"><a href="#2-禁止向集成分支执行变更历史的操作" class="headerlink" title="2.禁止向集成分支执行变更历史的操作"></a>2.禁止向集成分支执行变更历史的操作</h2><p>团队协同工作时，<strong>公共分支严禁拉取到本地做rebase变基活动的</strong>，公共分支是团队一起一天天积累下来的，只能往前走，不能做历史变更。</p><p><strong>集成分支不能被改变历史</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27-深度和广度优先搜索_如何找出社交网络中的三度好友关系</title>
      <link href="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们讲了图的表示方法，讲到如何用有向图、无向图来表示一个社交网络。在社交网络中，有一个<strong>六度分割理论</strong>，具体是说，你与世界上的另一个人间隔的关系不会超过六度，也就是说平均只需要六步就可以联系到任何两个互不相识的人。</p><p>一个用户的一度连接用户很好理解，就是他的好友，二度连接用户就是他好友的好友，三度连接用户就是他好友的好友的好友。在社交网络中，我们往往通过用户之间的连接关系，来实现推荐“可能认识的人”这么一个功能。今天的开篇问题就是，<font color="red">&gt;给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？</font></p><p>这就要用到今天要讲的深度优先和广度优先搜索算法。</p><a id="more"></a><h2 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h2><p>我们知道，算法是作用于具体数据结构之上的，深度优先搜索算法和广度优先搜索算法都是基于“图”这种数据结构的。这是因为，图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成“图”。</p><p>图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如今天要讲的两种最简单、最“暴力”的深度优先、广度优先搜索，还有 A<em>、IDA</em> 等启发式搜索算法。</p><p>我们上一节讲过，图有两种主要存储方法，邻接表和邻接矩阵。今天我会用邻接表来存储图。</p><p>我这里先给出图的代码实现。需要说明一下，深度优先搜索算法和广度优先搜索算法，既可以用在无向图，也可以用在有向图上。在今天的讲解中，都针对无向图来讲解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123; &#x2F;&#x2F; 无向图</span><br><span class="line">  private int v; &#x2F;&#x2F; 顶点的个数</span><br><span class="line">  private LinkedList&lt;Integer&gt; adj[]; &#x2F;&#x2F; 邻接表</span><br><span class="line"></span><br><span class="line">  public Graph(int v) &#123;</span><br><span class="line">    this.v &#x3D; v;</span><br><span class="line">    adj &#x3D; new LinkedList[v];</span><br><span class="line">    for (int i&#x3D;0; i&lt;v; ++i) &#123;</span><br><span class="line">      adj[i] &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void addEdge(int s, int t) &#123; &#x2F;&#x2F; 无向图一条边存两次</span><br><span class="line">    adj[s].add(t);</span><br><span class="line">    adj[t].add(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First-Search），我们平常都把简称为 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以我画了一张示意图，你可以看下。</p><p><img src="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/7a9c2a35-e805-4348-b1c5-8dabaf2ea0c2.jpg" alt></p><p>尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。所以，我们重点讲一下它的代码实现。</p><p>这里面，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点。我们搜索一条从 s 到 t 的路径。实际上，这样求得的路径就是从 s 到 t 的最短路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void bfs(int s, int t) &#123;</span><br><span class="line">  if (s &#x3D;&#x3D; t) return;</span><br><span class="line">  boolean[] visited &#x3D; new boolean[v];</span><br><span class="line">  visited[s]&#x3D;true;</span><br><span class="line">  Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  int[] prev &#x3D; new int[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] &#x3D; -1;</span><br><span class="line">  &#125;</span><br><span class="line">  while (queue.size() !&#x3D; 0) &#123;</span><br><span class="line">    int w &#x3D; queue.poll();</span><br><span class="line">   for (int i &#x3D; 0; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      int q &#x3D; adj[w].get(i);</span><br><span class="line">      if (!visited[q]) &#123;</span><br><span class="line">        prev[q] &#x3D; w;</span><br><span class="line">        if (q &#x3D;&#x3D; t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] &#x3D; true;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void print(int[] prev, int s, int t) &#123; &#x2F;&#x2F; 递归打印s-&gt;t的路径</span><br><span class="line">  if (prev[t] !&#x3D; -1 &amp;&amp; t !&#x3D; s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + &quot; &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不是很好理解，里面有三个重要的辅助变量 visited、queue、prev。只要理解这三个变量，读懂这段代码估计就没什么问题了。</p><p><strong>visited</strong> 是用来记录已经被访问的顶点，用来避免顶点被重复访问。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true。</p><p><strong>queue</strong> 是一个队列，用来存储已经被访问、但相连的顶点还没有被访问的顶点。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能。</p><p><strong>prev</strong> 用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个路径是反向存储的。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2。为了正向打印出路径，我们需要递归地来打印，你可以看下 print() 函数的实现方式。</p><p>为了方便理解，我画了一个广度优先搜索的分解图，你可以结合着代码以及我的讲解一块儿看。</p><p><img src="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/45ca0556-8f88-46ad-9b1d-c0100938f952.jpg" alt></p><p><img src="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/489b4444-adf4-4219-b9b8-26bcde37d09b.jpg" alt></p><p><img src="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/78b5e905-e557-43d9-a4e0-29c3cfc7af5e.jpg" alt></p><p>掌握了广优先搜索算法的原理，我们来看下，广度优先搜索的时间、空间复杂度是多少呢？</p><p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，广度优先搜索的时间复杂度也可以简写为 O(E)。</p><p>广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)。</p><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First-Search），简称 DFS。最直观的例子就是“走迷宫”。</p><p>假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>走迷宫的例子很容易能看懂，我们现在再来看下，如何在图中应用深度优先搜索，来找某个顶点到另一个顶点的路径。</p><p>你可以看我画的这幅图。搜索的起始顶点是 s，终止顶点是 t，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。如果映射到迷宫那个例子，s 就是你起始所在的位置，t 就是出口。</p><p>我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径。</p><p><img src="/2019/02/13/27-%E6%B7%B1%E5%BA%A6%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%89%E5%BA%A6%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/9f196cb9-2da6-4ef5-8c66-377ba2836c4b.jpg" alt></p><p>实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。回溯思想我们后面会有专门的一节来讲，我们现在还回到深度优先搜索算法上。</p><p>我把上面的过程用递归来翻译出来，就是下面这个样子。我们发现，深度优先搜索代码实现也用到了 prev、visited 变量以及 print() 函数，它们跟广度优先搜索代码实现里的作用是一样的。不过，深度优先搜索代码实现里，有个比较特殊的变量 found，它的作用是，当我们已经找到终止顶点 t 之后，我们就不再递归地继续查找了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">boolean found &#x3D; false; &#x2F;&#x2F; 全局变量或者类成员变量</span><br><span class="line"></span><br><span class="line">public void dfs(int s, int t) &#123;</span><br><span class="line">  found &#x3D; false;</span><br><span class="line">  boolean[] visited &#x3D; new boolean[v];</span><br><span class="line">  int[] prev &#x3D; new int[v];</span><br><span class="line">  for (int i &#x3D; 0; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] &#x3D; -1;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void recurDfs(int w, int t, boolean[] visited, int[] prev) &#123;</span><br><span class="line">  if (found &#x3D;&#x3D; true) return;</span><br><span class="line">  visited[w] &#x3D; true;</span><br><span class="line">  if (w &#x3D;&#x3D; t) &#123;</span><br><span class="line">    found &#x3D; true;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    int q &#x3D; adj[w].get(i);</span><br><span class="line">    if (!visited[q]) &#123;</span><br><span class="line">      prev[q] &#x3D; w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解了深度优先搜索算法之后，我们来看，深度度优先搜索的时、空间间复杂度是多少呢？</p><p>从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的深度优先搜索算法的时间复杂度是 O(E)，E 表示边的个数。</p><p>深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>了解了深度优先搜索和广度优先搜索的原理之后，开篇的问题是不是变得很简单了呢？我们现在来一起看下，如何找出社交网络中某个用户的三度好友关系？</p><p>上一节我们讲过，社交网络可以用图来表示。这个问题就非常适合用图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系。</p><p>我们只需要稍加改造一下广度优先搜索代码，用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>广度优先搜索和深度优先搜索是图上的两种最常用、最基本的搜索算法，比起其他高级的搜索算法，比如 A<em>、IDA</em> 等，要简单粗暴，没有什么优化，所以，也被叫作暴力搜索算法。所以，这两种搜索算法仅适用于状态空间不大，也就是说图不大的搜索。</p><p>广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助队列来实现，遍历得到的路径就是，起始顶点到终止顶点的最短路径。深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助栈来实现的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 我们通过广度优先搜索算法解决了开篇的问题，你可以思考一下，能否用深度优先搜索来解决呢？</p><p>2 学习数据结构最难的不是理解和掌握原理，而是能灵活地将各种场景和问题抽象成对应的数据结构和算法。今天的内容中提到，迷宫可以抽象成图，走迷宫可以抽象成搜索算法，你能具体讲讲，如何将迷宫抽象成一个图吗？或者换个说法，如何在计算机中存储一个迷宫？</p><p><strong>回答：</strong></p><p>1 可以用深度遍历，每次遍历到三度人脉，再回溯到上层节点，直到所有的三度人脉都找完。</p><p>2 将迷宫的每个岔口记为”顶点”，岔口之间的路径记为”边”，可以用邻接表存储，也可以用邻接矩阵存储。但是个人感觉，像那种标准的方格迷宫，适合用邻接矩阵存储，因为稠密度比较高。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>深度：借助一个栈</p><p>广度：借助一个队列</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26-图的表示_如何存储微博微信等社交网络中的好友关系</title>
      <link href="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/"/>
      <url>/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>微博、微信、LinkedIn 这些社交软件我想你肯定都玩过吧。在微博中，两个人可以互相关注；在微信中，两个人可以互加好友。那你知道，如何存储微博、微信等这些社交网络的好友关系吗？</p><p>这就要用到我们今天要讲的这种数据结构：图。实际上，涉及图的算法有很多，也非常复杂，比如图的搜索、最短路径、最小生成树、二分图等等。我们今天聚焦在图存储这一方面，后面会分好几篇来依次讲解图相关的算法。</p><a id="more"></a><h2 id="如何理解“图”？"><a href="#如何理解“图”？" class="headerlink" title="如何理解“图”？"></a>如何理解“图”？</h2><p>我们前面讲过了树这种非线性表数据结构，今天我们要讲另一种非线性表数据结构，<strong>图</strong>（Graph）。和树比起来，这是一种更加复杂的非线性表结构。</p><p>我们知道，树中的元素我们称为节点，图中的元素我们就叫作<strong>顶点</strong>（vertex）。从我画的图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫作<strong>边</strong>（edge）。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/709ad9cc-9677-47f4-bec9-21974c1d6542.jpg" alt></p><p>我们生活中就有很多符合图这种结构的例子。比如，开篇问题中讲到的社交网络，就是一个非常典型的图结构。</p><p>我们就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫作顶点的<strong>度</strong>（degree），就是跟顶点相连接的边的条数。</p><p>实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，也就是说，用户 A 关注了用户 B，但用户 B 可以不关注用户 A。那我们如何用图来表示这种单向的社交关系呢？</p><p>我们可以把刚刚讲的图结构稍微改造一下，引入边的“方向”的概念</p><p>如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫作“有向图”。以此类推，我们把边没有方向的图就叫作“无向图”。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/65924fc9-bfc2-49a3-90d0-2ce83d45ad12.jpg" alt></p><p>我们刚刚讲过，无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为<strong>入度</strong>（In-degree）和<strong>出度</strong>（Out-degree）。</p><p>顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><p>前面讲到了微信、微博、无向图、有向图，现在我们再来看另一种社交软件：QQ。</p><p>QQ 中的社交关系要更复杂的一点。不知道你有没有留意过 QQ 亲密度这样一个功能。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。如何在图中记录这种好友关系的亲密度呢？</p><p>这里就要用到另一种图，<strong>带权图</strong>（weighted graph）。在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/b6bc821f-622a-44e9-b2c8-c480a4e8f164.jpg" alt></p><p>关于图的概念比较多，我今天也只是介绍了几个常用的，理解起来都不复杂，不知道你都掌握了没有？掌握了图的概念之后，我们再来看下，如何在内存中存储图这种数据结构呢？</p><h2 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h2><p>图最直观的一种存储方法就是，<strong>邻接矩阵</strong>（Adjacency Matrix）。</p><p>邻接矩阵的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。对于带权图，数组中就存储相应的权重。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/663d7e76-d03e-41bd-becf-0c03817e55f5.jpg" alt></p><p>用邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。为什么这么说呢？</p><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了。</p><p>还有，如果我们存储的是<strong>稀疏图</strong>（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了。</p><p>但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。比如求解最短路径问题时会提到一个<strong>Floyd-Warshall 算法</strong>，就是利用矩阵循环相乘若干次得到结果。</p><h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><p>针对上面邻接矩阵比较浪费内存空间的问题，我们来看另外一种图的存储方法，<strong>邻接表</strong>（Adjacency List）。</p><p>我画了一张邻接表的图，你可以先看下。乍一看，邻接表是不是有点像散列表？每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。另外我需要说明一下，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点。对于无向图来说，也是类似的，不过，每个顶点的链表中存储的，是跟这个顶点有边相连的顶点，你可以自己画下。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/6534302e-7ab4-4211-b2ed-ef750b2e7cde.jpg" alt></p><p>还记得我们之前讲过的时间、空间复杂度互换的设计思想吗？邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。</p><p>就像图中的例子，如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，我们前面也讲过，链表的存储方式对缓存不友好。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p><p>在散列表那几节里，讲到，在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等。我们刚刚也讲到，邻接表长得很像散列。所以，我们也可以将邻接表同散列表一样进行“改进升级”。</p><p>我们可以将邻接表中的链表改成平衡二叉查找树。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们还可以将链表改成有序动态数组，可以通过二分查找的方法来快速定位两个顶点之间否是存在边。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>有了前面讲的理论知识，现在我们回过头来看开篇的问题，如何存储微博、微信等社交网络中的好友关系？</p><p>前面我们分析了，微博、微信是两种“图”，前者是有向图，后者是无向图。在这个问题上，两者的解决思路差不多，所以我只拿微博来讲解。</p><p>数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系。针对微博用户关系，假设我们需要支持下面这样几个操作：</p><ul><li><p>判断用户 A 是否关注了用户 B；</p></li><li><p>判断用户 A 是否是用户 B 的粉丝；</p></li><li><p>用户 A 关注用户 B；</p></li><li><p>用户 A 取消关注用户 B；</p></li><li><p>根据用户名称的首字母排序，分页获取用户的粉丝列表；</p></li><li><p>根据用户名称的首字母排序，分页获取用户的关注列表。</p></li></ul><p>关于如何存储一个图，前面我们讲到两种主要的存储方法，邻接矩阵和邻接表。因为社交网络是一张稀疏图，使用邻接矩阵存储比较浪费存储空间。所以，这里我们采用邻接表来存储。</p><p>不过，用一个邻接表来存储这种有向图是不够的。我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。</p><p>基于此，我们需要一个逆邻接表。邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系。对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/501440bcffdcf4e6f9a5ca1117e990a1.jpg" alt></p><p>基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系，所以我们选择改进版本，将邻接表中的链表改为支持快速查找的动态数据结构。选择哪种动态数据结构呢？红黑树、跳表、有序动态数组还是散列表呢？</p><p>因为我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。最重要的一点，跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效。</p><p>如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。这个时候该怎么办呢？</p><p>我们可以通过哈希算法等数据分片方式，将邻接表存储在不同的机器上。你可以看下面这幅图，我们在机器 1 上存储顶点 1，2，3 的邻接表，在机器 2 上，存储顶点 4，5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/240f6f0b-8494-4f67-b020-d3ca420c4aac.jpg" alt></p><p>除此之外，我们还有另外一种解决思路，就是利用外部存储（比如硬盘），因为外部存储的存储空间要比内存会宽裕很多。数据库是我们经常用来持久化存储关系数据的，所以我这里介绍一种数据库的存储方式。</p><p>我用下面这张表来存储这样一个图。为了高效地支持前面定义的操作，我们可以在表上建立多个索引，比如第一列、第二列，给这两列都建立索引。</p><p><img src="/2019/02/10/26-%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA-%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%BE%AE%E5%8D%9A%E5%BE%AE%E4%BF%A1%E7%AD%89%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB/dd8a7cb0-5d43-45eb-8381-a27f318341b2.jpg" alt></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了图这种非线性表数据结构，关于图，你需要理解这样几个概念：无向图、有向图、带权图、顶点、边、度、入度、出度。除此之外，我们还学习了图的两个主要的存储方式：邻接矩阵和邻接表。</p><p>邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。针对这个问题，邻接表还有改进升级版，即将链表换成更加高效的动态数据结构，比如平衡二叉查找树、跳表、散列表等。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 关于开篇思考题，我们只讲了微博这种有向图的解决思路，那像微信这种无向图，应该怎么存储呢？</p><p>2 除了今天举的社交网络可以用图来表示之外，符合图这种结构特点的例子还有很多，比如知识图谱（Knowledge Graph）。关于图这种数据结构，你还能想到其他生活或者工作中的例子吗？</p><p><strong>回答：</strong></p><p>1：使用邻接表存储，并且使用改进升级版（使用跳表或散列表等）</p><p>2 地图、网络。</p><p>工作流项目描述的就是有向图</p><p>小到公交车/地铁网络图，大到国家的铁路分布图</p><p>韩国偶像剧，人物之间的暗恋关系</p><p>ETL跑批时，各JOB之间的依赖关系</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>微信也是有向图……微信单方面删除好友之后另一方仍然会显示在好友列表中的啊(俗称僵尸)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内地图坐标系转换</title>
      <link href="/2019/02/08/%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/02/08/%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>文章出处<br><a href="https://blog.csdn.net/m0_37738114/article/details/80452485" target="_blank" rel="noopener">https://blog.csdn.net/m0_37738114/article/details/80452485</a></p><h2 id="一、国内常用坐标系"><a href="#一、国内常用坐标系" class="headerlink" title="一、国内常用坐标系"></a>一、国内常用坐标系</h2><p>1、WGS-84坐标系：地心坐标系，GPS原始坐标体系<br>在中国，任何一个地图产品都<font color="red">不允许使用<a href="https://www.baidu.com/s?wd=GPS%E5%9D%90%E6%A0%87&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">GPS坐标</a></font>，据说是为了保密。</p><p>2、GCJ-02 坐标系：国测局坐标，火星坐标系<br>1）国测局02年发布的坐标体系，它是一种对经纬度数据的加密算法，即加入随机的偏差。<br>2）互联网地图在国内必须至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。<br>3）是国内最广泛使用的坐标体系，高德、腾讯、Google中国地图都使用它。</p><p>3、CGCS2000坐标系：国家大地坐标系<br>该坐标系是通过中国GPS 连续运行基准站、 空间大地控制网以及天文大地网与空间地网联合平差建立的地心大地坐标系统。</p><p>4、BD-09坐标系<br>百度中国地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><a id="more"></a><p>5、搜狗坐标系<br>搜狗地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><p>6、图吧坐标系<br>图吧地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><h2 id="二、国内地图软件所采用的坐标系简介"><a href="#二、国内地图软件所采用的坐标系简介" class="headerlink" title="二、国内地图软件所采用的坐标系简介"></a>二、国内地图软件所采用的坐标系简介</h2><table>    <tr>        <td>1、百度地图1）境内（包括港澳台）：BD09a、在GCJ-02坐标系基础上再次加密b、支持WGS-84、GCJ-02转换成BD09，反向不支持，并且批量转换一次有条数限制2）境外：WGS-84</td>        <td>2、高德地图:1）境内：GCJ-02a、WGS-84——>GCJ-02（高德有接口提供，反过来没有）2）境外：暂不支持3）AMap 就是高德地图，是高德地图在纳斯达克上市用的名字，主要面向互联网企业或个人提供免费API服务4）MapABC 是高德集团底下的图盟公司，主要面向大众型企业或政府机关，并提供付费的有偿服务5）Amap和MapABC，数据和服务都是共享的，所以Mapabc用Amap的API是正常的</td>    </tr>    <tr>        <td>3、google地图1）境内：GCJ-02a、数据来源于高德，两者互通2）境外：WGS-84</td>        <td>4、天地图全球统一：CGCS2000</td>    </tr>    <tr>        <td>5、腾讯地图：soso地图境内：GCJ02</td>        <td>6、微软bing地图：BingMap全球统一：WGS-84</td>    </tr>    <tr>        <td>7、搜狗地图境内：搜狗坐标系a、在GCJ-02坐标系基础上再次加密b、支持WGS-84、GCJ-02、BD09转换成搜狗坐标，反向不支持</td>        <td>8、图吧地图: MapBar境内：图吧坐标系a、在GCJ-02坐标系基础上再次加密</td>    </tr>    <tr>        <td>9、阿里云地图境内：GCJ-02</td>        <td>10、灵图地图：51ditu境内：GCJ-02</td>    </tr></table><h2 id="三、各个坐标系之间的转换"><a href="#三、各个坐标系之间的转换" class="headerlink" title="三、各个坐标系之间的转换"></a>三、各个坐标系之间的转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">1、以下代码，提供的转换算法如下：</span><br><span class="line">1）WGS-84 ——&gt; GCJ02</span><br><span class="line">2）GCJ02 ——&gt; WGS-84</span><br><span class="line">3）GCJ02 ——&gt; BD09</span><br><span class="line">4）BD09 ——&gt; GCJ02</span><br><span class="line">5）BD09 ——&gt; WGS-84</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.   package com.xy;  </span><br><span class="line">2.</span><br><span class="line">3.   &#x2F;** </span><br><span class="line">4.    * 各地图API坐标系统比较与转换; </span><br><span class="line">5.    * WGS84坐标系：即地球坐标系，国际上通用的坐标系。设备一般包含GPS芯片或者北斗芯片获取的经纬度为WGS84地理坐标系, </span><br><span class="line">6.    * 谷歌地图采用的是WGS84地理坐标系（中国范围除外）; </span><br><span class="line">7.    * GCJ02坐标系：即火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 </span><br><span class="line">8.    * 谷歌中国地图和搜搜中国地图采用的是GCJ02地理坐标系; BD09坐标系：即百度坐标系，GCJ02坐标系经加密后的坐标系; </span><br><span class="line">9.    * 搜狗坐标系、图吧坐标系等，估计也是在GCJ02基础上加密而成的。  </span><br><span class="line">10.  *&#x2F;  </span><br><span class="line"></span><br><span class="line">11. public class PositionUtil &#123;  </span><br><span class="line">12.       </span><br><span class="line">13.     public static final String BAIDU_LBS_TYPE &#x3D; &quot;bd09ll&quot;;  </span><br><span class="line">14.       </span><br><span class="line">15.     public static double pi &#x3D; 3.1415926535897932384626;  </span><br><span class="line">16.     public static double a &#x3D; 6378245.0;  </span><br><span class="line">17.     public static double ee &#x3D; 0.00669342162296594323;  </span><br><span class="line">18.   </span><br><span class="line">19.     &#x2F;** </span><br><span class="line">20.      * 84 to 火星坐标系 (GCJ-02) World Geodetic System &#x3D;&#x3D;&gt; Mars Geodetic System </span><br><span class="line">21.      *  </span><br><span class="line">22.      * @param lat </span><br><span class="line">23.      * @param lon </span><br><span class="line">24.      * @return </span><br><span class="line">25.      *&#x2F;  </span><br><span class="line">26.     public static Gps gps84_To_Gcj02(double lat, double lon) &#123;  </span><br><span class="line">27.         if (outOfChina(lat, lon)) &#123;  </span><br><span class="line">28.             return null;  </span><br><span class="line">29.         &#125;  </span><br><span class="line">30.         double dLat &#x3D; transformLat(lon - 105.0, lat - 35.0);  </span><br><span class="line">31.         double dLon &#x3D; transformLon(lon - 105.0, lat - 35.0);  </span><br><span class="line">32.         double radLat &#x3D; lat &#x2F; 180.0 * pi;  </span><br><span class="line">33.         double magic &#x3D; Math.sin(radLat);  </span><br><span class="line">34.         magic &#x3D; 1 - ee * magic * magic;  </span><br><span class="line">35.         double sqrtMagic &#x3D; Math.sqrt(magic);  </span><br><span class="line">36.         dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * pi);  </span><br><span class="line">37.         dLon &#x3D; (dLon * 180.0) &#x2F; (a &#x2F; sqrtMagic * Math.cos(radLat) * pi);  </span><br><span class="line">38.         double mgLat &#x3D; lat + dLat;  </span><br><span class="line">39.         double mgLon &#x3D; lon + dLon;  </span><br><span class="line">40.         return new Gps(mgLat, mgLon);  </span><br><span class="line">41.     &#125;  </span><br><span class="line">42.   </span><br><span class="line"></span><br><span class="line">43.     &#x2F;** </span><br><span class="line">44.      * * 火星坐标系 (GCJ-02) to 84 * * @param lon * @param lat * @return </span><br><span class="line">45.      * *&#x2F;  </span><br><span class="line">46.     public static Gps gcj_To_Gps84(double lat, double lon) &#123;  </span><br><span class="line">47.         Gps gps &#x3D; transform(lat, lon);  </span><br><span class="line">48.         double lontitude &#x3D; lon * 2 - gps.getWgLon();  </span><br><span class="line">49.         double latitude &#x3D; lat * 2 - gps.getWgLat();  </span><br><span class="line">50.         return new Gps(latitude, lontitude);  </span><br><span class="line">51.     &#125;  </span><br><span class="line">52.   </span><br><span class="line"></span><br><span class="line">53.     &#x2F;** </span><br><span class="line">54.      * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 将 GCJ-02 坐标转换成 BD-09 坐标 </span><br><span class="line">55.      *  </span><br><span class="line">56.      * @param gg_lat </span><br><span class="line">57.      * @param gg_lon </span><br><span class="line">58.      *&#x2F;  </span><br><span class="line">59.     public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;  </span><br><span class="line">60.         double x &#x3D; gg_lon, y &#x3D; gg_lat;  </span><br><span class="line">61.         double z &#x3D; Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);  </span><br><span class="line">62.         double theta &#x3D; Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);  </span><br><span class="line">63.         double bd_lon &#x3D; z * Math.cos(theta) + 0.0065;  </span><br><span class="line">64.         double bd_lat &#x3D; z * Math.sin(theta) + 0.006;  </span><br><span class="line">65.         return new Gps(bd_lat, bd_lon);  </span><br><span class="line">66.     &#125;  </span><br><span class="line"></span><br><span class="line">67.   </span><br><span class="line">68.     &#x2F;** </span><br><span class="line">69.      * * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 * * 将 BD-09 坐标转换成GCJ-02 坐标 * * @param </span><br><span class="line">70.      * bd_lat * @param bd_lon * @return </span><br><span class="line">71.      *&#x2F;  </span><br><span class="line">72.     public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;  </span><br><span class="line">73.         double x &#x3D; bd_lon - 0.0065, y &#x3D; bd_lat - 0.006;  </span><br><span class="line">74.         double z &#x3D; Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);  </span><br><span class="line">75.         double theta &#x3D; Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);  </span><br><span class="line">76.         double gg_lon &#x3D; z * Math.cos(theta);  </span><br><span class="line">77.         double gg_lat &#x3D; z * Math.sin(theta);  </span><br><span class="line">78.         return new Gps(gg_lat, gg_lon);  </span><br><span class="line">79.     &#125;  </span><br><span class="line"></span><br><span class="line">80.   </span><br><span class="line"></span><br><span class="line">81.     &#x2F;** </span><br><span class="line">82.      * (BD-09)--&gt;84 </span><br><span class="line">83.      * @param bd_lat </span><br><span class="line">84.      * @param bd_lon </span><br><span class="line">85.      * @return </span><br><span class="line">86.      *&#x2F;  </span><br><span class="line"></span><br><span class="line">87.     public static Gps bd09_To_Gps84(double bd_lat, double bd_lon) &#123;  </span><br><span class="line">88.   </span><br><span class="line">89.         Gps gcj02 &#x3D; PositionUtil.bd09_To_Gcj02(bd_lat, bd_lon);  </span><br><span class="line">90.         Gps map84 &#x3D; PositionUtil.gcj_To_Gps84(gcj02.getWgLat(),  </span><br><span class="line">91.                 gcj02.getWgLon());  </span><br><span class="line">92.         return map84;  </span><br><span class="line">93.   </span><br><span class="line">94.     &#125;  </span><br><span class="line"></span><br><span class="line">95.   </span><br><span class="line">96.     public static boolean outOfChina(double lat, double lon) &#123;  </span><br><span class="line">97.         if (lon &lt; 72.004 || lon &gt; 137.8347)  </span><br><span class="line">98.             return true;  </span><br><span class="line">99.         if (lat &lt; 0.8293 || lat &gt; 55.8271)  </span><br><span class="line">100.              return true;  </span><br><span class="line">101.          return false;  </span><br><span class="line">102.      &#125;  </span><br><span class="line">103.    </span><br><span class="line">104.      public static Gps transform(double lat, double lon) &#123;  </span><br><span class="line">105.          if (outOfChina(lat, lon)) &#123;  </span><br><span class="line">106.              return new Gps(lat, lon);  </span><br><span class="line">107.          &#125;  </span><br><span class="line">108.          double dLat &#x3D; transformLat(lon - 105.0, lat - 35.0);  </span><br><span class="line">109.          double dLon &#x3D; transformLon(lon - 105.0, lat - 35.0);  </span><br><span class="line">110.          double radLat &#x3D; lat &#x2F; 180.0 * pi;  </span><br><span class="line">111.          double magic &#x3D; Math.sin(radLat);  </span><br><span class="line">112.          magic &#x3D; 1 - ee * magic * magic;  </span><br><span class="line">113.          double sqrtMagic &#x3D; Math.sqrt(magic);  </span><br><span class="line">114.          dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * pi);  </span><br><span class="line">115.          dLon &#x3D; (dLon * 180.0) &#x2F; (a &#x2F; sqrtMagic * Math.cos(radLat) * pi);  </span><br><span class="line">116.          double mgLat &#x3D; lat + dLat;  </span><br><span class="line">117.          double mgLon &#x3D; lon + dLon;  </span><br><span class="line">118.          return new Gps(mgLat, mgLon);  </span><br><span class="line">119.      &#125;  </span><br><span class="line">120.    </span><br><span class="line">121.      public static double transformLat(double x, double y) &#123;  </span><br><span class="line">122.          double ret &#x3D; -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y  </span><br><span class="line">123.                  + 0.2 * Math.sqrt(Math.abs(x));  </span><br><span class="line">124.          ret +&#x3D; (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">125.          ret +&#x3D; (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">126.          ret +&#x3D; (160.0 * Math.sin(y &#x2F; 12.0 * pi) + 320 * Math.sin(y * pi &#x2F; 30.0)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">127.          return ret;  </span><br><span class="line">128.      &#125;  </span><br><span class="line">129.    </span><br><span class="line">130.      public static double transformLon(double x, double y) &#123;  </span><br><span class="line">131.          double ret &#x3D; 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1  </span><br><span class="line">132.                  * Math.sqrt(Math.abs(x));  </span><br><span class="line">133.          ret +&#x3D; (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">134.          ret +&#x3D; (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0; </span><br><span class="line">135.          ret +&#x3D; (150.0 * Math.sin(x &#x2F; 12.0 * pi) + 300.0 * Math.sin(x &#x2F; 30.0  </span><br><span class="line">136.                  * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">137.          return ret;  </span><br><span class="line">138.      &#125;  </span><br><span class="line">139.    </span><br><span class="line">140.      public static void main(String[] args) &#123;  </span><br><span class="line">141.    </span><br><span class="line">142.          &#x2F;&#x2F; 北斗芯片获取的经纬度为WGS84地理坐标 31.426896,119.496145  </span><br><span class="line">143.          Gps gps &#x3D; new Gps(31.426896, 119.496145);  </span><br><span class="line">144.          System.out.println(&quot;gps :&quot; + gps);  </span><br><span class="line">145.          Gps gcj &#x3D; gps84_To_Gcj02(gps.getWgLat(), gps.getWgLon());  </span><br><span class="line">146.          System.out.println(&quot;gcj :&quot; + gcj);  </span><br><span class="line">147.          Gps star &#x3D; gcj_To_Gps84(gcj.getWgLat(), gcj.getWgLon());  </span><br><span class="line">148.          System.out.println(&quot;star:&quot; + star);  </span><br><span class="line">149.          Gps bd &#x3D; gcj02_To_Bd09(gcj.getWgLat(), gcj.getWgLon());  </span><br><span class="line">150.          System.out.println(&quot;bd  :&quot; + bd);  </span><br><span class="line">151.          Gps gcj2 &#x3D; bd09_To_Gcj02(bd.getWgLat(), bd.getWgLon());  </span><br><span class="line">152.          System.out.println(&quot;gcj :&quot; + gcj2);  </span><br><span class="line">153.      &#125;  </span><br><span class="line">154.  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2、百度在线转换API</span><br><span class="line">1.   http:&#x2F;&#x2F;api.map.baidu.com&#x2F;ag&#x2F;coord&#x2F;convert?from&#x3D;0&amp;to&#x3D;4&amp;x&#x3D;longitude&amp;y&#x3D;latitude   </span><br><span class="line">2.   from: 来源坐标系   （0表示WGS-84坐标，2表示GCJ-02坐标）  </span><br><span class="line">3.   to: 转换后的坐标  (4就是百度自己啦，这个必须是4才行）  </span><br><span class="line">4.   x: 精度  </span><br><span class="line">5.   y: 纬度</span><br><span class="line">得到的经纬度需要进一步转换才能得到BD-09坐标</span><br><span class="line">1.   import java.io.BufferedReader;  </span><br><span class="line">2.   import java.io.IOException;  </span><br><span class="line">3.   import java.io.InputStream;  </span><br><span class="line">4.   import java.io.InputStreamReader;  </span><br><span class="line">5.   import java.io.OutputStreamWriter;  </span><br><span class="line">6.   import java.net.URL;  </span><br><span class="line">7.   import java.net.URLConnection;  </span><br><span class="line">8.   import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;  </span><br><span class="line">9.   public class BaiduAPIConverter extends Thread &#123;  </span><br><span class="line">10.   public static void testPost(String x, String y) throws IOException &#123;  </span><br><span class="line">11.     try &#123;  </span><br><span class="line">12.       URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;api.map.baidu.com&#x2F;ag&#x2F;coord&#x2F;convert?from&#x3D;2&amp;to&#x3D;4&amp;x&#x3D;&quot;+ </span><br><span class="line">13.                                        x + &quot;&amp;y&#x3D;&quot; + y);  </span><br><span class="line">14.       URLConnection connection &#x3D; url.openConnection();  </span><br><span class="line">15.       connection.setDoOutput(true);  </span><br><span class="line">16.       OutputStreamWriter out &#x3D; new OutputStreamWriter(connection.getOutputStream(), &quot;utf-8&quot;);  </span><br><span class="line">17.       &#x2F;&#x2F; remember to clean up   </span><br><span class="line">18.       out.flush();  </span><br><span class="line">19.       out.close();  </span><br><span class="line">20.       &#x2F;&#x2F; 一旦发送成功，用以下方法就可以得到服务器的回应：   </span><br><span class="line">21.       String sCurrentLine, sTotalString;  </span><br><span class="line">22.       sCurrentLine &#x3D; sTotalString &#x3D; &quot;&quot;;  </span><br><span class="line">23.       InputStream l_urlStream;  </span><br><span class="line">24.       l_urlStream &#x3D; connection.getInputStream();  </span><br><span class="line">25.       BufferedReader l_reader &#x3D; new BufferedReader(new InputStreamReader(l_urlStream));  </span><br><span class="line">26.       while ((sCurrentLine &#x3D; l_reader.readLine()) !&#x3D; null) &#123;  </span><br><span class="line">27.         if (!sCurrentLine.equals(&quot;&quot;))  </span><br><span class="line">28.           sTotalString +&#x3D; sCurrentLine;  </span><br><span class="line">29.       &#125;  </span><br><span class="line">30.       sTotalString &#x3D; sTotalString.substring(1, sTotalString.length() - 1);  </span><br><span class="line">31.       String[] results &#x3D; sTotalString.split(&quot;\\,&quot;);  </span><br><span class="line"></span><br><span class="line">32.       if (results.length &#x3D;&#x3D; 3) &#123;  </span><br><span class="line">33.         if (results[0].split(&quot;\\:&quot;)[1].equals(&quot;0&quot;)) &#123;  </span><br><span class="line">34.           String mapX &#x3D; results[1].split(&quot;\\:&quot;)[1];  </span><br><span class="line">35.           String mapY &#x3D; results[2].split(&quot;\\:&quot;)[1];  </span><br><span class="line">36.           mapX &#x3D; mapX.substring(1, mapX.length() - 1);  </span><br><span class="line">37.           mapY &#x3D; mapY.substring(1, mapY.length() - 1);  </span><br><span class="line">38.           mapX &#x3D; new String(Base64.decode(mapX));  </span><br><span class="line">39.           mapY &#x3D; new String(Base64.decode(mapY));  </span><br><span class="line">40.           System.out.println(&quot;\t&quot; + mapX + &quot;\t&quot; + mapY);  </span><br><span class="line">41.         &#125;  </span><br><span class="line">42.       &#125;  </span><br><span class="line">43.      sleep(10000);  </span><br><span class="line">44.     &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">45.       &#x2F;&#x2F; TODO Auto-generated catch block   </span><br><span class="line">46.       e.printStackTrace();  </span><br><span class="line">47.     &#125;  </span><br><span class="line">48.   &#125;  </span><br><span class="line">49.   &#x2F;** </span><br><span class="line">50.    * @param args </span><br><span class="line">51.    * @throws IOException </span><br><span class="line">52.    *&#x2F;  </span><br><span class="line">53.   public static void main(String[] args) throws IOException &#123;  </span><br><span class="line">54.     testPost(&quot;120.151379&quot;, &quot;30.184678&quot;);  </span><br><span class="line">55.     System.out.println(&quot;ok&quot;);  </span><br><span class="line">56.   &#125;  </span><br><span class="line">57. &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3、百度地图获取WGS-84坐标</span><br><span class="line"></span><br><span class="line">在百度地图中取得WGS-84坐标，调用如下方法：</span><br><span class="line">BMapManager.getLocationManager().setLocationCoordinateType(</span><br><span class="line"></span><br><span class="line">MKLocationManager.MK_COORDINATE_WGS84);</span><br><span class="line">这样从百度api中取得的坐标就是WGS-84了，可是这种坐标如果显示到百度地图上就会偏移，也就是说取出一个坐标，原封不动的显示上去就偏移了，所以为了显示也是正常就需要在绘制到百度地图上之前转换成BD-09。</span><br><span class="line">转换成BD-09，调用方法：</span><br><span class="line">  GeoPoint wgs84;</span><br><span class="line">GeoPoint bd09 &#x3D; CoordinateConvert.bundleDecode(CoordinateConvert.fromWgs84ToBaidu(wgs84))；</span><br><span class="line">这里实在不明白为何要设计成CoordinateConvert.fromWgs84ToBaidu(wgs84)返回了一个Bundle，所以还需要CoordinateConvert.bundleDecode()再转成GeoPoint。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4、CGCS2000坐标与WGS-84坐标的转换</span><br><span class="line"></span><br><span class="line">CGCS2000与WGS84的基本定义是一致的，采用的参考椭球非常相近，椭球常数中仅扁率有细微差别，虽然因此会造成同一点在两个坐标系中的值会有微小差异，但是，在当前测量精度水平下这种微小差值是可以忽略的，因此，可以认为CGCS2000和WGS84是相容的，在坐标系的实现精度范围内两种坐标系下的坐标是一致的。</span><br><span class="line"></span><br><span class="line">另一方面，由于两者本身就不是由彼此加密或者解密就可以得到的关系，所以转换的算法十分复杂。通常采用工具软件来进行转换，如ArcGIS、BIGEMAP等。</span><br></pre></td></tr></table></figure><h2 id="四、取自一段大神的总结"><a href="#四、取自一段大神的总结" class="headerlink" title="四、取自一段大神的总结"></a>四、取自一段大神的总结</h2><p>采用自家坐标体系，而不采用国内通用的火星坐标体系，实在是自寻短处。当然，百度是因为做的足够大、足够好，所以很霸道，也为以后一统天下而不让别人瓜分之而做准备吧。搜狗虽然用自家坐标体系，但能将地球坐标直接导入，此举也属唯一。而图吧地图不知道学什么加密方式，以前用地球坐标用的好好的，现在用图吧自己的坐标，难道是因为给百度做过所以也来了这么一招？或者沿用百度？不得而知。</p><p>做地图开发的时候，不希望被一家地图API迁就，所以采用火星坐标GCJ-02是正确的选择，希望本文能够对选择使用谁家API的开发者提供一点帮助吧。就我个人而言，我绝不会使用非火星坐标系统的地图API，虽然百度地图API很好很强大确实很吸引我。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图坐标转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Git多人单分支集成协作时的常见场景</title>
      <link href="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-不同人修改不同文件如何处理"><a href="#1-不同人修改不同文件如何处理" class="headerlink" title="1.不同人修改不同文件如何处理"></a>1.不同人修改不同文件如何处理</h2><p><strong>JavaSsun用户修改 readme文件</strong><br><strong>haoran用户修改index文件</strong><br><strong>远端仓库新建一个名字为 feature/add_git_commands的分支</strong></p><p>为了在单机模拟两个人做操作，需要从远端克隆一个 命名为 git_learning_02 以 JavaSsun为用户的仓库</p><a id="more"></a><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/462c8fe6-41e9-448d-811b-af9aea07d29f.png" alt></p><p>再变更email</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/64daaa82-8983-411c-914a-61cc63b451e5.png" alt></p><p>基于远端刚才新建的分支在本地新建一个分支，并切换到该分支上（二者联系起来）</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/cc5a524a-5f7e-4b81-8c97-b773ac2f3224.png" alt></p><p>JavaSsun在git_learning_02仓库中修改readme文件，commit后 推送到远端仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push   即可（为什么不用加分支名了呢，因为上面命令中本地分支与远端分支做了关联）</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/0c2fe061-aebc-4a6e-ad4e-e191f9c57912.png" alt></p><p>远端仓库也有了最新的变更</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/c8d976b1-c8ee-4e78-900b-d01fe34540d4.png" alt></p><p><strong>至此，JavaSsun开发人员修改完了readme，并提交到了远程仓库。</strong></p><p>切换到haoran所属的git_learning 仓库，查看后发现没有 feature/add_git_commands分支，需要拉取下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git fetch github</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/16f7fea5-27cc-43cc-b7cc-1ed31bc51048.png" alt></p><p>将本地新建分支并与远端的分支做关联（名字最好一致，并查看hash值后发现确实是一致的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;add_git_commands github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/fba96bf8-4ef8-4dfb-8edf-c0004c9c1b76.png" alt></p><p><font color="red">Hash值都是 27582a7</font></p><p>haoran用户修改index文件，commit完成。<br>JavaSsun用户又修改了readme文件，并且push到远程。<br>此时，haoran用户push自己的index文件到远端，会报错，如下图：</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/7286fc61-21d2-43b1-884c-c86d466a2394.png" alt></p><p>如何解决呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch github  尝试拉取远端的最新变更</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/95006c82-d402-4b55-a1b4-a26869cad23d.png" alt></p><p>发现有一个是 ahead 1 , behind 1 即本地比远端多一个，远端也比本地多一个。</p><p><strong>如果团队不要求用线性树的模式的话，可以用merge 与远端的进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/86e9dc79-a8f3-4759-a9b1-5d7311f7b625.png" alt></p><p>查看readme文件，发现将JavaSsun用户提交的内容都合了进来。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/6e46ee55-4829-4bf3-b871-082e599fb039.png" alt></p><p>此时在使用 <strong>git push github</strong> 就不会报错</p><h2 id="2-不同人修改同文件不同区域如何处理"><a href="#2-不同人修改同文件不同区域如何处理" class="headerlink" title="2.不同人修改同文件不同区域如何处理"></a>2.不同人修改同文件不同区域如何处理</h2><p>开发之前都需要将自己的分支与远端做一次同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>haoran</strong>：  对index.html文件做了变更，并做了commit<br><strong>JavaSsun</strong>: 对index.html文件做了变更，并做了commit</p><p><strong>haoran</strong>用户将自己的变更推送到了远端。此时 JavaSsun用户并不知道远端发生了新变更，也想推送自己的变更，自然就被拒绝。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/ac9f49fa-3b5c-4606-be44-1157432c6d45.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/340a928c-76a7-45fd-b5c8-fd34a7fca38d.png" alt></p><p>出现比远端做一个commit，同时比远端少一个commit,做merge即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git merge origin&#x2F;feature&#x2F;add_git_commands(远端分支或者分支ID号)</span><br></pre></td></tr></table></figure><p>默认缺省即可，查看发现有了其他人添加的内容。</p><h2 id="3-不同人修改同文件同一区域如何处理"><a href="#3-不同人修改同文件同一区域如何处理" class="headerlink" title="3.不同人修改同文件同一区域如何处理"></a>3.不同人修改同文件同一区域如何处理</h2><p>工作区先进行同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>都对index.html文件的同一区域做了相同的变更，JavaSsun用户将自己的变更推送到了远端，haoran用户想推送自己的变更时被拒绝了。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/954bba88-adef-4176-9d20-f77bfcb8d8df.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果用 merge 直接与远端进行合并，又发现 Already up to date，但又push不上去。</span><br><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p>此时，需要用 git pull 命令,出现了冲突（需手动解决）<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/07f361a2-d594-4c27-84e9-ae0abfafec0e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/100853e3-cee0-4abe-8583-8575cde7c76e.png" alt></p><p><strong>&lt;&lt;&lt;&lt;&lt;HEAD 到 ===========是自己的变更</strong><br><strong>=========到&gt;&gt;&gt;&gt;&gt;&gt;&gt;是别人的变更</strong></p><p>留下双方都需要的变更<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/e869d140-31d9-4126-8225-bcbd683321fd.png" alt></p><p>使用 <strong>git status</strong> 出现提示信息<br><strong>git commit 保留二者的变更。 **<br>**git merge –abort 不想让这两个分支merge，恢复到merge之前的状态。</strong></p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/57b10dc7-595f-4c3f-a5cc-97f6922ab404.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push github 推送即可</span><br><span class="line"></span><br><span class="line">另一个人</span><br><span class="line">git pull  拉取远端最新的变更即可</span><br></pre></td></tr></table></figure><h2 id="4-同时变更了文件名和文件内容如何处理"><a href="#4-同时变更了文件名和文件内容如何处理" class="headerlink" title="4.同时变更了文件名和文件内容如何处理"></a>4.同时变更了文件名和文件内容如何处理</h2><p>A变更了文件名，B变更了文件内容，但还是按照原来的文件名推送。</p><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git mv index.html index.htm</span><br><span class="line">git status</span><br><span class="line">git commit -am &quot;Mv index.html to index.htm&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/08718508-fa10-4155-8729-c6735a141a07.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -am &quot;....&quot;</span><br><span class="line">git push  &#x2F;&#x2F;会报错</span><br><span class="line">git pull  &#x2F;&#x2F; 默认缺省值 :wq</span><br><span class="line">ll -al   &#x2F;&#x2F;文件名已经更改过来 index.htm</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/82033f41-57ba-40ec-b694-0002adfa4244.png" alt></p><h2 id="5-同一文件改成了不同的文件名如何处理"><a href="#5-同一文件改成了不同的文件名如何处理" class="headerlink" title="5.同一文件改成了不同的文件名如何处理"></a>5.同一文件改成了不同的文件名如何处理</h2><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index2.html</span><br><span class="line">git commit -am &quot;Mv index to index2&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/b2ff7258-bf35-4458-ad39-32d94e263c1b.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index1.html</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push &#x2F;&#x2F;报错</span><br><span class="line">git pull &#x2F;&#x2F;报冲突</span><br><span class="line">ll -al   &#x2F;&#x2F;发现出现两个文件</span><br><span class="line">diff index1.htm index2.htm  &#x2F;&#x2F;只是文件名不同，内容是一致的</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f685d46e-0796-4f75-9f98-67064df101dd.png" alt></p><p>查看状态，需要协作者一起协商文件名的选取</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/aaca27e6-94be-4348-b12a-72e295a477ef.png" alt></p><p>如果选择 index1.htm这个名字，需要按以下命令更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git rm index.htm index2.htm</span><br><span class="line">git add index1.htm</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f7faceed-f423-43e3-bbd6-9813f5e448a2.png" alt></p><p>远端的已经变成了index1.htm<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/33006191-16a2-4668-ba75-aba5a7837028.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Git与GitHub简单同步</title>
      <link href="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-注册一个GitHub账号"><a href="#1-注册一个GitHub账号" class="headerlink" title="1.注册一个GitHub账号"></a>1.注册一个GitHub账号</h2><p>略<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/3f130bd8-80ca-4c71-973a-0c3bd9146ea3.png" alt></p><a id="more"></a><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/2f0d55c7-f1f5-463a-9c1d-503aea9d7070.png" alt></p><p>将公钥粘贴到GitHub上来，方便推送。</p><h2 id="2-配置公私钥"><a href="#2-配置公私钥" class="headerlink" title="2.配置公私钥"></a>2.配置公私钥</h2><p><strong>查看是否之前有过公私钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ll -al</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/27b6c3ca-54d0-4f78-9fd0-d4efc9cc81b9.png" alt></p><p><strong>如果没有配置过，是不会出现 id_rsa 与 id_rsa.pub这两个文件的</strong></p><p><strong>生成公私钥命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;2642487764@qq.com&quot;</span><br><span class="line">一路回车即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/79ea4449-83f0-4a0c-9920-d8ff5cf7902b.jpg" alt></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/b21dc469-dfff-40c2-abfd-c661b11de310.png" alt></p><p>复制到GitHub的账户上即可、<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a35abfab-8c9d-4e94-a132-f502155abb62.png" alt></p><p><strong>好处</strong>：ssh协议做push活动时不需要再输入用户名密码，可以智能识别，允许自己往对应的GitHub账户上推送内容。</p><h2 id="3-GitHub上创建个人仓库"><a href="#3-GitHub上创建个人仓库" class="headerlink" title="3.GitHub上创建个人仓库"></a>3.GitHub上创建个人仓库</h2><p><strong>MIT License 可以直接拿过来用</strong></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/c7414606-ca57-4231-be64-3d36af153932.png" alt></p><p>点开会拥有 MIT lecense标识<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/07a92364-782e-48a4-8d2f-c0744488765b.png" alt></p><h2 id="4-本地仓库同步到GitHub"><a href="#4-本地仓库同步到GitHub" class="headerlink" title="4.本地仓库同步到GitHub"></a>4.本地仓库同步到GitHub</h2><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a9b74e0a-dc0e-4a35-9b3d-0de613b6569b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add github git@github.com:JavaSsun&#x2F;git_learning.git</span><br><span class="line"></span><br><span class="line">添加远程站点 并更名为  github</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/adf9277a-96d2-4318-a877-134fd63b77cb.png" alt></p><p><strong>有了上述github后 即可与远端建立联系</strong></p><p>因为 远端有了 License文件 ，在本地直接push的时候会报错，提示push前需要把远端的先pull下来。</p><p><strong>没有pull之前的版本树</strong><br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/617d8530-f5e2-447f-b4b9-a9976b5a926f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github master  拉取远端 master上的文件到本地，仅仅是拉取，没有与本地分支做merge</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6d78b45d-b26e-4c80-9596-9268d916ce74.png" alt></p><p>此时 远端的 LICENSE已经被fetch下来</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d21ef24-88fc-48de-a48d-ff36c39e4efa.png" alt></p><p>将本地master与远端master进行merge，但是会报错<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/4eff67a2-224d-4ed5-ac26-b46ca787549f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge -h  查找帮助</span><br><span class="line">git merge --allow-unrelated-histories github&#x2F;master</span><br><span class="line">在交互界面使用默认缺省值即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/8efd7ace-e75e-4fcb-8fb6-95d762d59e44.png" alt></p><p>查看merge后的当前树（发现有两个父亲，rebase则是线性的，只有一个）</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d37e621-8bac-43f7-b421-33b8974df6f5.png" alt></p><p>此时再将本地push到远方，不会再报错</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6b3b24b8-517f-417d-b87d-c04e67347a95.png" alt></p><p>查看当前树</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a48de224-c5cd-428b-a7c0-66acd18e58bb.png" alt></p><p>查看远端仓库</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/da932435-ce0a-4a69-ab63-161987e1bb6d.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Git常用场景</title>
      <link href="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-删除无用分支"><a href="#1-删除无用分支" class="headerlink" title="1.删除无用分支"></a>1.删除无用分支</h2><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cbe35443-f8b1-43e6-a798-b0828a836ef3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name             &#x2F;&#x2F; 删除分支(会有提示是否确认删除)</span><br><span class="line">git branch -D branch_name             &#x2F;&#x2F; 删除分支（确认删除情况下）</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-修改本地最新commit的messagee"><a href="#2-修改本地最新commit的messagee" class="headerlink" title="2.修改本地最新commit的messagee"></a>2.修改本地最新commit的messagee</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend               &#x2F;&#x2F;可以对最新的commit的message做变更</span><br></pre></td></tr></table></figure><h2 id="3-修改本地老旧commit的message"><a href="#3-修改本地老旧commit的message" class="headerlink" title="3.修改本地老旧commit的message"></a>3.修改本地老旧commit的message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  待修改commit的父ID号        &#x2F;&#x2F; -i交互式</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/caa4ac95-c0c9-491e-b4df-26f9c7faf1ba.png" alt><br>将第一个 pick 改为 reword / r 然后保存,会再次进入交互界面。</p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/8c965b60-3093-4927-b588-f07df7b8ef5d.png" alt></p><p>修改变更的信息后保存，查看信息。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/61baa9ed-06a6-4f23-b99a-442093cfbe82.png" alt></p><h2 id="4-连续多个本地commit整理成1个"><a href="#4-连续多个本地commit整理成1个" class="headerlink" title="4.连续多个本地commit整理成1个"></a>4.连续多个本地commit整理成1个</h2><p>将中间两个合并成一个commit<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f95841b5-9286-4c80-a1b9-2db49e5b147d.png" alt></p><p>此时，应该基准是中间两个的父ID号，即 7f7e472c30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c30</span><br></pre></td></tr></table></figure><p>选用 squash 或者 s 进行合并<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/e7eec623-3f36-4ca8-b02d-8f36a2f92b0d.png" alt></p><p>添加合并信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f2c191d1-ebab-4b52-b01b-fa120ae984a1.png" alt></p><p>git log –graph            //查看日志<br><strong>会对整理后的commit生成一个新的ID号</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/032b9093-e06b-4dbe-80c4-dd35b5ab5300.png" alt></p><h2 id="4-多个本地-间隔commit整理成1个"><a href="#4-多个本地-间隔commit整理成1个" class="headerlink" title="4.多个本地 间隔commit整理成1个"></a>4.多个本地 间隔commit整理成1个</h2><p><strong>将最新的一个与第一个合成一个commit</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/b9d3b699-43ee-4d12-b475-94be40a3bac9.png" alt></p><p>因为最早的一个没有父亲，所以直接使用rebase变更命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/5db8b72f-677d-4a87-acf5-ecad61863d6d.png" alt></p><p>添加   pick 7f7e471c 命令      //最古老的那一个    <strong>合并上限</strong><br>将        s 96764b86 添加到上面命令的下一行  //    <strong>合并下限</strong><br>删除   pick 96764b8  命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue   &#x2F;&#x2F;继续  使用这个继续操作</span><br><span class="line">git rebase --abort      &#x2F;&#x2F;舍弃</span><br></pre></td></tr></table></figure><p>添加变更信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/59279101-2af0-414e-9235-7ad4bdab712d.png" alt></p><p>合并成功，生成新的commit ID号<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/3b7309ee-3845-4d28-9106-cff524594bd5.png" alt></p><p>此时出现两个（树）根 可以看情况删除非master所在的根<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/6e3b571f-984d-4c1a-be95-15d2c6d66dbf.png" alt></p><h2 id="5-比较暂存区与HEAD所含文件的差异"><a href="#5-比较暂存区与HEAD所含文件的差异" class="headerlink" title="5.比较暂存区与HEAD所含文件的差异"></a>5.比较暂存区与HEAD所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变更内容后使用 git add 添加到暂存区</span><br><span class="line">git status</span><br><span class="line">git diff --cached            &#x2F;&#x2F;查看暂存区与HEAD所指向文件的具体变化</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/832bbece-3ea4-4ef6-a4d2-ff94c99a10b0.png" alt></p><h2 id="6-比较暂存区与工作区所含文件的差异"><a href="#6-比较暂存区与工作区所含文件的差异" class="headerlink" title="6.比较暂存区与工作区所含文件的差异"></a>6.比较暂存区与工作区所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff                    &#x2F;&#x2F;默认查看工作区与暂存区所有文件的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name      &#x2F;&#x2F;查看指定文件在工作区与暂存区的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name1 file_name2  file_nameN</span><br></pre></td></tr></table></figure><h2 id="7-将暂存区恢复成HEAD所处状态-变暂存区用-reset"><a href="#7-将暂存区恢复成HEAD所处状态-变暂存区用-reset" class="headerlink" title="7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)"></a>7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区有了新的优化方案。此前暂存区的内容不想保留，想回溯到之前的HEAD所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD                &#x2F;&#x2F;取消暂存区中的文件（文件由绿变红）</span><br><span class="line">git diff --cached             &#x2F;&#x2F;比较暂存区与HEAD 返回为空，即撤销成功</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/4da5296d-6b61-4e5e-92db-15f3430d4179.png" alt></p><h2 id="8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）"><a href="#8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）" class="headerlink" title="8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）"></a>8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区做了变化后，发现没有暂存区的好。<br>想舍弃工作区当前的更改，回溯到暂存区所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file_name   &#x2F;&#x2F; 舍弃工作区的变更，恢复为暂存区的内容</span><br><span class="line">git diff file_name          &#x2F;&#x2F; 没有返回信息，工作区与暂存区一致</span><br></pre></td></tr></table></figure><h2 id="9-取消暂存区部分文件的更改"><a href="#9-取消暂存区部分文件的更改" class="headerlink" title="9.取消暂存区部分文件的更改"></a>9.取消暂存区部分文件的更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- file_name1 file_name2</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/58261fc0-c409-42c7-9c92-9a22d67bc86a.png" alt></p><h2 id="10-消除最近的几次提交"><a href="#10-消除最近的几次提交" class="headerlink" title="10.消除最近的几次提交"></a>10.消除最近的几次提交</h2><p>恢复到提交的前几次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  ID                &#x2F;&#x2F;  回退到指定的commit的ID号</span><br></pre></td></tr></table></figure><h2 id="11-不同提交、分支的指定文件的差异化比较"><a href="#11-不同提交、分支的指定文件的差异化比较" class="headerlink" title="11.不同提交、分支的指定文件的差异化比较"></a>11.不同提交、分支的指定文件的差异化比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff branch_name1 branch_name2    &#x2F;&#x2F;比较两个分支的差异</span><br><span class="line">git diff branch_name1 branch_name2 -- file_name   &#x2F;&#x2F;比较指定文件在指定分支上的差异</span><br><span class="line"></span><br><span class="line">git diff 分支1对应的commit的ID号 分支2对应的commit的ID号   &#x2F;&#x2F;与上述一致</span><br></pre></td></tr></table></figure><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>常规做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm  指定文件名    &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git status       &#x2F;&#x2F;变红色，说明仅仅是删除了工作区中的，</span><br><span class="line">git rm 指定文件名 &#x2F;&#x2F;删除暂存区文件</span><br><span class="line">git status       &#x2F;&#x2F;变绿色，说明暂存区中文件被删除</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD  &#x2F;&#x2F;废除刚才所有变动</span><br></pre></td></tr></table></figure><p><strong>git 做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 指定文件名</span><br><span class="line">git status &#x2F;&#x2F; 变绿色</span><br></pre></td></tr></table></figure><h2 id="13-开发中临时添加紧急任务（stash）"><a href="#13-开发中临时添加紧急任务（stash）" class="headerlink" title="13.开发中临时添加紧急任务（stash）"></a>13.开发中临时添加紧急任务（stash）</h2><p>工作区与暂存区中的内容暂时还不能提交，但是当前又有一个更为紧急的任务需要完成时，可以把工作区与暂存区中的内容存放到另一个空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff       &#x2F;&#x2F; 工作区与暂存区是有差异的</span><br><span class="line">git stash      &#x2F;&#x2F; 将未commit的内容存放另一个空间</span><br><span class="line">git stash list &#x2F;&#x2F; 可以看到类似于存放在有ID号的堆栈中</span><br><span class="line">git status     &#x2F;&#x2F; 工作区与暂存区是干净的</span><br></pre></td></tr></table></figure><p><strong>此时可以处理紧急任务，add到暂存区，commit到仓库后，再回来继续当前开发，需要将之前存储在另一个空间的内容恢复出来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash apply &#x2F;&#x2F; 将内容弹出，但不删除空间中的内容，可反复使用</span><br><span class="line">git stash list  &#x2F;&#x2F; 依然存在</span><br><span class="line">git stash pop   &#x2F;&#x2F; 弹出且删除空间中的内容</span><br><span class="line">git stash list  &#x2F;&#x2F; 什么也没有</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/348f60ab-06f0-4957-8551-9c7dae0ef36c.png" alt></p><p><strong>处理完紧急任务后弹出内容</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/9578d032-8074-4f0c-b3d6-5d30c9bfd9bb.png" alt></p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cf033f3f-a3b8-4607-826a-f034b1aee126.png" alt></p><h2 id="14-指定不需要Git管理的文件"><a href="#14-指定不需要Git管理的文件" class="headerlink" title="14.指定不需要Git管理的文件"></a>14.指定不需要Git管理的文件</h2><p><strong>建立一个文件，指定文件名为 .gitignore</strong></p><p>在文件中添加需要Git版本忽略的文件即可。</p><p>可在GitHub上查看<br><a href="https://github.com/github-tools/github/blob/master/.gitignore" target="_blank" rel="noopener">https://github.com/github-tools/github/blob/master/.gitignore</a></p><h2 id="15-备份Git仓库到本地"><a href="#15-备份Git仓库到本地" class="headerlink" title="15.备份Git仓库到本地"></a>15.备份Git仓库到本地</h2><p>常用的传输协议<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/be6aa585-e6f5-4670-95d0-f34a4c1623d7.jpg" alt></p><p><strong>哑协议与智能协议</strong></p><p><strong>直观区别</strong>：哑协议传输进度不可见；智能协议传输可见。<br><strong>传输速度</strong>：智能协议比哑协议传输速度快。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/35a50a7b-3fbb-4413-9cec-692c4b2bdb72.jpg" alt></p><p><strong>哑协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git ya.git</span><br><span class="line">从本地另一个Git仓库中克隆一个文件到当前仓库</span><br><span class="line">--bare 是只克隆仓库中的内容，不可隆工作区中的内容</span><br><span class="line">将 .git 文件更名为 ya.git文件</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/ac7afc75-38b6-48e2-a671-8c6c719c2199.png" alt></p><p><strong>智能协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git zhineng.git</span><br><span class="line"></span><br><span class="line">前面添加    file:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/a1a209cd-6efb-40d7-9b5c-e090082711ed.png" alt></p><p><strong>本地推远端仓库（demo）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add zhineng file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;666-backup&#x2F;zhineng.git</span><br><span class="line">git brach -av</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Git安装及简单操作</title>
      <link href="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p>图片来源：极客时间，需个人购买教程。</p><h2 id="前言-Git下载路径"><a href="#前言-Git下载路径" class="headerlink" title="前言 Git下载路径"></a>前言 Git下载路径</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><h2 id="参考-廖雪峰-Git文档"><a href="#参考-廖雪峰-Git文档" class="headerlink" title="参考 廖雪峰 Git文档"></a>参考 廖雪峰 Git文档</h2><p>廖雪峰 Git文档<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version     &#x2F;&#x2F;可查看版本即安装成功</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-使用Git前的小配置"><a href="#1-使用Git前的小配置" class="headerlink" title="1 使用Git前的小配置"></a>1 使用Git前的小配置</h2><h3 id="1-1-配置User信息-（user-name-和-user-email）"><a href="#1-1-配置User信息-（user-name-和-user-email）" class="headerlink" title="1.1 配置User信息  （user.name 和 user.email）"></a>1.1 配置User信息  （user.name 和 user.email）</h3><p>方便代码变更时展示变更人信息 及 通知协作者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure><h3 id="1-2-config-作用域"><a href="#1-2-config-作用域" class="headerlink" title="1.2 config 作用域"></a>1.2 <font color="red">config 作用域</font></h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6075a03d-a390-4546-ad59-1b2a2a5c1795.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br><span class="line">git config --local user.name</span><br><span class="line">git config --local user.email</span><br></pre></td></tr></table></figure><h2 id="2-建Git仓库"><a href="#2-建Git仓库" class="headerlink" title="2 建Git仓库"></a>2 建Git仓库</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/025b15b1-6dd2-4a50-9d4d-b152d763370d.jpg" alt></p><h3 id="2-1-常用命令"><a href="#2-1-常用命令" class="headerlink" title="2.1 常用命令"></a>2.1 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git add                 &#x2F;&#x2F; 添加文件到暂存区</span><br><span class="line">git commit -m &#39;变更内容&#39; &#x2F;&#x2F; 添加文件到Git仓库</span><br><span class="line">git status              &#x2F;&#x2F; 查看文件状态</span><br><span class="line">git log                 &#x2F;&#x2F; 查看提交日志</span><br><span class="line"></span><br><span class="line">git checkout branc_name &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b branch_name &#x2F;&#x2F;创建并切换新分支</span><br><span class="line"></span><br><span class="line">git commit -am &#39;变更信息&#39; &#x2F;&#x2F;直接推到仓库，跳过暂存区，不推荐使用</span><br></pre></td></tr></table></figure><h3 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h3><p><font color="red"> local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖</font></p><h2 id="3-工作区与暂存区"><a href="#3-工作区与暂存区" class="headerlink" title="3 工作区与暂存区"></a>3 工作区与暂存区</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/0ea1afe7-4fd5-4f90-825e-d0f280c38dbb.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u            &#x2F;&#x2F; 可以将已修改的 Git所管理的文件 一起提到暂存区，如下所示</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9ff91e2a-397a-450e-b95c-5d266c60d2e3.jpg" alt></p><h2 id="4-Git-中的文件重命名"><a href="#4-Git-中的文件重命名" class="headerlink" title="4 Git 中的文件重命名"></a>4 Git 中的文件重命名</h2><p>常规步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv old_name  new_name       &#x2F;&#x2F; 重命名</span><br><span class="line">git add  new_name           &#x2F;&#x2F; 添加新文件进入暂存区</span><br><span class="line">git rm old_name             &#x2F;&#x2F; 删除暂存区中旧的文件</span><br><span class="line">git status                  &#x2F;&#x2F; Git智能的认为是文件重命名</span><br><span class="line">---  太繁琐  ---</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/cf8ae066-98f1-4e68-bbe9-7839f0e8fba7.png" alt></p><p><font color="red">Git方式重命名</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name  new_name  &#x2F;&#x2F; Git重命名文件   3合1</span><br><span class="line">git status                 &#x2F;&#x2F; 查看状态</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e6ad4c3-298d-4359-92df-fe65f2eb8ee5.png" alt></p><h2 id="5-git-log-查看版本演变历史"><a href="#5-git-log-查看版本演变历史" class="headerlink" title="5 git log 查看版本演变历史"></a>5 git log 查看版本演变历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git log                        &#x2F;&#x2F; 查看当前分支详细版本历史</span><br><span class="line"></span><br><span class="line">git log --oneline              &#x2F;&#x2F; 查看当前分支简略版本历史</span><br><span class="line"></span><br><span class="line">git log -n2                    &#x2F;&#x2F; 查看当前分支最近的两次版本提交记录</span><br><span class="line">git log -n2 --oneline          &#x2F;&#x2F; 组合使用</span><br><span class="line"></span><br><span class="line">git branch -a                  &#x2F;&#x2F; 查看有多少分支(简略)</span><br><span class="line">git branch -v                  &#x2F;&#x2F; 查看有多少分支(详细)</span><br><span class="line">git branch -av                 &#x2F;&#x2F; 常用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log                        &#x2F;&#x2F; 查看当前分支版本</span><br><span class="line"></span><br><span class="line">git log temp                   &#x2F;&#x2F; 查看指定分支temp的历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline temp         &#x2F;&#x2F; 查看指定分支temp的简略历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline --all temp   &#x2F;&#x2F; 此时 依然是查看所有分支的历史版本，temp不再起作用</span><br><span class="line"></span><br><span class="line">git log --all                  &#x2F;&#x2F; 查看所有分支版本历史</span><br><span class="line"></span><br><span class="line">git log --all --graph          &#x2F;&#x2F; 以图形化的方式查看所有分支（父子关系分支）关系</span><br></pre></td></tr></table></figure><p><font color="red">按需求组合：</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5db3e9f7-aabf-4ef3-9864-42aed7a2099e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all -n4 --graph         &#x2F;&#x2F; 查看简略ID</span><br><span class="line">git log --pretty&#x3D;oneline --all -n4 --graph  &#x2F;&#x2F; 查看详细ID</span><br></pre></td></tr></table></figure><p><strong>使用网页方式查看相关命令帮助</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help --web  log            &#x2F;&#x2F; 以网页方式查看log命令用法</span><br><span class="line">git help --web  commit         &#x2F;&#x2F; 以网页方式查看commit命令用法</span><br></pre></td></tr></table></figure><h2 id="6-gitk-通过图形界面工具查看版本演变历史"><a href="#6-gitk-通过图形界面工具查看版本演变历史" class="headerlink" title="6 gitk   通过图形界面工具查看版本演变历史"></a>6 gitk   通过图形界面工具查看版本演变历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br><span class="line"></span><br><span class="line">gitk --all</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ddf34b16-0714-4641-8483-02fffa3fcc0c.png" alt></p><h2 id="7-探索-git目录"><a href="#7-探索-git目录" class="headerlink" title="7 探索.git目录"></a>7 探索.git目录</h2><h3 id="7-1-HEAD文件"><a href="#7-1-HEAD文件" class="headerlink" title="7.1 HEAD文件"></a>7.1 HEAD文件</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28fe4315-38cf-495f-8da8-0731f13553d7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat HEAD        &#x2F;&#x2F;查看HEAD文本内容 HEAD是一个引用，指向当前工作分支，指向的是refs文件夹下的heads文件夹下的某个分支的ID号</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/d99a688c-7472-48a0-a725-d089915e1249.png" alt></p><p><font color="red">切换回master分支后，HEAD内容发生变化</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/03ef6a79-099b-4929-be05-36bb21a766f4.png" alt></p><h3 id="7-2-config配置文件"><a href="#7-2-config配置文件" class="headerlink" title="7.2 config配置文件"></a>7.2 config配置文件</h3><p>对config作用域的user信息的修改直接保存到该文件中。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/98e5bb44-5de4-4ee8-8226-019330ad2950.png" alt></p><p>将user.name 由 local1 改为local2后，再次查看该文件发现已经更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list      &#x2F;&#x2F;列出本地所有可以看得信息</span><br><span class="line">git config --local user.nane   &#x2F;&#x2F;列出指定信息（如user.name）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c595b00-c8c0-47d9-a8aa-793465e69f43.png" alt></p><p><strong>再次修改回去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &#39;local1&#39;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6c514813-a599-410d-98f0-144f247436ab.png" alt></p><h3 id="7-3-refs文件夹"><a href="#7-3-refs文件夹" class="headerlink" title="7.3 refs文件夹"></a>7.3 refs文件夹</h3><p>heads: 分支，一个独立的开发空间，前后端各1个分支，互不影响，需要集成时，合并到一个共同的分支上。<br>tags: 标签/里程碑 标明一个版本等。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28046633-46c0-4af5-8ad1-36344f509e92.png" alt></p><p><strong>heads文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t ID号前几位        &#x2F;&#x2F;查看存放的对象是一个什么类型 （commit类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/e0e52020-8d55-44b6-8a0a-392604927f6c.png" alt></p><p><strong>tags文件夹</strong></p><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c392142-567a-466e-b72a-f7bff540600f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p ID号前几位         &#x2F;&#x2F; 查看内容（tag类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/76815d92-3063-4ae0-8e1e-9d260cf93fac.png" alt></p><h3 id="7-4-objects文件夹"><a href="#7-4-objects文件夹" class="headerlink" title="7.4 objects文件夹"></a>7.4 objects文件夹</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6659db73-a48b-4935-b5fe-33b9af5f6978.png" alt></p><p><strong>查看98文件夹下存放的类型与内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看类型（tree类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/09cba8a4-0998-4c2b-a306-a57336988f2b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看内容</span><br><span class="line"></span><br><span class="line">blob 文本类型   再次查看blob ID号对应的内容是文本信息</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a2cd87bf-3284-4f0f-ad62-b512505b0199.png" alt></p><p>内容是文本里的内容信息</p><p><font color="red">核心类型：</font><br><strong>TREE  / COMMIT  /  BLOB</strong></p><h2 id="8-commit、tree、blob-三者关系"><a href="#8-commit、tree、blob-三者关系" class="headerlink" title="8 commit、tree、blob 三者关系"></a>8 commit、tree、blob 三者关系</h2><p>Git眼中，文件内容完全相同，就被认为是同一个对象。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c6b17719-a3a1-4b69-9edb-76ed250c6cef.jpg" alt><br>**<br>一个commit 对应一个 tree<br>blob 对应文本文件<br>tree 对应文件夹，文件夹下可能有tree或者blob<br>**<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ae5fb42a-36b4-4df1-bf33-9c3f29353970.png" alt></p><h2 id="9-tree的个数"><a href="#9-tree的个数" class="headerlink" title="9 tree的个数"></a>9 tree的个数</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c44300e9-0b7b-462a-b9d4-bc00140c4c3a.jpg" alt></p><p>查看某个目录下类型是文件的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .git&#x2F;objects -type f</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/96621697-d0f6-4774-8282-e08b68043fb7.png" alt></p><p>2个tree，1个commit，1个blob</p><h2 id="10-分离头指针时的注意事项（detached-HEAD）"><a href="#10-分离头指针时的注意事项（detached-HEAD）" class="headerlink" title="10 分离头指针时的注意事项（detached HEAD）"></a>10 分离头指针时的注意事项（detached HEAD）</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2ed04c46-8f7f-4bf7-b619-2df3653fb36b.png" alt></p><p>如果此时对某些文件做了修改，并提交到仓库后，切换分支时，会提示是否给当前没有依赖的变更创建新的分支，如果不创建，会丢失这次修改。<br>在Git看来，如果没有将某个commit与分支或者tag绑定，都会被清除<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5dc33929-8d2e-418e-96a5-1aea442dfbd6.png" alt></p><p>按照提示 git branch branch_name ID号 进行分支的挂钩，即可保留修改。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1b1a7c5a-850a-4d0f-bc42-b388bf34e891.png" alt></p><p><strong>因此，分离头指针指的是 某个变更没有基于branch进行，在切换分支时，分离头指针下的commit会被Git当做垃圾清理掉。如果这些变更是重要的，要与某个分支绑定在一起。</strong></p><h2 id="11-HEAD-与-branch"><a href="#11-HEAD-与-branch" class="headerlink" title="11  HEAD 与 branch"></a>11  HEAD 与 branch</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/dcec9acc-64e3-4422-8b45-58ac5b9e8b40.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch_name      &#x2F;&#x2F;基于当前分支创建新分支</span><br><span class="line">git checkout -b new_branch_name old_branch_name   &#x2F;&#x2F;基于指定分支创建新分支</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/587b9e50-28f3-40ec-bd1c-8ae109102004.png" alt></p><p>此时 .git/HEAD 的引用也指向了新的分支<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e96d652-d2b3-45c8-84b0-a6e6aec3a29f.png" alt></p><p><strong>HEAD 既可以指向最后一次提交的分支，也可以不与任何分支挂钩（即处于分离头指针状态下），整个HEAD指向了某个 commit上。当做分支切换时，HEAD指向新分支</strong></p><p><font color="red">HEAD 指向分支，分支指向commit，或者HEAD直接指向commit</font>.</p><p><strong>比较两次commit的差异性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff 待比较ID1  待比较ID2     &#x2F;&#x2F; ID1与ID2的提交比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD^1             &#x2F;&#x2F; 当前HEAD所指向的commit与他的父亲（上一次）比较</span><br><span class="line">git diff HEAD HEAD^1^1           &#x2F;&#x2F; 当前HEAD所指向的commit与他的爷爷（上两次）比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD~n             &#x2F;&#x2F; 当前HEAD所指向的commit与 上n次 比较</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper学习</title>
      <link href="/2019/01/10/ZooKeeper/"/>
      <url>/2019/01/10/ZooKeeper/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h2><p><a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></p><h2 id="1-2-介绍"><a href="#1-2-介绍" class="headerlink" title="1.2 介绍"></a>1.2 介绍</h2><p><strong>ZooKeeper</strong>是一个开源的分布式应用协调服务系统，主要用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。<br>问题：<br><img src="/2019/01/10/ZooKeeper/ac1656df-ca7c-45ee-9688-6201ee09006f.png" alt> </p><a id="more"></a><p><strong>Zookeeper特点</strong><br><img src="/2019/01/10/ZooKeeper/7d94097e-7d38-4b30-b02e-f4a0e8e8f2af.jpg" alt><br>&nbsp;&nbsp;1. Zookeeper有一个层次化的名称空间，很像一个分布式文件系统（树形层次结构）<br>&nbsp;&nbsp;2. Zookeeper树中的每个节点被称为—-<strong>Znode</strong><br>&nbsp;&nbsp;3. <strong>Znode</strong>，兼具文件和目录两种特点。既像文件一样维护者数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p><p><strong>ZNode类型</strong><br>&nbsp;&nbsp;Zookeeper中的节点分为<strong>临时节点</strong>、<strong>永久节点</strong>、<strong>顺序节点</strong>。节点的类型在创建时即被确定，并且不能改变。<br>&nbsp;&nbsp;1. <strong>临时节点（Ephemeral Node）</strong>：该节点的生命周期依赖于创建他们的会话。一旦会话（Session）结束，临时节点将被自动删除，Zookeeper的临时节点不允许拥有子节点。<br>&nbsp;&nbsp;2. <strong>永久节点（Persistent Node）</strong>：该节点的生命周期不依赖于会话，并且只有在客户端执行删除操作的时候，他们才能被删除。<br>&nbsp;&nbsp;3. <strong>顺序节点（Sequential Node）</strong>：顺序节点可以是持久的或者临时的。当一个新的Znode被创建为顺序节点时，Zookeeper通过将10位的序列号附加到原始名称来设置ZNode的路径。例如：如果将具有路径** /myapp<strong>的Znode创建为顺序节点，则Zookeeper会将路径更改为</strong>/myapp0000000001**，并且下一个序列号设置为0000000002.</p><p><strong>Watches</strong><br>&nbsp;&nbsp;客户端可以在节点上设置Watch，称之为监视器。当节点状态发生改变时（ZNode的增删改）将会触发Watch所对应的操作。当Watch被触发时，Zookeeper将会向客户端发送且仅发送一条通知。</p><h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>&nbsp;&nbsp;注：单机模式为例<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 配置JDK的环境变量<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 下载<br><code>wget http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</code><br>&nbsp;&nbsp;&nbsp;&nbsp;3. 解压<br><code>tar -zxvf zookeeper-3.4.11.tar.gz -C /usr</code><br>&nbsp;&nbsp;&nbsp;&nbsp;4. 修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改配置文件</span><br><span class="line">cp &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line"># 修改配置文件</span><br><span class="line">vi &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line"> tickTime&#x3D;2000</span><br><span class="line"> dataDir&#x3D;&#x2F;root&#x2F;zkData</span><br><span class="line"> clientPort&#x3D;2181</span><br></pre></td></tr></table></figure><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1. 启动 ZK Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;bin</span><br><span class="line">.&#x2F;zkServer.sh start ..&#x2F;conf&#x2F;zoo.cfg</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;2. 启动成功<br><img src="/2019/01/10/ZooKeeper/e16f5df3-83c2-4ff4-bfae-076bdcaaffff.jpg" alt></p><h1 id="三、Zookeeper指令操作"><a href="#三、Zookeeper指令操作" class="headerlink" title="三、Zookeeper指令操作"></a>三、Zookeeper指令操作</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用 客户端脚本连接ZK Server **<br><code>./zkCli.sh -server ip:port</code><br>&nbsp;&nbsp;</strong>常用指令**</p><ul><li>help 帮助</li><li>connect host:port 连接到指定 zk server</li><li>get path [watch] 获取指定节点数据</li><li>ls path [watch] 查看指定节点的所有子节点</li><li>set path data [version] 给指定节点设置数据</li><li>rmr path 递归删除指定节点</li><li>quit 退出客户端</li><li>create [-s] [-e] path data acl 创建节点 -s 顺序节点 -e 临时节点</li><li>close 关闭连接</li><li>delete path [version] 删除节点<h1 id="四、JAVA-API-操作"><a href="#四、JAVA-API-操作" class="headerlink" title="四、JAVA API 操作"></a>四、JAVA API 操作</h1><h2 id="4-1-Maven-依赖坐标"><a href="#4-1-Maven-依赖坐标" class="headerlink" title="4.1 Maven 依赖坐标"></a>4.1 Maven 依赖坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.101tec&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-增、删、改、查操作"><a href="#4-2-增、删、改、查操作" class="headerlink" title="4.2 增、删、改、查操作"></a>4.2 增、删、改、查操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.baizhi.zookeeper;</span><br><span class="line">import org.I0Itec.zkclient.ZkClient;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author haoransun</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ZkClientOperation &#123;</span><br><span class="line">     private ZkClient zkClient &#x3D; null;</span><br><span class="line">     @Before</span><br><span class="line">     public void before()&#123;</span><br><span class="line">         zkClient &#x3D; new ZkClient(&quot;192.168.128.160&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">     * 增删改查</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @Test</span><br><span class="line">     public void zkCRUD()&#123;</span><br><span class="line">         &#x2F;&#x2F; 创建持久节点</span><br><span class="line">         zkClient.createPersistent(&quot;&#x2F;tencent&quot;,true);</span><br><span class="line">         &#x2F;&#x2F; 创建临时节点</span><br><span class="line">         zkClient.createEphemeral(&quot;&#x2F;zpark&quot;,&quot;bzjy&quot;);</span><br><span class="line">         &#x2F;&#x2F; 创建临时顺序节点</span><br><span class="line">         String e1 &#x3D; zkClient.createEphemeralSequential(&quot;&#x2F;tencent&#x2F;league-of-legends&quot;, &quot;lol&quot;);</span><br><span class="line">         String e2 &#x3D; zkClient.createEphemeralSequential(&quot;&#x2F;tencent&#x2F;cross-fire&quot;, &quot;cf&quot;);</span><br><span class="line">         System.out.println(&quot;创建的临时顺序节点e1：&quot;+e1);</span><br><span class="line">         System.out.println(&quot;创建的临时顺序节点e2：&quot;+e2);</span><br><span class="line">         &#x2F;&#x2F; 获取节点列表</span><br><span class="line">         List&lt;String&gt; list &#x3D; zkClient.getChildren(&quot;&#x2F;tencent&quot;);</span><br><span class="line">         list.forEach(n -&gt; System.out.println(n));</span><br><span class="line">         &#x2F;&#x2F; 删除节点</span><br><span class="line">         boolean result &#x3D; zkClient.deleteRecursive(&quot;&#x2F;tencent&quot;);</span><br><span class="line">         System.out.println(&quot;删除结果：&quot;+result);</span><br><span class="line">         &#x2F;&#x2F; 获取节点内容</span><br><span class="line">         Object data &#x3D; zkClient.readData(&quot;&#x2F;zpark&quot;);</span><br><span class="line">         System.out.println(&quot;&#x2F;zpark 保存的数据为：&quot;+data);</span><br><span class="line">        &#x2F;&#x2F; 更新节点内容</span><br><span class="line">        监听接口 订阅方法 取消订阅方法</span><br><span class="line">        IZkChildListener subscribeChildChanges unsubscribeChildChanges</span><br><span class="line">        IZkDataListener subscribeDataChanges unsubscribeDataChanges</span><br><span class="line">        注册监听</span><br><span class="line">        在ZkClient中客户端可以通过注册相关的事件监听来实现对Zookeeper服务端事件的订阅，其中</span><br><span class="line">        ZkClient提供的常⽤监听事件接口有以下几种：</span><br><span class="line">        测试代码：</span><br><span class="line">         zkClient.writeData(&quot;&#x2F;zpark&quot;,new Date());</span><br><span class="line">         Object newData &#x3D; zkClient.readData(&quot;&#x2F;zpark&quot;);</span><br><span class="line">         System.out.println(&quot;&#x2F;zpark 更新后数据为：&quot;+newData);</span><br><span class="line">     &#125;</span><br><span class="line">         @After</span><br><span class="line">         public void after()&#123;</span><br><span class="line">             zkClient.close();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h2><p>&nbsp;&nbsp;在ZkClient中客户端可以通过注册相关的事件监听来实现对Zookeeper服务端事件的订阅，其中ZkClient提供的常用事件监听接口有以下几种：</p><table><thead><tr><th>监听接口</th><th>订阅方法</th><th>取消订阅方法</th></tr></thead><tbody><tr><td>IZkChildListener</td><td>subscribeChildChanges</td><td>unsubscribeChildChanges</td></tr><tr><td>IZkDataListener</td><td>subscribeDataChanges</td><td>unsubscribeDataChanges</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.baizhi.zookeeper;</span><br><span class="line">import org.I0Itec.zkclient.IZkChildListener;</span><br><span class="line">import org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line">import org.I0Itec.zkclient.ZkClient;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author gaozhy</span><br><span class="line">* @date 2018&#x2F;4&#x2F;20.17:32</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ZKListener &#123;</span><br><span class="line">     public static void main(String[] args) throws IOException &#123;</span><br><span class="line">         ZkClient zkClient &#x3D; new ZkClient(&quot;192.168.128.160:2181&quot;);</span><br><span class="line">         &#x2F;&#x2F; 订阅⼦节点改变</span><br><span class="line">         zkClient.subscribeChildChanges(&quot;&#x2F;tencent&quot;, new IZkChildListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleChildChange(String parentPath, List&lt;String&gt;currentChilds) throws Exception &#123;</span><br><span class="line">             System.out.println(&quot;parentPath: &quot;+parentPath);</span><br><span class="line">             currentChilds.forEach( n -&gt; System.out.println(&quot;child node:&quot;+n));</span><br><span class="line">             System.out.println(&quot;-----------------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         &#x2F;&#x2F; 订阅数据改变</span><br><span class="line">         zkClient.subscribeDataChanges(&quot;&#x2F;tencent&quot;, new IZkDataListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleDataChange(String dataPath, Object data)throws Exception &#123;</span><br><span class="line">             System.out.println(&quot;data change: &quot;+dataPath + &quot;,changedata: &quot;+data);</span><br><span class="line">         &#125;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleDataDeleted(String dataPath) throws Exception&#123;</span><br><span class="line">             System.out.println(&quot;delete node path: &quot;+dataPath);</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         System.in.read();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h1><h2 id="5-1-命名服务（Naming-Service"><a href="#5-1-命名服务（Naming-Service" class="headerlink" title="5.1 命名服务（Naming Service)"></a>5.1 命名服务（Naming Service)</h2><p>如：阿⾥巴巴集团开源的分布式服务框架Dubbo中使⽤ZooKeeper来作为其命名服务，维护全局的服务地址列表。在Dubbo实现中： 服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址，并向/dubbo/${serviceName}/consumers目录下写入自己的URL地址,注意：所有向ZK上注册的地址都是临时节点，这样能够保证服务提供者和消费者能够自动感应资源的变化。</p><p><img src="/2019/01/10/ZooKeeper/9fbc88b2-8d78-49c7-b59b-b38aebb6c49a.jpg" alt></p><h2 id="5-2-集群管理与Master选举"><a href="#5-2-集群管理与Master选举" class="headerlink" title="5.2 集群管理与Master选举"></a>5.2 集群管理与Master选举</h2><p>利用Zookeeper有两个特性，就可以实现另一种集群机器存活性能监控系统：</p><ol><li>客户端在节点X上注册一个Wather，那么如果X的子节点变化了，会通知客户端、</li><li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。<h2 id="5-3-数据发布与订阅（配置中心）"><a href="#5-3-数据发布与订阅（配置中心）" class="headerlink" title="5.3 数据发布与订阅（配置中心）"></a>5.3 数据发布与订阅（配置中心）</h2>发布与订阅模型，即所谓的配置中⼼，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获<br>取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址<br>列表等就⾮常适合使⽤。<h2 id="5-4-分布式锁"><a href="#5-4-分布式锁" class="headerlink" title="5.4 分布式锁"></a>5.4 分布式锁</h2>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强⼀致性。锁服务可以分为两类，⼀个是<br>保持独占，另⼀个是控制时序。</li></ol><p>更详细的应用场景，可参考：</p><ol><li><a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">http://jm.taobao.org/2011/10/08/1232/</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li></ol><p>yum install -y wget</p>]]></content>
      
      
      <categories>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（八）：Jvm知识点概览</title>
      <link href="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/"/>
      <url>/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/09/28/jvm-overview.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在流行的框架越来越多，封装的也越来越完善，各种框架可以搞定一切，几乎不用关注底层的实现，初级程序员只要熟悉基本的使用方法，便可以快速的开发上线；但对于高级程序员来讲，内功的修炼却越发的重要，比如算法、设计模式、底层原理等，只有把这些基础熟练之后，才能在开发过程中知其然知其所以然，出现问题时能快速定位到问题的本质。</p><p>对于Java程序员来讲，spring全家桶几乎可以搞定一切，spring全家桶便是精妙的招式，jvm就是内功心法很重要的一块，线上出现性能问题，jvm调优更是不可回避的问题。因此JVM基础知识对于高级程序员的重要性不必言语，我司在面试高级开发的时候，jvm相关知识也必定是考核的标准之一。</p><a id="more"></a><h2 id="jvm-总体梳理"><a href="#jvm-总体梳理" class="headerlink" title="jvm 总体梳理"></a>jvm 总体梳理</h2><p>jvm体系总体分四大块：</p><ul><li>类的加载机制</li><li>jvm内存结构</li><li>GC算法 垃圾回收</li><li>GC分析 命令调优</li></ul><h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>主要关注点：</p><ul><li>什么是类的加载</li><li>类的生命周期</li><li>类加载器</li><li>双亲委派模型</li></ul><p><strong>什么是类的加载</strong></p><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p><p><strong>类的生命周期</strong></p><p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图；</p><p><img src="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/3ff371f6-ed22-4e44-a2ff-57e5d8627769.png" alt></p><ul><li><p>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</p></li><li><p>连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用</p></li><li><p>初始化，为类的静态变量赋予正确的初始值</p></li><li><p>使用，new出对象程序中使用</p></li><li><p>卸载，执行垃圾回收</p></li></ul><p><strong>类加载器</strong></p><p><img src="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/d3684a2e-ded0-410d-91ec-c6bf9c830603.png" alt></p><ul><li><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</p></li><li><p>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器</p></li></ul><p><strong>类加载机制</strong></p><ul><li><p>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p></li><li><p>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p></li><li><p>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p></li></ul><h2 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h2><p>主要关注点：</p><ul><li>jvm内存结构都是什么</li><li>对象分配规则</li></ul><p><strong>jvm内存结构</strong></p><p><img src="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/fd5eb5e3-1bab-4e08-9ff3-9c7b0f044ff0.jpg" alt></p><blockquote><p>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。</p></blockquote><ul><li><p>Java堆（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p></li><li><p>方法区（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>程序计数器（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p></li><li><p>本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p></li></ul><p><strong>对象分配规则</strong></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</p></li><li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p></li><li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p></li><li><p>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</p></li></ul><h2 id="GC算法-垃圾回收"><a href="#GC算法-垃圾回收" class="headerlink" title="GC算法 垃圾回收"></a>GC算法 垃圾回收</h2><p>主要关注点：</p><ul><li>对象存活判断</li><li>GC算法</li><li>垃圾回收器</li></ul><p><strong>对象存活判断</strong></p><p>判断对象是否存活一般有两种方式：</p><ul><li><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p></li></ul><p><strong>GC算法</strong></p><p>GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p><ul><li><p>标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p></li><li><p>复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p></li><li><p>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></li><li><p>分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p></li></ul><p><strong>垃圾回收器</strong></p><ul><li><p>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</p></li><li><p>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</p></li><li><p>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</p></li><li><p>Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法</p></li><li><p>CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p></li><li><p>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</p></li></ul><h2 id="GC分析-命令调优"><a href="#GC分析-命令调优" class="headerlink" title="GC分析 命令调优"></a>GC分析 命令调优</h2><p>主要关注点：</p><ul><li>GC日志分析</li><li>调优命令</li><li>调优工具</li></ul><p><strong>GC日志分析</strong></p><p>摘录GC日志一部分（前部分为年轻代gc回收；后部分为full gc回收）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user&#x3D;0.17 sys&#x3D;0.08, real&#x3D;0.07 secs] </span><br><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user&#x3D;1.75 sys&#x3D;0.02, real&#x3D;0.68 secs]</span><br></pre></td></tr></table></figure><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p><p>Young GC日志:</p><p><img src="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/8dc9ddd8-4fff-414e-aced-6ce78a1f64ab.jpg" alt></p><p>Full GC日志:</p><p><img src="/2019/01/06/JVM%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9AJvm%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A6%82%E8%A7%88/be53fc5f-a78a-4e44-9886-7bbf720f7764.jpg" alt></p><p><strong>调优命令</strong></p><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo</p><ul><li><p>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p></li><li><p>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></li><li><p>jmap，JVM Memory Map命令用于生成heap dump文件</p></li><li><p>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看</p></li><li><p>jstack，用于生成java虚拟机当前时刻的线程快照。</p></li><li><p>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p></li></ul><p><strong>调优工具</strong></p><p>常用调优工具分为两类,jdk自带监控工具：jconsole和jvisualvm，第三方有：MAT(Memory Analyzer Tool)、GChisto。</p><ul><li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</p></li><li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p></li><li><p>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p></li><li><p>GChisto，一款专业分析gc日志的工具</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（七）：Jvm调优-工具</title>
      <link href="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/09/22/jvm-tool.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工具做为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析（dump文件分析）一般也不会在生产直接分析，往往dump下来的文件达1G左右，人工分析效率较低，因此利用工具来分析jvm相关问题，长长可以到达事半功倍的效果来。</p><p>jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory Analyzer Tool)、GChisto等。</p><p>对于大型 JAVA 应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM 能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump) 文件中，从而为我们分析和诊断问题提供了重要的依据。其中VisualVM和MAT是dump文件的分析利器。</p><a id="more"></a><h2 id="jdk自带的工具"><a href="#jdk自带的工具" class="headerlink" title="jdk自带的工具"></a>jdk自带的工具</h2><h3 id="jconsole"><a href="#jconsole" class="headerlink" title="jconsole"></a>jconsole</h3><p>Jconsole（Java Monitoring and Management Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java management extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。</p><p>直接在jdk/bin目录下点击jconsole.exe即可启动，界面如下:</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/79dabd81-e1af-4668-a49f-be8d3d2c0eea.jpg" alt></p><p>在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat启动脚本中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port&#x3D;6969  </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl&#x3D;false  </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br></pre></td></tr></table></figure><p>连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans</p><ul><li>概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/dcbe4aca-0bce-40ab-8d93-5ca336435ee9.jpg" alt></p><ul><li>内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/8b9a10ab-b3cc-4dce-ab7e-d3c5563b43ba.jpg" alt></p><ul><li>线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/43707420-2cf4-4d1b-b287-e4deb303065c.jpg" alt></p><ul><li>类，主要展示已加载类的相关信息。</li><li>VM 概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。</li><li>Mbean,查看Mbean的属性，方法等。</li></ul><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h3><p><strong>简介</strong></p><p>VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java 应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK) 工具所检索的 JVM 软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java 应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关 JVM 软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/23abdd86-fae4-474b-9d5c-ac9cfbf81b7a.jpg" alt></p><p>VisualVM 是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole 一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数，主界面如下；</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/346bf009-cd87-4db1-9885-ebe188f8c33b.jpg" alt></p><p>VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/a9296fda-fede-4507-b1d5-b0f76b683ee9.jpg" alt></p><p>如何安装：</p><blockquote><p>1、从主菜单中选择“工具”&gt;“插件”。<br>2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。<br>3、逐步完成插件安装程序。</p></blockquote><p>我这里以 Eclipse(pid 22296)为例，双击后直接展开，主界面展示了系统和jvm两大块内容，点击右下方jvm参数和系统属性可以参考详细的参数信息.</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/c1e50aff-088b-4e52-983e-912cc649d11d.jpg" alt></p><p>因为VisualVM的插件太多，我这里主要介绍三个我主要使用几个：监控、线程、Visual GC</p><p>监控的主页其实也就是，cpu、内存、类、线程的图表</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/532a4ba3-9dad-4698-817e-0e9de93fecb8.jpg" alt></p><p>线程和jconsole功能没有太大的区别</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/9d267e6c-4060-49a1-8364-ec0150c286d5.jpg" alt></p><p>Visual GC 是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/567e5aaf-7ec9-4df0-b7c3-96063c6f30f8.jpg" alt></p><p>以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/43989873-a617-4607-b01f-a41ef3519f4b.jpg" alt></p><h2 id="第三方调优工具"><a href="#第三方调优工具" class="headerlink" title="第三方调优工具"></a>第三方调优工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p><strong>MAT是什么？</strong></p><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p><p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过要介绍的 MAT（Eclipse Memory Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT 的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p><p>MAT以eclipse 插件的形式来安装，具体的安装过程就不在描述了，可以利用visualvm或者是 jmap命令生产堆文件，导入eclipse mat中生成分析报告：</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/611e841d-fec4-4fa7-979c-3d5dd80d309a.jpg" alt></p><p>生产这会报表的同时也会在dump文件的同级目录下生成三份（dump_Top_Consumers.zip、dump_Leak_Suspects.zip、dump_Top_Components.zip）分析结果的html文件，方便发送给相关同事来查看。</p><p>需要关注的是下面的Actions、Reports、Step by Step区域：</p><ul><li>Histogram：列出内存中的对象，对象的个数以及大小，支持正则表达式查找，也可以计算出该类所有对象的retained size</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/b821d7e2-f89b-49c5-b031-54870cf7b8b7.jpg" alt></p><ul><li>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/2d6f53f2-f472-42d2-902c-569aa51812aa.jpg" alt></p><ul><li>Top Consumers ： 通过图形列出最大的object</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/f604fc01-b69f-470c-b9f2-1780e0855f64.jpg" alt></p><ul><li><p>duplicate classes ：检测由多个类装载器加载的类</p></li><li><p>Leak Suspects ：内存泄漏分析</p></li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/236f053b-820d-4420-8632-c3347ecd883e.jpg" alt></p><ul><li>Top Components: 列出大于总堆数的百分之1的报表。</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/7719b3c4-027a-4796-ad89-ad2f16ae8058.jpg" alt></p><ul><li>Component Report:分析对象属于同一个包或者被同一个类加载器加载</li></ul><p>以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一下内存快照，随后在对比不同时间的堆内存的变化来发现问题。</p><h3 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h3><p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p><p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/888d723f-3827-4ce0-9cf6-d3563744d3dd.jpg" alt></p><ul><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/ae48019e-9227-4c6f-9549-261f3be9b5ee.jpg" alt></p><ul><li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p></li><li><p>GC Timeline：显示整个时间线上的垃圾收集</p></li></ul><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/302b4791-c49a-4751-985e-ab1493a4d904.jpg" alt></p><p><strong>不过这款工具已经不再维护，不能识别最新jdk的日志文件。</strong></p><h3 id="gcviewer"><a href="#gcviewer" class="headerlink" title="gcviewer"></a>gcviewer</h3><p>GCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和 BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示 的界面比较乱没有GChisto更专业一些。</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/feb86b24-9427-457c-817f-b28c55be153a.jpg" alt></p><h3 id="GC-Easy"><a href="#GC-Easy" class="headerlink" title="GC Easy"></a>GC Easy</h3><p>这是一个web工具,在线使用非常方便.</p><p>地址: <a href="http://gceasy.io/" target="_blank" rel="noopener">http://gceasy.io</a></p><p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p><p><img src="/2019/01/05/JVM%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/b7e6f5c3-0b48-400e-afe1-1c8343634dd8.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（六）：Java服务GC参数调优案例</title>
      <link href="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/09/19/GC-tuning.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文介绍了一次生产环境的JVM GC相关参数的调优过程，通过参数的调整避免了GC卡顿对JAVA服务成功率的影响。我们的Java HTTP服务属于OLTP类型，对成功率和响应时间的要求比较高，在生产环境中出现偶现的成功率突然下降然后又自动恢复的情况，如图所示：</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/e0555f10-4901-42db-ad9d-bd6b33798db1.jpg" alt></p><a id="more"></a><p>JVM和GC相关的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xmx22528m</span><br><span class="line">-Xms22528m</span><br><span class="line">-XX:NewRatio&#x3D;2</span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+CMSParallelRemarkEnabled</span><br></pre></td></tr></table></figure><p>总结来说，由于服务中大量使用了Cache，所以堆大小开到了22G。GC算法使用CMS（UseConcMarkSweepGC），开启了降低标记停顿（CMSParallelRemarkEnabled），设置年轻代为并行收集（UseParNewGC），年轻代和老年代的比例为1:2 （NewRatio＝2）.</p><p>JVM GC日志相关的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:&#x2F;data&#x2F;gc.log</span><br><span class="line">-XX:GCLogFileSize&#x3D;10M</span><br><span class="line">-XX:NumberOfGCLogFiles&#x3D;10</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+DisableExplicitGC</span><br><span class="line">-verbose:gc</span><br></pre></td></tr></table></figure><h2 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h2><h3 id="排除应用程序的内存使用问题"><a href="#排除应用程序的内存使用问题" class="headerlink" title="排除应用程序的内存使用问题"></a>排除应用程序的内存使用问题</h3><p>首先使用jmap查看内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live PID</span><br></pre></td></tr></table></figure><p>这个命令把程序中当前的对象按照个数和占用的空间排序以后打印出来。这里没有发现使用异常的对象。</p><h3 id="排除Cache内容过多的问题"><a href="#排除Cache内容过多的问题" class="headerlink" title="排除Cache内容过多的问题"></a>排除Cache内容过多的问题</h3><p>如果Cache内容过多也会导致JVM老年代容易被用满导致频繁GC，因此调出GC日志进行查看，发现每次GC以后内存使用一般是从20G降低到5G左右，因此常驻内存的Cache不是导致GC长时间卡顿的根本原因。对于GC LOG的查看有多种方式，使用VisualVM比较直观，需要使用VisualGC：</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/b4dec7c7-d04b-4537-858f-6f8686c6dd97.jpg" alt></p><p>从图中我们可以看到伊甸园和老年代的空间分配，由于整体内存是20G，设置 -XX:NewRatio=2 因此老年代是14G，伊甸园＋S0+S1=7G</p><h3 id="调整GC时间点（成功率抖动问题加重）"><a href="#调整GC时间点（成功率抖动问题加重）" class="headerlink" title="调整GC时间点（成功率抖动问题加重）"></a>调整GC时间点（成功率抖动问题加重）</h3><p>如果GC需要处理的内存量比较大，执行的时间也就比较长，STW （Stop the World）时间也就更长。按照这个思路调整CMS启动的时间点，希望提早GC，也就是让GC变得更加频繁但是期望每次执行的时间较少。添加了下面这两个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;50</span><br></pre></td></tr></table></figure><p>意思是说在Old区使用了50%的时候触发GC。实验后发现GC的频率有所增加，但是每次GC造成的陈功率降低现象并没有减弱，因此弃用这两个参数。</p><h3 id="调整对象在年轻代内存中驻留的时间（效果不明显）"><a href="#调整对象在年轻代内存中驻留的时间（效果不明显）" class="headerlink" title="调整对象在年轻代内存中驻留的时间（效果不明显）"></a>调整对象在年轻代内存中驻留的时间（效果不明显）</h3><p>如果能够降低老年代GC的频率也可以达到降低GC影响的目的，因此尝试让对象在年轻代内存中进行更长时间的驻留，提升这些对象在年轻代GC时候被销毁的概率。使用参数<code>-XX:MaxTenuringThreshold=31</code>调整以后收效不明显。</p><blockquote><p>备注：<br>1、MaxTenuringThreshold 在1.5.0_05之前最大值可以设置为31 ，1.5.0_06以后最大值可以设置为15，超过15会被认为无限大。参考：<a href="https://sourcevirtues.com/2013/03/29/never-set-gc-parameter-maxtenuringthreshold-greater-than-15/" target="_blank" rel="noopener">Never set GC parameter -XX:MaxTenuringThreshold greater than 15</a></p></blockquote><blockquote><p>2、提升年轻代GC被销毁的概率，只是调整这个参数效果不大，第二次age的值会重新计算，参考：<a href="http://bluedavy.me/?p=70" target="_blank" rel="noopener">说说MaxTenuringThreshold这个参数</a></p></blockquote><h3 id="CMS-Remark之前强制进行年轻代的GC"><a href="#CMS-Remark之前强制进行年轻代的GC" class="headerlink" title="CMS-Remark之前强制进行年轻代的GC"></a>CMS-Remark之前强制进行年轻代的GC</h3><p>首先补充一下CMS的相关知识，在CMS整个过程中有两个步骤是STW的，如图红色部分：</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/9667b98d-6b58-4b32-baa2-d3774df1de38.png" alt></p><p>CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停，它的收集周期是这样：</p><ul><li>1、初始标记(CMS-initial-mark),从root对象开始标记存活的对象</li><li>2、并发标记(CMS-concurrent-mark)</li><li>3、重新标记(CMS-remark),暂停所有应用程序线程，重新标记并发标记阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致）</li><li>4、并发清除(CMS-concurrent-sweep)</li><li>5、并发重设状态等待下次CMS的触发(CMS-concurrent-reset)。</li></ul><p>通过GC日志和成功率下降的时间点进行比对发现并不是每一次老年代GC都会导致成功率的下降，但是从中发现了一个规律：</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/4316e0b5-1aba-4654-bc22-e8844ed6ac2d.jpg" alt></p><p>前两次GC CMS-Remark过程在4s左右造成了成功率的下降，但是第三次GC并没有对成功率造成明显的影响,CMS-Remark只有0.18s。Java HTTP 服务是通过Nginx进行反向代理的，nginx设置的超时时间是3s，所以如果GC卡顿在3s以内就不会对成功率造成太大的影响。</p><p>从GC日志中又发现一个信息：</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/00fa89ca-e1fd-4894-b5ac-27b122b72b88.jpg" alt></p><p>在文档和相关资料中没有找到蓝色部分的含义，猜测是remark处理的内存量，处理的越多就越慢。添加下面两个参数强制在remark阶段和FULL GC阶段之前先在进行一次年轻代的GC，这样需要进行处理的内存量就不会太多。</p><blockquote><p>备注：<br>1、蓝色部分的含义：remark标记需要清理对象的容量。关于如何分析CMS日志，可以参考这篇文章：<a href="http://ifeve.com/jvm-cms-log/" target="_blank" rel="noopener">了解 CMS 垃圾回收日志</a></p></blockquote><blockquote><p>2、FULL GC阶段之前先在进行一次年轻代的GC的意义是：Yong区对象引用了Old区的对象，如果在Old区进行清理之前不进行Yong区清理，就会导致Old区被yong区引用的对象无法释放。可以参考这篇文章：<a href="http://mp.weixin.qq.com/s/HKdpmmvJKq45QZdV4Q2cYQ" target="_blank" rel="noopener">假笨说-又抓了一个导致频繁GC的鬼–数组动态扩容</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ScavengeBeforeFullGC </span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure><p>调优以后效果很明显，下面是两台配置完全相同的服务器在同一时间段的成功率和响应时间监控图，第一个没有添加强制年轻代GC的参数。</p><p><img src="/2019/01/03/JVM%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9AJava%E6%9C%8D%E5%8A%A1GC%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B/1744ddb0-0c3e-4bad-a5cf-b8b02ee0197a.jpg" alt></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1、在CMS-remark阶段需要对堆中所有的内存对象进行处理，如果在这个阶段之前强制执行一次年轻代的GC会大量减少remark需要处理的内存数量，进而降低JVM卡顿对成功率的影响。</p><p>2、对于Java HTTP服务，JVM的卡顿时间应该小于HTTP客户端的调用超时时间，否则JVM卡顿会对成功率造成影响。</p>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（五）：GC分析</title>
      <link href="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/09/18/GC-Analysis.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java GC就是JVM记录仪，书画了JVM各个分区的表演。</p><h2 id="什么是-Java-GC"><a href="#什么是-Java-GC" class="headerlink" title="什么是 Java GC"></a>什么是 Java GC</h2><p>ava GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p><p>在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。</p><p>简单总结一下，Java GC就是通过GC收集器回收不再存活的对象，保证JVM更加高效的运转。</p><a id="more"></a><h2 id="如何获取-Java-GC日志"><a href="#如何获取-Java-GC日志" class="headerlink" title="如何获取 Java GC日志"></a>如何获取 Java GC日志</h2><p>一般情况可以通过两种方式来获取GC日志，一种是使用命令动态查看，一种是在容器中设置相关参数打印GC日志。</p><h3 id="命令动态查看"><a href="#命令动态查看" class="headerlink" title="命令动态查看"></a>命令动态查看</h3><p>Java 自动的工具行命令，jstat可以用来动态监控JVM内存的使用，统计垃圾回收的各项信息。</p><p>比如常用命令，<code>jstat -gc</code> 统计垃圾回收堆的行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262</span><br><span class="line"> S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT   </span><br><span class="line">26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</span><br></pre></td></tr></table></figure><p>也可以设置间隔固定时间来打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 2000 20</span><br></pre></td></tr></table></figure><p>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次</p><h3 id="GC参数"><a href="#GC参数" class="headerlink" title="GC参数"></a>GC参数</h3><p>JVM的GC日志的主要参数包括如下几个：</p><ul><li><code>-XX:+PrintGC</code> 输出GC日志</li><li><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</li><li><code>-XX:+PrintGCTimeStamps</code> 输出GC的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDateStamps</code> 输出GC的时间戳（以日期的形式，如 2017-09-04T21:53:59.234+0800）</li><li><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li></ul><p>在生产环境中，根据需要配置相应的参数来监控JVM运行情况。</p><h3 id="Tomcat-设置示例"><a href="#Tomcat-设置示例" class="headerlink" title="Tomcat 设置示例"></a>Tomcat 设置示例</h3><p>我们经常在tomcat的启动参数中添加JVM相关参数，这里有一个典型的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS&#x3D;&quot;-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m -XX:SurvivorRatio&#x3D;4</span><br><span class="line">-verbose:gc -Xloggc:$CATALINA_HOME&#x2F;logs&#x2F;gc.log </span><br><span class="line">-Djava.awt.headless&#x3D;true </span><br><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails </span><br><span class="line">-Dsun.rmi.dgc.server.gcInterval&#x3D;600000 -Dsun.rmi.dgc.client.gcInterval&#x3D;600000</span><br><span class="line">-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold&#x3D;15&quot;</span><br></pre></td></tr></table></figure><p>根据上面的参数我们来做一下解析：</p><ul><li><p><code>-Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m</code><br>Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</p></li><li><p><code>-XX:SurvivorRatio=4</code><br>SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是8，则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio 设置成比较大的值（比如65536)来做到。</p></li><li><p><code>-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log</code><br>将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</p></li><li><p><code>-Djava.awt.headless=true</code> Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</p></li><li><p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDetails</code><br>设置gc日志的格式</p></li><li><p><code>-Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000</code><br>指定rmi调用时gc的时间间隔</p></li><li><p><code>-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15</code> 采用并发gc方式，经过15次minor gc 后进入年老代</p></li></ul><h2 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h2><p>摘录GC日志一部分</p><p>Young GC回收日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user&#x3D;0.17 sys&#x3D;0.08, real&#x3D;0.07 secs]</span><br></pre></td></tr></table></figure><p>Full GC回收日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user&#x3D;1.75 sys&#x3D;0.02, real&#x3D;0.68 secs]</span><br></pre></td></tr></table></figure><p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p><p>通过两张图非常明显看出gc日志构成：</p><p>Young GC日志:</p><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/9e0de54e-83a7-4c05-adea-4c814e202501.jpg" alt></p><p>Full GC日志:</p><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/2e14f800-f310-47c4-affe-703e1ca34159.jpg" alt></p><h2 id="GC分析工具"><a href="#GC分析工具" class="headerlink" title="GC分析工具"></a>GC分析工具</h2><h3 id="GChisto"><a href="#GChisto" class="headerlink" title="GChisto"></a>GChisto</h3><p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor GC、full gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p><p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add 选择gc.log日志</p><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/7ad77ea3-d355-4cfe-a5ed-c14567adb079.jpg" alt></p><ul><li>GC Pause Stats:可以查看GC 的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li></ul><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/9e9d0583-25a4-48d6-a30b-4cf108020c7a.jpg" alt></p><ul><li><p>GC Pause Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p></li><li><p>GC Timeline：显示整个时间线上的垃圾收集</p></li></ul><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/07ae7481-cdbc-443d-81f7-78704d79b96b.jpg" alt></p><p><strong>不过这款工具已经不再维护</strong></p><h3 id="GC-Easy"><a href="#GC-Easy" class="headerlink" title="GC Easy"></a>GC Easy</h3><p>这是一个web工具,在线使用非常方便.</p><p>地址: <a href="http://gceasy.io/" target="_blank" rel="noopener">http://gceasy.io</a></p><p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p><p><img src="/2019/01/02/JVM%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGC%E5%88%86%E6%9E%90/2bba726a-8009-4e89-82f5-f51e988cb031.png" alt></p><p>推荐使用此工具进行gc分析。（<strong>可能要挂个VPN</strong>）</p>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（四）：Jvm调优-命令</title>
      <link href="/2019/01/01/JVM%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/01/01/JVM%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/09/03/jvm-command.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等，但是在生产环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。</p><p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo下面做一一介绍</p><a id="more"></a><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><blockquote><ul><li>-l : 输出主类全名或jar路径</li><li>-q : 只输出LVMID</li><li>-m : 输出JVM启动时传递给main()的参数</li><li>-v : 输出JVM启动时显示指定的JVM参数</li></ul></blockquote><p>其中[option]、[hostid]参数也可以不写。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l -m</span><br><span class="line">  28920 org.apache.catalina.startup.Bootstrap start</span><br><span class="line">  11589 org.apache.catalina.startup.Bootstrap start</span><br><span class="line">  25816 sun.tools.jps.Jps -l -m</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p><h3 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><ul><li>[option] : 操作参数</li><li>LVMID : 本地虚拟机进程ID</li><li>[interval] : 连续输出的时间间隔</li><li>[count] : 连续输出的次数</li></ul></blockquote><h4 id="option-参数总览"><a href="#option-参数总览" class="headerlink" title="option 参数总览"></a>option 参数总览</h4><table><thead><tr><th>Option</th><th>Displays…</th></tr></thead><tbody><tr><td>class</td><td>class loader的行为统计。Statistics on the behavior of the class loader.</td></tr><tr><td>compiler</td><td>HotSpt JIT编译器行为统计。Statistics of the behavior of the HotSpot Just-in-Time compiler.</td></tr><tr><td>gc</td><td>垃圾回收堆的行为统计。Statistics of the behavior of the garbage collected heap.</td></tr><tr><td>gccapacity</td><td>各个垃圾回收代容量(young,old,perm)和他们相应的空间统计。Statistics of the capacities of the generations and their corresponding spaces.</td></tr><tr><td>gcutil</td><td>垃圾回收统计概述。Summary of garbage collection statistics.</td></tr><tr><td>gccause</td><td>垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因。Summary of garbage collection statistics (same as -gcutil), with the cause of the last and</td></tr><tr><td>gcnew</td><td>新生代行为统计。Statistics of the behavior of the new generation.</td></tr><tr><td>gcnewcapacity</td><td>新生代与其相应的内存空间的统计。Statistics of the sizes of the new generations and its corresponding spaces.</td></tr><tr><td>gcold</td><td>年老代和永生代行为统计。Statistics of the behavior of the old and permanent generations.</td></tr><tr><td>gcoldcapacity</td><td>年老代行为统计。Statistics of the sizes of the old generation.</td></tr><tr><td>gcpermcapacity</td><td>永生代行为统计。Statistics of the sizes of the permanent generation.</td></tr><tr><td>printcompilation</td><td>HotSpot编译方法统计。HotSpot compilation method statistics.</td></tr></tbody></table><h4 id="option-参数详解"><a href="#option-参数详解" class="headerlink" title="option 参数详解"></a>option 参数详解</h4><h5 id="class"><a href="#class" class="headerlink" title="-class"></a>-class</h5><p>监视类装载、卸载数量、总空间以及耗费的时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 11589</span><br><span class="line"> Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  7035  14506.3     0     0.0       3.67</span><br></pre></td></tr></table></figure><blockquote><ul><li>Loaded : 加载class的数量</li><li>Bytes : class字节大小</li><li>Unloaded : 未加载class的数量</li><li>Bytes : 未加载class的字节大小</li><li>Time : 加载时间</li></ul></blockquote><h5 id="compiler"><a href="#compiler" class="headerlink" title="-compiler"></a>-compiler</h5><p>输出JIT编译过的方法数量耗时等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler 1262</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">    2573      1       0    47.60          1 org&#x2F;apache&#x2F;catalina&#x2F;loader&#x2F;WebappClassLoader findResourceInternal</span><br></pre></td></tr></table></figure><blockquote><ul><li>Compiled : 编译数量</li><li>Failed : 编译失败数量</li><li>Invalid : 无效数量</li><li>Time : 编译耗时</li><li>FailedType : 失败类型</li><li>FailedMethod : 失败方法的全限定名</li></ul></blockquote><h5 id="gc"><a href="#gc" class="headerlink" title="-gc"></a>-gc</h5><p>垃圾回收堆的行为统计，<strong>常用命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262</span><br><span class="line"> S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT   </span><br><span class="line">26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</span><br></pre></td></tr></table></figure><p><strong>C即Capacity 总容量，U即Used 已使用的容量</strong></p><blockquote><ul><li>S0C : survivor0区的总容量</li><li>S1C : survivor1区的总容量</li><li>S0U : survivor0区已使用的容量</li><li>S1U : survivor1区已使用的容量</li><li>EC : Eden区的总容量</li><li>EU : Eden区已使用的容量</li><li>OC : Old区的总容量</li><li>OU : Old区已使用的容量</li><li>PC 当前perm的容量 (KB)</li><li>PU perm的使用 (KB)</li><li>YGC : 新生代垃圾回收次数</li><li>YGCT : 新生代垃圾回收时间</li><li>FGC : 老年代垃圾回收次数</li><li>FGCT : 老年代垃圾回收时间</li><li>GCT : 垃圾回收总消耗时间</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 2000 20</span><br></pre></td></tr></table></figure><p>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次</p><h5 id="gccapacity"><a href="#gccapacity" class="headerlink" title="-gccapacity"></a>-gccapacity</h5><p>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity 1262</span><br><span class="line"> NGCMN    NGCMX     NGC    S0C   S1C       EC         OGCMN      OGCMX      OGC        OC       PGCMN    PGCMX     PGC      PC         YGC    FGC </span><br><span class="line">614400.0 614400.0 614400.0 26112.0 24064.0 564224.0   434176.0   434176.0   434176.0   434176.0 524288.0 1048576.0 524288.0 524288.0    320     1</span><br></pre></td></tr></table></figure><blockquote><ul><li>NGCMN : 新生代占用的最小空间</li><li>NGCMX : 新生代占用的最大空间</li><li>OGCMN : 老年代占用的最小空间</li><li>OGCMX : 老年代占用的最大空间</li><li>OGC：当前年老代的容量 (KB)</li><li>OC：当前年老代的空间 (KB)</li><li>PGCMN : perm占用的最小空间</li><li>PGCMX : perm占用的最大空间</li></ul></blockquote><h5 id="gcutil"><a href="#gcutil" class="headerlink" title="-gcutil"></a>-gcutil</h5><p>同-gc，不过输出的是已使用空间占总空间的百分比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 28920</span><br><span class="line">  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"> 12.45   0.00  33.85   0.00   4.44  4       0.242     0    0.000    0.242</span><br></pre></td></tr></table></figure><h5 id="gccause"><a href="#gccause" class="headerlink" title="-gccause"></a>-gccause</h5><p>垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause 28920</span><br><span class="line">  S0     S1     E      O      P       YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line"> 12.45   0.00  33.85   0.00   4.44      4    0.242     0    0.000    0.242   Allocation Failure   No GC</span><br></pre></td></tr></table></figure><blockquote><ul><li>LGCC：最近垃圾回收的原因</li><li>GCC：当前垃圾回收的原因</li></ul></blockquote><h5 id="gcnew"><a href="#gcnew" class="headerlink" title="-gcnew"></a>-gcnew</h5><p>统计新生代的行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew 28920</span><br><span class="line"> S0C      S1C      S0U        S1U  TT  MTT  DSS      EC        EU         YGC     YGCT  </span><br><span class="line"> 419392.0 419392.0 52231.8    0.0  6   6    209696.0 3355520.0 1172246.0  4       0.242</span><br></pre></td></tr></table></figure><blockquote><ul><li>TT：Tenuring threshold(提升阈值)</li><li>MTT：最大的tenuring threshold</li><li>DSS：survivor区域大小 (KB)</li></ul></blockquote><h5 id="gcnewcapacity"><a href="#gcnewcapacity" class="headerlink" title="-gcnewcapacity"></a>-gcnewcapacity</h5><p>新生代与其相应的内存空间的统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity 28920</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC        YGC   FGC </span><br><span class="line"> 4194304.0  4194304.0  4194304.0 419392.0 419392.0 419392.0 419392.0  3355520.0  3355520.0     4     0</span><br></pre></td></tr></table></figure><blockquote><ul><li>NGC:当前年轻代的容量 (KB)</li><li>S0CMX:最大的S0空间 (KB)</li><li>S0C:当前S0空间 (KB)</li><li>ECMX:最大eden空间 (KB)</li><li>EC:当前eden空间 (KB)</li></ul></blockquote><h5 id="gcold"><a href="#gcold" class="headerlink" title="-gcold"></a>-gcold</h5><p>统计旧生代的行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcold 28920</span><br><span class="line">   PC       PU        OC           OU       YGC    FGC    FGCT     GCT   </span><br><span class="line">1048576.0  46561.7   6291456.0     0.0      4      0      0.000    0.242</span><br></pre></td></tr></table></figure><h5 id="gcoldcapacity"><a href="#gcoldcapacity" class="headerlink" title="-gcoldcapacity"></a>-gcoldcapacity</h5><p>统计旧生代的大小和空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcoldcapacity 28920</span><br><span class="line">   OGCMN       OGCMX        OGC         OC         YGC   FGC    FGCT     GCT   </span><br><span class="line">  6291456.0   6291456.0   6291456.0   6291456.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure><h5 id="gcpermcapacity"><a href="#gcpermcapacity" class="headerlink" title="-gcpermcapacity"></a>-gcpermcapacity</h5><p>永生代行为统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcpermcapacity 28920</span><br><span class="line">    PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT   </span><br><span class="line"> 1048576.0  2097152.0  1048576.0  1048576.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure><h5 id="printcompilation"><a href="#printcompilation" class="headerlink" title="-printcompilation"></a>-printcompilation</h5><p>hotspot编译方法统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -printcompilation 28920</span><br><span class="line">    Compiled  Size  Type Method</span><br><span class="line">    1291      78     1    java&#x2F;util&#x2F;ArrayList indexOf</span><br></pre></td></tr></table></figure><blockquote><ul><li>Compiled：被执行的编译任务的数量</li><li>Size：方法字节码的字节数</li><li>Type：编译类型</li><li>Method：编译方法的类名和方法名。类名使用”/” 代替 “.” 作为空间分隔符. 方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation 选项</li></ul></blockquote><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。 jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p><h3 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure><h3 id="option参数-1"><a href="#option参数-1" class="headerlink" title="option参数"></a>option参数</h3><blockquote><ul><li>dump : 生成堆转储快照</li><li>finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li><li>heap : 显示Java堆详细信息</li><li>histo : 显示堆中对象的统计信息</li><li>permstat : to print permanent generation statistics</li><li>F : 当-dump没有响应时，强制生成dump快照</li></ul></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><h5 id="dump"><a href="#dump" class="headerlink" title="-dump"></a>-dump</h5><p>常用格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dump::live,format&#x3D;b,file&#x3D;&lt;filename&gt; pid</span><br></pre></td></tr></table></figure><p>dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -dump:live,format&#x3D;b,file&#x3D;dump.hprof 28920</span><br><span class="line">  Dumping heap to &#x2F;home&#x2F;xxx&#x2F;dump.hprof ...</span><br><span class="line">  Heap dump file created</span><br></pre></td></tr></table></figure><p>dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis Tool)打开。</p><h5 id="finalizerinfo"><a href="#finalizerinfo" class="headerlink" title="-finalizerinfo"></a>-finalizerinfo</h5><p>打印等待回收对象的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -finalizerinfo 28920</span><br><span class="line">  Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01</span><br><span class="line">  Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure><p>可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。</p><h5 id="heap"><a href="#heap" class="headerlink" title="-heap"></a>-heap</h5><p>打印heap的概要信息，GC使用的算法，heap的配置及wise heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 28920</span><br><span class="line">  Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01  </span><br><span class="line"></span><br><span class="line">  using thread-local object allocation.</span><br><span class="line">  Parallel GC with 4 thread(s)&#x2F;&#x2F;GC 方式  </span><br><span class="line"></span><br><span class="line">  Heap Configuration: &#x2F;&#x2F;堆内存初始化配置</span><br><span class="line">     MinHeapFreeRatio &#x3D; 0 &#x2F;&#x2F;对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">     MaxHeapFreeRatio &#x3D; 100 &#x2F;&#x2F;对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">     MaxHeapSize      &#x3D; 2082471936 (1986.0MB) &#x2F;&#x2F;对应jvm启动参数-XX:MaxHeapSize&#x3D;设置JVM堆的最大大小</span><br><span class="line">     NewSize          &#x3D; 1310720 (1.25MB)&#x2F;&#x2F;对应jvm启动参数-XX:NewSize&#x3D;设置JVM堆的‘新生代’的默认大小</span><br><span class="line">     MaxNewSize       &#x3D; 17592186044415 MB&#x2F;&#x2F;对应jvm启动参数-XX:MaxNewSize&#x3D;设置JVM堆的‘新生代’的最大大小</span><br><span class="line">     OldSize          &#x3D; 5439488 (5.1875MB)&#x2F;&#x2F;对应jvm启动参数-XX:OldSize&#x3D;&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">     NewRatio         &#x3D; 2 &#x2F;&#x2F;对应jvm启动参数-XX:NewRatio&#x3D;:‘新生代’和‘老生代’的大小比率</span><br><span class="line">     SurvivorRatio    &#x3D; 8 &#x2F;&#x2F;对应jvm启动参数-XX:SurvivorRatio&#x3D;设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">     PermSize         &#x3D; 21757952 (20.75MB)  &#x2F;&#x2F;对应jvm启动参数-XX:PermSize&#x3D;&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">     MaxPermSize      &#x3D; 85983232 (82.0MB)&#x2F;&#x2F;对应jvm启动参数-XX:MaxPermSize&#x3D;&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">     G1HeapRegionSize &#x3D; 0 (0.0MB)  </span><br><span class="line"></span><br><span class="line">  Heap Usage:&#x2F;&#x2F;堆内存使用情况</span><br><span class="line">  PS Young Generation</span><br><span class="line">  Eden Space:&#x2F;&#x2F;Eden区内存分布</span><br><span class="line">     capacity &#x3D; 33030144 (31.5MB)&#x2F;&#x2F;Eden区总容量</span><br><span class="line">     used     &#x3D; 1524040 (1.4534378051757812MB)  &#x2F;&#x2F;Eden区已使用</span><br><span class="line">     free     &#x3D; 31506104 (30.04656219482422MB)  &#x2F;&#x2F;Eden区剩余容量</span><br><span class="line">     4.614088270399305% used &#x2F;&#x2F;Eden区使用比率</span><br><span class="line">  From Space:  &#x2F;&#x2F;其中一个Survivor区的内存分布</span><br><span class="line">     capacity &#x3D; 5242880 (5.0MB)</span><br><span class="line">     used     &#x3D; 0 (0.0MB)</span><br><span class="line">     free     &#x3D; 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  To Space:  &#x2F;&#x2F;另一个Survivor区的内存分布</span><br><span class="line">     capacity &#x3D; 5242880 (5.0MB)</span><br><span class="line">     used     &#x3D; 0 (0.0MB)</span><br><span class="line">     free     &#x3D; 5242880 (5.0MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Old Generation &#x2F;&#x2F;当前的Old区内存分布</span><br><span class="line">     capacity &#x3D; 86507520 (82.5MB)</span><br><span class="line">     used     &#x3D; 0 (0.0MB)</span><br><span class="line">     free     &#x3D; 86507520 (82.5MB)</span><br><span class="line">     0.0% used</span><br><span class="line">  PS Perm Generation&#x2F;&#x2F;当前的 “永生代” 内存分布</span><br><span class="line">     capacity &#x3D; 22020096 (21.0MB)</span><br><span class="line">     used     &#x3D; 2496528 (2.3808746337890625MB)</span><br><span class="line">     free     &#x3D; 19523568 (18.619125366210938MB)</span><br><span class="line">     11.337498256138392% used  </span><br><span class="line"></span><br><span class="line">  670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p>可以很清楚的看到Java堆中各个区域目前的情况。</p><h5 id="histo"><a href="#histo" class="headerlink" title="-histo"></a>-histo</h5><p>打印堆的对象统计，包括对象数、内存大小等等 （因为在dump:live前会进行full gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 28920 | more</span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         83613       12012248  &lt;constMethodKlass&gt;</span><br><span class="line">   2:         23868       11450280  [B</span><br><span class="line">   3:         83613       10716064  &lt;methodKlass&gt;</span><br><span class="line">   4:         76287       10412128  [C</span><br><span class="line">   5:          8227        9021176  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:          8227        5830256  &lt;instanceKlassKlass&gt;</span><br><span class="line">   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   8:         73627        1767048  java.lang.String</span><br><span class="line">   9:          2260        1348848  &lt;methodDataKlass&gt;</span><br><span class="line">  10:          8856         849296  java.lang.Class</span><br><span class="line">  ....</span><br></pre></td></tr></table></figure><p>仅仅打印了前10行</p><p><code>xml class name</code>是对象类型，说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B  byte</span><br><span class="line">C  char</span><br><span class="line">D  double</span><br><span class="line">F  float</span><br><span class="line">I  int</span><br><span class="line">J  long</span><br><span class="line">Z  boolean</span><br><span class="line">[  数组，如[I表示int[]</span><br><span class="line">[L+类名 其他对象</span><br></pre></td></tr></table></figure><h5 id="permstat"><a href="#permstat" class="headerlink" title="-permstat"></a>-permstat</h5><p>打印Java堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -permstat 28920</span><br><span class="line">  Attaching to process ID 28920, please wait...</span><br><span class="line">  Debugger attached successfully.</span><br><span class="line">  Server compiler detected.</span><br><span class="line">  JVM version is 24.71-b01</span><br><span class="line">  finding class loader instances ..done.</span><br><span class="line">  computing per loader stat ..done.</span><br><span class="line">  please wait.. computing liveness.liveness analysis may be inaccurate ...</span><br><span class="line"></span><br><span class="line">  class_loader            classes bytes   parent_loader           alive?  type  </span><br><span class="line">  &lt;bootstrap&gt;             3111    18154296          null          live    &lt;internal&gt;</span><br><span class="line">  0x0000000600905cf8      1       1888    0x0000000600087f08      dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">  0x00000006008fcb48      1       1888    0x0000000600087f08      dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x00000007800500a0</span><br><span class="line">  0x00000006016db798      0       0       0x00000006008d3fc0      dead    java&#x2F;util&#x2F;ResourceBundle$RBClassLoader@0x0000000780626ec0</span><br><span class="line">  0x00000006008d6810      1       3056      null          dead    sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x00000007800500a0</span><br></pre></td></tr></table></figure><h5 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h5><p>强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap -histo选项。此模式下，不支持live子选项。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><p>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p><h3 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><blockquote><ul><li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为 false. 默认值为 true.&gt;</li><li>-refs false|true 关闭对象引用跟踪(tracking of references to objects)。 默认值为 true. 默认情况下, 返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or incoming references), 会统计/计算堆中的所有对象。&gt;</li><li>-port port-number 设置 jhat HTTP server 的端口号. 默认值 7000.&gt;</li><li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a file that lists data members that should be excluded from the reachable objects query)。 例如, 如果文件列列出了 java.lang.String.value , 那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及 java.lang.String.value 的都会被排除。&gt;</li><li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。 在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as not being new). 其他对象被标记为新的(new). 在比较两个不同的堆转储时很有用.&gt;</li><li>-debug int 设置 debug 级别. 0 表示不输出调试信息。 值越大则表示输出更详细的 debug 信息.&gt;</li><li>-version 启动后只显示版本信息就退出&gt;</li><li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J 可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat 的Java虚拟机使用的最大堆内存为 512 MB. 如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</li></ul></blockquote><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ jhat -J-Xmx512m dump.hprof</span><br><span class="line">  eading from dump.hprof...</span><br><span class="line">  Dump file created Fri Mar 11 17:13:42 CST 2016</span><br><span class="line">  Snapshot read, resolving...</span><br><span class="line">  Resolving 271678 objects...</span><br><span class="line">  Chasing references, expect 54 dots......................................................</span><br><span class="line">  Eliminating duplicate references......................................................</span><br><span class="line">  Snapshot resolved.</span><br><span class="line">  Started HTTP server on port 7000</span><br><span class="line">  Server is ready.</span><br></pre></td></tr></table></figure><p>中间的-J-Xmx512m是在dump快照很大的情况下分配512M内存去启动HTTP服务器，运行完之后就可在浏览器打开Http://localhost:7000进行快照分析 堆快照分析主要在最后面的Heap Histogram里，里面根据class列出了dump的时候所有存活对象。</p><p><strong>分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。</strong></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>打开浏览器Http://localhost:7000，该页面提供了几个查询功能可供使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">All classes including platform</span><br><span class="line">Show all members of the rootset</span><br><span class="line">Show instance counts for all classes (including platform)</span><br><span class="line">Show instance counts for all classes (excluding platform)</span><br><span class="line">Show heap histogram</span><br><span class="line">Show finalizer summary</span><br><span class="line">Execute Object Query Language (OQL) query</span><br></pre></td></tr></table></figure><p>一般查看堆异常情况主要看这个两个部分： Show instance counts for all classes (excluding platform)，平台外的所有对象信息。如下图：</p><p><img src="/2019/01/01/JVM%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4/374b1b07-692f-465d-8abe-6a9a73308a02.jpg" alt></p><p>Show heap histogram 以树状图形式展示堆情况。如下图：</p><p><img src="/2019/01/01/JVM%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AJvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4/f94f68dc-b02d-4fe9-9e42-90fe379a3aa8.jpg" alt></p><p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。</p><p><strong>一般情况，会down到客户端用工具来分析</strong></p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p><h3 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br></pre></td></tr></table></figure><h3 id="option参数-2"><a href="#option参数-2" class="headerlink" title="option参数"></a>option参数</h3><blockquote><ul><li>-F : 当正常输出请求不被响应时，强制输出线程堆栈</li><li>-l : 除堆栈外，显示关于锁的附加信息</li><li>-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</li></ul></blockquote><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 11494|more</span><br><span class="line">2016-07-28 13:40:04</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.71-b01 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; daemon prio&#x3D;10 tid&#x3D;0x00007febb0002000 nid&#x3D;0x6b6f waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">&quot;http-bio-8005-exec-2&quot; daemon prio&#x3D;10 tid&#x3D;0x00007feb94028000 nid&#x3D;0x7b8c waiting on condition [0x00007fea8f56e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">        at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">        - parking to wait for  &lt;0x00000000cae09b80&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)</span><br><span class="line">        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">      .....</span><br></pre></td></tr></table></figure><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p><h3 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br></pre></td></tr></table></figure><h3 id="option参数-3"><a href="#option参数-3" class="headerlink" title="option参数"></a>option参数</h3><blockquote><ul><li>-flag : 输出指定args参数的值</li><li>-flags : 不需要args参数，输出所有JVM参数的值</li><li>-sysprops : 输出系统属性，等同于System.getProperties()</li></ul></blockquote><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flags 11494</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction&#x3D;80</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（三）：GC算法_垃圾收集器</title>
      <link href="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/08/29/GC-garbage-collection.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的 Lisp 语言，经过半个多世纪，目前已经十分成熟了。 jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.</p><a id="more"></a><h2 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h2><p>判断对象是否存活一般有两种方式：</p><p><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，<strong>无法解决对象相互循环引用的问题</strong>。</p><p><strong>可达性分析</strong>（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 -清除算法"></a>标记 -清除算法</h3><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>它的主要缺点有两个：一个是<strong>效率问题</strong>，标记和清除过程的效率都不高；另外一个是<strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致：当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/f92b4989-0e86-4154-8f6e-01929e088bfe.jpg" alt></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，<strong>只要移动堆顶指针</strong>，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/c5ecdcfd-7ac7-4696-af61-f2e2bcd61f6d.jpg" alt></p><h3 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h3><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/5049b1c7-e94b-43b4-a1ee-9dbd718d7415.jpg" alt></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在<strong>新生代</strong>中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集。而<strong>老年代</strong>中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用<strong>“标记-清理”或“标记-整理”算法</strong>来进行回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><blockquote><p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p></blockquote><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；<strong>垃圾收集的过程中会Stop The World（服务暂停）</strong></p><p>参数控制：<code>-XX:+UseSerialGC</code> 串行收集器</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/bc371962-0e75-427c-8f38-95523e42fe05.jpg" alt></p><p>ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p><p>参数控制：</p><p><code>-XX:+UseParNewGC</code> ParNew收集器<br><code>-XX:ParallelGCThreads</code> 限制线程数量</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/da1feedb-42e8-4acb-8d40-f4407fae159f.jpg" alt></p><h3 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h3><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p><p>参数控制：<code>-XX:+UseParallelGC</code> 使用Parallel收集器+ 老年代串行</p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p><p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+ 老年代并行</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。<strong>初始标记</strong>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，<strong>并发标记</strong>阶段就是进行GC Roots Tracing的过程，而<strong>重新标记</strong>阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p><p><strong>优点</strong>: 并发收集、低停顿<br><strong>缺点</strong>: 产生大量空间碎片、并发阶段会降低吞吐量</p><p>参数控制：</p><p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器<br><code>-XX:+ UseCMSCompactAtFullCollection</code> Full GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长<br><code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full GC后，进行一次碎片整理<br><code>-XX:ParallelCMSThreads</code> 设定CMS的线程数量（一般情况约等于可用CPU数量）</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/762a1303-4577-4a76-94b8-6337f585cc07.jpg" alt></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p><ol><li><p><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></li><li><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></li></ol><p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/4765894f-95c4-45e7-ad88-c6d957a94378.jpg" alt></p><p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p><p>收集步骤：</p><ul><li><p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)</p></li><li><p>2、Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p></li><li><p>3、Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p></li></ul><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/6fd7d7a7-4431-4011-bfb2-ff3a6431b3e4.jpg" alt></p><ul><li><p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p></li><li><p>5、Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p></li></ul><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/fc9cf3f5-d1a8-45e2-8e44-93f6a8a20eb3.jpg" alt></p><ul><li>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</li></ul><p><img src="/2019/01/01/JVM%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGC%E7%AE%97%E6%B3%95-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/b6d859a6-82e4-4f73-bc7e-138bedd6e777.jpg" alt></p><h2 id="常用的收集器组合"><a href="#常用的收集器组合" class="headerlink" title="常用的收集器组合"></a>常用的收集器组合</h2><table><thead><tr><th>服务器31</th><th>新生代GC策略</th><th>老年老代GC策略</th><th>说明</th></tr></thead><tbody><tr><td>组合1</td><td>Serial</td><td>Serial Old</td><td>Serial和Serial Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td></tr><tr><td>组合2</td><td>Serial</td><td>CMS+Serial Old</td><td>CMS（Concurrent Mark Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial Old策略进行GC。</td></tr><tr><td>组合3</td><td>ParNew</td><td>CMS</td><td>使用<code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项<code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew GC策略。</td></tr><tr><td>组合4</td><td>ParNew</td><td>Serial Old</td><td>使用<code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew GC策略，年老代默认使用Serial Old GC策略。</td></tr><tr><td>组合5</td><td>Parallel Scavenge</td><td>Serial Old</td><td>Parallel Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 / (应用程序运行时间 + GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td></tr><tr><td>组合6</td><td>Parallel Scavenge</td><td>Parallel Old</td><td>Parallel Old是Serial Old的并行版本</td></tr><tr><td>组合7</td><td>G1GC</td><td>G1GC</td><td><code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseG1GC</code> #开启；<code>-XX:MaxGCPauseMillis =50</code> #暂停时间目标；<code>-XX:GCPauseIntervalMillis =200</code> #暂停间隔目标；<code>-XX:+G1YoungGenSize=512m</code> #年轻代大小；<code>-XX:SurvivorRatio=6</code> #幸存区比例</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-堆的应用_如何获取Top10最热门的搜索关键词</title>
      <link href="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/"/>
      <url>/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>搜索引擎的热门搜索排行榜功能你用过吗？你知道这个功能是如何实现的吗？实际上，它的实现并不复杂。搜索引擎每天会接收大量的用户搜索请求，它会把这些用户输入的搜索关键词记录下来，然后再离线地统计分析，得到最热门的 Top 10 搜索关键词。</p><p>那请你思考下，<font color="red">假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何能快速获取到热门榜 Top 10 的搜索关键词呢？</font></p><p>这个问题就可以用堆来解决，这也是堆这种数据结构一个非常典型的应用。上一节我们讲了堆和堆排序的一些理论知识，今天我们就来讲一讲，堆这种数据结构几个非常重要的应用：优先级队列、求 Top K 和求中位数。</p><a id="more"></a><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>首先，我们来看第一个应用场景：优先级队列。</p><p>优先级队列，顾名思义，它首先应该是一个队列。我们前面讲过，队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p><p>如何实现一个优先级队列呢？方法有很多，但是用堆来实现是最直接、最高效的。这是因为，堆和优先级队列非常相似。一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><p>你可别小看这个优先级队列，它的应用场景非常多。我们后面要讲的很多数据结构和算法都要依赖它。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。不仅如此，很多语言中，都提供了优先级队列的实现，比如，Java 的 PriorityQueue，C++ 的 priority_queue 等。</p><p>只讲这些应用场景比较空泛，现在，我举两个具体的例子，让你感受一下优先级队列具体是怎么用的。</p><h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1. 合并有序小文件"></a>1. 合并有序小文件</h3><p>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p><p>整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p><p>假设，这个最小的字符串来自于 13.txt 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p><p>这里我们用数组这种数据结构，来存储从小文件中取出来的字符串。每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。有没有更加高效方法呢？</p><p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。</p><p>我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100。是不是比原来数组存储的方式高效了很多呢？</p><h3 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2. 高性能定时器"></a>2. 高性能定时器</h3><p>设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p><p><img src="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/90371146-b311-4ee5-93ef-ee5dfe956df1.jpg" alt></p><p>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p><p>针对这些问题，我们就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</p><p>这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。</p><p>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</p><p>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</p><p>这样，定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</p><h2 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h2><p>刚刚我们学习了优先级队列，我们现在来看，堆的另外一个非常重要的应用场景，那就是“求 Top K 问题”。</p><p>我把这种求 Top K 的问题抽象成两类。一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p><p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p><p>遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)。</p><p>针对动态数据求得 Top K 就是实时 Top K。怎么理解呢？我举一个例子。一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。</p><p>如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 O(nlogK)，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p><h2 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h2><p>前面我们讲了如何求 Top K 的问题，现在我们来讲下，如何求动态数据集合中的中位数。</p><p>中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 n/2 +1 个数据就是中位数（注意：假设数据是从 0 开始编号的）；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 n/2 个和第 n/2 +1 个数据，这个时候，我们可以随意取一个作为中位数，比如取两个数中靠前的那个，就是第 n/2 个数据。</p><p><img src="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/6fce4644-9c21-479d-a1d5-7894d934ad07.jpg" alt></p><p>对于一组静态数据，中位数是固定的，我们可以先排序，第 n/2 个数据就是中位数。每次询问中位数的时候，我们直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。但是，如果我们面对的是动态数据集合，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。</p><p><strong>借助堆这种数据结构，我们不用排序，就可以非常高效地实现求中位数操作。我们来看看，它是如何做到的？</strong></p><p>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p><p>也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2  个数据存储在大顶堆中，后 n/2  个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2   +1 个数据，小顶堆中就存储 n/2  个数据。</p><p><img src="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/af29cbd7-9e29-441f-9c5e-31e441500620.jpg" alt></p><p>我们前面也提到，数据是动态变化的，当新添加一个数据的时候，我们如何调整两个堆，让大顶堆中的堆顶元素继续是中位数呢？</p><p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p><p>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：如果 n 是偶数，两个堆中的数据个数都是 n/2；如果 n 是奇数，大顶堆有 n/2 +1 个数据，小顶堆有 n/2 个数据。这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p><p><img src="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/2ef2927b-2049-4e2b-a8dc-4ab980676cb3.jpg" alt></p><p>于是，我们就可以利用两个堆，一个大顶堆、一个小顶堆，实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以时间复杂度变成了 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 O(1)。</p><p>实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，原理是类似的。还记得我们在<strong>“为什么要学习数据结构与算法”</strong>里的这个问题吗？“如何快速求接口的 99% 响应时间？”我们现在就来看下，利用两个堆如何来实现。</p><p>在开始这个问题的讲解之前，我先解释一下，什么是“99% 响应时间”。</p><p>中位数的概念就是将数据从小到大排列，处于中间位置，就叫中位数，这个数据会大于等于前面 50% 的数据。99 百分位数的概念可以类比中位数，如果将一组数据从小到大排列，这个 99 百分位数就是大于前面 99% 数据的那个数据。</p><p>如果你还是不太理解，我再举个例子。假设有 100 个数据，分别是 1，2，3，……，100，那 99 百分位数就是 99，因为小于等于 99 的数占总个数的 99%。</p><p><img src="/2018/12/30/25-%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96Top10%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D/54c4f801-0157-4db3-aedd-a5236f13127b.jpg" alt></p><p>弄懂了这个概念，我们再来看 99% 响应时间。如果有 100 个接口访问请求，每个接口请求的响应时间都不同，比如 55 毫秒、100 毫秒、23 毫秒等，我们把这 100 个接口的响应时间按照从小到大排列，排在第 99 的那个数据就是 99% 响应时间，也叫 99 百分位响应时间。</p><p>我们总结一下，如果有 n 个数据，将数据从小到大排列之后，99 百分位数大约就是第 n<em>99% 个数据，同类，80 百分位数大约就是第 n</em>80% 个数据。</p><p>弄懂了这些，我们再来看如何求 99% 响应时间。</p><p>我们维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n<em>99% 个数据，小顶堆中保存 n</em>1% 个数据。大顶堆堆顶的数据就是我们要找的 99% 响应时间。</p><p>每次插入一个数据的时候，我们要判断这个数据跟大顶堆和小顶堆堆顶数据的大小关系，然后决定插入到哪个堆中。如果这个新插入的数据比大顶堆的堆顶数据小，那就插入大顶堆；如果这个新插入的数据比小顶堆的堆顶数据大，那就插入小顶堆。</p><p>但是，为了保持大顶堆中的数据占 99%，小顶堆中的数据占 1%，在每次新插入数据之后，我们都要重新计算，这个时候大顶堆和小顶堆中的数据个数，是否还符合 99:1 这个比例。如果不符合，我们就将一个堆中的数据移动到另一个堆，直到满足这个比例。移动的方法类似前面求中位数的方法，这里我就不啰嗦了。</p><p>通过这样的方法，每次插入数据，可能会涉及几个数据的堆化操作，所以时间复杂度是 O(logn)。每次求 99% 响应时间的时候，直接返回大顶堆中的堆顶数据即可，时间复杂度是 O(1)。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>学懂了上面的一些应用场景的处理思路，我想你应该能解决开篇的那个问题了吧。假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？</p><p>处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等。但是，如果我们将处理的场景限定为单机，可以使用的内存为 1GB。那这个问题该如何解决呢？</p><p>假设我们选用散列表。我们就顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，我们去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</p><p>然后，我们再根据前面讲的用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。</p><p>以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了。</p><p>不知道你发现了没有，上面的解决思路其实存在漏洞。10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 1GB 的可用内存空间，所以我们无法一次性将所有的搜索关键词加入到内存中。这个时候该怎么办呢？</p><p>我们在哈希算法那一节讲过，相同数据经过哈希算法得到的哈希值是一样的。我们可以根据哈希算法的这个特点，将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。</p><p>具体可以这样做：我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。</p><p>对这 10 亿个关键词分片之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 500MB。1GB 的内存完全可以放得下。</p><p>我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>我们今天主要讲了堆的几个重要的应用，它们分别是：优先级队列、求 Top K 问题和求中位数问题。</p><p>优先级队列是一种特殊的队列，优先级高的数据先出队，而不再像普通的队列那样，先进先出。实际上，堆就可以看作优先级队列，只是称谓不一样罢了。求 Top K 问题又可以分为针对静态数据和针对动态数据，只需要利用一个堆，就可以做到非常高效率的查询 Top K 的数据。求中位数实际上还有很多变形，比如求 99 百分位数据、90 百分位数据等，处理的思路都是一样的，即利用两个堆，一个大顶堆，一个小顶堆，随着数据的动态添加，动态调整两个堆中的数据，最后大顶堆的堆顶元素就是要求的数据。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。如果你是负责开发这个功能的工程师，你会如何来实现呢？</p><p><strong>回答1：</strong></p><p>1. 用散列表存储每个链接的点击数<br>2. 用优先级队列实现高性能定时器，在初始化和处理函数时更新插入1小时的定时器<br>3. 利用堆，将散列表中的链接根据点击次数求top10</p><p><strong>回答2：</strong></p><p>我的思路是这样子，<br>1，对每篇新闻摘要计算一个hashcode，并建立摘要与hashcode的关联关系，使用map存储，以hashCode为key，新闻摘要为值</p><p>2，按每小时一个文件的方式记录下被点击的摘要的hashCode</p><p>3，当一个小时结果后，上一个小时的文件被关闭，开始计算上一个小时的点击top10</p><p>4，将hashcode分片到多个文件中，通过对hashCode取模运算，即可将相同的hashCode分片到相同的文件中</p><p>5，针对每个文件取top10的hashCode，使用Map&lt;hashCode,int&gt;的方式，统计出所有的摘要点击次数，然后再使用小顶堆（大小为10）计算top10,</p><p>6，再针对所有分片计算一个总的top10,最后合并的逻辑也是使用小顶堆，计算top10</p><p>7，如果仅展示前一个小时的top10,计算结束</p><p>8，如果需要展示全天，需要与上一次的计算按hashCode进行合并，然后在这合并的数据中取top10</p><p>9，在展示时，将计算得到的top10的hashcode，转化为新闻摘要显示即可</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>之前遇到qq的一个面试题，一个用户的登录了qq，如果五分钟内用户没有检测到心跳包，就需要用户重新登录，登录后重新计时五分钟，是不是也用高等计时器来管理海量用户的计时登录问题，把qq号和时间五分钟当成堆节点，有心跳来就调整堆，把五分钟规定时间剩下最少的用户放在堆顶，后台线程每次扫描的时候取堆顶元素，然后计算剩余的等待时间，等规定时间到了，就取堆顶元素，判断是否为0，如果为0，就需要重新登录，一直取堆顶，直到取到不为0的元素，然后计算剩余等待时间，线程休眠，等到了规定时间再来</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-堆和堆排序_为什么说堆排序没有快速排序快</title>
      <link href="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/"/>
      <url>/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们今天讲另外一种特殊的树，“堆”（Heap）。堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。</p><p>前面我们学过快速排序，平均情况下，它的时间复杂度为 O(nlogn)。尽管这两种排序算法的时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定，但是，<font color="red">在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢？</font></p><p>现在，你可能还无法回答，甚至对问题本身还有点疑惑。没关系，带着这个问题，我们来学习今天的内容。</p><a id="more"></a><h2 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h2><p>前面我们提到，堆是一种特殊的树。我们现在就来看看，什么样的树才是堆。此处罗列了两点要求，只要满足这两点，它就是一个堆。</p><ul><li><p><strong>堆是一个完全二叉树；</strong></p></li><li><p><strong>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</strong></p></li></ul><p>分别解释一下这两点。</p><p>第一点，堆必须是一个完全二叉树。还记得我们之前讲的完全二叉树的定义吗？完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p><p>第二点，堆中的每个节点的值必须大于等于（或者小于等于）其子树中每个节点的值。实际上，我们还可以换一种说法，堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。这两种表述是等价的。</p><p>于每个节点的值都大于等于子树中每个节点值的堆，我们叫作“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫作“小顶堆”。</p><p>定义解释清楚了，你来看看，下面这几个二叉树是不是堆？</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/990c30da-9b18-4d9b-9345-8d261d9f0866.jpg" alt></p><p>其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。除此之外，从图中还可以看出来，对于同一组数据，我们可以构建多种不同形态的堆。</p><h2 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h2><p>要实现一个堆，我们先要知道，<strong>堆都支持哪些操作</strong>以及<strong>如何存储一个堆</strong>。</p><p>之前讲过，完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p><p>我画了一个用数组存储堆的例子，你可以先看下。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/385cef63-7b74-4613-a986-e6888ca5c053.jpg" alt></p><p>从图中我们可以看到，数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为 i/2 的节点。</p><p>知道了如何存储一个堆，那我们再来看看，堆上的操作有哪些呢？此处罗列了几个非常核心的操作，分别是往堆中插入一个元素和删除堆顶元素。（如果没有特殊说明，下面都是拿大顶堆来讲解）。</p><h3 id="1-往堆中插入一个元素"><a href="#1-往堆中插入一个元素" class="headerlink" title="1. 往堆中插入一个元素"></a>1. 往堆中插入一个元素</h3><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。</p><p>如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫作<strong>堆化</strong>（heapify）。</p><p>堆化实际上有两种，从下往上和从上往下。这里我先讲<strong>从下往上</strong>的堆化方法。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/b50e59dc-ed0b-419c-9af7-9fe01dd6b40a.jpg" alt></p><p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。</p><p>我这里画了一张堆化的过程分解图。我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/e3744661e038e4ae570316bc862b2c0e.jpg" alt></p><p>我将上面讲的往堆中插入数据的过程，翻译成了代码，你可以结合着一块看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Heap &#123;</span><br><span class="line">  private int[] a; &#x2F;&#x2F; 数组，从下标1开始存储数据</span><br><span class="line">  private int n;  &#x2F;&#x2F; 堆可以存储的最大数据个数</span><br><span class="line">  private int count; &#x2F;&#x2F; 堆中已经存储的数据个数</span><br><span class="line"></span><br><span class="line">  public Heap(int capacity) &#123;</span><br><span class="line">    a &#x3D; new int[capacity + 1];</span><br><span class="line">    n &#x3D; capacity;</span><br><span class="line">    count &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void insert(int data) &#123;</span><br><span class="line">    if (count &gt;&#x3D; n) return; &#x2F;&#x2F; 堆满了</span><br><span class="line">    ++count;</span><br><span class="line">    a[count] &#x3D; data;</span><br><span class="line">    int i &#x3D; count;</span><br><span class="line">    while (i&#x2F;2 &gt; 0 &amp;&amp; a[i] &gt; a[i&#x2F;2]) &#123; &#x2F;&#x2F; 自下往上堆化</span><br><span class="line">      swap(a, i, i&#x2F;2); &#x2F;&#x2F; swap()函数作用：交换下标为i和i&#x2F;2的两个元素</span><br><span class="line">      i &#x3D; i&#x2F;2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-删除堆顶元素"><a href="#2-删除堆顶元素" class="headerlink" title="2. 删除堆顶元素"></a>2. 删除堆顶元素</h3><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。</p><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p><p>这里我也画了一个分解图。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/5916121b08da6fc0636edf1fc24b5a81.jpg" alt></p><p>实际上，我们稍微改变一下思路，就可以解决这个问题。你看我画的下面这幅图。我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是<strong>从上往下的堆化方法</strong>。</p><p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/110d6f442e718f86d2a1d16095513260.jpg" alt></p><p>我把上面的删除过程同样也翻译成了代码，贴在这里，你可以结合着看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void removeMax() &#123;</span><br><span class="line">  if (count &#x3D;&#x3D; 0) return -1; &#x2F;&#x2F; 堆中没有数据</span><br><span class="line">  a[1] &#x3D; a[count];</span><br><span class="line">  --count;</span><br><span class="line">  heapify(a, count, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void heapify(int[] a, int n, int i) &#123; &#x2F;&#x2F; 自上往下堆化</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    int maxPos &#x3D; i;</span><br><span class="line">    if (i*2 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i*2]) maxPos &#x3D; i*2;</span><br><span class="line">    if (i*2+1 &lt;&#x3D; n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos &#x3D; i*2+1;</span><br><span class="line">    if (maxPos &#x3D;&#x3D; i) break;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i &#x3D; maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，一个包含 n 个节点的完全二叉树，树的高度不会超过 log<sub>2</sub>n。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 O(logn)。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p><h2 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h2><p>前面我们讲过好几种排序算法，我们再来回忆一下，有时间复杂度是 O(n<sup>2</sup>) 的冒泡排序、插入排序、选择排序，有时间复杂度是 O(nlogn) 的归并排序、快速排序，还有线性排序。</p><p>这里我们借助于堆这种数据结构实现的排序算法，就叫作堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且它还是原地排序算法。如此优秀，它是怎么做到的呢？</p><p>我们可以把堆排序的过程大致分解成两个大的步骤，<strong>建堆</strong>和<strong>排序</strong>。</p><h3 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1. 建堆"></a>1. 建堆</h3><p>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。建堆的过程，有两种思路。</p><p>第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</p><p>第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</p><p>我举了一个例子，并且画了一个第二种实现思路的建堆分解步骤图，你可以看下。因为叶子节点往下堆化只能自己跟自己比较，所以我们直接从第一个非叶子节点开始，依次堆化就行了。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt></p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/aabb8d15b1b92d5e040895589c60419d.jpg" alt></p><p>对于程序员来说，看代码可能更好理解一些，所以，我将第二种实现思路翻译成了代码，你可以看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void buildHeap(int[] a, int n) &#123;</span><br><span class="line">  for (int i &#x3D; n&#x2F;2; i &gt;&#x3D; 1; --i) &#123;</span><br><span class="line">    heapify(a, n, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void heapify(int[] a, int n, int i) &#123;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    int maxPos &#x3D; i;</span><br><span class="line">    if (i*2 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i*2]) maxPos &#x3D; i*2;</span><br><span class="line">    if (i*2+1 &lt;&#x3D; n &amp;&amp; a[maxPos] &lt; a[i*2+1]) maxPos &#x3D; i*2+1;</span><br><span class="line">    if (maxPos &#x3D;&#x3D; i) break;</span><br><span class="line">    swap(a, i, maxPos);</span><br><span class="line">    i &#x3D; maxPos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，在这段代码中，我们对下标从 n/2 开始到 1 的数据进行堆化，下标是 n/2+1 到 n 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 n/2​+1 到 n 的节点都是叶子节点。</p><p>现在，我们来看，建堆操作的时间复杂度是多少呢？</p><p>每个节点堆化的时间复杂度是 O(logn)，那  n/2+1 个节点堆化的总时间复杂度是不是就是 O(nlogn) 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是 O(n)。我带你推导一下。</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。</p><p>我把每一层的节点个数和对应的高度画了出来，你可以看看。我们只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/96250546-fac4-4ab9-831c-6ff477a87f13.jpg" alt></p><p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/815a13fe-6095-44da-b026-697b3e54d18e.jpg" alt></p><p>这个公式的求解稍微有点技巧，不过我们高中应该都学过：把公式左右都乘以 2，就得到另一个公式 S2。我们将 S2 错位对齐，并且用 S2 减去 S1，可以得到 S。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/d1a22a0d-1a69-447e-a9d1-0572bb9f4040.jpg" alt></p><p>S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算，最终的结果就是下面图中画的这个样子。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/ecb56aa1-5d59-46e6-ac1e-7fdc9eb64e70.jpg" alt></p><p>因为 h=log<sub>2</sub>n，代入公式 S，就能得到 S=O(n)，所以，建堆的时间复杂度就是 O(n)。</p><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h3><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</p><p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/23958f889ca48dbb8373f521708408d1.jpg" alt></p><p>堆排序的过程，我也翻译成了代码。结合着代码看，你理解起来应该会更加容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n表示数据的个数，数组a中的数据从下标1到n的位置。</span><br><span class="line">public static void sort(int[] a, int n) &#123;</span><br><span class="line">  buildHeap(a, n);</span><br><span class="line">  int k &#x3D; n;</span><br><span class="line">  while (k &gt; 1) &#123;</span><br><span class="line">    swap(a, 1, k);</span><br><span class="line">    --k;</span><br><span class="line">    heapify(a, k, 1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们再来分析一下堆排序的时间复杂度、空间复杂度以及稳定性。</p><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)，所以，堆排序整体的时间复杂度是 O(nlogn)。</p><p>堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>今天的内容到此就讲完了。我这里要稍微解释一下，在前面的讲解以及代码中，我都假设，堆中的数据是从数组下标为 1 的位置开始存储。那如果从 0 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，计算子节点和父节点的下标的公式改变了。</p><p>如果节点的下标是 i，那左子节点的下标就是 2∗i+1，右子节点的下标就是 2∗i+2，父节点的下标就是 (i−1)/2。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>现在我们来看开篇的问题，在实际开发中，为什么快速排序要比堆排序性能好？</p><p>我觉得主要有两方面的原因。</p><h3 id="第一点，堆排序数据访问的方式没有快速排序友好。"><a href="#第一点，堆排序数据访问的方式没有快速排序友好。" class="headerlink" title="第一点，堆排序数据访问的方式没有快速排序友好。"></a>第一点，堆排序数据访问的方式没有快速排序友好。</h3><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/8037cd36-e989-4924-95ae-ddd1a5a9fe7f.jpg" alt></p><h3 id="第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。"><a href="#第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。" class="headerlink" title="第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。"></a>第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</h3><p>我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。</p><p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p><p><img src="/2018/12/29/24-%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B2%A1%E6%9C%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%BF%AB/722bec97-6d62-4691-9db7-409212d2bee9.jpg" alt></p><p>对于第二点，你可以自己做个试验看下。我们用一个记录交换次数的变量，在代码中，每次交换的时候，我们就对这个变量加一，排序完成之后，这个变量的值就是总的数据交换次数。这样你就能很直观地理解我刚刚说的，堆排序比快速排序交换次数多。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了堆这种数据结构。堆是一种完全二叉树。它最大的特性是：每个节点的值都大于等于（或小于等于）其子树节点的值。因此，堆被分成了两类，大顶堆和小顶堆。</p><p>堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。</p><p>除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 n/2 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n/2 +1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？</p><p>2 我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？</p><p><strong>回答：</strong></p><p>1 使用数组存储表示完全二叉树时，从数组下标为1开始存储数据，数组下标为i的节点，左子节点为2i, 右子节点为2i + 1. 这个结论很重要（可以用数学归纳法证明)，将此结论记为『原理1』，以下证明会用到这个原理。</p><p>为什么，对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点？ 使用反证法证明即可：</p><p>如果下标为n/2 + 1的节点不是叶子节点，即它存在子节点，按照『原理1』，它的左子节点为：2(n/2 + 1) = n + 2，大家明显可以看出，这个数字已经大于n + 1，超出了实现完全二叉树所用数组的大小（数组下标从1开始记录数据，对于n个节点来说，数组大小是n + 1），左子节点都已经超出了数组容量，更何况右子节点。以此类推，很容易得出：下标大于n/2 + 1的节点肯定都是也叶子节点了，故而得出结论：对于完全二叉树来说，下标从n/2 + 1 到 n的节点都是叶子节点</p><p>备注下：用数组存储表示完全二叉树时，也可以从下标为0开始，只是这样做的话，计算左子节点时，会多一次加法运算</p><hr><p>2 堆的应用除了堆排以外，还有如下一些应用：</p><p>从大数量级数据中筛选出top n 条数据； 比如：从几十亿条订单日志中筛选出金额靠前的1000条数据</p><p>在一些场景中，会根据不同优先级来处理网络请求，此时也可以用到优先队列(用堆实现的数据结构)；比如：网络框架Volley就用了Java中PriorityBlockingQueue，当然它是线程安全的</p><p>可以用堆来实现多路归并，从而实现有序，leetcode上也有相关的一题：Merge K Sorted Lists</p><hr><p>1.topK</p><p>2.流里面的中值</p><p>3.流里面的中位数</p><p><strong>第二种回答：</strong></p><p>思考题1证明<br>结论：对于完全二叉树来说，下标从(n/2)+1到n都是叶子节点<br>证明：<br>假设堆有n个节点<br>假设满二叉树有h层 则满二叉树的总节点数 2^0+2^1…+2^(h-2)+2^(h-1)=(2^h)-1&gt; n n为h层完全二叉树节点数<br>堆为完全二叉树，相同高度，完全二叉树总结点数小于满二叉树节点数，即n&lt;(2^h)-1， 即(2^h)&gt;n+1 —–①<br>完全二叉树1到h-1层节点的数量总和： 2^0+2^1…+2^(h-2)=(2^(h-1))-1=(2^h)/2 -1 —–②<br>如果数组的第0位也存储数据，由②可知，完全二叉树的第h层开始的节点的下标为i=(2^h)/2 -1，由①，i&gt;((n+1)/2)-1=(n/2)+1<br>结论1：如果数组的第0位也存储数据，完全二叉树的节点下标至少开始于(n/2)+1<br>如果数组的第0位不存储数据，则由②可知，完全二叉树的第h层开始的节点的下标为j=(2^h)/2，由①，j&gt;(n+1)/2=(n/2)+2<br>结论2：如果数组的第0位不存储数据，完全二叉树的节点下标至少开始于(n/2)+2<br>综上，堆（完全二叉树）的叶子节点的下标范围从(n/2)+1到n-1或从(n/2)+2到n，也即堆的叶子节点下标从(n/2)+1到n</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-递归树_如何借助树来求解递归算法的时间复杂度</title>
      <link href="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天，我们来讲树这种数据结构的一种特殊应用，递归树。</p><p>我们都知道，递归代码的时间复杂度分析起来很麻烦。我们在前文讲过，如何利用递推公式，求解归并排序、快速排序的时间复杂度，但是，有些情况，比如快排的平均时间复杂度的分析，用递推公式的话，会涉及非常复杂的数学推导。</p><p>除了用递推公式这种比较复杂的分析方法，有没有更简单的方法呢？今天，我们就来学习另外一种方法，<strong>借助递归树来分析递归算法的时间复杂度</strong>。</p><a id="more"></a><h2 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h2><p>我们前面讲过，递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。</p><p>如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作<strong>递归树</strong>。我这里画了一棵斐波那契数列的递归树，你可以看看。节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/f7a343d5-ab31-43ff-a63c-6c2606cffed8.jpg" alt></p><p>通过这个例子，你对递归树的样子应该有个感性的认识了，看起来并不复杂。现在，我们就来看，<strong>如何用递归树来求解时间复杂度</strong>。</p><p>归并排序算法你还记得吧？它的递归实现代码非常简洁。现在我们就借助归并排序来看看，如何用递归树，来分析递归代码的时间复杂度。</p><p>归并排序的原理我就不详细介绍了，如果你忘记了，可以回看一下它的内容。归并排序每次会将数据规模一分为二。我们把归并排序画成递归树，就是下面这个样子：</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/03af0380-4d2f-48fc-8014-7da65e712bc2.jpg" alt></p><p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n。</p><p>现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n∗h)。</p><p>从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。我们前两节中讲到，满二叉树的高度大约是 log<sub>2</sub>n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p><p>利用递归树的时间复杂度分析方法并不难理解，关键还是在实战，所以，接下来会通过三个实际的递归算法，带你实战一下递归的复杂度分析。学完这节课之后，你应该能真正掌握递归代码的复杂度分析。</p><h2 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h2><p>在用递归树推导之前，我们先来回忆一下用递推公式的分析方法。你可以回想一下，当时，我们为什么说用递推公式来求解平均时间复杂度非常复杂？</p><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(n/2)+n，很容易就能推导出时间复杂度是 O(nlogn)。但是，我们并不可能每次分区都这么幸运，正好一分为二。</p><p>我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n/10)+T(9n/10)+n。</p><p>这个公式可以推导出时间复杂度，但是推导过程非常复杂。那我们来看看，<strong>用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢？</strong></p><p>我们还是取 k 等于 9，也就是说，每次分区都很不平均，一个分区是另一个分区的 9 倍。如果我们把递归分解的过程画成递归树，就是下面这个样子：</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/ff52e021-8a15-4bb7-8e72-bb1870f6b5ef.jpg" alt></p><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h∗n ，也就是说，时间复杂度就是 O(h∗n)。</p><p>因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？</p><p>我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，递归树中最短的一个路径每次都乘以 1/10​，最长的一个路径每次都乘以 9/10。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 log<sub>10</sub>n，最长的路径是 log<sub>10/9</sub>n。</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/e21261eb-d1bc-42ea-88c5-16de02c496c7.jpg" alt></p><p>所以，遍历数据的个数总和就介于 nlog<sub>10</sub>n 和 nlog<sub>10/9</sub>n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。</p><p>刚刚我们假设 k=9，那如果 k=99，也就是说，每次分区极其不平均，两个区间大小是 1:99，这个时候的时间复杂度是多少呢？</p><p>我们可以类比上面 k=9 的分析过程。当 k=99 的时候，树的最短路径就是 log<sub>100</sub>n，最长路径是 log<sub>100/99</sub>n，所以总遍历数据个数介于 nlog<sub>100</sub>n 和 nlog<sub>100/99</sub>n 之间。尽管底数变了，但是时间复杂度也仍然是 O(nlogn)。</p><p>也就是说，对于 k 等于 9，99，甚至是 999，9999……，只要 k 的值不随 n 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)。</p><h2 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h2><p>在递归那一节中，我们举了一个跨台阶的例子，你还记得吗？那个例子实际上就是一个斐波那契数列。为了方便你回忆，我把它的代码实现贴在这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">  return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一段代码的时间复杂度是多少呢？你可以先试着分析一下，然后再来看，我是怎么利用递归树来分析的。</p><p>我们先把上面的递归代码画成递归树，就是下面这个样子：</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/8aeff7c8-b639-426d-8ac6-05debf7cf0b0.jpg" alt></p><p>这棵递归树的高度是多少呢？</p><p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2。</p><p>每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2<sup>2</sup>。依次类推，第 k 层的时间消耗就是 2<sup>k−1</sup>，那整个算法的总的时间消耗就是每一层时间消耗之和。</p><p>如果路径长度都为 n，那这个总和就是 2<sup>n</sup>−1。</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/06c7fab9-fa66-4dcb-b888-03897b60c95b.jpg" alt></p><p>如果路径长度都是 n/2 ，那整个算法的总的时间消耗就是 2<sup> n/2</sup>−1。</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/af664ca8-450d-45d1-94d4-6599b0d92a2e.jpg" alt></p><p>所以，这个算法的时间复杂度就介于 O(2<sup>n</sup>) 和 O(2<sup>n/2</sup>) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了上面算法的时间复杂度是指数级的，非常高。</p><h2 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h2><p>前面两个复杂度分析都比较简单，我们再来看个稍微复杂的。</p><p>我们在高中的时候都学过排列组合。“如何把 n 个数据的所有排列都找出来”，这就是全排列的问题。</p><p>我来举个例子。比如，1，2，3 这样 3 个数据，有下面这几种不同的排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1, 2, 3</span><br><span class="line">1, 3, 2</span><br><span class="line">2, 1, 3</span><br><span class="line">2, 3, 1</span><br><span class="line">3, 1, 2</span><br><span class="line">3, 2, 1</span><br></pre></td></tr></table></figure><p>如何编程打印一组数据的所有排列呢？这里就可以用递归来实现。</p><p>如果我们确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题。</p><p>如果我们把它写成递推公式，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设数组中存储的是1，2， 3...n。</span><br><span class="line">        </span><br><span class="line">f(1,2,...n) &#x3D; &#123;最后一位是1, f(n-1)&#125; + &#123;最后一位是2, f(n-1)&#125; +...+&#123;最后一位是n, f(n-1)&#125;。</span><br></pre></td></tr></table></figure><p>如果我们把递推公式改写成代码，就是下面这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用方式：</span><br><span class="line">&#x2F;&#x2F; int[]a &#x3D; a&#x3D;&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span><br><span class="line">&#x2F;&#x2F; k表示要处理的子数组的数据个数</span><br><span class="line">public void printPermutations(int[] data, int n, int k) &#123;</span><br><span class="line">  if (k &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">      System.out.print(data[i] + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 0; i &lt; k; ++i) &#123;</span><br><span class="line">    int tmp &#x3D; data[i];</span><br><span class="line">    data[i] &#x3D; data[k-1];</span><br><span class="line">    data[k-1] &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">    printPermutations(data, n, k - 1);</span><br><span class="line"></span><br><span class="line">    tmp &#x3D; data[i];</span><br><span class="line">    data[i] &#x3D; data[k-1];</span><br><span class="line">    data[k-1] &#x3D; tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用我前面讲的递归树分析方法，这个递归代码的时间复杂度会比较难分析。现在，我们来看下，如何借助递归树，轻松分析出这个代码的时间复杂度。</p><p>首先，我们还是画出递归树。不过，现在的递归树已经不是标准的二叉树了。</p><p><img src="/2018/12/27/23-%E9%80%92%E5%BD%92%E6%A0%91-%E5%A6%82%E4%BD%95%E5%80%9F%E5%8A%A9%E6%A0%91%E6%9D%A5%E6%B1%82%E8%A7%A3%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1eb000de-2ce5-45dc-beba-8f938cf980ac.jpg" alt></p><p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n∗(n−1)。第三层有 n∗(n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n∗(n−1)∗(n−2)。</p><p>以此类推，第 k 层总的交换次数就是 n∗(n−1)∗(n−2)∗…∗(n−k+1)。最后一层的交换次数就是 n∗(n−1)∗(n−2)∗…∗2∗1。每一层的交换次数之和就是总的交换次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n + n*(n-1) + n*(n-1)*(n-2) +... + n*(n-1)*(n-2)*...*2*1</span><br></pre></td></tr></table></figure><p>这个公式的求和比较复杂，我们看最后一个数，n∗(n−1)∗(n−2)∗…∗2∗1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n∗n!，也就是说，全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n∗n!)，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p><p>这里我稍微说下，掌握分析的方法很重要，思路是重点，不要纠结于精确的时间复杂度到底是多少。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天，我们用递归树分析了递归代码的时间复杂度。加上我们在排序那一节讲到的递推公式的时间复杂度分析方法，我们现在已经学习了两种递归代码的时间复杂度分析方法了。</p><p>有些代码比较适合用递推公式来分析，比如归并排序的时间复杂度、快速排序的最好情况时间复杂度；有些比较适合采用递归树来分析，比如快速排序的平均时间复杂度。而有些可能两个都不怎么适合使用，比如二叉树的递归前中后序遍历。</p><p>时间复杂度分析的理论知识并不多，也不复杂，掌握起来也不难，但是，在我们平时的工作、学习中，面对的代码千差万别，能够灵活应用学到的复杂度分析方法，来分析现有的代码，并不是件简单的事情，所以，你平时要多实战、多分析，只有这样，面对任何代码的时间复杂度分析，你才能做到游刃有余、毫不畏惧。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 个细胞的生命周期是 3 小时，1 小时分裂一次。求 n 小时后，容器内有多少细胞？请你用已经学过的递归时间复杂度的分析方法，分析一下这个递归问题的时间复杂度。</p><p><strong>回答：</strong></p><p>假设细胞到了第三个小时是先分裂完再死亡，那么递推公式就应该是：<br>f(n) = f(n-1)*2 - f(n-3)<br>一次乘法和一次减法一起看作一次基本操作消耗，那么情况和斐波那契数列很像。<br>最高的树应该有n层， 最短的是n/3层，每层操作数都是指数增长。<br>那么时间复杂度应该是在O(2^n)量级的。</p><p>即：</p><p>假设细胞先分裂再死亡，即，每个细胞分裂三次后死亡（存活三个小时）。</p><p>n 从第 0 个小时开始，</p><p>n = 0，f(0) = 1</p><p>n = 1，f(1) = 2*f(1)</p><p>n = 2，f(2) = 2*f(1)</p><p>n = 3，f(3) = 2*f(2) - f(0) ，减去存活了三个小时的细胞个数。</p><p>n = 4，f(4) = 2*f(3) - f(1)，减去存活了三个小时的细胞个数。</p><p>以此类推：</p><p>f(n) = 2*f(n-1) - f(n-3)，减去存活了三个小时的细胞个数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-红黑树下_实现红黑树的技巧</title>
      <link href="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://blog.csdn.net/wan198809/article/details/48602921" target="_blank" rel="noopener">参考 算法导论-红黑树</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>红黑树是一个让我又爱又恨的数据结构，“爱”是因为它稳定、高效的性能，“恨”是因为实现起来实在太难了。我今天讲的红黑树的实现，对于基础不太好的同学，理解起来可能会有些困难。但是，我觉得没必要去死磕它。</p><p>我为什么这么说呢？因为，即便你将左右旋背得滚瓜烂熟，我保证你过不几天就忘光了。因为，学习红黑树的代码实现，对于你平时做项目开发没有太大帮助。对于绝大部分开发工程师来说，这辈子你可能都用不着亲手写一个红黑树。除此之外，它对于算法面试也几乎没什么用，一般情况下，靠谱的面试官也不会让你手写红黑树的。</p><p>如果你对数据结构和算法很感兴趣，想要开拓眼界、训练思维，我还是很推荐你看一看这节的内容。但是如果学完今天的内容你还觉得懵懵懂懂的话，也不要纠结。我们要有的放矢去学习。你先把平时要用的、基础的东西都搞会了，如果有余力了，再来深入地研究这节内容。</p><p>好，我们现在就进入正式的内容。<font color="red">上一节，我们讲到红黑树定义的时候，提到红黑树的叶子节点都是黑色的空节点。当时我只是粗略地解释了，这是为了代码实现方便，那更加确切的原因是什么呢？</font> 我们这节就来说一说。</p><a id="more"></a><h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>不知道你有没有玩过魔方？其实魔方的复原解法是有固定算法的：遇到哪几面是什么样子，对应就怎么转几下。你只要跟着这个复原步骤，就肯定能将魔方复原。</p><p>实际上，红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，我们就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。</p><p>还记得我们前面讲过的红黑树的定义吗？今天的内容里，我们会频繁用到它，所以，我们现在再来回顾一下。一棵合格的红黑树需要满足这样几个要求：</p><ul><li><p><strong>根节点是黑色的</strong></p></li><li><p><strong>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据</strong></p></li><li><p><strong>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</strong></p></li><li><p><strong>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</strong></p></li></ul><p>在插入、删除节点的过程中，第三、第四点要求可能会被破坏，而我们今天要讲的“平衡调整”，实际上就是要把被破坏的第三、第四点恢复过来。</p><p>在正式开始之前，我先介绍两个非常重要的操作，<strong>左旋（rotate left）、右旋（rotate right）</strong>。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的全称估计你已经猜到了，就叫<strong>围绕某个节点的右旋</strong>。</p><p>我们下面的平衡调整中，会一直用到这两个操作，所以我这里画了个示意图，帮助你彻底理解这两个操作。图中的 a，b，r 表示子树，可以为空。</p><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/0e37e597737012593a93105ebbf4591e.jpg" alt></p><p>前面我说了，红黑树的插入、删除操作会破坏红黑树的定义，具体来说就是会破坏红黑树的平衡，所以，我们现在就来看下，红黑树在插入、删除数据之后，如何调整平衡，继续当一棵合格的红黑树的。</p><h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p>首先，我们来看插入操作。</p><p><strong>红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。</strong>所以，关于插入操作的平衡调整，有这样两种特殊情况，但是也都非常好处理。</p><ul><li><p><strong>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义</strong></p></li><li><p><strong>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了</strong></p></li></ul><p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，调整的过程包含两种基础的操作：<strong>左右旋转</strong>和<strong>改变颜色</strong>。</p><p>红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫作<strong>关注节点</strong>。关注节点会随着不停地迭代处理，而不断发生变化。最开始的关注节点就是新插入的节点。</p><p>新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况。我们只需要根据每种情况的特点，不停地调整，就可以让红黑树继续符合定义，也就是继续保持平衡。</p><p>我们下面依次来看每种情况的调整过程。提醒你注意下，为了简化描述，我把父节点的兄弟节点叫作叔叔节点，父节点的父节点叫作祖父节点。</p><p><strong>CASE 1：如果关注节点是 a，它的叔叔节点 d 是红色</strong>，我们就依次执行下面的操作：</p><ul><li><p>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</p></li><li><p>将关注节点 a 的祖父节点 c 的颜色设置成红色；</p></li><li><p>关注节点变成 a 的祖父节点 c；</p></li><li><p>跳到 CASE 2 或者 CASE 3。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/3753e588-3096-46f2-bb90-85764e436668.jpg" alt></p><p><strong>CASE 2：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</strong>，我们就依次执行下面的操作：</p><ul><li><p>关注节点变成节点 a 的父节点 b；</p></li><li><p>围绕新的关注节点b 左旋；</p></li><li><p>跳到 CASE 3</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/c862156c-c7be-4b75-bfd4-84896a731aee.jpg" alt></p><p><strong>CASE 3：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</strong>，我们就依次执行下面的操作：</p><ul><li><p>围绕关注节点 a 的祖父节点 c 右旋；</p></li><li><p>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换。</p></li><li><p>调整结束。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/8376175c-35be-41c1-88d6-3bcde01bd35b.jpg" alt></p><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>红黑树插入操作的平衡调整还不是很难，但是它的删除操作的平衡调整相对就要难多了。不过原理都是类似的，我们依旧只需要根据关注节点与周围节点的排布特点，按照一定的规则去调整就行了。</p><p>删除操作的平衡调整分为两步，第一步是<strong>针对删除节点初步调整</strong>。初步调整只是保证整棵红黑树在一个节点删除之后，仍然满足最后一条定义的要求，也就是说，每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；第二步是<strong>针对关注节点进行二次调整</strong>，让它满足红黑树的第三条定义，即不存在相邻的两个红色节点。</p><h3 id="1-针对删除节点初步调整"><a href="#1-针对删除节点初步调整" class="headerlink" title="1. 针对删除节点初步调整"></a>1. 针对删除节点初步调整</h3><p>这里需要注意一下，红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红 - 黑”或者“黑 - 黑”。如果一个节点被标记为了“黑 - 黑”，那在计算黑色节点个数的时候，要算成两个黑色节点。</p><p>在下面的讲解中，如果一个节点既可以是红色，也可以是黑色，在画图的时候，我会用一半红色一半黑色来表示。如果一个节点是“红 - 黑”或者“黑 - 黑”，我会用左上角的一个小黑点来表示额外的黑色。</p><p><strong>CASE 1：如果要删除的节点是 a，它只有一个子节点 b</strong>，那我们就依次进行下面的操作：</p><ul><li><p>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</p></li><li><p>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</p></li><li><p>调整结束，不需要进行二次调整。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/88a433ef-876a-4c4d-ae09-feb39f70d6c1.jpg" alt></p><p><strong>CASE 2：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</strong>。我们就依次进行下面的操作：</p><ul><li><p>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</p></li><li><p>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</p></li><li><p>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；</p></li><li><p>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/59102e7a-6072-483a-be4c-0433fe0526f5.jpg" alt></p><p><strong>CASE 3：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</strong>，我们就依次进行下面的操作：</p><ul><li><p>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；</p></li><li><p>将节点 a 替换成后继节点 d；</p></li><li><p>把节点 d 的颜色设置为跟节点 a 相同的颜色；</p></li><li><p>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；</p></li><li><p>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/8c84c290-3001-4f00-b320-fa7ddb52b68e.jpg" alt></p><h3 id="2-针对关注节点进行二次调整"><a href="#2-针对关注节点进行二次调整" class="headerlink" title="2. 针对关注节点进行二次调整"></a>2. 针对关注节点进行二次调整</h3><p>经过初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点。</p><p><strong>CASE 1：如果关注节点是 a，它的兄弟节点 c 是红色的</strong>，我们就依次进行下面的操作：</p><ul><li><p>围绕关注节点 a 的父节点 b 左旋；</p></li><li><p>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</p></li><li><p>关注节点不变；</p></li><li><p>继续从四种情况中选择适合的规则来调整。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/bc29ea9c-d155-43af-9a1d-101399c617a7.jpg" alt></p><p><strong>CASE 2：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</strong>，我们就依次进行下面的操作：</p><ul><li><p>将关注节点 a 的兄弟节点 c 的颜色变成红色；</p></li><li><p>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</p></li><li><p>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；</p></li><li><p>关注节点从 a 变成其父节点 b；</p></li><li><p>继续从四种情况中选择符合的规则来调整。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/591fc4b3-7a4c-4d62-9468-0bb4a875faf8.jpg" alt></p><p><strong>CASE 3：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</strong>，我们就依次进行下面的操作：</p><ul><li><p>围绕关注节点 a 的兄弟节点 c 右旋；</p></li><li><p>节点 c 和节点 d 交换颜色；</p></li><li><p>关注节点不变；</p></li><li><p>转到 CASE 4，继续调整。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/d607c22a-d25d-4da7-8f87-22b34a0bcf7f.jpg" alt></p><p><strong>CASE 4：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</strong>，我们就依次进行下面的操作：</p><ul><li><p>围绕关注节点 a 的父节点 b 左旋；</p></li><li><p>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</p></li><li><p>将关注节点 a 的父节点 b 的颜色设置为黑色；</p></li><li><p>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</p></li><li><p>将关注节点 a 的叔叔节点 e 设置为黑色；</p></li><li><p>调整结束。</p></li></ul><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/b97ceab8-e306-4975-ae62-f9f18b1c9694.jpg" alt></p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>红黑树的平衡调整就讲完了，现在，你能回答开篇的问题了吗？为什么红黑树的定义中，要求叶子节点是黑色的空节点？</p><p>要我说，之所以有这么奇怪的要求，其实就是为了实现起来方便。只要满足这一条要求，那在任何时刻，红黑树的平衡操作都可以归结为我们刚刚讲的那几种情况。</p><p>还是有点不好理解，我通过一个例子来解释一下。假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”，我们往一棵红黑树中插入一个数据，新插入节点的父节点也是红色的，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。那我们应该如何调整呢？</p><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/9b28b72a-97ac-451e-a3ba-9b08ce9ecb4c.jpg" alt></p><p>你会发现，这个时候，我们前面讲的插入时，三种情况下的平衡调整规则，没有一种是适用的。但是，如果我们把黑色的空节点都给它加上，变成下面这样，你会发现，它满足 CASE 2 了。</p><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/55fb172e-f086-46b5-b258-fd106a193b73.jpg" alt></p><p>你可能会说，你可以调整一下平衡调整规则啊。比如把 CASE 2 改为“如果关注节点 a 的叔叔节点 b 是黑色或者不存在，a 是父节点的右子节点，就进行某某操作”。当然可以，但是这样的话规则就没有原来简洁了。</p><p>你可能还会说，这样给红黑树添加黑色的空的叶子节点，会不会比较浪费存储空间呢？答案是不会的。虽然我们在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，在具体实现的时候，我们只需要像下面这样，共用一个黑色的、空的叶子节点就行了。</p><p><img src="/2018/12/25/22-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8B-%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8A%80%E5%B7%A7/379c804d-8635-4685-ab24-a7474ce6457e.jpg" alt></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>红黑树一向都很难学”，有这种想法的人很多。但是我感觉，其实主要原因是，很多人试图去记忆它的平衡调整策略。实际上，你只需要能看懂我讲的过程，没有知识盲点，就算是掌握了这部分内容了。毕竟实际的软件开发并不是闭卷考试，当你真的需要实现一个红黑树的时候，可以对照着我讲的步骤，一点一点去实现。</p><p>现在，我就来总结一下，如何比较轻松地看懂我今天讲的操作过程。</p><p>第一点，<strong>把红黑树的平衡调整的过程比作魔方复原，不要过于深究这个算法的正确性</strong>。你只需要明白，只要按照固定的操作步骤，保持插入、删除的过程，不破坏平衡树的定义就行了。</p><p>第二点，<strong>找准关注节点，不要搞丢、搞错关注节点</strong>。因为每种操作规则，都是基于关注节点来做的，只有弄对了关注节点，才能对应到正确的操作规则中。在迭代的调整过程中，关注节点在不停地改变，所以，这个过程一定要注意，不要弄丢了关注节点。</p><p>第三点，<strong>插入操作的平衡调整比较简单，但是删除操作就比较复杂</strong>。针对删除操作，我们有两次调整，第一次是针对要删除的节点做初步调整，让调整后的红黑树继续满足第四条定义，“每个节点到可达叶子节点的路径都包含相同个数的黑色节点”。但是这个时候，第三条定义就不满足了，有可能会存在两个红色节点相邻的情况。第二次调整就是解决这个问题，让红黑树不存在相邻的红色节点。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>人生要学会放弃一些东西</strong></p><p>一：我说的case3的情况是表示老师的画的那个图，case3图的例子根节点到左边叶子节点只经过2个黑色节点，到右边叶子节点却经过了3个黑色节点。</p><p>二：我这里就大概说下吧（一家之言，自己的一点经验，论）：<br>1.左旋右旋这个，个人还是认为要画图，不画图我自己也写不出那个代码……哈哈。</p><p>2.说到插入删除的算法，我说用到了递推，就比如插入的CASE1的情况，CASE1的处理之后，关注节点从本身变成了他的祖父节点（红色节点），这就是往根节点递推。不过我认为CASE1处理过一次之后，不一定会进入case2或者case3，是有可能还在case1的。</p><p>换句话说，就是可以在case1的情况下，一直往根节点走，因为当前节点永远是红色，所以在最后要把根节点涂黑。同时，只要进入到case2,case3的情况，就是变成平衡二叉树的单旋和双旋的情况，双旋的处理逻辑就是把双旋变成单旋（比如先右后左旋就是把树变成“左撇子”）。这个就变成了单左旋能一步到位处理的平衡了，这个就是归纳。把未知情况转化为已知，如果我没有记错的话，数学归纳法的核心思想就是递推和归纳。</p><p>3.其实我们只要记住，除了关注的节点所在的子树，其他的子树本身都是一颗红黑树，他们是满足红黑树的所有特征的。当关注节点往根节点递推时，这个时候关注节点的子树也已经满足了红黑树的定义，我们就不用再去特别关注子树的特征。只要注意关注节点往上的部分。这样就能把问题简化，思考的时候思路会清晰一些。</p><p>4.再说到删除算法，我看到人没理解为什么要红-黑，黑-黑节点的出现。这里我的看法是，红黑树最不好控制的其实是最后一个的性质4（每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点），因为你永远不知道别的子树到底有多少个黑色节点。这里加入红-黑，黑-黑节点就可以控制红黑树满足性质4，到时候要恢复颜色，只要去掉多余的黑色即可。</p><p>接下来的处理思路就是要满足：1.每个节点不是红的就是黑的，2.相邻节点不能是红的。这个思路计时变复杂为简单。</p><p>删除的case1情况，并没有真正处理，而且为了进入接下来的case2,case3,case4，这里又是之前说到的归纳思想。case2的情况又是一个递推思路，关注节点往根节点递推，让其左右子树都满足红黑树的定义。因为往上推，右子树多了一个黑色节点，就把关注节点的兄弟节点变红，使其满足性质4.</p><p>删除的case3是为了进入case4，提前变色的原因和case2是一样的，都是为了满足性质4。同样是归纳推理的思路。都要记住一点，各种case下的其他子树节点都满足红黑树的定义，需要分类讨论的，都在这几种case情况中了。</p><p>4.最后的建议，其实说了这么多，很多的表达都不太清楚，但是个人感觉，数学基础好的同学，理解红黑树会好一些，学习的时候多画画图，人对图形的敏感肯定比文字高，另外的就是大家可以去看看源码，本人是做java开发的，jdk1.8的treemap就是用红黑树实现的，跟着源码多看看，跟着百度上的教程思考，动笔画画图，都能理解的。我自己看jdk源码的也是看了将近两个月才大概明白（因为也在上班，只有晚上有一些时间来看看代码）。学习的过程中要耐心，学习红黑树本身也不是为了“默写”，而是去学习思想，锻炼思维，复杂问题简单化，新问题转化为已解决过的问题等等。其实说到最后，都是用到了数学的思维，这些思维都会在潜移默化中影响到自己。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-红黑树上_为什么工程中都用红黑树这种二叉树</title>
      <link href="/2018/12/23/21-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%83%BD%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/12/23/21-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%83%BD%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上两节，我们依次讲了树、二叉树、二叉查找树。二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。</p><p>不过，二叉查找树在频繁的动态更新过程中，可能会出现树的高度远大于 log2n 的情况，从而导致各个操作的效率下降。极端情况下，二叉树会退化为链表，时间复杂度会退化到 O(n)。我上一节说了，要解决这个复杂度退化的问题，我们需要设计一种平衡二叉查找树，也就是今天要讲的这种数据结构。</p><p>很多书籍里，但凡讲到平衡二叉查找树，就会拿红黑树作为例子。不仅如此，如果你有一定的开发经验，你会发现，在工程中，很多用到平衡二叉查找树的地方都会用红黑树。你有没有想过，<font color="red">为什么工程中都喜欢用红黑树，而不是其他平衡二叉查找树呢？</font></p><p>带着这个问题，让我们一起来学习今天的内容吧！</p><a id="more"></a><h2 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h2><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p><p><img src="/2018/12/23/21-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%83%BD%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91/521356c5-4acd-4cf6-948e-821a69407ea8.jpg" alt></p><p>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是<strong>AVL 树</strong>，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p><p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树，它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</p><p>我们学习数据结构和算法是为了应用到实际的开发中的，所以，我觉得没必去死抠定义。对于平衡二叉查找树这个概念，我觉得我们要从这个数据结构的由来，去理解“平衡”的意思。</p><p>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</p><p>所以，<strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些</strong>。</p><p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p><h2 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h2><p>平衡二叉查找树其实有很多，比如，Splay Tree（伸展树）、Treap（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树。它的出镜率甚至要高于“平衡二叉查找树”这几个字，有时候，我们甚至默认平衡二叉查找树就是红黑树，那我们现在就来看看这个“明星树”。</p><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，我前面说了，它的定义是不严格符合平衡二叉查找树的定义的。那红黑树究竟是怎么定义的呢？</p><p>顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li><p><strong>根节点是黑色的</strong></p></li><li><p><strong>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据</strong></p></li><li><p><strong>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的</strong></p></li><li><p><strong>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</strong></p></li></ul><p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的，下一节我们讲红黑树的实现的时候会讲到。这节我们暂时不考虑这一点，所以，在画图和讲解的时候，我将黑色的、空的叶子节点都省略掉了。</p><p>为了让你更好地理解上面的定义，我画了两个红黑树的图例，你可以对照着看下。</p><p><img src="/2018/12/23/21-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%83%BD%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91/893ec79e-cb63-450f-b7ff-86f769258f98.jpg" alt></p><h2 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h2><p>我们前面也讲到，平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，<strong>“平衡”的意思可以等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重</strong>。</p><p>我们在上一节讲过，二叉查找树很多操作的性能都跟树的高度成正比。一棵极其平衡的二叉树（满二叉树或完全二叉树）的高度大约是 log<sub>2</sub>n，所以如果要证明红黑树是近似平衡的，我们只需要分析，红黑树的高度是否比较稳定地趋近 log<sub>2</sub>n 就好了。</p><p>红黑树的高度不是很好分析，需要一步一步来推导。</p><p><strong>首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？</strong></p><p>红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p><p><img src="/2018/12/23/21-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B7%A5%E7%A8%8B%E4%B8%AD%E9%83%BD%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BF%99%E7%A7%8D%E4%BA%8C%E5%8F%89%E6%A0%91/7e6ecc308fe44120f30de809822215ed.jpg" alt></p><p>前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小。</p><p>上一节我们说，完全二叉树的高度近似log<sub>2</sub>n，这里的四叉“黑树”的高度要低于完全二叉树，所以去掉红色节点的“黑树”的高度也不会超过 log<sub>2</sub>n。</p><p><strong>我们现在知道只包含黑色节点的“黑树”的高度，那我们现在把红色节点加回去，高度会变成多少呢？</strong></p><p>从上面我画的红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log<sub>2</sub>n，所以加入红色节点之后，最长路径不会超过 2log<sub>2</sub>n，也就是说，红黑树的高度近似 2log<sub>2</sub>n。</p><p>所以，红黑树的高度只比高度平衡的 AVL 树的高度（log<sub>2</sub>n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>我们刚刚提到了很多平衡二叉查找树，现在我们就来看下，为什么在工程中大家都喜欢用红黑树这种平衡二叉查找树？</p><p>我们前面提到 Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。</p><p>AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。</p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。</p><p>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>很多人都觉得红黑树很难，的确，它算是最难掌握的一种数据结构。其实红黑树最难的地方是它的实现，我们今天还没有涉及，下一节我会专门来讲。</p><p>不过呢，我认为，我们其实不应该把学习的侧重点，放到它的实现上。那你可能要问了，关于红黑树，我们究竟需要掌握哪些东西呢？</p><p>还记得我多次说过的观点吗？<strong>我们学习数据结构和算法，要学习它的由来、特性、适用的场景以及它能解决的问题。对于红黑树，也不例外。你如果能搞懂这几个问题，其实就已经足够了</strong>。</p><p>红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。</p><p>因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>动态数据结构支持动态地数据插入、删除、查找操作，除了红黑树，我们前面还学习过哪些呢？能对比一下各自的优势、劣势，以及应用场景吗？</p><p><strong>回答：</strong></p><p>散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。</p><p>跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。</p><p>红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用架构演变过程</title>
      <link href="/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p>看了好多大佬的架构设计经验，也看到好多大型网站的基本架构，始终是老虎吃天-无从下手，个人在此乱画一下，记录当前的经验见解。</p><a id="more"></a><p><img src="/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（二）：Jvm内存结构</title>
      <link href="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 虚拟机是中、高级开发人员必须修炼的知识，有着较高的学习门槛，很多人都不情愿去接触它。可能是觉得学习成本较高又或者是感觉没什么实用性，所以干脆懒得“搭理”它了。其实这种想法是错误的。举个最简单的例子，JVM 基本上是每家招聘公司都会问到的问题，它们会这么无聊问这些不切实际的问题吗？很显然不是。由 JVM 引发的故障问题，无论在我们开发过程中还是生产环境下都是非常常见的。比如 OutOfMemoryError(OOM) 内存溢出问题，你应该遇到过 Tomcat 容器中加载项目过多导致的 OOM 问题，导致 Web 项目无法启动。这就是JVM引发的故障问题。那到底JVM哪里发生内存溢出了呢？为什么会内存溢出呢？如何监控？最重要的就是如何解决问题呢？能解决问题的技术才是最实用最好的技术。然而你对JVM的内存结构都不清楚，就妄想解决JVM引发的故障问题，是不切实际的。了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解那块的内存区域出现问题，以便于快速的解决生产故障。</p><p>先来一张官方图：</p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/94319eb4-b7c4-4c14-9f59-9fb8f5872d13.jpg" alt></p><a id="more"></a><p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p><p>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，<strong>方法区还有一个别名Non-Heap(非堆)</strong>；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p><p>通过一张图来了解如何通过参数来控制各区域的内存大小</p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/f6fa3f67-7e43-4516-bd90-4cd90c582e8e.jpg" alt></p><p>控制参数</p><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p><blockquote><p>老年代空间大小=堆空间大小-年轻代大空间大小</p></blockquote><p><strong>JVM和系统调用之间的关系</strong></p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/fd48e7cf-d12e-4105-9951-ddf343c29f3b.jpg" alt></p><p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。</p><p>ava堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</strong></p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开来。</p><p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p><p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>方法区有时被称为持久代（PermGen）。</p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/067d767a-a512-4c28-b752-2645fcc9c2be.jpg" alt></p><p>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。</p><p>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    private static Logger LOGGER &#x3D; Logger.getLogger(HelloWorld.class.getName());</span><br><span class="line">    public void sayHello(String message) &#123;</span><br><span class="line">        SimpleDateFormat formatter &#x3D; new SimpleDateFormat(&quot;dd.MM.YYYY&quot;);</span><br><span class="line">        String today &#x3D; formatter.format(new Date());</span><br><span class="line">        LOGGER.info(today + &quot;: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序的数据在内存中的存放如下：</p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/1bb8771d-7414-473a-9222-d417880111b1.jpg" alt></p><p>通过JConsole工具可以查看运行中的Java程序（比如Eclipse）的一些信息：堆内存的分配，线程的数量以及加载的类的个数；</p><p><img src="/2018/12/11/JVM%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AJvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/JUtH_20121024_RuntimeDataAreas_5_JConsole.png" alt></p><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p><p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><h2 id="JVM栈（JVM-Stacks）"><a href="#JVM栈（JVM-Stacks）" class="headerlink" title="JVM栈（JVM Stacks）"></a>JVM栈（JVM Stacks）</h2><p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p><h2 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h2><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h2 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h2><p>对内存结构清晰的认识同样可以帮助理解不同OutOfMemoryErrors：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><p>原因：对象不能被分配到堆内存中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><p>原因：类或者方法不能被加载到持久代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br></pre></td></tr></table></figure><p>原因：创建的数组大于堆内存的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?</span><br></pre></td></tr></table></figure><p>原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: &lt;reason&gt; &lt;stack trace&gt;（Native method）</span><br></pre></td></tr></table></figure><p>原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现</p>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM（一）：Java类加载机制</title>
      <link href="/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在介绍<strong>类的加载机制</strong>之前，先来看一看类的加载机制在整个Java运行期间所处的位置。</p><p><img src="/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/5c52258c-78ec-4bf9-ba03-4120c03a413d.jpg" alt></p><p>由上图可知，Java文件由编译器编译成.class文件，接下来由<strong>类加载器</strong>将这些.class文件加载进JVM中。类加载器的作用就是类的加载。</p><a id="more"></a><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。</p><p>类加载的最终结果是位于<strong>堆区</strong>中的<strong>Class</strong>对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内数据结构的接口。</p><h3 id="启动类加载器的时机"><a href="#启动类加载器的时机" class="headerlink" title="启动类加载器的时机"></a>启动类加载器的时机</h3><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，<strong>JVM规范</strong>允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（<strong>LinkageError错误</strong>）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h3 id="从何处加载-class文件"><a href="#从何处加载-class文件" class="headerlink" title="从何处加载.class文件"></a>从何处加载.class文件</h3><ul><li><p>本地磁盘系统直接加载</p></li><li><p>网络下载.class文件（Applet）</p></li><li><p>zip，jar等压缩文件中加载.class文件</p></li><li><p>特定数据库提取.class文件</p></li><li><p>Java源文件动态编译为.class文件</p></li><li><p>其他文件生成（JSP应用）</p></li></ul><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。它们的顺序如下图：</p><p><img src="/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/78a7885d-874f-470d-b790-b06e9fc4cc75.jpg" alt></p><p><strong>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段</strong>。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，<strong>而解析阶段则不一定</strong>，它在某些情况下可以在初始化阶段之后开始。<font color="red">即Java运行时的动态绑定。</font>另外注意这里的几个阶段是<strong>按顺序开始</strong>，而<strong>不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，<strong>通常在一个阶段执行的过程中调用或激活另一个阶段</strong>。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事:</p><p>（1）通过一个类的全限定名来获取其定义的二进制字节流</p><p>（2）将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</p><p>（3）在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。</p><p>相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为开发人员可以<strong>使用系统的类加载器加载，还可以使用自定义的类加载器加载</strong>。</p><p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式<strong>存储在方法区</strong>之中，而且在<strong>Java堆</strong>中也创建一个<code>java.lang.Class</code>类的对象，这样便可以<strong>通过该对象访问方法区中的这些数据</strong>。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载类的正确性"><a href="#验证：确保被加载类的正确性" class="headerlink" title="验证：确保被加载类的正确性"></a>验证：确保被加载类的正确性</h4><p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的规范，并且不会损害虚拟机自身的安全。主要完成4个阶段的验证：</p><ul><li><p><strong>文件格式验证</strong>：验证.class文件字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。（魔数、主版本号都是.class文件里面包含的数据信息）</p></li><li><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了<code>java.lang.Object</code>之外，类中的字段方法是不是和父类冲突等等。</p></li><li><p><strong>字节码验证</strong>：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出损害虚拟机安全的事。</p></li><li><p><strong>符号引用验证</strong>：确保解析动作能正确执行。</p></li></ul><p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果某些被引用的类经反复验证，那么我们就没有必要再去去验证，毕竟验证需要花费一定的的时间。可以使用-Xverfity:none来关闭大部分的验证，进而缩短虚拟机类加载时间。</p><h4 id="准备：为类的静态变量分配内存并初始化为默认值"><a href="#准备：为类的静态变量分配内存并初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存并初始化为默认值"></a>准备：为类的静态变量分配内存并初始化为默认值</h4><p>准备阶段是<strong>正式为类变量分配内存并设置类变量初始值</strong>的阶段，这些内存都将在方法区中分配。对于该阶段需要注意以下3点：</p><ul><li><p>1：此时进行内存分配的仅仅是类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p></li><li><p>2：这里所设置的初始值通常下是数据类型默认值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p></li></ul><p>假设一个类变量的定义为：<code>public static int value = 3</code>；</p><p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的<code>public static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p><blockquote><p><strong>注意</strong>：</p></blockquote><ul><li><p>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</p></li><li><p>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</p></li><li><p>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</p></li><li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</p></li><li><p>3：如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p></li></ul><p>假设上面的类变量value被定义为： <code>public static final int value = 3</code>；</p><p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据<code>ConstantValue</code>的设置将value赋值为3。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</p><h4 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，</p><p><strong>符号引用</strong>：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用）。</p><p><strong>直接引用</strong>：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</p><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p><ul><li><p>声明类变量是指定初始值</p></li><li><p>使用静态代码块为类变量指定初始值</p></li></ul><p><strong>JVM初始化步骤</strong></p><ul><li><p>1 假如这个类还没有被加载和连接，则程序先加载并连接该类</p></li><li><p>2 假如该类的直接父类还没有被初始化，则先初始化其直接父类</p></li><li><p>3 假如类中有初始化语句，则系统依次执行这些初始化语句</p></li></ul><p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p><ul><li><p>创建类的实例，也就是new的方式</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（如<code>Class.forName(“com.shengsiyuan.Test”)</code>）</p></li><li><p>初始化某个类的子类，则其父类也会被初始化</p></li><li><p>Java虚拟机启动时被标明为启动类的类（<code>Java Test</code>），直接使用<code>java.exe</code>命令来运行某个主类</p></li></ul><h4 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h4><p>在如下几种情况下，Java虚拟机将结束生命周期</p><ul><li><p>执行了<code>System.exit()</code>方法</p></li><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统出现错误而导致Java虚拟机进程终止</p></li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类。</p><p>寻找类加载器，先看一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.demo;</span><br><span class="line"></span><br><span class="line">public class ClassLoaderTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassLoader loader &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        System.out.println(loader);</span><br><span class="line">        System.out.println(loader.getParent());</span><br><span class="line">        System.out.println(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/7ccf18ee-6d97-4027-a568-8c0ac1c00cc6.png" alt></p><p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父Loader，原因是<code>Bootstrap Loader</code>（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p><p><strong>Java语言自带的3个类加载器</strong></p><p><strong>Bootstrap ClassLoader</strong> &gt; <strong>Extention ClassLoader</strong> &gt; <strong>Appclass Loader</strong></p><p><strong>层次关系：</strong></p><p><img src="/2018/12/10/JVM%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/414ed0d3-b88f-49fe-815c-7a5ddddd9d86.jpg" alt></p><blockquote><p>这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p></blockquote><p><strong>Java虚拟机角度</strong>:<br>只存在两种不同的类加载器：<strong>启动类加载器</strong>：它使用<strong>C++</strong>实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；<strong>所有其它的类加载器</strong>：这些类加载器都由<strong>Java语言</strong>实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p><p><strong>Java开发人员角度</strong>：</p><p><strong>启动类加载器</strong>：<font color="red">Bootstrap ClassLoader</font>.负责加载存放在<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.<em>开头的类均被<code>Bootstrap ClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。</em></p><p><strong>扩展类加载器</strong>：<font color="red">Extension ClassLoader</font>._该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax._开头的类），开发者可以直接使用扩展类加载器。</p><p><strong>应用程序类加载器</strong>：<font color="red">Application ClassLoader</font>。该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得<strong>从本地文件系统加载标准的java class文件</strong>，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p><ul><li><p>1 在执行非置信代码之前，自动验证数字签名。</p></li><li><p>2 动态地创建符合用户特定需要的定制化构建类。</p></li><li><p>3 从特定的场所取得java class，例如数据库中和网络中。</p></li></ul><p><strong>JVM类加载机制</strong></p><p><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p><h2 id="类的加载-1"><a href="#类的加载-1" class="headerlink" title="类的加载"></a>类的加载</h2><p>类加载有三种方式：</p><ul><li><p>1 命令行启动应用时候由JVM初始化加载</p></li><li><p>2 通过Class.forName()方法动态加载</p></li><li><p>3 通过ClassLoader.loadClass()方法动态加载</p></li></ul><p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p><ul><li><p><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</p></li><li><p><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</p></li><li><p><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</p></li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><p>双亲委派机制:</p><ul><li><p><strong>1 当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成</strong>。</p></li><li><p><strong>2 当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</strong></p></li><li><p><strong>3 如果<code>BootStrapClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用<code>ExtClassLoader</code>来尝试加载；</strong></p></li><li><p><strong>4 若ExtClassLoader也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</strong></p></li></ul><p><strong>ClassLoader源码分析：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</span><br><span class="line">        return loadClass(name, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先判断该类型是否已经被加载</span><br><span class="line">        Class c &#x3D; findLoadedClass(name);</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                     &#x2F;&#x2F;如果存在父类加载器，就委派给父类加载器加载</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</span><br><span class="line">                    c &#x3D; findBootstrapClass0(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">             &#x2F;&#x2F; 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>双亲委派模型意义：</p><ul><li><p>系统类防止内存中出现多份同样的字节码</p></li><li><p>保证Java程序安全稳定运行</p></li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输 Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自<code>ClassLoader</code>类，从上面对<code>loadClass</code>方法来分析来看，我们只需要重写 findClass 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line">    private String root;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        byte[] classData &#x3D; loadClassData(name);</span><br><span class="line">        if (classData &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new ClassNotFoundException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return defineClass(name, classData, 0, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private byte[] loadClassData(String className) &#123;</span><br><span class="line">        String fileName &#x3D; root + File.separatorChar</span><br><span class="line">                + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream ins &#x3D; new FileInputStream(fileName);</span><br><span class="line">            ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            int bufferSize &#x3D; 1024;</span><br><span class="line">            byte[] buffer &#x3D; new byte[bufferSize];</span><br><span class="line">            int length &#x3D; 0;</span><br><span class="line">            while ((length &#x3D; ins.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, length);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getRoot() &#123;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setRoot(String root) &#123;</span><br><span class="line">        this.root &#x3D; root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)  &#123;</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader &#x3D; new MyClassLoader();</span><br><span class="line">        classLoader.setRoot(&quot;E:\\temp&quot;);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; testClass &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            testClass &#x3D; classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;);</span><br><span class="line">            Object object &#x3D; testClass.newInstance();</span><br><span class="line">            System.out.println(object.getClass().getClassLoader());</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p><ul><li><p>1、这里传递的文件名需要是类的全限定性名称，即<code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass 方法是按这种格式进行处理的。</p></li><li><p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p></li><li><p>3、这类Test 类本身可以被 <code>AppClassLoader</code>类加载，因此我们不能把<code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由<code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map-Reduce学习</title>
      <link href="/2018/11/20/Map-Reduce%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/11/20/Map-Reduce%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">Map-Reduce的过程与MongoDB如出一辙</font>（如下图）<br><img src="/2018/11/20/Map-Reduce%E5%AD%A6%E4%B9%A0/b8211209-31ef-425b-b480-9765994698c9.jpg" alt></p><h2 id="1-Map-Reduce简介"><a href="#1-Map-Reduce简介" class="headerlink" title="1 Map-Reduce简介"></a>1 Map-Reduce简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapReduce</strong>是一种编程模型，用于大规模数据集（大于<strong>1TB</strong>）的并行运算。该运算充分利用<strong>Hadoop</strong>存储节点（<strong>DateNode</strong>）所在物理主机的CPU、内存、网络以及少许磁盘完成分布式计算。通过在<strong>DateNode</strong>所在的主机上启动<strong>NodeManager</strong>进程，该进程负责启动计算任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapReduce</strong>计算框架将分布式计算分为两个阶段：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Map</strong>阶段：在任务计算初期，计算框架会提前计算好任务切片（对数据做区域划分），然后<font color="red">根据切片数目</font>启动MapTask，对切片所映射的数据做局部的分析/计算，将计算的临时结果存储到对应物理主机的磁盘（<strong>MapTask</strong>的溢写）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Reduce</strong>阶段：在<strong>Map</strong>阶段的所有操作完成计算任务后，计算框架会选择若干机器（手动指定）执行ReduceTask，完成对<strong>Map</strong>阶段计算数据的汇总（<strong>shuffle</strong><font color="red">洗牌</font>）。</p><a id="more"></a><h2 id="2-Map-Reduce计算过程"><a href="#2-Map-Reduce计算过程" class="headerlink" title="2 Map-Reduce计算过程"></a>2 Map-Reduce计算过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">修路的故事</font>：我们要修一条从<font color="red">西藏</font>到<font color="red">上海</font>的高速公路，由<strong>西北</strong>到<strong>东南</strong>；首先呢，这个工程量是十分巨大的，我们不能让一个工程队去修这条路，（从理论上来讲，是可行的，从祖父到重孙….）但是周期太长，中间会不会发生变故，还不好说。所以一个大的工程出现后，要有一个合理的时间规划，假如期限是1年内搞定，那怎么办呢？此时就需要路段区间同时施工，但区间同时施工又会产生一个问题，这个事儿该由谁来主持呢？史某一个人来主持吗？不可能，修路这种东西，尤其是跨地区修路，是非常难的。每个省、市。区都有自己的特殊的东西，如：钉子户的解决，拆迁的成本等。修路是一个国家的大事，不是某个人可以单独解决的。这就由每个地区的国土资源部来审核、主持。但是跨地区呢？由中央国土资源管理中心来审核、主持各个地区的国土资源部。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提议：修一条从西藏到上海的路，带动周边经济。中央的国土资源部拿到这个请求后，会开会商讨，觉得此事儿可行，靠谱。中央会下发文件，给该工程起代号。中央可以审批，但是有一个前提：就是在我审批之后，未来这个路的具体修法不可能让国家领导人来操心吧，所以：中央审批完成后，会由第一人做三件事，<strong>1.</strong> <font color="red">具体的施工区间（这条路会经过哪些省份、地区）路段</font>（方便各国土资源部进行各自的土地划量，区间同时作业）。<strong>2.</strong> 当地具体该怎么修这条路呢，是修水泥路呢？还是沥漆呢？路面有多宽，多厚？需不需要修建  绿化带呢？即<font color="red">修路的标准要定好</font>。<strong>3.</strong><font color="red">路段的对接标准</font>:各个工程队都不傻，都会只负责各自的划分区域，那些交接的区域该怎么对接呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整理好上述三件事后，要将文件进行公示，<font color="red">即所有人都能看到</font> <strong>4</strong>.将文件详情上传给中央后，中央说：修吧。<strong>5.</strong> 中央会让河南省的国土资源部推荐一个人，即<font color="red">工程总监</font>，全权负责西藏到上海的修路事宜。 当地的（河南省）的国土资源部会选举、指派一个<font color="red">工程总监</font>作为<font color="red">负责人</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个负责人可能一晚上都睡不好觉了，因为这是一个大项目，搞砸了咋笨呢？此人心里会思考：这么大的工程量我该怎样去检测、去实施呢？<strong>6.</strong><font color="red">修路的管理规范定制好</font>，每隔多长时间，<font color="red">各个工程队要向我汇报各个区间的施工进度</font>，有什么难题向我汇报，我要知道工程的施工进度（假如说在施工期间，某个施工队因为技术达不到而修不了某一区间段内的路，要及时通报我，我会从其他地方抽调专业的施工队来帮助你修路）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个工程总监想了一夜终于想好后，紧接着该第七步路。<strong>7.</strong> 工程总监从网上下载<font color="red">初期的公示文件</font>：因为要看路段从哪到哪，经过哪些区域，需要哪一个地区的国土资源部配合我的工作等详细信息；<strong>8.</strong> 一切就绪后，负责人就开始<font color="red">向中央申请资金</font>了，<strong>9.</strong> 工程总监将资金、工程区间段的图纸、施工信息等下发给拨给各个地区的<font color="red">国土资源部</font>，交给他们去具体的修路。<strong>10.</strong> 各地区国土资源部拿到拨款后，会在<font color="red">当地进行招标</font>，(带动当地经济，肥水不流外人田)  钱已经给到了<font color="red">工程队</font>。<font color="red">工程队</font>拿到钱后，并不是立马开始修路的，他要去根据<font color="red">公示文件</font>去判断区间范围和修路标准，<strong>11.</strong> 各地区中标<font color="red">工程队开始施工修路</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<font color="red">施工期间</font>要注意的事项：各个地区开始同时施工，施工的第一阶段，<font color="blue">所有的工程队只修自己所负责的区间段，按照既定的标准去修就OK了</font>；各个施工队汇报工程进度时，汇报对象不再是当地政府，而是<font color="red">工程总监</font>，可能出现的状况：当地政府指定了某一个施工队，但是没有考虑施工的具体难易，本地的工程队儿干不了，向工程总监反馈，工程总监考虑从其他地区调工程队来（不到万不得已，不会调，因为有人力、物力、财力流失浪费）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">当所有的工程队把自己所下发的区间段修完后，工程总监就知道了</font>，此时路段该对接了，第一阶段的Map，因为有公示文件订好了，照着干就行，工程总监干预不了，而第二阶段的Reduce阶段则由<strong>工程总监</strong>说了算。（不可能让某一个区域的个人去做对接，效率太慢，也不可能让所有的工程队都参与对接，浪费资源）由工程总监去指定若干个工程队去进行工程的对接（原来1000,现在改为10个或不等个）。</p><h3 id="2-1-举例"><a href="#2-1-举例" class="headerlink" title="2.1 举例"></a>2.1 举例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1. Client JVM</strong><font color="red">(提议人)</font>，向<strong>ResourceManager</strong><font color="red">(中央国土资源中心)</font>进行<strong>Job</strong><font color="red">(提议)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2. ResourceManager</strong>会下发一个文件<strong>get new application(授权)</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>3. Client JVM<font color="red">(客户端)</font></strong> 要<strong>copy job resource</strong><font color="red">(公示自己的文件)</font>，工程所用到的资源：路段信息、施工标准、运行上下文等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>4. Client JVM</strong><font color="red">(提议人)</font>，向<strong>ResourceManager</strong><font color="red">(中央)</font>进行<strong>submit applications</strong><font color="red">(施工文档的提交)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>5a. ResourceManager</strong><font color="red">(中央)</font>会<strong>start container</strong><font color="red">(下发命令)</font>，给地方的<strong>NodeManager</strong><font color="red">(国土资源中心)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>5b. NodeManager</strong><font color="red">(当地政府)</font>除了找工程队外，还要选举、启动<strong>MRAppMaster</strong><font color="red">(工程总监)</font>，<strong>MRAppMaster只有一个</strong>。所有的地方政府都要听他的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>6. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>Initialize Job</strong><font color="red">(初始化Job)</font>，即相当于先将任务的<font color="red">监测进程</font>启动好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>7. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>retrieve input splits</strong><font color="red">(查看输入切片，相当于区域路段信息，)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>8. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>allocate resources</strong><font color="red">(拨款,请求资源：Cpu、内存等)</font> from <strong>ResourceManager</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>9a. MRAppMaster</strong><font color="red">(工程总监)</font>会<strong>start container</strong><font color="red">(发号指令)</font>给<strong>NodeManager</strong><font color="red">(地方政府)</font>，去跟地方国土资源中心说：中央给你拨了那么多款，你去把路给我修好了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>9b. NodeManagerr</strong><font color="red">(地方政府)</font>会<strong>launch</strong><font color="red">(启动)</font>一个本地的<strong>YarnChild</strong><font color="red">(工程队)</font>,此处的YarnChild是一个统称，它既可以是MapTask(区域施工)，也可以工程对接（Reduce Task）.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>10. YarnChild</strong><font color="red">(工程队)</font>会<strong>retrieve job resources</strong><font color="red">(查询确认自己的到底要修那条路，施工。对接标准如何，取决于启动的是区间作业工程队，还是工程对接工程队)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>11. YarnChild</strong><font color="red">(工程队)</font><strong>run</strong> 任务，第一阶段一定是<strong>MapTask</strong>,这个任务量取决于有多少个<strong>切片</strong>（splits），第二阶段由<strong>MRAppMaster</strong>去找寻指定的<strong>NodeManager</strong>启动<strong>ReduceTask</strong>。<br><font color="red">路修完后：工程总监<strong>MRAppMaster</strong>、YarnChild<strong>工程队</strong>的头衔头没有了，当地政府还存在，所以整个<strong>Yarn框架</strong>的核心进程就两个：<strong>ResourceManager</strong>和<strong>NodeManager</strong>，MRAppMaster和YarnChild属于计算过程中的进程，用完就回收。</font></p><p><img src="/2018/11/20/Map-Reduce%E5%AD%A6%E4%B9%A0/wpsA77A.tmp.jpg" alt><br><strong>ResourceManager</strong>：资源管理中心，管理<strong>NodeManager</strong>、分配任务资源<br><strong>NodeManager</strong>：启动<strong>MRAppMaster</strong>、<strong>YarnChild</strong><br><font color="red">以上两个是Yarn框架的常驻内存进程。</font><br><strong>MRAppMaster</strong>：监测任务运行（一个任务，只有一个）<br><strong>YarnChild</strong>：MapTask或者ReduceTask的总称，具体计算进程。<br><strong>YarnChild</strong>进程数目：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapTask</strong>：切片控制（数据逻辑映射区间）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ReduceTask</strong>：程序手动指定。</p><h2 id="3-搭建YARN计算环境"><a href="#3-搭建YARN计算环境" class="headerlink" title="3 搭建YARN计算环境"></a>3 搭建YARN计算环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# cp &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml.template &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;yarn-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;CentOS&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">启动Yarn</span><br><span class="line">[root@CentOS ~]# start-yarn.sh</span><br><span class="line">[root@CentOS ~]# jps</span><br><span class="line">1628 SecondaryNameNode</span><br><span class="line">1780 ResourceManager</span><br><span class="line">1447 DataNode</span><br><span class="line">1905 Jps</span><br><span class="line">1363 NameNode</span><br><span class="line">1863 NodeManager</span><br></pre></td></tr></table></figure><p>访问：<a href="http://centos:8088/cluster" target="_blank" rel="noopener">http://centos:8088/cluster</a> 即可看到MapReduce的界面化管理。<br><a href="https://www.jianshu.com/p/20ed705ed5b6?utm_campaign" target="_blank" rel="noopener">参考文档</a></p><h2 id="4-掌握Map-Reduce编程模型"><a href="#4-掌握Map-Reduce编程模型" class="headerlink" title="4 掌握Map-Reduce编程模型"></a>4 掌握<strong>Map-Reduce</strong>编程模型</h2><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-二叉树基础下_有了如此高效的散列表—_为什么还需要二叉树</title>
      <link href="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://mp.weixin.qq.com/s/ONKJyusGCIE2ctwT9uLv9g" target="_blank" rel="noopener">参考文章</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节我们学习了树、二叉树以及二叉树的遍历，今天我们再来学习一种特殊的的二叉树，二叉查找树。二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。</p><p>我们之前说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是 O(1)。<font color="red">既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</font></p><p>带着这些问题，我们就来学习今天的内容，二叉查找树</p><a id="more"></a><h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？</p><p>这些都依赖于二叉查找树的特殊结构。<strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</strong>。 我画了几个二叉查找树的例子，你一看应该就清楚了。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/91bfbc8e-9631-463e-8f7c-ebb43767c1a1.jpg" alt></p><p>前面我们讲到，二叉查找树支持快速查找、插入、删除操作，现在我们就依次来看下，这三个操作是如何实现的。</p><h2 id="1-二叉查找树的查找操作"><a href="#1-二叉查找树的查找操作" class="headerlink" title="1. 二叉查找树的查找操作"></a>1. 二叉查找树的查找操作</h2><p>首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/0516e4bb-b599-45de-a642-70cb721e9899.jpg" alt></p><p>这里我把查找的代码实现了一下，贴在下面了，结合代码，理解起来会更加容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchTree &#123;</span><br><span class="line">  private Node tree;</span><br><span class="line"></span><br><span class="line">  public Node find(int data) &#123;</span><br><span class="line">    Node p &#x3D; tree;</span><br><span class="line">    while (p !&#x3D; null) &#123;</span><br><span class="line">      if (data &lt; p.data) p &#x3D; p.left;</span><br><span class="line">      else if (data &gt; p.data) p &#x3D; p.right;</span><br><span class="line">      else return p;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static class Node &#123;</span><br><span class="line">    private int data;</span><br><span class="line">    private Node left;</span><br><span class="line">    private Node right;</span><br><span class="line"></span><br><span class="line">    public Node(int data) &#123;</span><br><span class="line">      this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-二叉查找树的插入操作"><a href="#2-二叉查找树的插入操作" class="headerlink" title="2. 二叉查找树的插入操作"></a>2. 二叉查找树的插入操作</h2><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/ec20514d-9e50-4413-b773-68d9bad6848c.jpg" alt></p><p>同样，插入的代码我也实现了一下，贴在下面，你可以看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void insert(int data) &#123;</span><br><span class="line">  if (tree &#x3D;&#x3D; null) &#123;</span><br><span class="line">    tree &#x3D; new Node(data);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node p &#x3D; tree;</span><br><span class="line">  while (p !&#x3D; null) &#123;</span><br><span class="line">    if (data &gt; p.data) &#123;</span><br><span class="line">      if (p.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">        p.right &#x3D; new Node(data);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.right;</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; data &lt; p.data</span><br><span class="line">      if (p.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">        p.left &#x3D; new Node(data);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      p &#x3D; p.left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二叉查找树的删除操作"><a href="#3-二叉查找树的删除操作" class="headerlink" title="3. 二叉查找树的删除操作"></a>3. 二叉查找树的删除操作</h2><p>二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p><p>第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55。</p><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13。</p><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点 18。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/b6fd1c6d-0cfa-4155-b5e8-c85938a91d2e.jpg" alt></p><p>老规矩，我还是把删除的代码贴在这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void delete(int data) &#123;</span><br><span class="line">  Node p &#x3D; tree; &#x2F;&#x2F; p指向要删除的节点，初始化指向根节点</span><br><span class="line">  Node pp &#x3D; null; &#x2F;&#x2F; pp记录的是p的父节点</span><br><span class="line">  while (p !&#x3D; null &amp;&amp; p.data !&#x3D; data) &#123;</span><br><span class="line">    pp &#x3D; p;</span><br><span class="line">    if (data &gt; p.data) p &#x3D; p.right;</span><br><span class="line">    else p &#x3D; p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  if (p &#x3D;&#x3D; null) return; &#x2F;&#x2F; 没有找到</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 要删除的节点有两个子节点</span><br><span class="line">  if (p.left !&#x3D; null &amp;&amp; p.right !&#x3D; null) &#123; &#x2F;&#x2F; 查找右子树中最小节点</span><br><span class="line">    Node minP &#x3D; p.right;</span><br><span class="line">    Node minPP &#x3D; p; &#x2F;&#x2F; minPP表示minP的父节点</span><br><span class="line">    while (minP.left !&#x3D; null) &#123;</span><br><span class="line">      minPP &#x3D; minP;</span><br><span class="line">      minP &#x3D; minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data &#x3D; minP.data; &#x2F;&#x2F; 将minP的数据替换到p中</span><br><span class="line">    p &#x3D; minP; &#x2F;&#x2F; 下面就变成了删除minP了</span><br><span class="line">    pp &#x3D; minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 删除节点是叶子节点或者仅有一个子节点</span><br><span class="line">  Node child; &#x2F;&#x2F; p的子节点</span><br><span class="line">  if (p.left !&#x3D; null) child &#x3D; p.left;</span><br><span class="line">  else if (p.right !&#x3D; null) child &#x3D; p.right;</span><br><span class="line">  else child &#x3D; null;</span><br><span class="line"></span><br><span class="line">  if (pp &#x3D;&#x3D; null) tree &#x3D; child; &#x2F;&#x2F; 删除的是根节点</span><br><span class="line">  else if (pp.left &#x3D;&#x3D; p) pp.left &#x3D; child;</span><br><span class="line">  else pp.right &#x3D; child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h2 id="4-二叉查找树的其他操作"><a href="#4-二叉查找树的其他操作" class="headerlink" title="4. 二叉查找树的其他操作"></a>4. 二叉查找树的其他操作</h2><p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。</p><p>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？我这里有两种解决方法。</p><p>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><p>第二种方法比较不好理解，不过更加优雅。</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/00245029-3894-4569-90f4-df501cd969d2.jpg" alt></p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/20a78e3f-efeb-4496-a615-82da7e1de696.jpg" alt></p><p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/7173dd30-3d71-4dc1-bad6-cc22cf1420d3.jpg" alt></p><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>好了，对于二叉查找树常用操作的实现方式，你应该掌握得差不多了。现在，我们来分析一下，二叉查找树的插入、删除、查找操作的时间复杂度。</p><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p><p><img src="/2018/11/18/20-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8B-%E6%9C%89%E4%BA%86%E5%A6%82%E6%AD%A4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E4%BA%8C%E5%8F%89%E6%A0%91/e3d9b2977d350526d2156f01960383d9.jpg" alt></p><p>我刚刚其实分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？</p><p>从我前面的例子、图，以及还有代码来看，不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？</p><p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p><p>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;&#x3D; 1+2+4+8+...+2^(L-2)+1</span><br><span class="line">n &lt;&#x3D; 1+2+4+8+...+2^(L-2)+2^(L-1)</span><br></pre></td></tr></table></figure><p>借助等比数列的求和公式，我们可以计算出，L 的范围是[log<sub>2</sub>(n+1), log<sub>2</sub>n +1]。完全二叉树的层数小于等于 log<sub>2</sub>n +1，也就是说，完全二叉树的高度小于等于 log<sub>2</sub>n。</p><p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节课要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近 logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是 O(logn)。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>我们在散列表那节中讲过，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？</p><p>我认为有下面几个原因：</p><p><strong>第一</strong>，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</p><p><strong>第二</strong>，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</p><p><strong>第三</strong>，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p><strong>第四</strong>，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了一种特殊的二叉树，二叉查找树。它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。对于存在重复数据的二叉查找树，我介绍了两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是 O(n) 和 O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的 O(logn)，下一篇我们具体来讲。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？</p><p><strong>回答：</strong></p><p><strong>1：</strong><br>确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。</p><p><strong>2：</strong><br>递归法，根节点高度=max(左子树高度，右子树高度)+1</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-二叉树基础上_什么样的二叉树适合用数组来存储</title>
      <link href="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/"/>
      <url>/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://mp.weixin.qq.com/s/ONKJyusGCIE2ctwT9uLv9g" target="_blank" rel="noopener">参考文章</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们讲的都是线性表结构，栈、队列等等。今天我们讲一种非线性表结构，树。树这种数据结构比线性表的数据结构要复杂得多，内容也比较多，所以会分四篇来讲解。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/d785f5f3-bdc4-4658-89dd-5961bb3f5464.jpg" alt></p><p>带着问题学习，是最有效的学习方式之一，所以在正式的内容开始之前，还是给你出一道思考题：<font color="red">二叉树有哪几种存储方式？什么样的二叉树适合用数组来存储？</font></p><p>带着这些问题，我们就来学习今天的内容，树！</p><a id="more"></a><h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>我们首先来看，什么是“树”？再完备的定义，都没有图直观。所以我在图中画了几棵“树”。你来看看，这些“树”都有什么特征？</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/d8048b41-c828-4eec-9c1e-fe04fd7547ba.jpg" alt></p><p>你有没有发现，“树”这种数据结构真的很像我们现实生活中的“树”，这里面每个元素我们叫作“节点”；用来连线相邻节点之间的关系，我们叫作“父子关系”。</p><p>比如下面这幅图，A 节点就是 B 节点的<strong>父节点</strong>，B 节点是 A 节点的<strong>子节点</strong>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<strong>兄弟节点</strong>。我们把没有父节点的节点叫作<strong>根节点</strong>，也就是图中的节点 E。我们把没有子节点的节点叫作<strong>叶子节点</strong>或者<strong>叶节点</strong>，比如图中的 G、H、I、J、K、L 都是叶子节点。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/73b70ee7-2e6c-48e1-86e2-351297da4468.jpg" alt></p><p>除此之外，关于“树”，还有三个比较相似的概念：<strong>高度</strong>（Height）、<strong>深度</strong>（Depth）、<strong>层</strong>（Level）。它们的定义是这样的：</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/3dfe773f-bece-4eb3-b1fd-41d6fc94d746.jpg" alt></p><p>这三个概念的定义比较容易混淆，描述起来也比较空洞。我举个例子说明一下，你一看应该就能明白。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/7d1eb241-8cb0-42e3-a956-40e1803a16cb.jpg" alt></p><p>记这几个概念，我还有一个小窍门，就是类比“高度”“深度”“层”这几个名词在生活中的含义。</p><p><strong>“高度”</strong>这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。</p><p><strong>“深度”</strong>这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。</p><p><strong>“层数”</strong>跟深度的计算类似，不过，计数起点是 1，也就是说根节点的位于第 1 层。</p><h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>树结构多种多样，不过我们最常用还是二叉树。</p><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<strong>左子节点</strong>和<strong>右子节点</strong>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。我画的这几个都是二叉树。以此类推，你可以想象一下四叉树、八叉树长什么样子。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/ca380eff-ce65-4179-bf6c-2895bfb53a6a.jpg" alt></p><p>这个图里面，有两个比较特殊的二叉树，分别是编号 2 和编号 3 这两个。</p><p>其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作<strong>满二叉树</strong>。</p><p>编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作<strong>完全二叉树</strong>。</p><p>满二叉树很好理解，也很好识别，但是完全二叉树，有的人可能就分不清了。我画了几个完全二叉树和非完全二叉树的例子，你可以对比着看看。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/f3e22b48-2af8-4222-89e3-6ff79363c7a2.jpg" alt></p><p>你可能会说，满二叉树的特征非常明显，我们把它单独拎出来讲，这个可以理解。但是完全二叉树的特征不怎么明显啊，单从长相上来看，完全二叉树并没有特别特殊的地方啊，更像是“芸芸众树”中的一种。</p><p>那我们为什么还要特意把它拎出来讲呢？为什么偏偏把最后一层的叶子节点靠左排列的叫完全二叉树？如果靠右排列就不能叫完全二叉树了吗？这个定义的由来或者说目的在哪里？</p><p>要理解完全二叉树定义的由来，我们需要先了解，<strong>如何表示（或者存储）一棵二叉树？</strong></p><p>想要存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。</p><p>我们先来看比较简单、直观的<strong>链式存储法</strong>。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/f279f6ba-8bb9-4c10-98ae-028b67da70e2.jpg" alt></p><p>我们再来看，基于数组的<strong>顺序存储法</strong>。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推，B 节点的左子节点存储在 2 * i = 2 * 2 = 4 的位置，右子节点存储在 2 * i + 1 = 2 * 2 + 1 = 5 的位置。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/d23feeb2-d223-41fc-9c88-e521dbb5659c.jpg" alt></p><p>我来总结一下，如果节点 X 存储在数组中下标为 i 的位置，下标为 2 * i 的位置存储的就是左子节点，下标为 2 * i + 1 的位置存储的就是右子节点。反过来，下标为 i/2 的位置存储就是它的父节点。通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置），这样就可以通过下标计算，把整棵树都串起来。</p><p>不过，我刚刚举的例子是一棵完全二叉树，所以仅仅“浪费”了一个下标为 0 的存储位置。如果是非完全二叉树，其实会浪费比较多的数组存储空间。你可以看我举的下面这个例子。</p><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/31da6a57-3c06-4112-8acc-e60cb872605c.jpg" alt></p><p>所以，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><p>当我们讲到堆和堆排序的时候，你会发现，堆其实就是一种完全二叉树，最常用的存储方式就是数组。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>面我讲了二叉树的基本定义和存储方法，现在我们来看二叉树中非常重要的操作，二叉树的遍历。这也是非常常见的面试题。</p><p>如何将所有节点都遍历打印出来呢？经典的方法有三种，<strong>前序遍历</strong>、<strong>中序遍历</strong>和<strong>后序遍历</strong>。其中，前、中、后序，表示的是节点与它的左右子树节点遍历打印的先后顺序。</p><ul><li><p><strong>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树</strong></p></li><li><p><strong>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</strong></p></li><li><p><strong>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身</strong></p></li></ul><p><img src="/2018/11/16/19-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80%E4%B8%8A-%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%82%E5%90%88%E7%94%A8%E6%95%B0%E7%BB%84%E6%9D%A5%E5%AD%98%E5%82%A8/4cf91f09-1c20-4538-826d-2208f3f995f8.jpg" alt></p><p><strong>实际上，二叉树的前、中、后序遍历就是一个递归的过程。</strong>比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。</p><p>写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) &#x3D; print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) &#x3D; inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) &#x3D; postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>有了递推公式，代码写起来就简单多了。这三种遍历方式的代码，我都写出来了，你可以看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void preOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印root节点</span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印root节点</span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void postOrder(Node* root) &#123;</span><br><span class="line">  if (root &#x3D;&#x3D; null) return;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root &#x2F;&#x2F; 此处为伪代码，表示打印root节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树的前、中、后序遍历的递归实现是不是很简单？<strong>你知道二叉树遍历的时间复杂度是多少吗</strong>？我们一起来看看。</p><p>从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点的个数 n 成正比，也就是说二叉树遍历的时间复杂度是 O(n)。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>今天，讲了一种非线性表数据结构，树。关于树，有几个比较常用的概念你需要掌握，那就是：根节点、叶子节点、父节点、子节点、兄弟节点，还有节点的高度、深度、层数，以及树的高度。</p><p>我们平时最常用的树就是二叉树。二叉树的每个节点最多有两个子节点，分别是左子节点和右子节点。二叉树中，有两种比较特殊的树，分别是满二叉树和完全二叉树。满二叉树又是完全二叉树的一种特殊情况。</p><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。除此之外，二叉树里非常重要的操作就是前、中、后序遍历操作，遍历的时间复杂度是 O(n)，你需要理解并能用递归代码来实现。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？</p><p>2 我们讲了三种二叉树的遍历方式，前、中、后序。实际上，还有另外一种遍历方式，也就是按层遍历，你知道如何实现吗？</p><p><strong>回答：</strong></p><p>1 是卡特兰数，是C[n,2n] / (n+1)种形状，c是组合数，节点的不同又是一个全排列，一共就是n!*C[n,2n] / (n+1)个二叉树。可以通过数学归纳法推导得出。</p><p>2 层次遍历需要借助队列这样一个辅助数据结构。（其实也可以不用，这样就要自己手动去处理节点的关系，代码不太好理解，好处就是空间复杂度是o(1)。不过用队列比较好理解，缺点就是空间复杂度是o(n)）。根节点先入队列，然后队列不空，取出对头元素，如果左孩子存在就入列队，否则什么也不做，右孩子同理。直到队列为空，则表示树层次遍历结束。树的层次遍历，其实也是一个广度优先的遍历算法。</p><p>层序遍历，借用队列辅助即可，根节点先入队列，然后循环从队列中pop节点，将pop出来的节点的左子节点先入队列，右节点后入队列，依次循环，直到队列为空，遍历结束。</p><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">leetcode上有个类似的题目</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> * int val;</span><br><span class="line"> * TreeNode left;</span><br><span class="line"> * TreeNode right;</span><br><span class="line"> * TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        if (root &#x3D;&#x3D; null) return new ArrayList&lt;&gt;(0);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; curLevelNodes &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode node &#x3D; queue.poll();</span><br><span class="line">            curLevelNodes.offer(node);</span><br><span class="line"></span><br><span class="line">            if (queue.isEmpty()) &#123;</span><br><span class="line">                List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(curLevelNodes.size());</span><br><span class="line">                while (!curLevelNodes.isEmpty()) &#123;</span><br><span class="line">                    TreeNode curNode &#x3D; curLevelNodes.poll();</span><br><span class="line">                    list.add(curNode.val);</span><br><span class="line"></span><br><span class="line">                    if (curNode.left !&#x3D; null) &#123;</span><br><span class="line">                        queue.offer(curNode.left);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (curNode.right !&#x3D; null) &#123;</span><br><span class="line">                        queue.offer(curNode.right);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-哈希算法下_哈希算法在分布式系统中有哪些应用</title>
      <link href="/2018/11/15/18-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8B-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8/"/>
      <url>/2018/11/15/18-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8B-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://mp.weixin.qq.com/s/yimfkNYF_tIJJqUIzV7TFA" target="_blank" rel="noopener">什么是一致性哈希</a></p><p><a href="http://www.zsythink.net/archives/1182" target="_blank" rel="noopener">白话解析：一致性哈希算法</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节，讲了哈希算法的四个应用，它们分别是：安全加密、数据校验、唯一标识、散列函数。今天，我们再来看剩余三种应用：<strong>负载均衡</strong>、<strong>数据分片</strong>、<strong>分布式存储</strong>。</p><p>你可能已经发现，这三个应用都跟分布式系统有关。没错，今天我就带你看下，<font color="red">哈希算法是如何解决这些分布式问题的</font>。</p><a id="more"></a><h2 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h2><p>我们知道，负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个会话粘滞（session sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。</p><p>最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p><ul><li><p><strong>如果客户端很多，映射表可能会很大，比较浪费内存空间</strong></p></li><li><p><strong>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大</strong></p></li></ul><p>如果借助哈希算法，这些问题都可以非常完美地解决。<strong>我们可以通过哈希算法，对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号</strong>。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><p>哈希算法还可以用于数据的分片。这里有两个例子。</p><h3 id="1-如何统计“搜索关键词”出现的次数？"><a href="#1-如何统计“搜索关键词”出现的次数？" class="headerlink" title="1. 如何统计“搜索关键词”出现的次数？"></a>1. 如何统计“搜索关键词”出现的次数？</h3><p>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数，该怎么做呢？</p><p>我们来分析一下。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</p><p>针对这两个难点，<strong>我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。</p><p>这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。</p><p>实际上，这里的处理过程也是 MapReduce 的基本设计思想。</p><h3 id="2-如何快速判断图片是否在图库中？"><a href="#2-如何快速判断图片是否在图库中？" class="headerlink" title="2. 如何快速判断图片是否在图库中？"></a>2. 如何快速判断图片是否在图库中？</h3><p>如何快速判断图片是否在图库中？上一节我们讲过这个例子，不知道你还记得吗？当时介绍了一种方法，即给每个图片取唯一标识（或者信息摘要），然后构建散列表。</p><p>假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。</p><p>我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让每台机器只维护某一部分图片对应的散列表。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。</p><p>当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。</p><p>现在，我们来估算一下，给这 1 亿张图片构建散列表大约需要多少台机器。</p><p>散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节（这里只是估算，并不准确）。</p><p>假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解，能更好地评估解决方案的可行性。</p><p>实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片的思路，可以突破单机内存、CPU 等资源的限制。</p><h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。</p><p>该如何决定将哪个数据放到哪个机器上呢？我们可以借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。</p><p>但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。</p><p>原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了。</p><p><img src="/2018/11/15/18-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8B-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8/f76e08f2-c380-482a-b149-724ee7e2fcc4.jpg" alt></p><p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生<strong>雪崩效应</strong>，压垮数据库。</p><p>所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<strong>一致性哈希算法</strong>就要登场了。</p><p>假设我们有 k 个机器，数据的哈希值的范围是[0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就将某几个小区间的数据，从原来的机器中搬移到新的机器中。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。</p><p>一致性哈希算法的基本思想就是这么简单。除此之外，它还会借助一个虚拟的环和虚拟结点，更加优美地实现出来。</p><p>除了我们上面讲到的分布式缓存，实际上，一致性哈希算法的应用非常广泛，在很多分布式存储系统中，都可以见到一致性哈希算法的影子。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>在负载均衡应用中，利用哈希算法替代映射表，可以实现一个会话粘滞的负载均衡策略。在数据分片应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，可以突破单机资源的限制。在分布式存储应用中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容、缩容导致数据大量搬移的难题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>总共讲了七个哈希算法的应用。实际上，也只是冰山一角，哈希算法还有很多其他的应用，比如网络协议中的 CRC 校验、Git commit id 等等。除了这些，你还能想到其他用到哈希算法的地方吗？</p><p><strong>回答：</strong></p><p>身份证最后一个数组校验，S3协议中的签名校验，HTTPS协议，KMS加密服务。。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-哈希算法上_如何防止数据库中的用户信息被脱库</title>
      <link href="/2018/11/13/17-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8A-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%A2%AB%E8%84%B1%E5%BA%93/"/>
      <url>/2018/11/13/17-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8A-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%A2%AB%E8%84%B1%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得 2011 年 CSDN 的“脱库”事件吗？当时，CSDN 网站被黑客攻击，超过 600 万用户的注册邮箱和密码明文被泄露，很多网友对 CSDN 明文保存用户密码行为产生了不满。如果你是 CSDN 的一名工程师，<font color="red">你会如何存储用户密码这么重要的数据吗？仅仅 MD5 加密一下存储就够了吗？ </font>要想搞清楚这个问题，就要先弄明白哈希算法。</p><p>哈希算法历史悠久，业界著名的哈希算法也有很多，比如 MD5、SHA 等。在我们平时的开发中，基本上都是拿现成的直接用。所以，这篇文章不会重点剖析哈希算法的原理，也不会教你如何设计一个哈希算法，而是从实战的角度告诉你，<strong>在实际的开发中，我们该如何用哈希算法解决问题</strong>。</p><a id="more"></a><h2 id="什么是哈希算法？"><a href="#什么是哈希算法？" class="headerlink" title="什么是哈希算法？"></a>什么是哈希算法？</h2><p>我们前面几节讲到“散列表”“散列函数”，这里又讲到“哈希算法”，你是不是有点一头雾水？实际上，不管是“散列”还是“哈希”，这都是中文翻译的差别，英文其实就是<strong>“Hash”</strong>。所以，我们常听到有人把“散列表”叫作“哈希表”“Hash 表”，把“哈希算法”叫作“Hash 算法”或者“散列算法”。那到底什么是哈希算法呢？</p><p>哈希算法的定义和原理非常简单，基本上一句话就可以概括了。将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是<strong>哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<strong>哈希值</strong>。但是，要想设计一个优秀的哈希算法并不容易，根据经验，总结了需要满足的几点要求：</p><ul><li><p><strong>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）</strong></p></li><li><p><strong>对输入数据非常敏感，哪怕原始数据只修改了一个 Bit，最后得到的哈希值也大不相同</strong></p></li><li><p><strong>列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小</strong></p></li><li><p><strong>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值</strong></p></li></ul><p>这些定义和要求都比较理论，可能还是不好理解，拿 MD5 这种哈希算法来具体说明一下。</p><p>我们分别对“今天我来讲哈希算法”和“jiajia”这两个文本，计算 MD5 哈希值，得到两串看起来毫无规律的字符串（MD5 的哈希值是 128 位的 Bit 长度，为了方便表示，我把它们转化成了 16 进制编码）。可以看出来，无论要哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&quot;今天我来讲哈希算法&quot;) &#x3D; bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(&quot;jiajia&quot;) &#x3D; cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure><p>我们再来看两个非常相似的文本，“我今天讲哈希算法！”和“我今天讲哈希算法”。这两个文本只有一个感叹号的区别。如果用 MD5 哈希算法分别计算它们的哈希值，你会发现，尽管只有一字之差，得到的哈希值也是完全不同的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(&quot;我今天讲哈希算法！&quot;) &#x3D; 425f0d5a917188d2c3c3dc85b5e4f2cb</span><br><span class="line">MD5(&quot;我今天讲哈希算法&quot;) &#x3D; a1fb91ac128e6aa37fe42c663971ac3d</span><br></pre></td></tr></table></figure><p>在前面也说了，通过哈希算法得到的哈希值，很难反向推导出原始数据。比如上面的例子中，我们就很难通过哈希值“a1fb91ac128e6aa37fe42c663971ac3d”反推出对应的文本“我今天讲哈希算法”。</p><p>哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中。比如，我们把今天这篇包含 4000 多个汉字的文章，用 MD5 计算哈希值，用不了 1ms 的时间。</p><p>哈希算法的应用非常非常多，我选了最常见的七个，分别是</p><ul><li><p><strong>安全加密</strong></p></li><li><p><strong>唯一标识</strong></p></li><li><p><strong>数据校验</strong></p></li><li><p><strong>散列函数</strong></p></li><li><p><strong>负载均衡</strong></p></li><li><p><strong>数据分片</strong></p></li><li><p><strong>分布式存储</strong></p></li></ul><p>这节我们先来看前四个应用。</p><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 <strong>MD5</strong>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <strong>SHA</strong>（Secure Hash Algorithm，安全散列算法）。</p><p>除了这两个之外，当然还有很多其他加密算法，比如 <strong>DES</strong>（Data Encryption Standard，数据加密标准）、<strong>AES</strong>（Advanced Encryption Standard，高级加密标准）。</p><p>前面讲到的哈希算法四点要求，对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。</p><p>第一点很好理解，加密的目的就是防止原始数据泄露，所以很难通过哈希值反向推导原始数据，这是一个最基本的要求。所以我着重讲一下第二点。实际上，不管是什么哈希算法，我们只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的。为什么这么说呢？</p><p>里就基于组合数学中一个非常基础的理论，<strong>鸽巢原理</strong>（也叫抽屉原理）。这个原理本身很简单，它是说，如果有 10 个鸽巢，有 11 只鸽子，那肯定有 1 个鸽巢中的鸽子数量多于 1 个，换句话说就是，肯定有 2 只鸽子在 1 个鸽巢内。</p><p>有了鸽巢原理的铺垫之后，我们再来看，为<strong>什么哈希算法无法做到零冲突？</strong></p><p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于鸽巢原理，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^128&#x3D;340282366920938463463374607431768211456</span><br></pre></td></tr></table></figure><p>为了让你能有个更加直观的感受，我找了两段字符串放在这里。这两段字符串经过 MD5 哈希算法加密之后，产生的哈希值是相同的。</p><p><img src="/2018/11/13/17-%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8A-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E8%A2%AB%E8%84%B1%E5%BA%93/e814f9d0-c7a5-4e8c-994d-6c7758ae058c.jpg" alt></p><p>不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。像 MD5，有 2^128 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 1/2^128。</p><p>如果我们拿到一个 MD5 哈希值，希望通过毫无规律的穷举的方法，找到跟这个 MD5 值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是被很难破解的。</p><p>除此之外，没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。我们在实际的开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法。</p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>我先来举一个例子。如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。那我们该如何搜索呢？</p><p>我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时。有没有比较快的方法呢？</p><p>我们可以给每一个图片取一个唯一标识，或者说信息摘要。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>如果还想继续提高效率，我们可以把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。</p><p>如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>电驴这样的 BT 下载软件你肯定用过吧？我们知道，BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。</p><p>我们知道，网络传输是不安全的，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。现在的问题是，如何来校验文件块的安全、正确、完整呢？</p><p>具体的 BT 协议很复杂，校验方法也有很多，我来说其中的一种思路。</p><p>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>前面讲了很多哈希算法的应用，实际上，散列函数也是哈希算法的一种应用。</p><p>我们前两节讲到，散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，散列函数对于散列算法冲突的要求要低很多。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。</p><p>不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，更加关注散列后的值是否能平均分布，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，有了前面的基础，现在你有没有发现开篇的问题其实很好解决？</p><p>我们可以通过哈希算法，对用户密码进行加密之后再存储，不过最好选择相对安全的加密算法，比如 SHA 等（因为 MD5 已经号称被破解了）。不过仅仅这样加密之后存储就万事大吉了吗？</p><p>字典攻击你听说过吗？如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用 00000、123456 这样的简单数字组合做密码，很容易就被猜中。</p><p>那我们就需要维护一个常用密码的字典表，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。（注意，这里说是的是“基本上可以认为”，因为根据我们前面的学习，哈希算法存在散列冲突，也有可能出现，尽管密文一样，但是明文并不一样的情况。）</p><p>针对字典攻击，我们可以引入一个盐（salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。所有的安全措施，只是增加攻击的成本而已。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天的内容比较偏实战，讲到了哈希算法的四个应用场景。一起来回顾一下。</p><p>第一个应用是唯一标识，哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示很大的数据。</p><p>第二个应用是用于校验数据的完整性和正确性。</p><p>第三个应用是安全加密，我们讲到任何哈希算法都会出现散列冲突，但是这个冲突概率非常小。越是复杂哈希算法越难破解，但同样计算时间也就越长。所以，选择哈希算法的时候，要权衡安全性和计算时间来决定用哪种哈希算法。</p><p>第四个应用是散列函数，这个我们前面讲散列表的时候已经详细地讲过，它对哈希算法的要求非常特别，更加看重的是散列的平均性和哈希算法的执行效率。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>现在，区块链是一个很火的领域，它被很多人神秘化，不过其底层的实现原理并不复杂。其中，哈希算法就是它的一个非常重要的理论基础。你能讲一讲区块链使用的是哪种哈希算法吗？是为了解决什么问题而使用的呢？</p><p><strong>回答：</strong></p><p>区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。</p><p>区块头保存着 自己区块体 和 上一个区块头 的哈希值。</p><p>因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。</p><p>区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>加salt，也可理解为为密码加点佐料后再进行hash运算。比如原密码是123456，不加盐的情况加密后假设是是xyz。 黑客拿到脱机的数据后，通过彩虹表匹配可以轻松破解常用密码。如果加盐，密码123456加盐后可能是12ng34qq56zz，再对加盐后的密码进行hash后值就与原密码hash后的值完全不同了。而且加盐的方式有很多种，可以是在头部加，可以在尾部加，还可在内容中间加，甚至加的盐还可以是随机的。这样即使用户使用的是最常用的密码，黑客拿到密文后破解的难度也很高。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop学习</title>
      <link href="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-BigData是什么？"><a href="#1-BigData是什么？" class="headerlink" title="1 BigData是什么？"></a>1 BigData是什么？</h2><p>&nbsp;&nbsp; 巨量资料,需要利用目前主流软件工具在合理的时间范围内对数据进行截取，转换已达到帮助企业获取有用资讯的目的。<br>&nbsp;&nbsp; 数据量极大：GB、TB、PB数据样板足够大。<br>&nbsp;&nbsp; 数据时效性：time-value 数据处理速度快，合理的时间范围。<br>&nbsp;&nbsp; 数据多样性：数据存在形式多样化。<br>&nbsp;&nbsp; 数据可疑性：数据要有价值。—清洗、降噪（沙海淘金）</p><h2 id="2-BigData面临的问题？"><a href="#2-BigData面临的问题？" class="headerlink" title="2 BigData面临的问题？"></a>2 BigData面临的问题？</h2><p>&nbsp;&nbsp; 存储、分析：<br>&nbsp;&nbsp; 方案：<br>&nbsp;&nbsp; 垂直提升：升级硬件，成本高 &nbsp;&nbsp; 计算机-摩尔定律（每18个月，成本不变-性能提升1倍）<br>&nbsp;&nbsp; <font color="red">水平扩展：成本可线性控制–分布式思维&nbsp;&nbsp; √</font><br>&nbsp;&nbsp; <strong>Hadoop</strong>就是在通过线性服务扩展，去解决大数据所面临的存储和计算。<br>&nbsp;&nbsp; <strong>Hadoop</strong>有两个模块：<br>&nbsp;&nbsp; &nbsp;&nbsp; <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS</a> hadoop distributed file system：解决大数据存储问题。<br>&nbsp;&nbsp; &nbsp;&nbsp; MapReduce:通过Map阶段和Reduce阶段实现对大数据的分布式并行计算。</p><a id="more"></a><h2 id="3-Hadoop生态："><a href="#3-Hadoop生态：" class="headerlink" title="3 Hadoop生态："></a>3 Hadoop生态：</h2><p>&nbsp;&nbsp; HDFS：分布式文件存储系统<br>&nbsp;&nbsp; MapReduce：分布式计算引擎<br>&nbsp;&nbsp; HBase：基于HDFS上的一款列存储NoSQL数据库<br>&nbsp;&nbsp; Flume：分布式日志采集<br>&nbsp;&nbsp; Kafka：分布式消息队列<br>&nbsp;&nbsp; <strong>Mahout：机器学习算法库，绝大多数算法通过MapReduce计算模型实现</strong><br>&nbsp;&nbsp; Zookeeper：分布式协调服务<br><strong>大数据计算</strong><br>&nbsp;&nbsp; 离线计算：Hadoop Map Reduce<br>&nbsp;&nbsp; 近实时计算：Spark Core(离线计算)<br>&nbsp;&nbsp; 实时计算：Storm、KafkaStream、SparkStram</p><p><strong>HDFS安装（单机环境-伪分布式）</strong><br>1）CentOS-6.5 64 bit 基本配置<br>&nbsp;&nbsp;&nbsp;&nbsp;1.主机名必须CentOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;sysconfig&#x2F;network </span><br><span class="line">NETWORKING&#x3D;yes</span><br><span class="line">HOSTNAME&#x3D;CentOS</span><br><span class="line">然后reboot即可。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp; 2.修改主机名和ip的映射关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.80.100 CentOS</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp; 3.关闭本机的防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">关机开机自启</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure><p>2）安装 JDK 配置 JAVA_HOME环境变量<br><font color="blue"><br>附注：yum install -y lrzsz     使用rz进行上传<br>lrzsz自行百度（是一款在linux可代替ftp上传和下载的程序）<br></font><br>在usr/local安装jdk-rpm后，使用 <code>ls /usr/java/latest</code>可以产看安装信息<br><font color="red">配置用户环境变量</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS local]# vi .bashrc</span><br><span class="line"># .bashrc</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;latest</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line"></span><br><span class="line">wq保存退出后使用 source .bashrc命令使其立即生效</span><br></pre></td></tr></table></figure><p>使用jps看是否识别：jps [用于查看java进程]</p><p>3）配置 CentOS 系统的 SSH免密码登录（<strong>基于密钥的安全验证</strong>）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始带密码用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.80.100</span><br><span class="line">ssh 身份@主机名</span><br><span class="line">输入 yes 输入密码即可</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSH 为 Secure Shell的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两种安全验证级别：</p><ol><li><p>基于口令的安全验证<br>&nbsp;&nbsp;&nbsp;&nbsp;只要你知道你自己的账号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，即受到<font color="red">中间人</font>这种方式的攻击。</p></li><li><p>基于密钥的安全验证<br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/167b4606-c285-4335-a8c4-f35058d2ea44.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;需要依靠<a href="https://baike.baidu.com/item/%E5%AF%86%E5%8C%99" target="_blank" rel="noopener">密匙</a>，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的<a href="https://baike.baidu.com/item/%E5%8F%A3%E4%BB%A4" target="_blank" rel="noopener">口令</a>。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。<br>第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒</p><h3 id="3-1-在自己的机器上产生公私钥对"><a href="#3-1-在自己的机器上产生公私钥对" class="headerlink" title="3.1 在自己的机器上产生公私钥对"></a>3.1 在自己的机器上产生公私钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa         使用rsa算法生成公私钥对（按4次回家即可）</span><br><span class="line">在用户的家目录下</span><br><span class="line">ls -al .ssh&#x2F;              即可看到</span><br><span class="line">使用 ssh-copy-id CentOS   添加到目标机的目录下（CentOS为目标机名称）</span><br><span class="line">被添加到 .ssh&#x2F;authorized_keys文件中</span><br><span class="line">ls -al .ssh&#x2F;              即可看到</span><br></pre></td></tr></table></figure><p>有了 .ssh/authorized_keys 才可免密码登录，使用 ssh root@CentOS 验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh&#x2F;id_rsa.pub &gt;&gt; .ssh&#x2F;authorized_keys</span><br><span class="line">与</span><br><span class="line">ssh-copy-id CentOS 等价</span><br></pre></td></tr></table></figure><p>4）<strong>安装配置 Hadoop（单机环境）</strong></p><ol><li>解压Hadoop tar包 到 /usr/目录下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf hadoop-2.6.0_x64.tar.gz -C &#x2F;usr&#x2F;</span><br><span class="line">ls &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;</span><br></pre></td></tr></table></figure></li><li>配置hadoop环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> vi .bashrc</span><br><span class="line"> HADOOP_HOME&#x3D;&#x2F;usr&#x2F;hadoop-2.6.0</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;latest</span><br><span class="line">PATH&#x3D;\$PATH:\$JAVA_HOME&#x2F;bin:\$HADOOP_HOME&#x2F;bin:\$HADOOP_HOME&#x2F;sbin</span><br><span class="line">CLASSPATH&#x3D;.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line">export HADOOP_HOME</span><br><span class="line">:wq保存退出</span><br><span class="line">source .bashrc 使其立即生效</span><br></pre></td></tr></table></figure>附注：hadoop的安装目录结构 使用插件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br><span class="line">使用 tree -L 2 &#x2F;usr&#x2F;hadoop-2.6.0&#x2F; </span><br><span class="line">可以查看hadoop的两级目录，2：代表看2级  1：看1级目录</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/02eec767-36ad-402f-8810-01714d9289b5.jpg" alt></p><p>配置参考 <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p><p>这里的/tmp/hadoop-${user.name} 改成 /usr/hadoop-2.6.0/hadoop-${user.name}   安装在父级目录下</p><ol start="3"><li>修改hadoop配置文件(参考上面的链接地址)<br>1 core-site.xml<br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/67e36864-d57b-4d53-a6ee-1caeec63c5cf.png" alt></li></ol><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/8c22fd03-3996-41ba-b054-73e5e67183c2.png" alt></p></li></ol><p><font color="red">此处配置的是访问Namenode服务节点的入口CentOS:9000</font></p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/20153575-b524-4128-ac34-156fb6b3c75e.png" alt></p><p><font color="red">而CentOS:50010是访问Datenode服务节点的入口</font></p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/1673b7cd-f5a0-42fc-b25d-04238010169f.png" alt></p><p><strong>/usr/hadoop-2.6.0/hadoop-root</strong> 此处是整个Hdoop存储的基准目录（无论是Namenode存储元数据，还是Datenode存储块数据）他们都要存储在此基准目录下。（因为用户名是root，所以${user.name}被替换为root)</p><p><strong>使用命令行</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree -L 2 &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;hadoop-root&#x2F;</span><br><span class="line">即可看到 dfs下有data（存储块数据）、name(存储元数据)、namesecondary(秘书)三个文件目录。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;hdfs:&#x2F;&#x2F;CentOS:9000&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;usr&#x2F;hadoop-2.6.0&#x2F;hadoop-$&#123;user.name&#125;&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>  2 hdfs-site.xml</p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/323d8f26-c7c4-40a9-b33e-108dc55f2c8a.png" alt><br><font color="red">此处设置副本集，因为当前是伪分布式，只有一个机器，所以设置为1，块没有副本。</font><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/7c75db69-b861-4a39-8462-59b60988daeb.png" alt><br><font color="red">此处只有CentOS存储了</font></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;&#x2F;hdfs-site.xml</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>   3 slaves<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;slaves </span><br><span class="line">将 localhost 改为 CentOS  即当前的主机名</span><br></pre></td></tr></table></figure><br> <strong>启动 HDFS服务</strong><br>第一次启动时参考链接，使用如下命令进行启动：<br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/3fc6c3f7-29e9-4bab-bd63-a57bb4d70d88.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format  （仅第一次启动时需要）</span><br><span class="line"></span><br><span class="line">start-dfs.sh   启动（其中需要输入yes即可）</span><br><span class="line">jps 出现如下即成功</span><br><span class="line">DataNode</span><br><span class="line">NameNode</span><br><span class="line">SecondaryNameNode</span><br><span class="line">Jps</span><br><span class="line"></span><br><span class="line">也可通过 浏览器 192.168.80.100:50070访问</span><br><span class="line">                本机IP:50070访问</span><br><span class="line">出现Hadoop页面即成功启动</span><br><span class="line"></span><br><span class="line">stop-dfs.sh  （使用此命令关闭hadoop服务）</span><br></pre></td></tr></table></figure><p>使用如下命令进行<font color="red">上传、删除</font>操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put &#x2F;root&#x2F;hadoop-2.6.0_x64.tar.gz &#x2F;</span><br><span class="line">hdfs dfs -rm -r -f &#x2F;hadoop-2.6.0_x64.tar.gz</span><br><span class="line">创建目录：hdfs dfs -mkdir &#x2F;dir</span><br><span class="line">查看目录：hdfs dfs -ls &#x2F;</span><br></pre></td></tr></table></figure><p>页面效果：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/7a72e903-35e7-4c4e-aa3b-f0a0e7496aa6.png" alt><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/9d8d0169-e01e-4092-8998-399a69eec890.png" alt></p><p><strong>为什么需要使用hdfs namenode -format 对“老大”格式化呢？</strong><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/a832df60-4c67-4993-a064-460b7f98de50.png" alt><br>使用 tree /usr/hadoop-2.6.0/hadoop-root/命令可以看到name下的block元数据，例如当前是 <font color="red">blk_1073741827和blk_1073741828</font>，对比下图，可知页面此处存储的是元数据。<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/d1a8e8f4-1c4d-4a7b-a55d-b7f9a2ebf371.png" alt>)<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/8c0f6317-7dac-4998-8639-ae08f1ae312a.png" alt><br><strong>如果启动不起来，只能使用命令 rm -rf /usr/hadoop-2.6.0/hadoop-root，删掉此文件夹，重新格式化 hdfs namenode -format</strong></p><p><strong>如果想要获取某一个切片数据怎么办呢？使用 sz命令层层查找，如图所示：</strong><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/e3b2f8c4-be62-4c14-bbd9-3d809d6ebe45.jpg" alt></p><h2 id="4-Hadoop架构图-三个服务节点详解"><a href="#4-Hadoop架构图-三个服务节点详解" class="headerlink" title="4 Hadoop架构图-三个服务节点详解"></a>4 Hadoop架构图-三个服务节点详解</h2><h3 id="4-1-回顾文件系统-FastDFS-MongDB架构对比"><a href="#4-1-回顾文件系统-FastDFS-MongDB架构对比" class="headerlink" title="4.1 回顾文件系统 FastDFS-MongDB架构对比"></a>4.1 回顾文件系统 FastDFS-MongDB架构对比</h3><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/984cd0ea-bfe4-4798-8ddb-4d6e57638359.jpg" alt><br><font color="red">木桶原理</font>：以性能最短的作为整个集群的上限。<br><font color="red">泳道原理</font>：各司其职，彼此独立。</p><h3 id="4-2-架构图"><a href="#4-2-架构图" class="headerlink" title="4.2 架构图"></a>4.2 架构图</h3><p><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS</a></p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/77d58bfc-e130-4014-b8a2-5b97969a9ab9.jpg" alt></p><p><font color="red">Block</font>：HDFS底层将文件切割成<font color="red">Block</font>，默认切割尺度128MB（切割尺度可配置，若不足128MB，按照实际大小存储成一个Block）.<br><font color="red">Namenode</font>：管理集群元数据（文件名、数据块映射）、下发指令给Datenode<br><font color="red">Datenode</font>：数据节点，负责其存储数据块的读写请求，同时向Namenode汇报自己的状态信息<br><font color="red">Rack</font>：机架，优化存储，优化计算，可以通过命令<code>hdfs dfsadmin -printTopology</code>看到。<br><strong>架构理解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDFS是一个主从架构，HDFS只维护了一个单一的Namenode节点，作为“老大”，这个主节点发号施令，并且存储元信息，监测Datenodes节点群的状态。HDFS有一系列的Datenode节点，作为Namenode的“小弟”， 小弟听从执行老大的各种指令，例如Creation,Deletion,Replication。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Namenode存储的是元数据，也可以理解为块的索引，”一个文件切割成块，就像把大象切割存到了冰箱里，未来如果想要大象在幻化拼接出来，就需要这种索引，即元数据.“，Namenode存的是元数据（索引），而不是数据。这些集群的元数据存储在Namenode节点的内存中，元数据即是文件路径、块到Datenode的映射关系等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Hadoop是以块的形式存储数据的，块的大小是128MB，这是一种切割尺度，例如存出一个文件，如果小于128MB，则切不开，一个块即可存储，此时块的大小即是文件的实际大小</font>,<font color="blue">但是，对于Namenode而言，再小的一个文件也需要记录，需要记录这个块存储在了那个Datenode上面，即块到Datenode的映射关系。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">举个例子：有一个文件，这个文件128MB，按照128MB的尺度去切，能切除一个块出来，Namenode就需要存储一个块的元信息即可；“Hadoop不适合存储小文件”。又比如：有1W个文件，加在一起是128MB，现在用同样的尺度去切，则每一个文件都是一个Block,会产生1W个Block,则Namenode上会存储1W个块的元信息（映射信息）,Datenode存储1W个文件，这1W个文件有128MB，对于Datenode而言，1个128MB的文件和1W个文件总共128MB加在一起去存储，没有任何影响，都是存，但是问题来了，Namenode则得不偿失，Namenode的内存浪费很严重（整个HDFS中只有1个Namenode,其内存及其宝贵）.Datenode不够可以线性扩展。</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看上图可知：Datenode节点之间没有关系，只不过他们之间的Block是有复制的，Hadoop的机制是每一个块，在整个集群中最起码有一个备份，（这里与FastDFS和MongoDB的备份不同，他们是服务器与服务器之间的备份，FastDFS卷内是机器间整体的备份，MongoDB是shard之间整体的备份，而Hadoop做的是块的备份，更细粒度的备份，FastDFS与MongoDB做的是整体间的备份，就要求副本集成员之间机器的配置必须是一样的，而Hadoop则没有这种要求，不管是什么类型的机器，只要能存储数据，我都能利用起来，哪怕是存储一个Block,这样意味着Hadoop对成百上千个Datanode的硬件要求极低(能存就行）。<font color="red">这是Hadoop与传统的分布式文件系统最大的差异,传统的是做机器内部整体的备份，Hadoop没有这个要求，Datanode之间彼此独立，依据各自性能存储不同数量的块。</font>如果有一个机器挂掉了，则有备份，这就是Hadopp做的故障转移，<font color="red">只要保证每个块，存在一定数量的副本即可</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看上面图可知：客户端只要是操作元数据，走的是Namenode。 只要是对块的读写，走的是Datenode,同时，Namenode负责向Datenode发号指令。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Rack:机架</font>，类似于书架(书多了没地方放，有了书架可以更好的管理书籍)，机器多了，就需要机架，更方便的管理机器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于上图，<font color="red">块的复制是机架间的复制，</font>我们都有风险意识，不要把鸡蛋放到一个篮子里，防止鸡飞蛋打。将一批机器放在一个物理的机架上，这批机器共享一个交换机，<font color="red">首先</font>，这样有助于运维，如果这个机架上的某个机器坏了，检修这个机架上的故障机器即可，对别的机架上的机器运转没有影响；<font color="red">其次</font>，如果有电气故障（失火，机器都烧没了），别的机架上的机器不受影响。<font color="blue">安全角度，块的副本集起码不是都在一个机架间的机器上，保证了容灾恢复块数据。</font>效率角度：尽可能做机架内部机器间的通讯，尽量避免跨机架间通信，因为要多走起码一个路由器.</p><p>** HDFS存储特点：**<br> 1）各个DataNode物理服务节点配置物理要求<br> 2）不擅长存储小文件<br><strong>NameNode和Secondary(辅助)NameNode</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为Namenode太忙了，就需要为Namenode配置一个<font color="red">秘书 SecondaryNamenode</font>.类比现实生活：<strong>假如说公司的领导跑路了，小秘在也不能担当领导的职责，总经理跑路了，总经理助理也不能下发任意指令。没有人听总经理助理的命令，不具备对集群的管理能力，充其量就是<font color="red">端茶、倒水、整理文件</font></strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">NameNode</font>主要是维系集群的元数据信息，主要是：<strong>fsimage、edits、edits_inprogress</strong>，而<font color="red">SecondayNameNode</font>充其量只有<strong>fsimage、edits</strong>，缺少了<font color="red">edits_inprogress</font> 类似于下图：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/02668115-cf77-4fc3-8a60-21552578ca51.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>edits与fsimage</strong>：存储在NameNode服务器本地的两个文件，edits文件类似于日志文件，记录的是用户对NameNode元数据的修改；fsimage记录的是内存中的数据。edits和fsimage加起来才等价于<font color="red">老大Memory中的元数据。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Hadoop启动过程与上述两文件的关系：（Memory中元数据的由来）</strong>Hadoop在启动NameNode的时候,<font color="purple">NameNode将fsimage和edits中的数据加载到内存中，fsimage是元数据的二进制信息，而edits是对元数据的修改操作信息；因此会利用edits中的日志对fsimage做一些执行操作，以达到内存中的数据恢复至上一次关机前的内存状态，当内存数据恢复之后，Namenode会刷新这两个文件，结果会导致edits被清空，而fsimage与内存保持高度一致。这些操作都发生在启动过程中</font>，接下来，NameNode开始正常工作，即开始管理Datenode,因为Datenode会汇报自己的状态信息，此时Namenode会将这些收集到的状态信息与自己内存中信息作对比，一旦对比通过，则集群可以正常运行；<font color="red">在此期间，外界可以对HDFS做一些文件上传、修改的指令，此时会分为两个阶段：修改的指令直接发到NameNode的内存中，此时达到了对元数据的修改；同时，内存中的数据是不稳定的，易丢，Hadoop为了保证用户的每一次操作都是安全的，会将写的数据存入edits日志中，此刻，内存中的数据才是整个NameNode所有的数据（原始的+新发送的指令数据）,edits+fsimage才等于内存中的数据，问题来了？如果Hadoop长时间工作在一个修改比较频繁的环境下，会导致edits会越来越大（Memory的内存消耗暂时不看），对比Redis的AOF持久化，AOF记录的是内存中所有的操作，而edits记录的只是从这一次启动到正常工作以后所有的修改操作的增量，会导致edits文件越来越大，如果edits有一种机制：可以flush就好了，即刷新fsimage到磁盘即可，只要刷新成功，edits中的数据既可以释放。</font>但是。如果去刷新fsimage,会拉低NameNode的性能（NameNode的神经是紧绷的，因为他要管理整个集群的信息，有成千上百个人等着我去主持会议，汇报工作，发布指令，能让我在家里整理内务？），如果刷新成功，当关闭再次开启的时候，edtits不会有那么大了，Namenode启动就会十分快了，反之，Namenode没有时间去整理自己的edits，下一次启动还是走上述两个阶段，还是慢的要死。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个公司的规模如果十分大了，就会想方设法提高效率，总裁级别的人一般都有小秘，小秘<font color="red">辅助</font>的做一些日常工作，再怎么辅助，不能干预公司的决定，古代宦官、后宫不能干政是一个道理。让小秘去整理内务，没让小秘去管理自己的小弟，况且小弟也不会听小秘的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">SecondaryNameNode就相当于给NameNode请了一个小秘、保姆、助理</font>.助理没有非常大的权利，但是待遇很好，总裁在那个办公室，小秘就在总裁办公室的旁边，<strong>有点像皇帝身边的太监</strong>。为什么待遇这么好呢？小秘给总经理做事，总经理的一些私事是不想让小弟知道的，小秘要保密的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，NameNode负责去管理元数据和DateNode，但因为分身乏术，疏于对自己自身数据的持久化，丧失了对自己数据的管理能力，就需要有一个和NameNode内存、配置一样的机器，因为SecondaryNameNode会定时的去访问NameNode,问NameNode需不需要我来做整理啊？此处的“问”就是去查NameNode的edits文件有多大了，距离我上一次来整理你过了多长时间了，如果这两个条件满足了，即<font color="red">时间到了而且文件过大了</font>,小秘就会拷贝-下载（不能拿走，即剪切，总经理要用怎么办呢？）edits和fsimage各一份到自己的本地磁盘中，在拷贝的过程中，总经理还在忙（比如还有人要修改文件），怎么办呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">NameNode中的edits_inprogress登场了，即准备一个临时的文件，如果有人发来的写的指令，总裁就先将指令暂存到edits_inprogerss文件中，同时，小秘会在自己内存中模拟总裁以前的NameNode的过程，加载、合并，拿到一个更新的fsimage,比总裁的fsimage心新，因为在小秘那里，原有的fsimage已经和edits合并了，当然是最新的了；然后小秘会将自己最新的fsimage(已经整理好的文件)再次上传给总裁那里，为了不与总裁原有的fsimage命名冲突，给他叫做fsimage.chk文件，（chk:取自50070中页面里的save checkpoint 检查点）。</font><font color="red">上传、下载走的都是http协议</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传结束后，NameNode就不再需要edits和fsimage这两个文件了，会用edits_inprogress和fsimage.chk替换掉原有的edits和fsimage。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，NameNode工作起来就很流畅了，负责管理DateNode，管理元数据，没有时间整理内务，整理内务的工作由SecondaryNameNode来做，小秘至少的配置是内存与总裁的一致。小秘不在了，挂掉了，集群仍可以正常访问，NameNode会在第一次启动的时候整理自己的内存文件，会导致如果长时间运行，下次再启动的时候，启动时间过长。因此，<font color="red">NameNode挂了，休想通过SecondaryNaemNode来进行恢复，但有一种极端情况，在小秘下载合并之前，没有人对NameNode做出修改指令，此时是可以考虑从小秘那里来恢复的</font></p><h2 id="5-HDFS-Shell-amp-JAVA-API"><a href="#5-HDFS-Shell-amp-JAVA-API" class="headerlink" title="5 HDFS Shell &amp; JAVA API"></a>5 HDFS Shell &amp; JAVA API</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html" target="_blank" rel="noopener"><strong>HDFS命令参考</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">命令帮助：</span><br><span class="line">hdfs dfs -help   或者 hadoop fs -help</span><br><span class="line">常用命令解释：</span><br><span class="line">-appendToFile：追加至文件</span><br><span class="line">-cat：查看</span><br><span class="line">-chmod：修改权限</span><br><span class="line">-copyFromLocal：从本地上传文件到hdfs</span><br><span class="line">-copyToLocal：从hdfs下载文件到本地</span><br><span class="line">上面两个都是linux与hdfs跨机器间的文件交流</span><br><span class="line">-cp：hdfs文件间的相互拷贝，集群内部的</span><br><span class="line">-df：查看磁盘使用情况</span><br><span class="line">-du：查看目录使用情况</span><br><span class="line">-get：下载</span><br><span class="line">-ls：展示文件目录</span><br><span class="line">-mkdir:创建目录</span><br><span class="line">-moveFromLocal：从本机剪切文件到hdfs</span><br><span class="line">-moveToLocal：从hdfs剪切文件到本地</span><br><span class="line">-mv：hdfs集群内部文件的移动</span><br><span class="line">-put：上传</span><br><span class="line">-rm [-r] [-f] ：删除文件</span><br><span class="line">-tail -f :查看</span><br><span class="line">-text: 查看</span><br><span class="line">-touchz：创建衣一个空白文件</span><br><span class="line"></span><br><span class="line">案例</span><br><span class="line">[root@CentOS ~]# hadoop fs -appendToFile &#x2F;root&#x2F;install.log &#x2F;aa.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -cat  &#x2F;aa.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -copyToLocal &#x2F;aa.log &#x2F;root&#x2F;</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -mkdir -p &#x2F;dir1&#x2F;dir2</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -cp &#x2F;aa.log &#x2F;dir1&#x2F;dir2</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -mv &#x2F;aa.log &#x2F;ab.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -touchz &#x2F;hello.java</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -rm -r -f &#x2F;dir1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>JAVA API 操作HDFS</strong></p><ol><li><p>搭建 window开发环境<br>a. 解压 hadoop安装包到 C:/</p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/c21d3f86-602a-4632-9b54-1c3ffb4bd5f3.png" alt></p><p>b. 配置 HADOOP_HOME 环境变量</p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/312f00b3-d45d-41aa-b1a6-a0fef6da117e.png" alt></p><p>c. 拷贝 winutil.exe和hadoop.dll文件到hadoop安装bin目录下</p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/3ac8ee8d-48dc-478d-bea4-3c0fd776e6b1.jpg" alt><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/683955c3-5970-4d07-bcce-7e909a6f6360.png" alt></p><p>d. 在Windows上配置CentOS上配置主机名和IP映射关系</p><p><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/f9897f92-69cf-4274-91e4-4c18d6ad7604.png" alt></p><p>e. 重启IDE<br><strong>导入Maven依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-hdfs&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>API代码</strong><br>上传1：<br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/9efe882e-1c3d-4850-9e54-692a77f8e337.jpg" alt><br><img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/5abcc04c-fda4-411f-a0e4-66041c5deae0.jpg" alt></p></li></ol><p><strong>启动报错：</strong>因为当前是在Windows下操作Hadoop,用户是Administrator,不是root,所以不能操作，Linux上的Root用户才有的操作方法。可以从两处修改：<br>  A：关闭Hadoop的系统权限，DFS permission配置  true改为false即可。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  修改hdfs-site.xml</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfspermission&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><br>  B：修改虚拟机的启动参数，告诉虚拟机是以root用户去连接。<br>  <img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/7b50ef60-63f5-4b20-a613-f91b65ee85bc.jpg" alt><br>上传2：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/2748002c-4c99-4cdd-b356-237652509cf4.jpg" alt><br>结果：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/68b62ece-a2a3-4c62-a3db-88f5e0d59ef9.jpg" alt><br><font color="red">客户端可以用如下代码设置副本集个数</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Before</span><br><span class="line">public void before()throws IOException&#123;</span><br><span class="line">    Configuration conf &#x3D; new Configuration();</span><br><span class="line">    conf.set(&quot;fs.defaultFS&quot;,&quot;http:&#x2F;&#x2F;CentOS:9000&quot;);</span><br><span class="line">    conf.set(&quot;dfs.replication&quot;,&quot;1&quot;); &#x2F;&#x2F;设置副本集</span><br><span class="line">    fs &#x3D; FileSysten.get(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/7a522c44-979c-4d76-947c-b16eaa0d094c.jpg" alt><br>创建目录（“true”存在就递归删除，不存在就创建）：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/430bfe18-50fc-4d96-afa7-82e86c19376d.jpg" alt><br>展示目录下的内容：<img src="/2018/11/10/Hadoop%E5%AD%A6%E4%B9%A0/198c9b96-5511-4adb-b818-745806da174e.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-散列表下_为什么散列表和链表经常一起使用</title>
      <link href="/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你有没有发现，有两种数据结构，散列表和链表，经常会被放在一起使用。你还记得，前面的章节中都有哪些地方讲到散列表和链表的组合使用吗？我带你一起回忆一下。</p><p>在链表那一节，我讲到如何用链表来实现 LRU 缓存淘汰算法，但是链表实现的 LRU 缓存淘汰算法的时间复杂度是 O(n)，当时我也提到了，通过散列表可以将这个时间复杂度降低到 O(1)。</p><p>在跳表那一节，我提到 Redis 的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。当时我们也提到，Redis 有序集合不仅使用了跳表，还用到了散列表。</p><p>除此之外，如果你熟悉 Java 编程语言，你会发现 LinkedHashMap 这样一个常用的容器，也用到了散列表和链表两种数据结构。</p><p>今天，我们就来看看，在这几个问题中，散列表和链表都是如何组合起来使用的，以及为什么散列表和链表会经常放到一块使用。</p><a id="more"></a><h2 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h2><p>链表那一节中，我提到，借助散列表，我们可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)。现在，我们就来看看它是如何做到的。</p><p>首先，我们来回顾一下当时我们是如何通过链表实现 LRU 缓存淘汰算法的。</p><p>我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。</p><p>实际上，总结一下，一个缓存（cache）系统主要包含下面这几个操作：</p><ul><li><p><strong>往缓存中添加一个数据</strong></p></li><li><p><strong>从缓存中删除一个数据</strong></p></li><li><p><strong>在缓存中查找一个数据</strong></p></li></ul><p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：</p><p><img src="/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/1f6f32a0-88a5-4d88-807a-cccc8dbd6ec0.jpg" alt></p><p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？</p><p>因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的<strong>双向链表</strong>，另一个链是散列表中的<strong>拉链</strong>。<strong>前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中</strong>。</p><p>了解了这个散列表和双向链表的组合存储结构之后，我们再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是 O(1) 的？</p><p>首先，我们来看<strong>如何查找一个数据</strong>。我们前面讲过，散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。</p><p>其次，我们来看<strong>如何删除一个数据</strong>。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p><p>最后，我们来看<strong>如何添加一个数据</strong>。添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p><p>这整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 O(1)。至此，我们就通过散列表和双向链表的组合使用，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型。</p><h2 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h2><p>在跳表那一节，讲到有序集合的操作时，我稍微做了些简化。实际上，在有序集合中，每个成员对象有两个重要的属性，<strong>key</strong>（键值）和 <strong>score</strong>（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。</p><p>举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。</p><p>所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p><ul><li><p><strong>添加一个成员对象</strong></p></li><li><p><strong>按照键值来删除一个成员对象</strong></p></li><li><p><strong>按照键值来查找一个成员对象</strong></p></li><li><p><strong>照分值区间查找数据，比如查找积分在[100, 356]之间的成员对象</strong></p></li><li><p><strong>按照分值从小到大排序成员变量</strong></p></li></ul><p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。</p><p>实际上，Redis 有序集合的操作还有另外一类，也就是查找成员对象的排名（Rank）或者根据排名区间查找成员对象。这个功能单纯用刚刚讲的这种组合结构就无法高效实现了。这块内容后续文章再讲。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>前面我们讲了两个散列表和链表结合的例子，现在我们再来看另外一个，Java 中的 LinkedHashMap 这种容器。</p><p>果你熟悉 Java，那你几乎天天会用到这个容器。我们之前讲过，HashMap 底层是通过散列表这种数据结构实现的。而 LinkedHashMap 前面比 HashMap 多了一个“Linked”，这里的“Linked”是不是说，LinkedHashMap 是一个通过链表法解决散列冲突的散列表呢？</p><p>实际上，LinkedHashMap 并没有这么简单，其中的“Linked”也并不仅仅代表它是通过链表法解决散列冲突的。关于这一点，在我是初学者的时候，也误解了很久。</p><p>我们先来看一段代码。你觉得这段代码会以什么样的顺序打印 3，1，5，2 这几个 key 呢？原因又是什么呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">m.put(3, 11);</span><br><span class="line">m.put(1, 12);</span><br><span class="line">m.put(5, 23);</span><br><span class="line">m.put(2, 22);</span><br><span class="line"></span><br><span class="line">for (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我先告诉你答案，上面的代码会按照数据插入的顺序依次来打印，也就是说，打印的顺序就是 3，1，5，2。你有没有觉得奇怪？散列表中数据是经过散列函数打乱之后无规律存储的，这里是如何实现按照数据的插入顺序来遍历打印的呢？</p><p>你可能已经猜到了，LinkedHashMap 也是通过散列表和链表组合在一起实现的。实际上，它不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据。你可以看下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 10是初始大小，0.75是装载因子，true是表示按照访问时间排序</span><br><span class="line">HashMap&lt;Integer, Integer&gt; m &#x3D; new LinkedHashMap&lt;&gt;(10, 0.75f, true);</span><br><span class="line">m.put(3, 11);</span><br><span class="line">m.put(1, 12);</span><br><span class="line">m.put(5, 23);</span><br><span class="line">m.put(2, 22);</span><br><span class="line"></span><br><span class="line">m.put(3, 26);</span><br><span class="line">m.get(5);</span><br><span class="line"></span><br><span class="line">for (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">  System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码打印的结果是 1，2，3，5。我来具体分析一下，为什么这段代码会按照这样顺序来打印。</p><p>每次调用 put() 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：</p><p><img src="/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/a3f444e9-72c8-4300-9284-b851cd5fe9d5.jpg" alt></p><p>在第 8 行代码中，再次将键值为 3 的数据放入到 LinkedHashMap 的时候，会先查找这个键值是否已经有了，然后，再将已经存在的 (3,11) 删除，并且将新的 (3,26) 放到链表的尾部。所以，这个时候链表中的数据就是下面这样:</p><p><img src="/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/9a51688d-cf8d-45dc-8681-8f5557e9181e.jpg" alt></p><p>当第 9 行代码访问到 key 为 5 的数据的时候，我们将被访问到的数据移动到链表的尾部。所以，第 9 行代码之后，链表中的数据是下面这样：</p><p><img src="/2018/11/09/16-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8B-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/76d21396-0fe9-4b5c-a935-dee40bc61f08.jpg" alt></p><p>所以，最后打印出来的数据是 1，2，3，5。从上面的分析，你有没有发现，按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统？实际上，它们两个的实现原理也是一模一样的。</p><p>总结一下，实际上，<strong>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突</strong>。</p><h2 id="解答开篇-amp-内容小结"><a href="#解答开篇-amp-内容小结" class="headerlink" title="解答开篇 &amp; 内容小结"></a>解答开篇 &amp; 内容小结</h2><p>弄懂刚刚我讲的这三个例子，开篇的问题也就不言而喻了。这里总结一下，为什么散列表和链表经常一块使用？</p><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>个人感觉其实就两种数据结构，链表和数组。</p><p>数组占据随机访问的优势，却有需要连续内存的缺点。</p><p>链表具有可不连续存储的优势，但访问查找是线性的。</p><p>散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。</p><p>我们可以得出数据结构和算法的重要性排行榜：连续空间 &gt; 时间 &gt; 碎片空间。</p><hr><p>看好些人询问LRU中设计的到pre，next和hnext的具体含义，将自己的理解说下，pre和next组成双向链表，这个链表是按照缓存的时间由大到小，组成的一个缓存队列；对于hnext作用是，在最新时间插入缓存数据时，通过哈希函数得出的冲突，用其连接。<br>总结：在双向链表中，时间是从大到小；在hnext组成的拉链中，时间从左到右依次变小。<br>核心：数据结构的设计，一定是建立应用场景之上，根据最新时间加入缓存。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 今天讲的几个散列表和链表结合使用的例子里，我们用的都是双向链表。如果把双向链表改成单链表，还能否正常工作呢？为什么呢？</p><p>2 假设猎聘网有 10 万名猎头，每个猎头都可以通过做任务（比如发布职位）来积累积分，然后通过积分来下载简历。假设你是猎聘网的一名工程师，如何在内存中存储这 10 万个猎头 ID 和积分信息，让它能够支持这样几个操作：</p><ul><li><p><strong>根据猎头的 ID 快速查找、删除、更新这个猎头的积分信息</strong></p></li><li><p><strong>查找积分在某个区间的猎头 ID 列表</strong></p></li><li><p><strong>查找按照积分从小到大排名在第 x 位到第 y 位之间的猎头 ID 列表</strong></p></li></ul><p><strong>回答：</strong></p><p>1 </p><p>在删除一个元素时，虽然能 O(1) 的找到目标结点，但是要删除该结点需要拿到前一个结点的指针，遍历到前一个结点复杂度会变为 O(N），所以用双链表实现比较合适。</p><p>（但其实硬要操作的话，单链表也是可以实现 O(1) 时间复杂度删除结点的）。</p><p>2 </p><p>以积分排序构建一个跳表，再以猎头 ID 构建一个散列表。</p><p>1）ID 在散列表中所以可以 O(1) 查找到这个猎头；</p><p>2）积分以跳表存储，跳表支持区间查询；</p><p>3）这点根据目前学习的知识暂时无法实现，老师文中也提到了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-散列表中_如何打造一个工业级水平的散列表</title>
      <link href="/2018/11/09/15-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2018/11/09/15-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过上一篇的学习，我们知道，散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p><p>今天，我们就来学习一下，<font color="red">如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</font></p><a id="more"></a><h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。那什么才是好的散列函数呢？</p><p>首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。</p><p>第一个例子就是我们上一节的学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫作“数据分析法”。</p><p>第二个例子就是上一节的开篇思考题，如何实现 Word 拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的<strong>ASCll 码值</strong>“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(&quot;nice&quot;)&#x3D;((&quot;n&quot; - &quot;a&quot;) * 26*26*26 + (&quot;i&quot; - &quot;a&quot;)*26*26 + (&quot;c&quot; - &quot;a&quot;)*26+ (&quot;e&quot;-&quot;a&quot;)) &#x2F; 78978</span><br></pre></td></tr></table></figure><h2 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h2><p>我们上一节讲到散列表的装载因子的时候说过，装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p><p>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，我们该如何处理呢？</p><p>还记得我们前面多次讲的“动态扩容”吗？你可以回想一下，我们是如何做数组、栈、队列的动态扩容的。</p><p>针对散列表，当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p><p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。</p><p>你可以看我图里这个例子。在原来的散列表中，21 这个元素原来存储在下标为 0 的位置，搬移到新的散列表中，存储在下标为 7 的位置。</p><p><img src="/2018/11/09/15-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/18f97b17-52bb-44ef-931b-88f9f1146b27.jpg" alt></p><p>对于支持动态扩容的散列表，插入操作的时间复杂度是多少呢？前面章节我已经多次分析过支持动态扩容的数组、栈等数据结构的时间复杂度了。所以，这里我就不啰嗦了，你要是还不清楚的话，可以回去复习一下。</p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p><p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p><p>我们前面讲到，当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p><h2 id="如何避免低效地扩容？"><a href="#如何避免低效地扩容？" class="headerlink" title="如何避免低效地扩容？"></a>如何避免低效地扩容？</h2><p>我们刚刚分析得到，大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>我举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，听起来就很耗时，是不是？</p><p>如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p><p><img src="/2018/11/09/15-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/d34bacee-e47a-47c5-ab46-ed7735fbfb4f.jpg" alt></p><p>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p><h2 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h2><p>上一节我们讲了两种主要的散列冲突的解决办法，开放寻址法和链表法。这两种冲突解决办法在实际的软件开发中都非常常用。比如，Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。那你知道，这两种冲突解决方法各有什么优势和劣势，又各自适用哪些场景吗？</p><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>我们先来看看，开放寻址法的优点有哪些。</p><p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。你可不要小看序列化，很多场合都会用到的。我们后面就有一节会讲什么是数据结构序列化、如何序列化，以及为什么要序列化。</p><p>我们再来看下，开放寻址法有哪些缺点。</p><p>一节我们讲到，用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p>所以，<strong>总结一下，当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因</strong>。</p><h3 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2. 链表法"></a>2. 链表法</h3><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>还记得我们之前在链表那一节讲的吗？链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p><p>当然，如果我们存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p><p><img src="/2018/11/09/15-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%AD-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%B8%9A%E7%BA%A7%E6%B0%B4%E5%B9%B3%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8/9503c27c-7d83-43d8-b767-e176f5d03d44.jpg" alt></p><p>所以，<strong>总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p><h2 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h2><p>刚刚我讲了实现一个工业级散列表需要涉及的一些关键技术，现在，我就拿一个具体的例子，Java 中的 HashMap 这样一个工业级的散列表，来具体看下，这些技术是怎么应用的。</p><h3 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h3><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p><h3 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2. 装载因子和动态扩容"></a>2. 装载因子和动态扩容</h3><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h3 id="3-散列冲突解决方法"><a href="#3-散列冲突解决方法" class="headerlink" title="3. 散列冲突解决方法"></a>3. 散列冲突解决方法</h3><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p><p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4. 散列函数"></a>4. 散列函数</h3><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。我把它摘抄出来，你可以看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int hash(Object key) &#123;</span><br><span class="line">    int h &#x3D; key.hashCode()；</span><br><span class="line">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); &#x2F;&#x2F;capicity表示散列表的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">  int var1 &#x3D; this.hash;</span><br><span class="line">  if(var1 &#x3D;&#x3D; 0 &amp;&amp; this.value.length &gt; 0) &#123;</span><br><span class="line">    char[] var2 &#x3D; this.value;</span><br><span class="line">    for(int var3 &#x3D; 0; var3 &lt; this.value.length; ++var3) &#123;</span><br><span class="line">      var1 &#x3D; 31 * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    this.hash &#x3D; var1;</span><br><span class="line">  &#125;</span><br><span class="line">  return var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容就讲完了，我现在来分析一下开篇的问题：如何设计的一个工业级的散列函数？如果这是一道面试题或者是摆在你面前的实际开发问题，你会从哪几个方面思考呢？</p><p>首先，我会思考，<strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong></p><p>结合已经学习过的散列知识，我觉得应该有这样几点要求：</p><ul><li><p><strong>支持快速的查询、插入、删除操作</strong></p></li><li><p><strong>内存占用合理，不能浪费过多的内存空间</strong></p></li><li><p><strong>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况</strong></p></li></ul><p><strong>如何实现这样一个散列表呢？</strong>根据前面讲到的知识，可以从三个方面来考虑设计思路：</p><ul><li><p><strong>设计一个合适的散列函数</strong></p></li><li><p><strong>定义装载因子阈值，并且设计动态扩容策略</strong></p></li><li><p><strong>选择合适的散列冲突解决方法</strong></p></li></ul><p>关于散列函数、装载因子、动态扩容策略，还有散列冲突的解决办法，我们前面都讲过了，具体如何选择，还要结合具体的业务场景、具体的业务数据来具体分析。不过只要我们朝这三个方向努力，就离设计出工业级的散列表不远了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>一节的内容比较偏理论，今天的内容侧重实战。主要讲了如何设计一个工业级的散列表，以及如何应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。分了三部分来讲解这些内容，分别是：如何设计散列函数，如何根据装载因子动态扩容，以及如何选择散列冲突解决方法。</p><p><strong>关于散列函数的设计</strong>，我们要尽可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响散列表的性能。</p><p><strong>关于散列冲突解决方法的选择</strong>，我对比了开放寻址法和链表法两种方法的优劣和适应的场景。大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成 O(n)，抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p><p>对于动态散列表来说，不管我们如何设计散列函数，选择什么样的散列冲突解决方法。随着数据的不断增加，散列表总会出现装载因子过高的情况。这个时候，我们就需要启动动态扩容。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int hash(Object key) &#123;</span><br><span class="line">    int h &#x3D; key.hashCode()；</span><br><span class="line">    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1); &#x2F;&#x2F;capicity 表示散列表的大小</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK HashMap源码中，是分两步走的：</p><p>1. hash值的计算，源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">        int hash;</span><br><span class="line">        return key &#x3D;&#x3D; null ? 0 : (hash &#x3D; key.hashCode()) ^ hash &gt;&gt;&gt; 16;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>2. 在插入或查找的时候，计算Key被映射到桶的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int index &#x3D; hash(key) &amp; (capacity - 1)</span><br></pre></td></tr></table></figure><p>JDK HashMap中hash函数的设计，确实很巧妙：</p><p>首先hashcode本身是个32位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA规范），这也是大家常说的，重写equals必须重写hashcode的重要原因。</p><p>获取对象的hashcode以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode &gt;&gt;&gt; 16)，这一步甚是巧妙，是将高16位移到低16位，这样计算出来的整型值将“具有”高位和低位的性质</p><p>最后，用hash表当前的容量减去一，再和刚刚计算出来的整型值做位与运算。进行位与运算，很好理解，是为了计算出数组中的位置。</p><p>但这里有个问题：为什么要用容量减去一？</p><p>因为 A % B = A &amp; (B - 1)，所以，(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity，可以看出这里本质上是使用了「除留余数法」</p><p>综上，可以看出，hashcode的随机性，加上移位异或算法，得到一个非常随机的hash值，再通过「除留余数法」，得到index，整体的设计过程与上文所说的“散列函数”设计原则非常吻合！</p><h2 id="知识总结"><a href="#知识总结" class="headerlink" title="知识总结"></a>知识总结</h2><p>一、如何设计散列函数？</p><p>1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。</p><p>2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。</p><p>3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。</p><p>二、如何根据装载因子动态扩容？</p><p>1.如何设置装载因子阈值？</p><p>①可以通过设置装载因子的阈值来控制是扩容还是缩容，支持动态扩容的散列表，插入数据的时间复杂度使用摊还分析法。</p><p>②装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如何权衡？如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。</p><p>2.如何避免低效扩容？分批扩容</p><p>①分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。</p><p>②分批扩容的查询操作：先查新散列表，再查老散列表。</p><p>③通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。</p><p>三、如何选择散列冲突解决方法？</p><p>①常见的2中方法：开放寻址法和链表法。</p><p>②大部分情况下，链表法更加普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。</p><p>③但是，对于小规模数据、装载因子不高的散列表，比较适合用开放寻址法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-散列表上_Word文档中的单词拼写检查功能如何实现</title>
      <link href="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Word 这种文本编辑器你平时应该经常用吧，那你有没有留意过它的拼写检查功能呢？一旦我们在 Word 里输入一个错误的英文单词，它就会用标红的方式提示“拼写错误”。</p><p><font color="red">Word 的这个单词拼写检查功能，虽然很小但却非常实用。你有没有想过，这个功能是如何实现的呢？</font></p><p>其实啊，一点儿都不难。只要你学完今天的内容，散列表（Hash Table）。你就能像微软 Office 的工程师一样，轻松实现这个功能。</p><a id="more"></a><h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”，你一定也经常听过它，在前面的文章里，也不止一次提到过，但是你是不是真的理解这种数据结构呢？</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p>我用一个例子来解释一下。假如我们有 89 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 89 名选手的编号依次是 1 到 89。现在我们希望编程实现这样一个功能，通过编号快速找到对应的选手信息。你会怎么做呢？</p><p>我们可以把这 89 名选手的信息放在数组里。编号为 1 的选手，我们放到数组中下标为 1 的位置；编号为 2 的选手，我们放到数组中下标为 2 的位置。以此类推，编号为 k 的选手放到数组中下标为 k 的位置。</p><p>因为参赛编号跟数组下标一一对应，当我们需要查询参赛编号为 x 的选手的时候，我们只需要将下标为 x 的数组元素取出来就可以了，时间复杂度就是 O(1)。这样按照编号查找选手信息，效率是不是很高？</p><p>实际上，这个例子已经用到了散列的思想。在这个例子里，参赛编号是自然数，并且与数组的下标形成一一映射，所以利用数组支持根据下标随机访问的时候，时间复杂度是 O(1) 这一特性，就可以实现快速查找编号对应的选手信息。</p><p>你可能要说了，这个例子中蕴含的散列思想还不够明显，那我来改造一下这个例子。</p><p>假设校长说，参赛编号不能设置得这么简单，要加上年级、班级这些更详细的信息，所以我们把编号的规则稍微修改了一下，用 6 位数字来表示。比如 051167，其中，前两位 05 表示年级，中间两位 11 表示班级，最后两位还是原来的编号 1 到 89。这个时候我们该如何存储选手信息，才能够支持通过编号来快速查找选手信息呢？</p><p>思路还是跟前面类似。尽管我们不能直接把编号作为数组下标，但我们可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，我们用同样的方法，取参赛编号的后两位，作为数组下标，来读取数组中的数据。</p><p>这就是典型的散列思想。其中，参赛选手的编号我们叫作<strong>键</strong>（key）或者<strong>关键字</strong>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash 值”“哈希值”）。</p><p><img src="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/197a76d0-f233-4fc5-89cc-07f77f9afc2a.jpg" alt></p><p>通过这个例子，我们可以总结出这样的规律：散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>从上面的例子我们可以看到，散列函数在散列表中起着非常关键的作用。现在我们就来学习下散列函数。</p><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 <strong>hash(key)</strong>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p>那第一个例子中，编号就是数组下标，所以 hash(key) 就等于 key。改造后的例子，写成散列函数稍微有点复杂。我用伪代码将它写成函数就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int hash(String key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取后两位字符</span><br><span class="line">  string lastTwoChars &#x3D; key.substr(length-2, length);</span><br><span class="line">  &#x2F;&#x2F; 将后两位字符转换为整数</span><br><span class="line">  int hashValue &#x3D; convert lastTwoChas to int-type;</span><br><span class="line">  return hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚举的学校运动会的例子，散列函数比较简单，也比较容易想到。但是，如果参赛选手的编号是随机生成的 6 位数字，又或者用的是 a 到 z 之间的字符串，<strong>该如何构造散列函数呢？这里总结了三点散列函数设计的基本要求</strong>：</p><ul><li><p><strong>散列函数计算得到的散列值是一个非负整数</strong></p></li><li><p><strong>如果 key1 = key2，那 hash(key1) == hash(key2)</strong></p></li><li><p><strong>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</strong></p></li></ul><p>我来解释一下这三点。其中，第一点理解起来应该没有任何问题。因为数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数。第二点也很好理解。相同的 key，经过散列函数得到的散列值也应该是相同的。</p><p>第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种<strong>散列冲突</strong>。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</p><p>所以我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，我们需要通过其他途径来解决。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>再好的散列函数也无法避免散列冲突。那究竟该如何解决散列冲突问题呢？我们常用的散列冲突解决方法有两类，<strong>开放寻址法</strong>（open addressing）和<strong>链表法</strong>（chaining）。</p><h3 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h3><p>开放寻址法的核心思想是，如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？先讲一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。</p><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>我说的可能比较抽象，我举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。</p><p><img src="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/bb1127d6-8488-4ecc-9193-19e285ff833e.jpg" alt></p><p>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p><p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p><p><img src="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/9126b0d33476777e7371b96e676e90ff.jpg" alt></p><p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别。我们不能单纯地把要删除的元素设置为空。这是为什么呢？</p><p>还记得我们刚讲的查找操作吗？在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p><p>我们可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p><p><img src="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/2f3998de-3d3b-418e-9ded-a51e9bc2afbe.jpg" alt></p><p>你可能已经发现了，线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+1<sup>2</sup>，hash(key)+2<sup>2</sup>……</p><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<strong>装载因子</strong>（load factor）来表示空位的多少。</p><p>装载因子的计算公式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2. 链表法"></a>2. 链表法</h3><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p><p><img src="/2018/11/08/14-%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%8A-Word%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/49734c0c-2f61-484b-b9d1-313e4640cabd.jpg" alt></p><p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p><p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>有了前面这些基本知识储备，我们来看一下开篇的思考题：Word 文档中单词拼写检查功能是如何实现的？</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天讲了一些比较基础、比较偏理论的散列表知识，包括散列表的由来、散列函数、散列冲突的解决方法。</p><p>散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。散列表两个核心问题是<strong>散列函数设计</strong>和<strong>散列冲突解决</strong>。散列冲突有两种常用的解决方法，开放寻址法和链表法。散列函数设计的好坏决定了散列冲突的概率，也就决定散列表的性能。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1 假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p><p>2 有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p><p><strong>第一个</strong>：</p><p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p><p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p><p><strong>第二个：</strong></p><p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-跳表_为什么Redis一定要用跳表来实现有序集合</title>
      <link href="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/"/>
      <url>/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><a href="https://github.com/wangzheng0822/algo" target="_blank" rel="noopener">王争GitHub跳表Java实现</a></p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上两节我们讲了二分查找算法。当时我讲到，因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？</p><p>实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫作<strong>跳表</strong>（Skip list），也就是今天要讲的内容。</p><p>跳表这种数据结构对你来说，可能会比较陌生，因为一般的数据结构和算法书籍里都不怎么会讲。但是它确实是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代<strong>红黑树（Red-black tree）</strong>。</p><p>Redis 中的有序集合（Sorted Set）就是用跳表来实现的。如果你有一定基础，应该知道红黑树也可以实现快速的插入、删除和查找操作。<font color="red">那 Redis 为什么会选择用跳表来实现有序集合呢？</font> 为什么不用红黑树呢？学完今天的内容，你就知道答案了。</p><a id="more"></a><h2 id="如何理解“跳表”"><a href="#如何理解“跳表”" class="headerlink" title="如何理解“跳表”"></a>如何理解“跳表”</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/fca3a729-2a1c-4204-94e6-e1b8abf20a81.jpg" alt></p><p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引或索引层。你可以看我画的图。图中的 down 表示 down 指针，指向下一级结点。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/23db967f-0455-4eda-a456-113f5974f92c.jpg" alt></p><p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p><p>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。那如果我们再加一级索引呢？效率会不会提升更多呢？</p><p>前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/c0f2cc91-b83e-42d2-9233-8f7b156f81b5.jpg" alt></p><p>我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。我画了一个包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/046e22d5-393c-4896-b5ff-7db0046bcf58.jpg" alt></p><p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。</p><p>前面讲的<strong>这种链表加多级索引的结构，就是跳表</strong>。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。接下来，我会定量地分析一下，用跳表查询到底有多快。</p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>前面我讲过，算法的执行效率可以通过时间复杂度来度量，这里依旧可以用。我们知道，在一个单链表中查询某个数据的时间复杂度是 O(n)。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？</p><p>这个时间复杂度的分析方法比较难想到。我把问题分解一下，先来看这样一个问题，如果链表里有 n 个结点，会有多少级索引呢？</p><p>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2<sup>k</sup>)</strong>。</p><p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log<sub>2</sub>n-1。如果包含原始链表这一层，整个跳表的高度就是 log<sub>2</sub>n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>那这个 m 的值是多少呢？按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？我来解释一下。</p><p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/d6fabfd7-4a23-43ed-8199-b071ebfd27a9.jpg" alt></p><p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引，也就是我们讲过的空间换时间的设计思路。</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。那到底需要消耗多少额外的存储空间呢？我们来分析一下跳表的空间复杂度。</p><p>跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/e43ab30f-6e8f-4214-a4f6-4331b7447816.jpg" alt></p><p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？</p><p>我们前面都是每两个结点抽一个结点到上级索引，如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？我画了一个每三个结点抽一个的示意图，你可以看下。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/72f174e7-94a4-4bdd-97bd-c54430f466c7.jpg" alt></p><p>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/6c787336-e95e-4ecd-89cd-d23b567817ca.jpg" alt></p><p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p><p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表长什么样子我想你应该已经很清楚了，它的查找操作我们刚才也讲过了。实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。</p><p>我们现在来看下， 如何在跳表中插入一个数据，以及它是如何做到 O(logn) 的时间复杂度的？</p><p>我们知道，在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。</p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。我画了一张图，你可以很清晰地看到插入的过程。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/6caaec16-ee68-44de-a803-0a147428ff4c.jpg" alt></p><p>好了，我们再来看删除操作。</p><p>如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/80cda4f9-c476-4f02-aec8-4eb51e2e1f9c.jpg" alt></p><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡（如果不了解也没关系，我们后面会讲），而跳表是通过随机函数来维护前面提到的“平衡性”。</p><p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p><p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p><p><img src="/2018/11/06/13-%E8%B7%B3%E8%A1%A8-%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88/be4ca3d3-7f54-4cd9-91de-6caf070c2900.jpg" alt></p><p>随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容到此就讲完了。现在，我来讲解一下开篇的思考题：为什么 Redis 要用跳表来实现有序集合，而不是红黑树？</p><p>Redis 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。不过散列表我们后面才会讲到，所以我们现在暂且忽略这部分。如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li><p>插入一个数据</p></li><li><p>删除一个数据</p></li><li><p>查找一个数据；按照区间查找数据（比如查找值在[100, 356]之间的数据）</p></li><li><p>迭代输出有序序列</p></li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</p><p>对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们讲了跳表这种数据结构。跳表使用空间换时间的设计思路，通过构建多级索引来提高查询的效率，实现了基于链表的“二分查找”。跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 O(logn)。</p><p>跳表的空间复杂度是 O(n)。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在今天的内容中，对于跳表的时间复杂度分析，我分析了每两个结点提取一个结点作为索引的时间复杂度。如果每三个或者五个结点提取一个结点作为上级索引，对应的在跳表中查询数据的时间复杂度是多少呢？</p><p><strong>回答：</strong></p><p>如果每三个或者五个节点提取一个节点作为上级索引，那么对应的查询数据时间复杂度，应该也还是 O(logn)。</p><p>假设每 5 个节点提取，那么最高一层有 5 个节点，而跳表高度为 log5n，每层最多需要查找 5 个节点，即 O(mlogn) 中的 m = 5，最终，时间复杂度为 O(logn)。</p><p>空间复杂度也还是 O(logn)，虽然省去了一部分索引节点，但是似乎意义不大。</p><p>不知道在一般的生产系统，跳表的提取是按照多少个节点来实现？还是每个系统根据实际情况，都不一样。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-二分查找下_如何快速定位IP对应的省份地址</title>
      <link href="/2018/11/04/12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/"/>
      <url>/2018/11/04/12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过 IP 地址来查找 IP 归属地的功能，不知道你有没有用过？没用过也没关系，你现在可以打开百度，在搜索框里随便输一个 IP 地址，就会看到它的归属地。</p><p><img src="/2018/11/04/12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/c2daea40-5ba6-47a8-a2a4-14700561d4bb.jpg" alt></p><p>这个功能并不复杂，它是通过维护一个很大的 IP 地址库来实现的。地址库中包括 IP 地址范围和归属地的对应关系。</p><a id="more"></a><p>当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在[202.102.133.0, 202.102.133.255]这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台 </span><br><span class="line">[202.102.156.34, 202.102.157.255] 山东青岛 </span><br><span class="line">[202.102.48.0, 202.102.48.255] 江苏宿迁 </span><br><span class="line">[202.102.49.15, 202.102.51.251] 江苏泰州 </span><br><span class="line">[202.102.56.0, 202.102.56.255] 江苏连云港</span><br></pre></td></tr></table></figure><p>在我的问题是，在庞大的地址库中逐一比对 IP 地址所在的区间，是非常耗时的。<font color="red">假设我们有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地呢？</font></p><p>是不是觉得比较难？不要紧，等学完今天的内容，你就会发现这个问题其实很简单。</p><p>上一篇我讲了二分查找的原理，并且介绍了最简单的一种二分查找的代码实现。今天我们来讲几种二分查找的变形问题。</p><p>不知道你有没有听过这样一个说法：“十个二分九个错”。二分查找虽然原理极其简单，但是想要写出没有 Bug 的二分查找并不容易。</p><p>唐纳德·克努特（Donald E.Knuth）在《计算机程序设计艺术》的第 3 卷《排序和查找》中说到：“尽管第一个二分查找算法于 1946 年出现，然而第一个完全正确的二分查找算法实现直到 1962 年才出现。”</p><p>你可能会说，我们上一篇学的二分查找的代码实现并不难写啊。那是因为上一节讲的只是二分查找中最简单的一种情况，在不存在重复元素的有序数组中，查找值等于给定值的元素。最简单的二分查找写起来确实不难，但是，二分查找的变形问题就没那么好写了。</p><p>二分查找的变形问题很多，我只选择几个典型的来讲解，其他的你可以借助我今天讲的思路自己来分析。</p><p><img src="/2018/11/04/12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/b3218b2d-afd7-4025-9c93-e5c4d712ae1b.jpg" alt></p><p>需要特别说明一点，为了简化讲解，今天的内容，我都以数据是从小到大排列为前提，如果你要处理的数据是从大到小排列的，解决思路也是一样的。同时，我希望你最好先自己动手试着写一下这 4 个变形问题，然后再看我的讲述，这样你就会对我说的“二分查找比较难写”有更加深的体会了。</p><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>上一节中的二分查找是最简单的一种，即有序数据集合中不存在重复的数据，我们在其中查找值等于某个给定值的数据。如果我们将这个问题稍微修改下，有序数据集合中存在重复的数据，我们希望找到第一个值等于给定值的数据，这样之前的二分查找代码还能继续工作吗？</p><p>比如下面这样一个有序数组，其中，a[5]，a[6]，a[7]的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><p><img src="/2018/11/04/12-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DIP%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9C%81%E4%BB%BD%E5%9C%B0%E5%9D%80/3ff6cfce-5c14-4718-b9d3-af177c2ff40e.jpg" alt></p><p>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4]比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7]正好等于 8，所以代码就返回了。</p><p>尽管 a[7]也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。我们上一节讲的二分查找代码就无法处理这种情况了。所以，针对这个变形问题，我们可以稍微改造一下上一节的代码。</p><p>100 个人写二分查找就会有 100 种写法。网上有很多关于变形二分查找的实现方法，有很多写得非常简洁，比如下面这个写法。但是，尽管简洁，理解起来却非常烧脑，也很容易写错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D; low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt;&#x3D; value) &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (low &lt; n &amp;&amp; a[low]&#x3D;&#x3D;value) return low;</span><br><span class="line">  else return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这个实现之后，你是不是觉得很不好理解？如果你只是死记硬背这个写法，我敢保证，过不了几天，你就会全都忘光，再让你写，90% 的可能会写错。所以，我换了一种实现方法，你看看是不是更容易理解呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid &#x3D;&#x3D; 0) || (a[mid - 1] !&#x3D; value)) return mid;</span><br><span class="line">      else high &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我来稍微解释一下这段代码。a[mid]跟要查找的 value 的大小关系有三种情况：大于、小于、等于。对于 a[mid]&gt;value 的情况，我们需要更新 high= mid-1；对于 a[mid]</p><p>如果我们查找的是任意一个值等于给定值的元素，当 a[mid]等于要查找的值时，a[mid]就是我们要找的元素。但是，如果我们求解的是第一个值等于给定值的元素，当 a[mid]等于要查找的值时，我们就需要确认一下这个 a[mid]是不是第一个值等于给定值的元素。</p><p>我们重点看第 11 行代码。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p><p>对比上面的两段代码，是不是下面那种更好理解？实际上，<strong>很多人都觉得变形的二分查找很难写，主要原因是太追求第一种那样完美、简洁的写法</strong>。而对于我们做工程开发的人来说，代码易读懂、没 Bug，其实更重要，所以我觉得第二种写法更好。</p><h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><p>前面的问题是查找第一个值等于给定值的元素，我现在把问题稍微改一下，查找最后一个值等于给定值的元素，又该如何做呢？</p><p>如果你掌握了前面的写法，那这个问题你应该很轻松就能解决。你可以先试着实现一下，然后跟我写的对比一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] !&#x3D; value)) return mid;</span><br><span class="line">      else low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还是重点看第 11 行代码。如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。</p><p>如果我们经过检查之后，发现 a[mid]后面的一个元素 a[mid+1]也等于 value，那说明当前的这个 a[mid]并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p><h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3，4，6，7，10。如果查找第一个大于等于 5 的元素，那就是 6。</p><p>实际上，实现的思路跟前面的那两种变形问题的实现思路类似，代码写起来甚至更简洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt;&#x3D; value) &#123;</span><br><span class="line">      if ((mid &#x3D;&#x3D; 0) || (a[mid - 1] &lt; value)) return mid;</span><br><span class="line">      else high &#x3D; mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low=mid+1。</p><p>对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素。这段逻辑对应的代码是第 7 行。</p><p>如果 a[mid-1]也大于等于要查找的值 value，那说明要查找的元素在[low, mid-1]之间，所以，我们将 high 更新为 mid-1。</p><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><p>现在，我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3，5，6，8，9，10。最后一个小于等于 7 的元素就是 6。是不是有点类似上面那一种？实际上，实现思路也是一样的。</p><p>有了前面的基础，你完全可以自己写出来了，所以我就不详细分析了。我把代码贴出来，你可以写完之后对比一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch7(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">    if (a[mid] &gt; value) &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if ((mid &#x3D;&#x3D; n - 1) || (a[mid + 1] &gt; value)) return mid;</span><br><span class="line">      else low &#x3D; mid + 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>好了，现在我们回头来看开篇的问题：如何快速定位出一个 IP 地址的归属地？</p><p>现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p><p>然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了</p><p>然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>上一节我说过，凡是用二分查找能解决的，绝大部分我们更倾向于用散列表或者二叉查找树。即便是二分查找在内存使用上更节省，但是毕竟内存如此紧缺的情况并不多。那二分查找真的没什么用处了吗？</p><p>实际上，上一节讲的求“值等于给定值”的二分查找确实不怎么会被用到，二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。比如今天讲的这几种变体问题，用其他数据结构，比如散列表、二叉树，就比较难实现了。</p><p>变体的二分查找算法写起来非常烧脑，很容易因为细节处理不好而产生 Bug，这些容易出错的细节有：<strong>终止条件、区间上下界更新方法、返回值选择</strong>。所以今天的内容你最好能用自己实现一遍，对锻炼编码能力、逻辑思维、写出 Bug free 代码，会很有帮助。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们今天讲的都是非常规的二分查找问题，今天的思考题也是一个非常规的二分查找问题。如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p><p><strong>回答：</strong></p><p>有三种方法查找循环有序数组</p><p> 一、<br> 1. 找到分界下标，分成两个有序数组<br> 2. 判断目标值在哪个有序数据范围内，做二分查找</p><p> 二、<br> 1. 找到最大值的下标 x;<br> 2. 所有元素下标 +x 偏移，超过数组范围值的取模;<br> 3. 利用偏移后的下标做二分查找；<br> 4. 如果找到目标下标，再作 -x 偏移，就是目标值实际下标。</p><p> 两种情况最高时耗都在查找分界点上，所以时间复杂度是 O(N）。</p><p> 复杂度有点高，能否优化呢？</p><p> 三、<br>我们发现循环数组存在一个性质：以数组中间点为分区，会将数组分成一个有序数组和一个循环有序数组。</p><p> 如果首元素小于 mid，说明前半部分是有序的，后半部分是循环有序数组；<br> 如果首元素大于 mid，说明后半部分是有序的，前半部分是循环有序的数组；<br> 如果目标元素在有序数组范围中，使用二分查找；<br> 如果目标元素在循环有序数组中，设定数组边界后，使用以上方法继续查找。</p><p> 时间复杂度为 O(logN)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-二分查找上_如何用最省内存的方式实现快速查找功能</title>
      <link href="/2018/11/02/11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A-%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/11/02/11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A-%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们讲一种<strong>针对有序数据集合</strong>的查找算法：二分查找（Binary Search）算法，也叫折半查找算法。二分查找的思想非常简单，很多非计算机专业的同学很容易就能理解，但是看似越简单的东西往往越难掌握好，想要灵活应用就更加困难。</p><p>老规矩，我们还是来看一道思考题。</p><p>设我们有 1000 万个整数数据，每个数据占 8 个字节，<font color="red">如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？</font> 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？带着这个问题，让我们进入今天的内容吧！</p><a id="more"></a><h2 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h2><p>二分查找是一种非常简单易懂的快速查找算法，生活中到处可见。比如说，我们现在来做一个猜字游戏。我随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。你来想想，如何快速猜中我写的数字呢？</p><p>假设我写的数字是 23，你可以按照下面的步骤来试一试。（如果猜测范围的数字有偶数个，中间数有两个，就选择较小的那个。）</p><p><img src="/2018/11/02/11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A-%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/9b6dd338-0fec-45eb-8c46-97b038d050b5.jpg" alt></p><p>7 次就猜出来了，是不是很快？这个例子用的就是二分思想，按照这个思想，即便我让你猜的是 0 到 999 的数字，最多也只要 10 次就能猜中。不信的话，你可以试一试。</p><p>这是一个生活中的例子，我们现在回到实际的开发场景中。假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。</p><p>最简单的办法当然是从第一个订单开始，一个一个遍历这 1000 个订单，直到找到金额等于 19 元的订单为止。但这样查找会比较慢，最坏情况下，可能要遍历完这 1000 条记录才能找到。那用二分查找能不能更快速地解决呢？</p><p>为了方便讲解，我们假设只有 10 个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。</p><p>还是利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。为了更加直观，我画了一张查找过程的图。其中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标。</p><p><img src="/2018/11/02/11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A-%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/a18c1799-64f4-46b2-b1a9-0ddb8ceb4041.jpg" alt></p><p>看懂这两个例子，你现在对二分的思想应该掌握得妥妥的了。我这里稍微总结升华一下，<strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0</strong>。</p><h2 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn) 惊人的查找速度"></a>O(logn) 惊人的查找速度</h2><p>二分查找是一种非常高效的查找算法，高效到什么程度呢？我们来分析一下它的时间复杂度。</p><p>我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p><p><img src="/2018/11/02/11-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8A-%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E7%9C%81%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%9F%A5%E6%89%BE%E5%8A%9F%E8%83%BD/7e140e07-43f6-40ec-8588-b091e57fc657.jpg" alt></p><p>可以看出来，这是一个等比数列。其中 n/2k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p><p>二分查找是我们目前为止遇到的第一个时间复杂度为 O(logn) 的算法。后面章节我们还会讲堆、二叉树的操作等等，它们的时间复杂度也是 O(logn)。我这里就再深入地讲讲 O(logn) 这种<strong>对数时间复杂度</strong>。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。为什么这么说呢？</p><p>因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。</p><p>我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。</p><p>反过来，对数对应的就是指数。有一个非常著名的<strong>“阿基米德与国王下棋的故事”</strong>，你可以自行搜索一下，感受一下指数的“恐怖”。这也是为什么我们说，指数时间复杂度的算法在大规模数据面前是无效的。</p><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p>实际上，简单的二分查找并不难写，注意我这里的“简单”二字。下一节，我们会讲到二分查找的变体问题，那才是真正烧脑的。今天，我们来看如何来写最简单的二分查找。</p><p><strong>最简单的情况</strong>就是<strong>有序数组中不存在重复元素</strong>，我们在其中用二分查找值等于给定值的数据。我用 Java 代码实现了一个最简单的二分查找算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int bsearch(int[] a, int n, int value) &#123;</span><br><span class="line">  int low &#x3D; 0;</span><br><span class="line">  int high &#x3D; n - 1;</span><br><span class="line"></span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">    if (a[mid] &#x3D;&#x3D; value) &#123;</span><br><span class="line">      return mid;</span><br><span class="line">    &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">      low &#x3D; mid + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我稍微解释一下，low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示[low, high]的中间位置。我们通过对比 a[mid]与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。如果你有一些编程基础，看懂这些应该不成问题。现在，我就着重强调一下<strong>容易出错的 3 个地方</strong>。</p><h3 id="1-循环退出条件"><a href="#1-循环退出条件" class="headerlink" title="1. 循环退出条件"></a>1. 循环退出条件</h3><p>注意是 low&lt;=high，而不是 low&lt;high。</p><h3 id="2-mid-的取值"><a href="#2-mid-的取值" class="headerlink" title="2.mid 的取值"></a>2.mid 的取值</h3><p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p><h3 id="3-low-和-high-的更新"><a href="#3-low-和-high-的更新" class="headerlink" title="3.low 和 high 的更新"></a>3.low 和 high 的更新</h3><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。</p><p>如果你留意我刚讲的这三点，我想一个简单的二分查找你已经可以实现了。<strong>实际上，二分查找除了用循环来实现，还可以用递归来实现</strong>，过程也非常简单。</p><p>我用 Java 语言实现了一下这个过程，正好你可以借此机会回顾一下写递归代码的技巧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 二分查找的递归实现</span><br><span class="line">public int bsearch(int[] a, int n, int val) &#123;</span><br><span class="line">  return bsearchInternally(a, 0, n - 1, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int bsearchInternally(int[] a, int low, int high, int value) &#123;</span><br><span class="line">  if (low &gt; high) return -1;</span><br><span class="line"></span><br><span class="line">  int mid &#x3D;  low + ((high - low) &gt;&gt; 1);</span><br><span class="line">  if (a[mid] &#x3D;&#x3D; value) &#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125; else if (a[mid] &lt; value) &#123;</span><br><span class="line">    return bsearchInternally(a, mid+1, high, value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return bsearchInternally(a, low, mid-1, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><p>前面我们分析过，二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。那什么情况下适合用二分查找，什么情况下不适合呢？</p><h3 id="首先，二分查找依赖的是顺序表结构，简单点说就是数组"><a href="#首先，二分查找依赖的是顺序表结构，简单点说就是数组" class="headerlink" title="首先，二分查找依赖的是顺序表结构，简单点说就是数组"></a>首先，二分查找依赖的是顺序表结构，简单点说就是数组</h3><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。我们在数组和链表那两节讲过，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p><p>二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p><h3 id="其次，二分查找针对的是有序数据"><a href="#其次，二分查找针对的是有序数据" class="headerlink" title="其次，二分查找针对的是有序数据"></a>其次，二分查找针对的是有序数据</h3><p>二分查找对这一点的要求比较苛刻，数据必须是有序的。如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。那针对动态数据集合，如何在其中快速查找某个数据呢？别急，等到<strong>二叉树</strong>那一节我会详细讲。</p><h3 id="再次，数据量太小不适合二分查找"><a href="#再次，数据量太小不适合二分查找" class="headerlink" title="再次，数据量太小不适合二分查找"></a>再次，数据量太小不适合二分查找</h3><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p>不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><h2 id="最后，数据量太大也不适合二分查找"><a href="#最后，数据量太大也不适合二分查找" class="headerlink" title="最后，数据量太大也不适合二分查找"></a>最后，数据量太大也不适合二分查找</h2><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>二分查找的理论知识你应该已经掌握了。我们来看下开篇的思考题：如何在 1000 万个整数中快速查找某个整数？</p><p>这个问题并不难。我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。借助今天讲的内容，我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p><p>看起来这个问题并不难，很轻松就能解决。实际上，它暗藏了“玄机”。如果你对数据结构和算法有一定了解，知道散列表、二叉树这些支持快速查找的动态数据结构。你可能会觉得，用散列表和二叉树也可以解决这个问题。实际上是不行的。</p><p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了一种针对有序数据的高效查找算法，二分查找，它的时间复杂度是 O(logn)。</p><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找的区间缩小为一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：循环退出条件、mid 的取值，low 和 high 的更新。</p><p>二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>1 如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</p><p>2 我刚才说了，如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？如果你自己推导一下，你就会深刻地认识到，为何我们会选择用数组而不是链表来实现二分查找了。</p><p><strong>回答1：</strong></p><p>因为要精确到后六位，可以先用二分查找出整数位，然后再二分查找小数第一位，第二位，到第六位。</p><p>整数查找很简单，判断当前数小于+1后大于即可找到，</p><p>小数查找举查找小数后第一位来说，从x.0到(x+1).0，查找终止条件与整数一样，当前数小于，加0.1大于，</p><p>后面的位数以此类推，可以用x*10^(-i)通项来循环或者递归，终止条件是i&gt;6，</p><p>想了一下复杂度，每次二分是logn，包括整数位会查找7次，所以时间复杂度为7logn。空间复杂度没有开辟新的储存空间，空间复杂度为1。</p><p>没有具体用代码实现，只是思路</p><p><strong>回答2：</strong></p><p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br>第一次查找中间点，需要移动指针n/2次；<br>第二次，需要移动指针n/4次；<br>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值</p><p>总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.</p><p>最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同</p><p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>1 个人觉得二分查找进行优化时，还个细节注意：<br>将mid = lo + (hi - lo) /2，将除法优化成移位运算时，得注意运算符的优先级，千万不能写成这样：mid = lo + (hi - lo) &gt;&gt; 1</li></ul><ul><li>2 平方根可以用牛顿迭代实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-排序优化_如何实现一个通用的高性能的排序函数</title>
      <link href="/2018/11/01/10-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/"/>
      <url>/2018/11/01/10-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，C++ STL 中的 sort()、stable_sort()，还有 Java 语言中的 Collections.sort()。在平时的开发中，我们也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。那你知道这些排序函数是如何实现的吗？底层都利用了哪种排序算法呢？</p><p>基于这些问题，今天我们就来看排序这部分的最后一块内容：<font color="red">如何实现一个通用的、高性能的排序函数？</font></p><a id="more"></a><h2 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h2><p>如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？我们先回顾一下前面讲过的几种排序算法。</p><p><img src="/2018/11/01/10-%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0/2a6b75aa-dd02-4d70-b256-280028054fea.jpg" alt></p><p>们前面讲过，线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p><p>时间复杂度是 O(nlogn) 的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。</p><p>知道你有没有发现，使用归并排序的情况其实并不多。我们知道，快排在最坏情况下的时间复杂度是 O(n2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？</p><p>还记得我们前文讲的归并排序的空间复杂度吗？归并排序并不是原地排序算法，空间复杂度是 O(n)。所以，粗略点、夸张点讲，如果要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费就翻倍了。</p><p>前面我们讲到，快速排序比较适合来实现排序函数，但是，我们也知道，快速排序在最坏情况下的时间复杂度是 O(n2)，如何来解决这个“复杂度恶化”的问题呢？</p><h2 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h2><p>我们先来看下，为什么最坏情况下快速排序的时间复杂度是 O(n2) 呢？我们前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，<strong>这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理</strong>。</p><p>那什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？</p><p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多</strong>。</p><p>如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是 O(n2)。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。</p><p>我这里介绍两个比较常用、比较简单的分区算法，你可以直观地感受一下。</p><h3 id="1-三数取中法"><a href="#1-三数取中法" class="headerlink" title="1. 三数取中法"></a>1. 三数取中法</h3><p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><h3 id="2-随机法"><a href="#2-随机法" class="headerlink" title="2. 随机法"></a>2. 随机法</h3><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选的很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p><p>我们知道，快速排序是用递归来实现的。我们在递归那一节讲过，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h2 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h2><p>为了让你对如何实现一个排序函数有一个更直观的感受，我拿 Glibc 中的 qsort() 函数举例说明一下。虽说 qsort() 从名字上看，很像是基于快速排序算法实现的，实际上它并不仅仅用了快排这一种算法。</p><p>如果你去看源码，你就会发现，qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。现在计算机的内存都挺大的，我们很多时候追求的是速度。还记得我们前面讲过的用空间换时间的技巧吗？这就是一个典型的应用。</p><p>但如果数据量太大，就跟我们前面提到的，排序 100MB 的数据，这个时候我们再用归并排序就不合适了。所以，<strong>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序</strong>。</p><p>那 qsort() 是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，qsort() 选择分区点的方法就是“三数取中法”。是不是也并不复杂？</p><p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。我们之前在讲递归那一节也讲过，不知道你还有没有印象？</p><p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，<strong>O(n<sup>2</sup>) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长</strong>。我们现在就来分析下这个说法。</p><p>我们在讲复杂度分析的时候讲过，算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果我们深究的话，实际上时间复杂度并不等于代码实际的运行时间。</p><p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p><p>假设 k=1000，c=200，当我们对小规模数据（比如 n=100）排序时，n<sup>2</sup>的值实际上比 knlogn+c 还要小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knlogn+c &#x3D; 1000 * 100 * log100 + 200 远大于10000</span><br><span class="line"></span><br><span class="line">n^2 &#x3D; 100*100 &#x3D; 10000</span><br></pre></td></tr></table></figure><p>所以，对于小规模数据的排序，O(n2) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法。</p><p>还记得我们之前讲到的哨兵来简化代码，提高执行效率吗？在 qsort() 插入排序的算法实现中，也利用了这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p><p>好了，C 语言的 qsort() 我已经分析完了，你有没有觉得其实也不是很难？基本上都是用了我们前面讲到的知识点，有了前面的知识积累，看一些底层的类库的时候是不是也更容易了呢？</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我带你分析了一下如何来实现一个工业级的通用的、高效的排序函数，内容比较偏实战，而且贯穿了一些前面几节的内容，你要多看几遍。我们大部分排序函数都是采用 O(nlogn) 排序算法来实现，但是为了尽可能地提高性能，会做很多优化。</p><p>着重讲了快速排序的一些优化策略，比如合理选择分区点、避免递归太深等等。最后，我还带你分析了一个 C 语言中 qsort() 的底层实现原理，希望你对此能有一个更加直观的感受。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>在今天的内容中，我分析了 C 语言的中的 qsort() 的底层排序算法，你能否分析一下你所熟悉的语言中的排序函数都是用什么排序算法实现的呢？都有哪些优化技巧？</p><p><strong>回答1：</strong></p><p>查看了下Arrays.sort的源码，主要采用TimSort算法, 大致思路是这样的：</p><p>1 元素个数 &lt; 32, 采用二分查找插入排序(Binary Sort)<br>2 元素个数 &gt;= 32, 采用归并排序，归并的核心是分区(Run)<br>3 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈<br>4 如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值<br>5 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并<br>6 最终栈内的分区被全部合并，得到一个排序好的数组</p><p>Timsort的合并算法非常巧妙：</p><p>1 找出左分区最后一个元素(最大)及在右分区的位置<br>2 找出右分区第一个元素(最小)及在左分区的位置<br>3 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的</p><p><strong>回答2：</strong></p><p>java1.8中的排序，在元素小于47的时候用插入排序，大于47小于286用双轴快排，大于286用timsort归并排序，并在timesort中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-线性排序_如何根据年龄给100万用户数据排序</title>
      <link href="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前两篇中，着重分析了几种常用排序算法的原理、时间复杂度、空间复杂度、稳定性等。今天，会讲三种时间复杂度是 O(n) 的排序算法：桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序（Linear sort）。之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。</p><p>这几种排序算法理解起来都不难，时间、空间复杂度分析起来也很简单，但是对要排序的数据要求很苛刻，所以我们<strong>今天学习重点的是掌握这些排序算法的适用场景</strong>。</p><p>按照惯例，我先给你出一道思考题：<font color="red">如何根据年龄给 100 万用户排序？</font> 你可能会说，我用上一节课讲的归并、快排就可以搞定啊！是的，它们也可以完成功能，但是时间复杂度最低也是 O(nlogn)。有没有更快的排序方法呢？让我们一起进入今天的内容！</p><a id="more"></a><h2 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h2><p>首先，我们来看桶排序。桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/a832a843-33a8-4915-a9a1-f24202902e26.jpg" alt></p><p>桶排序的时间复杂度为什么是 O(n) 呢？我们一块儿来分析一下。</p><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><h3 id="桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？"><a href="#桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？" class="headerlink" title="桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？"></a>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</h3><p>答案当然是否定的。为了让你轻松理解桶排序的核心思想，我刚才做了很多假设。实际上，桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中。</strong>所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><p>比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？</p><p>现在我来讲一下，如何借助桶排序的处理思想来解决这个问题。</p><p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p><p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>不过，你可能也发现了，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB 订单数据是无法均匀地被划分到 100 个文件中的。有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？</p><p>针对这些划分之后还是比较大的文件，我们可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，我们就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p><h2 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h2><p>我个人觉得，<strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>我们都经历过高考，高考查分数系统你还记得吗？我们查分数的时候，系统会显示我们的成绩以及所在省的排名。如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？</p><p>考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p>数排序的算法思想就是这么简单，跟桶排序非常类似，只是桶的大小粒度不一样。<strong>不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p><p>想弄明白这个问题，我们就要来看计数排序算法的实现方法。我还拿考生那个例子来解释。为了方便说明，我对数据规模做了简化。假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。</p><p>考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6]的值。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/221ca9b1-f6cf-4b63-ad43-6ebcf184ed71.jpg" alt></p><p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/800f16d6-49c0-47c8-a282-403fee91761a.jpg" alt></p><p>那我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？这个处理方法非常巧妙，很不容易想到。</p><p>思路是这样的：我们对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/6f76bbd3-8144-43dd-ae81-f7eeb673e635.jpg" alt></p><p>有了前面的数据准备之后，现在我就要讲计数排序中最复杂、最难理解的一部分了，请集中精力跟着我的思路！</p><p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。</p><p>此类推，当我们扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/1d730cb17249f8e92ef5cab53ae65784.jpg" alt></p><p>上面的过程有点复杂，我写成了代码，你可以对照着看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span><br><span class="line">public void countingSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;&#x3D; 1) return;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 查找数组中数据的范围</span><br><span class="line">  int max &#x3D; a[0];</span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">    if (max &lt; a[i]) &#123;</span><br><span class="line">      max &#x3D; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int[] c &#x3D; new int[max + 1]; &#x2F;&#x2F; 申请一个计数数组c，下标大小[0,max]</span><br><span class="line">  for (int i &#x3D; 0; i &lt;&#x3D; max; ++i) &#123;</span><br><span class="line">    c[i] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 计算每个元素的个数，放入c中</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 依次累加</span><br><span class="line">  for (int i &#x3D; 1; i &lt;&#x3D; max; ++i) &#123;</span><br><span class="line">    c[i] &#x3D; c[i-1] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 临时数组r，存储排序之后的结果</span><br><span class="line">  int[] r &#x3D; new int[n];</span><br><span class="line">  &#x2F;&#x2F; 计算排序的关键步骤，有点难理解</span><br><span class="line">  for (int i &#x3D; n - 1; i &gt;&#x3D; 0; --i) &#123;</span><br><span class="line">    int index &#x3D; c[a[i]]-1;</span><br><span class="line">    r[index] &#x3D; a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将结果拷贝给a数组</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] &#x3D; r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种利用另外一个数组来计数的实现方式是不是很巧妙呢？这也是为什么这种排序算法叫计数排序的原因。不过，你千万不要死记硬背上面的排序过程，重要的是理解和会用。</p><p>我总结一下，<strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数</strong>。</p><p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p><h2 id="基数排序（Radix-sort"><a href="#基数排序（Radix-sort" class="headerlink" title="基数排序（Radix sort)"></a>基数排序（Radix sort)</h2><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>我们之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，有没有时间复杂度是 O(n) 的算法呢？现在我就来介绍一种新的排序算法，基数排序。</p><p>刚刚这个问题里有这样的规律：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p><p>借助稳定排序算法，这里有一个巧妙的实现思路。还记得我们前文中，在阐述排序算法的稳定性的时候举的订单的例子吗？我们这里也可以借助相同的处理思路，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p><p>手机号码稍微有点长，画图比较不容易看清楚，我用字符串排序的例子，画了一张基数排序的过程分解图，你可以看下。</p><p><img src="/2018/10/28/9-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E5%B9%B4%E9%BE%84%E7%BB%99100%E4%B8%87%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F/7e1fc232-30d7-4e1a-9bb6-a2214f32efec.jpg" alt></p><p>注意，这里按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p><p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p>实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词，最短的只有 1 个字母，最长的我特意去查了下，有 45 个字母，中文翻译是尘肺病。对于这种不等长的数据，基数排序还适用吗？</p><p>实际上，我们可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据<strong>ASCII 值</strong>，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>总结一下，<strong>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</strong>。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>今天的内容学完了。我们再回过头来看看开篇的思考题：如何根据年龄给 100 万用户排序？现在思考题是不是变得非常简单了呢？我来说一下我的解决思路。</p><p>实际上，根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素。这样就得到了按照年龄排序的 100 万用户数据。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天，我们学习了 3 种线性时间复杂度的排序算法，有桶排序、计数排序、基数排序。它们对要排序的数据都有比较苛刻的要求，应用不是非常广泛。但是如果数据特征比较符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到 O(n)。</p><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们今天讲的都是针对特殊数据的排序算法。实际上，还有很多看似是排序但又不需要使用排序算法就能处理的排序问题。</p><p>假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？</p><p><strong>回答：</strong></p><p>用两个指针a、b：a指针从头开始往后遍历，遇到大写字母就停下，b从后往前遍历，遇到小写字母就停下，交换a、b指针对应的元素；重复如上过程，直到a、b指针相交。<br>对于小写字母放前面，数字放中间，大写字母放后面，可以先将数据分为小写字母和非小写字母两大类，进行如上交换后再在非小写字母区间内分为数字和大写字母做同样处理</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-排序下_如何用快排思想在O(n)内查找第K大元素</title>
      <link href="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><p><a href="https://visualgo.net/en" target="_blank" rel="noopener">算法动态排序</a></p><p><a href="https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ" target="_blank" rel="noopener">图解排序算法</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇讲了冒泡排序、插入排序、选择排序这三种排序算法，它们的时间复杂度都是 O(n2)，比较高，适合小规模数据的排序。今天，讲两种时间复杂度为 O(nlogn) 的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序，比上一篇讲的那三种排序算法要更常用。</p><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，<font color="red">比如：如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</font> 这就要用到这篇文章所要讲的内容。</p><a id="more"></a><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p>我们先来看<strong>归并排序</strong>（Merge Sort）。</p><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/3c091865-ea07-4f41-bb8c-8fa31df5ec3f.jpg" alt></p><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>从我刚才的描述，你有没有感觉到，分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。分治算法的思想在后续会有专门的一篇来讲，现在不展开讨论，我们今天的重点还是排序算法。</p><p>前面我通过举例让你对归并有了一个感性的认识，又告诉你，归并排序用的是分治思想，可以用递归来实现。我们现在就来看看<strong>如何用递归代码来实现归并排序</strong>。</p><p>前文提到，写递归代码的技巧就是，分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r 不用再继续分解</span><br></pre></td></tr></table></figure><p>我来解释一下这个递推公式。</p><p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码，你可以翻译成你熟悉的编程语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if p &gt;&#x3D; r  then return</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取p到r之间的中间位置q</span><br><span class="line">  q &#x3D; (p+r) &#x2F; 2</span><br><span class="line">  &#x2F;&#x2F; 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r]) 这个函数的作用就是，将已经有序的 A[p…q]和 A[q+1…r]合并成一个有序的数组，并且放入 A[p…r]。那这个过程具体该如何做呢？</p><p>如图所示，我们申请一个临时数组 tmp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。</p><p>继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r]中。</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/cbbceb39-83d7-4fc8-9e2e-0ebf7a2cc648.jpg" alt></p><p>我们把 merge() 函数写成伪代码，就是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i :&#x3D; p，j :&#x3D; q+1，k :&#x3D; 0 &#x2F;&#x2F; 初始化变量i, j, k</span><br><span class="line">  var tmp :&#x3D; new array[0...r-p] &#x2F;&#x2F; 申请一个大小跟A[p...r]一样的临时数组</span><br><span class="line">  while i&lt;&#x3D;q AND j&lt;&#x3D;r do &#123;</span><br><span class="line">    if A[i] &lt;&#x3D; A[j] &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[i++] &#x2F;&#x2F; i++等于i:&#x3D;i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start :&#x3D; i，end :&#x3D; q</span><br><span class="line">  if j&lt;&#x3D;r then start :&#x3D; j, end:&#x3D;r</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while start &lt;&#x3D; end do &#123;</span><br><span class="line">    tmp[k++] &#x3D; A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将tmp中的数组拷贝回A[p...r]</span><br><span class="line">  for i:&#x3D;0 to r-p do &#123;</span><br><span class="line">    A[p+i] &#x3D; tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h2><p>这样跟着我一步一步分析，归并排序是不是没那么难啦？还记得上节课我们分析排序算法的三个问题吗？接下来，我们来看归并排序的三个问题。</p><h3 id="第一，归并排序是稳定的排序算法吗？"><a href="#第一，归并排序是稳定的排序算法吗？" class="headerlink" title="第一，归并排序是稳定的排序算法吗？"></a>第一，归并排序是稳定的排序算法吗？</h3><p>结合我前面画的那张图和归并排序的伪代码，你应该能发现，归并排序稳不稳定关键要看 merge() 函数，也就是两个有序子数组合并成一个有序数组的那部分代码。</p><p>在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><h3 id="第二，归并排序的时间复杂度是多少？"><a href="#第二，归并排序的时间复杂度是多少？" class="headerlink" title="第二，归并排序的时间复杂度是多少？"></a>第二，归并排序的时间复杂度是多少？</h3><p>归并排序涉及递归，时间复杂度的分析稍微有点复杂。我们正好借此机会来学习一下，如何分析递归代码的时间复杂度。</p><p>在递归那一篇我们讲过，递归的适用场景是，一个问题 a 可以分解为多个子问题 b、c，那求解问题 a 就可以分解为求解问题 b、c。问题 b、c 解决之后，我们再把 b、c 的结果合并成 a 的结果。</p><p>如果我们定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，那我们就可以得到这样的递推关系式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(a) &#x3D; T(b) + T(c) + K</span><br></pre></td></tr></table></figure><p>其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p><p>从刚刚的分析，我们可以得到一个重要的结论：<strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式</strong>。</p><p>套用这个公式，我们来分析一下归并排序的时间复杂度。</p><p>我们假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。我们知道，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>通过这个公式，如何来求解 T(n) 呢？还不够直观？那我们再进一步分解一下计算过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n</span><br><span class="line">     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。</p><p>从我们的原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p><h3 id="第三，归并排序的空间复杂度是多少？"><a href="#第三，归并排序的空间复杂度是多少？" class="headerlink" title="第三，归并排序的空间复杂度是多少？"></a>第三，归并排序的空间复杂度是多少？</h3><p>归并排序的时间复杂度任何情况下都是 O(nlogn)，看起来非常优秀。（待会儿你会发现，即便是快速排序，最坏情况下，时间复杂度也是 O(n2)。）但是，归并排序并没有像快排那样，应用广泛，这是为什么呢？因为它有一个致命的“弱点”，那就是<strong>归并排序不是原地排序算法</strong>。</p><p>这是因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间。这一点你应该很容易理解。那我现在问你，归并排序的空间复杂度到底是多少呢？是 O(n)，还是 O(nlogn)，应该如何分析呢？</p><p>如果我们继续按照分析递归时间复杂度的方法，通过递推公式来求解，那整个归并过程需要的空间复杂度就是 O(nlogn)。不过，类似分析时间复杂度那样来分析空间复杂度，这个思路对吗？</p><p>实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p><h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p>们再来看快速排序算法（Quicksort），我们习惯性把它简称为“快排”。快排利用的也是分治思想。乍看起来，它有点像归并排序，但是思路其实完全不一样。我们待会会讲两者的区别。现在，我们先来看下快排的核心思想。</p><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p><p>我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/f1096c34-45e2-4441-8c40-721b5d6e76d2.jpg" alt></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p><p>如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) &#x3D; quick_sort(p…q-1) + quick_sort(q+1… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r</span><br></pre></td></tr></table></figure><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现，你可以翻译成你熟悉的任何语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;&#x3D; r then return</span><br><span class="line">  </span><br><span class="line">  q &#x3D; partition(A, p, r) &#x2F;&#x2F; 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个 merge() 合并函数，我们这里有一个 partition() 分区函数。partition() 分区函数实际上我们前面已经讲过了，就是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p><p>果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]。</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/70e71071-578c-4304-9a75-5bf0d5687dbc.jpg" alt></p><p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，我们就需要在 A[p…r]的原地完成分区操作。</p><p>原地分区函数的实现思路非常巧妙，我写成了伪代码，我们一起来看一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot :&#x3D; A[r]</span><br><span class="line">  i :&#x3D; p</span><br><span class="line">  for j :&#x3D; p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i :&#x3D; i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br></pre></td></tr></table></figure><p>这里的处理有点类似选择排序。我们通过游标 i 把 A[p…r-1]分成两部分。A[p…i-1]的元素都是小于 pivot 的，我们暂且叫它“已处理区间”，A[i…r-1]是“未处理区间”。我们每次都从未处理的区间 A[i…r-1]中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。</p><p>数组的插入操作还记得吗？在数组某个位置插入元素，需要搬移数据，非常耗时。当时我们也讲了一种处理技巧，就是交换，在 O(1) 的时间复杂度内完成插入操作。这里我们也借助这个思想，只需要将 A[i]与 A[j]交换，就可以在 O(1) 时间复杂度内将 A[j]放到下标为 i 的位置。</p><p>文字不如图直观，所以我画了一张图来展示分区的整个过程。</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/87652728-e2e9-4cf6-800b-857cfdab1622.jpg" alt></p><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>到此，快速排序的原理你应该也掌握了。现在，我再来看另外一个问题：快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢？</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/0db4f6c3-3b1a-4d09-b2c1-1e0e3a2f22ff.jpg" alt></p><p>以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p><h3 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h3><p>现在，我们来分析一下快速排序的性能。我在讲解快排的实现原理的时候，已经分析了稳定性和空间复杂度。快排是一种原地、不稳定的排序算法。现在，我们集中精力来看快排的时间复杂度。</p><p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>但是，公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)。</p><p>我们刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>我们假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line"></span><br><span class="line">T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树，在树那一篇再提，这里暂时不说。<strong>结论</strong>：T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。而且，我们也有很多方法将这个概率降到很低，如何来做？我们后面文章再讲。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>快排核心思想就是分治和分区，我们可以利用分区的思想，来解答开篇的问题：O(n) 时间复杂度内求无序数组中的第 K 大元素。比如，4， 2， 5， 12， 3 这样一组数据，第 3 大元素就是 4。</p><p>我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。</p><p>如果 p+1=K，那 A[p]就是要求解的元素；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 K</p><p><img src="/2018/10/24/8-%E6%8E%92%E5%BA%8F%E4%B8%8B-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%AB%E6%8E%92%E6%80%9D%E6%83%B3%E5%9C%A8On%E5%86%85%E6%9F%A5%E6%89%BE%E7%AC%ACK%E5%A4%A7%E5%85%83%E7%B4%A0/8ff2c815-883b-48bc-9b74-22b6c2195ed2.jpg" alt></p><p>我们再来看，为什么上述解决思路的时间复杂度是 O(n)？</p><p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……直到区间缩小为 1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><p>你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？</p><p>不过，时间复杂度就并不是 O(n) 了，而是 O(K * n)。你可能会说，时间复杂度前面的系数不是可以忽略吗？O(K * n) 不就等于 O(n) 吗？</p><p>这个可不能这么简单地划等号。当 K 是比较小的常量时，比如 1、2，那最好时间复杂度确实是 O(n)；但当 K 等于 n/2 或者 n 时，这种最坏情况下的时间复杂度就是 O(n2) 了。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><p><strong>回答1：</strong></p><p>每次从各个文件中取一条数据，在内存中根据数据时间戳构建一个最小堆，然后每次把最小值给写入新文件，同时将最小值来自的那个文件再出来一个数据，加入到最小堆中。这个空间复杂度为常数，但没能很好利用1g内存，而且磁盘单个读取比较慢，所以考虑每次读取一批数据，没了再从磁盘中取，时间复杂度还是一样O(n)。</p><p><strong>回答2：</strong></p><p>1. 开10个文件通道，初始每个通道加载100M的日志到内存，充分利用内存，实现高速读写<br>2. 创建一个数组，容量为10，读取内存中每个文件的首位记录，放入数组并升序排序<br>3. 取数组首位记录，写入新文件<br>4. 从数组首位记录所属文件读取首位记录，使用二分查找插入有序数组<br>5. 重复步骤三<br>6. 如果内存中的某个文件内存记录读取完毕，则遍历所有文件内存，从磁盘中加载日志记录到内存，保持每个文件100M内存记录，直至整个文件读取完毕</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-排序上_为什么插入排序比冒泡排序更受欢迎</title>
      <link href="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/"/>
      <url>/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><p><a href="https://visualgo.net/en" target="_blank" rel="noopener">算法动态排序</a></p><p><a href="https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ" target="_blank" rel="noopener">图解排序算法</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>排序对于任何一个程序员来说，可能都不会陌生。你学的第一个算法，可能就是排序。大部分编程语言中，也都提供了排序函数。在平常的项目中，我们也经常会用到排序。排序非常重要，所以花多一点时间来详细讲解经典的排序算法。</p><p>排序算法太多了，有很多可能你连名字都没听说过，比如猴子排序、睡眠排序、面条排序等。我只讲众多排序算法中的一小撮，也是最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。我按照时间复杂度把它们分成了三类，分三篇文章来讲解。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/ecaf2819-2502-40fc-8c33-44dd091a8cf1.jpg" alt></p><p>带着问题去学习，是最有效的学习方法。所以按照惯例，还是先提出一个思考题：</p><p><font color="red"><strong>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</strong></font></p><p>你可以先思考一两分钟，带着这个问题，我们开始今天的内容！</p><a id="more"></a><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。那分析一个排序算法，要从哪几个方面入手呢？</p><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p><h4 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h4><p>我们在分析排序算法的时间复杂度时，要分别给出最好情况、最坏情况、平均情况下的时间复杂度。除此之外，你还要说出最好、最坏时间复杂度对应的要排序的原始数据是什么样的。</p><p>为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。</p><h4 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2. 时间复杂度的系数、常数 、低阶"></a>2. 时间复杂度的系数、常数 、低阶</h4><p>我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</p><h4 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3. 比较次数和交换（或移动）次数"></a>3. 比较次数和交换（或移动）次数</h4><p>这一篇和下一篇讲的都是基于比较的排序算法。基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，<strong>原地排序</strong>（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。我们今天讲的三种排序算法，都是原地排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p><p>你可能要问了，两个 3 哪个在前，哪个在后有什么关系啊，稳不稳定又有什么关系呢？为什么要考察排序算法的稳定性呢？</p><p>很多数据结构和算法课程，在讲排序的时候，都是用整数来举例，但在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。</p><p>比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p><p>最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</p><p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</p><p><strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong><br>第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/85a7e807-9c44-42c2-a602-36ba12e8eb57.jpg" alt></p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>我们从冒泡排序开始，学习今天的三种排序算法。</p><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>我用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/7d40a101-e71d-483a-9395-dbc9964f0ddd.jpg" alt></p><p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/64dda6c0-b5ba-4590-915e-aa9d171bc0a5.jpg" alt></p><p>实际上，刚讲的冒泡过程还可以优化。<strong>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序</strong>，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/36d2a029-b668-4811-94e3-2d6ca6d0848d.jpg" alt></p><p>冒泡排序算法的原理比较容易理解，具体的代码我贴到下面，你可以结合着代码来看我前面讲的原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 冒泡排序，a表示数组，n表示数组大小</span><br><span class="line">public void bubbleSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;&#x3D; 1) return;</span><br><span class="line"> </span><br><span class="line"> for (int i &#x3D; 0; i &lt; n; ++i) &#123;</span><br><span class="line">    &#x2F;&#x2F; 提前退出冒泡循环的标志位</span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; n - i - 1; ++j) &#123;</span><br><span class="line">      if (a[j] &gt; a[j+1]) &#123; &#x2F;&#x2F; 交换</span><br><span class="line">        int tmp &#x3D; a[j];</span><br><span class="line">        a[j] &#x3D; a[j+1];</span><br><span class="line">        a[j+1] &#x3D; tmp;</span><br><span class="line">        flag &#x3D; true;  &#x2F;&#x2F; 表示有数据交换      </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!flag) break;  &#x2F;&#x2F; 没有数据交换，提前退出</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，结合刚才我分析排序算法的三个方面，我有三个问题要问你。</p><h3 id="第一：冒泡排序是原地排序算法吗？"><a href="#第一：冒泡排序是原地排序算法吗？" class="headerlink" title="第一：冒泡排序是原地排序算法吗？"></a>第一：冒泡排序是原地排序算法吗？</h3><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p><h3 id="第二：冒泡排序是稳定的排序算法吗？"><a href="#第二：冒泡排序是稳定的排序算法吗？" class="headerlink" title="第二：冒泡排序是稳定的排序算法吗？"></a>第二：冒泡排序是稳定的排序算法吗？</h3><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><h3 id="第三：冒泡排序的时间复杂度是多少？"><a href="#第三：冒泡排序的时间复杂度是多少？" class="headerlink" title="第三：冒泡排序的时间复杂度是多少？"></a>第三：冒泡排序的时间复杂度是多少？</h3><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是<strong>倒序排列</strong>的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/b3843501-e61a-4e9d-a682-4c1e47b67d47.jpg" alt></p><p>最好、最坏情况下的时间复杂度很容易分析，那平均情况下的时间复杂是多少呢？我们前面讲过，平均时间复杂度就是加权平均期望时间复杂度，分析的时候要结合概率论的知识。</p><p>对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过<strong>“有序度”</strong>和<strong>“逆序度”</strong>这两个概念来进行分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/db52606a-9e67-4988-ac03-5c6d07a94f87.jpg" alt></p><p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 <strong>n*(n-1)/2</strong>，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序），我想你应该已经想到了。关于逆序度.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逆序元素对：a[i] &gt; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><p>关于这三个概念，我们还可以得到一个公式：<strong>逆序度 = 满有序度 - 有序度</strong>。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p><p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/6879a45c-9608-4ebd-b7d7-764c68475bfc.jpg" alt></p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<strong>逆序度，也就是n*(n-1)/2–初始有序度</strong>。此例中就是 15–3=12，要进行 12 次交换操作。</p><p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n<em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n</em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n<sup>2</sup>)，所以平均情况下的时间复杂度就是 O(n<sup>2</sup>)。</p><p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。等快排的时候，还会再次用这种“不严格”的方法来分析平均时间复杂度。</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/d76fe011-2c48-4d8e-9bc5-2c6a17df15ae.jpg" alt></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><p>那<strong>插入排序具体是如何借助上面的思想来实现排序的呢？</strong></p><p>首先，我们将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/9d34a618-fabe-4299-a0e7-ad927a967cbb.jpg" alt></p><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于<strong>逆序度</strong>。</p><p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/d9aab7a6-d279-4032-af89-7dc714c56238.jpg" alt></p><p>插入排序的原理也很简单吧？我也将代码实现贴在这里，你可以结合着代码再看下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 插入排序，a表示数组，n表示数组大小</span><br><span class="line">public void insertionSort(int[] a, int n) &#123;</span><br><span class="line">  if (n &lt;&#x3D; 1) return;</span><br><span class="line"></span><br><span class="line">  for (int i &#x3D; 1; i &lt; n; ++i) &#123;</span><br><span class="line">    int value &#x3D; a[i];</span><br><span class="line">    int j &#x3D; i - 1;</span><br><span class="line">    &#x2F;&#x2F; 查找插入的位置</span><br><span class="line">    for (; j &gt;&#x3D; 0; --j) &#123;</span><br><span class="line">      if (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+1] &#x3D; a[j];  &#x2F;&#x2F; 数据移动</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+1] &#x3D; value; &#x2F;&#x2F; 插入数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，三个问题。</p><h3 id="第一：插入排序是原地排序算法吗？"><a href="#第一：插入排序是原地排序算法吗？" class="headerlink" title="第一：插入排序是原地排序算法吗？"></a>第一：插入排序是原地排序算法吗？</h3><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p><h3 id="第二：插入排序是稳定的排序算法吗？"><a href="#第二：插入排序是稳定的排序算法吗？" class="headerlink" title="第二：插入排序是稳定的排序算法吗？"></a>第二：插入排序是稳定的排序算法吗？</h3><p>在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><h3 id="第三：插入排序的时间复杂度是多少？"><a href="#第三：插入排序的时间复杂度是多少？" class="headerlink" title="第三：插入排序的时间复杂度是多少？"></a>第三：插入排序的时间复杂度是多少？</h3><p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n<sup>2</sup>)。</p><p>还记得我们在数组中插入一个数据的平均时间复杂度是多少吗？没错，是 O(n)。所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n<sup>2</sup>)。</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分<strong>已排序区间</strong>和<strong>未排序区间</strong>。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/d497f2d8-e054-4ada-845f-a984966d50c8.jpg" alt></p><p>照例，也有三个问题需要你思考，不过前面两种排序算法我已经分析得很详细了，这里就直接公布答案了。</p><p>首先，选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n<sup>2</sup>)。</p><p>那选择排序是<strong>稳定的排序算法</strong>吗？这个问题我着重来说一下。</p><p>答案是否定的，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>基本的知识都讲完了，我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p><p>们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。我们来看这段操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line">if (a[j] &gt; a[j+1]) &#123; &#x2F;&#x2F; 交换</span><br><span class="line">   int tmp &#x3D; a[j];</span><br><span class="line">   a[j] &#x3D; a[j+1];</span><br><span class="line">   a[j+1] &#x3D; tmp;</span><br><span class="line">   flag &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line">if (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+1] &#x3D; a[j];  &#x2F;&#x2F; 数据移动</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><p>这个只是我们非常理论的分析，为了实验，针对上面的冒泡排序和插入排序的 Java 代码，可以写一个性能对比测试程序，随机生成 10000 个数组，每个数组中包含 200 个数据，然后在我的机器上分别用冒泡和插入排序算法来排序，冒泡排序算法大约 700ms 才能执行完成，而插入排序只需要 100ms 左右就能搞定！</p><p>以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n2)，但是如果我们希望把性能优化做到极致，那肯定首选插入排序。插入排序的算法思路也有很大的优化空间，我们只是讲了最基础的一种。如果你对插入排序的优化感兴趣，可以自行学习一下<a href="https://baike.baidu.com/item/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/3229428?fr=aladdin" target="_blank" rel="noopener">希尔排序</a>。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>要想分析、评价一个排序算法，需要从执行效率、内存消耗和稳定性三个方面来看。因此，这一篇文章，带你分析了三种时间复杂度是 O(n2) 的排序算法，冒泡排序、插入排序、选择排序。需要重点掌握的是它们的分析方法。</p><p><img src="/2018/10/22/7-%E6%8E%92%E5%BA%8F%E4%B8%8A-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%9B%B4%E5%8F%97%E6%AC%A2%E8%BF%8E/0f2eab21-bad5-49c5-b1bc-1688f0043ab8.jpg" alt></p><p>这三种时间复杂度为 O(n2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。后面文章提到排序优化的时候，还会提到，有些编程语言中的排序函数的实现原理会用到插入排序算法。</p><p>今天讲的这三种排序算法，实现代码都非常简单，对于小规模数据的排序，用起来非常高效。但是在大规模数据排序的时候，这个时间复杂度还是稍微有点高，所以我们更倾向于用下一篇要讲的时间复杂度为 O(nlogn) 的排序算法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>特定算法是依赖特定的数据结构的。我们今天讲的几种排序算法，都是基于数组实现的。如果数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</p><p><strong>回答：</strong>应该有个前提，是否允许修改链表的节点value值，还是只能改变节点的位置。一般而言，考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>冒泡、插入、选择排序都有一个共同点，将待排序数列分为已排序和未排序两部分。在未排序的部分中查找一个最值，放到已排序数列的恰当位置。</p><p>具体到代码层面，外层循环的变量用于分割已排序和未排序数，内层循环的变量用于在未排序数中查找。从思路上看，这三种算法其实是一样的，所以时间复杂度也相同。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-递归_如何用三行代码找到最终推荐人</title>
      <link href="/2018/10/20/6-%E9%80%92%E5%BD%92-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/"/>
      <url>/2018/10/20/6-%E9%80%92%E5%BD%92-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>推荐注册返佣金</strong>的这个功能我想你应该不陌生吧？现在很多 App 都有这个功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p><p>一般来说，我们会通过数据库来记录这种推荐关系。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id。</p><p><img src="/2018/10/20/6-%E9%80%92%E5%BD%92-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/e2684753-9a8d-4f18-8f80-65e0e4de02e2.jpg" alt></p><p>基于这个背景，我的问题是，<strong>给定一个用户 ID，如何查找这个用户的“最终推荐人”？</strong> 带着这个问题，我们来学习今天的内容，递归（Recursion）！</p><a id="more"></a><h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><p>从我自己学习数据结构和算法的经历来看，我个人觉得，有两个最难理解的知识点，一个是<strong>动态规划</strong>，另一个就是<strong>递归</strong>。</p><p>归是一种应用非常广泛的算法（或者编程技巧）。之后我们要讲的很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，搞懂递归非常重要，否则，后面复杂一些的数据结构和算法学起来就会比较吃力。</p><p>不过，别看我说了这么多，递归本身可是一点儿都不“高冷”，咱们生活中就有很多用到递归的例子。</p><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？电影院里面太黑了，看不清，没法数，现在你怎么办？</p><p>别忘了你是程序员，这个可难不倒你，递归就开始排上用场了。于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用<strong>递推公式</strong>来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n)&#x3D;f(n-1)+1 其中，f(1)&#x3D;1</span><br></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return f(n-1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>刚刚这个例子是非常典型的递归，那究竟什么样的问题可以用递归来解决呢？我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决。</p><h3 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1. 一个问题的解可以分解为几个子问题的解"></a>1. 一个问题的解可以分解为几个子问题的解</h3><p>何为子问题？子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题。</p><h3 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h3><p>比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的。</p><h3 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3. 存在递归终止条件"></a>3. 存在递归终止条件</h3><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件。</p><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>刚刚铺垫了这么多，现在我们来看，如何来写递归代码？我个人觉得，写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p><p><strong>先记住这个理论。</strong></p><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p><p>我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>有了递推公式，递归代码基本上就完成了一半。我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。这个递归终止条件足够吗？我们可以用 n=2，n=3 这样比较小的数试验一下。</p><p>n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 f(1)=1，f(2)=2。这个时候，你可以再拿 n=3，n=4 来验证一下，这个终止条件是否足够并且正确。</p><p>我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; 1;</span><br><span class="line">f(2) &#x3D; 2;</span><br><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">  return f(n-1) + f(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong></font>。</p><p>刚讲的电影院的例子，我们的递归调用只有一个分支，也就是说“一个问题只需要分解为一个子问题”，我们很容易能够想清楚“递“和”归”的每一个步骤，所以写起来、理解起来都不难。</p><p>但是，当我们面对的是一个问题要分解为多个子问题的情况，递归代码就没那么好理解了。</p><p>像我刚刚讲的第二个例子，人脑几乎没办法把整个“递”和“归”的过程一步一步都想清楚。</p><p>计算机擅长做重复的事情，所以递归正和它的胃口。而我们人脑更喜欢平铺直叙的思维方式。当我们看到递归时，我们总想把递归平铺展开，脑子里就会循环，一层一层往下调，然后再一层一层返回，试图想搞清楚计算机每一步都是怎么执行的，这样就很容易被绕进去。</p><p>对于递归代码，这种试图想清楚整个递和归过程的做法，实际上是进入了一个思维误区。很多时候，我们理解起来比较吃力，主要原因就是自己给自己制造了这种理解障碍。那正确的思维方式应该是怎样的呢？</p><p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>在实际的软件开发中，编写递归代码时，我们会遇到很多问题，比如堆栈溢出。而堆栈溢出会造成系统性崩溃，后果会非常严重。为什么递归代码容易造成堆栈溢出呢？我们又该如何预防堆栈溢出呢？</p><p>在“栈”那一节提过，，函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p>比如前面的讲到的电影院的例子，如果我们将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>那么，如何避免出现堆栈溢出呢?</p><p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。不过，我写的代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 全局变量，表示递归的深度。</span><br><span class="line">int depth &#x3D; 0;</span><br><span class="line"></span><br><span class="line">int f(int n) &#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  if (depth &gt; 1000) throw exception;</span><br><span class="line">  </span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return f(n-1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。递归代码要警惕重复计算</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：</p><p><img src="/2018/10/20/6-%E9%80%92%E5%BD%92-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%89%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E6%8E%A8%E8%8D%90%E4%BA%BA/df02be98-0ae8-4bb0-b6ac-9341e4511f27.jpg" alt></p><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><p>按照上面的思路，我们来改造一下刚才的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; hasSolvedList可以理解成一个Map，key是n，value是f(n)</span><br><span class="line">  if (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    return hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int ret &#x3D; f(n-1) + f(n-2);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了堆栈溢出、重复计算这两个常见的问题。递归代码还有很多别的问题。</p><p>在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p><h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p><p>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看 f(x) =f(x-1)+1 这个递推公式。我们这样改写看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  int ret &#x3D; 1;</span><br><span class="line">  for (int i &#x3D; 2; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">    ret &#x3D; ret + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，第二个例子也可以改为非递归的实现方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  if (n &#x3D;&#x3D; 2) return 2;</span><br><span class="line">  </span><br><span class="line">  int ret &#x3D; 0;</span><br><span class="line">  int pre &#x3D; 2;</span><br><span class="line">  int prepre &#x3D; 1;</span><br><span class="line">  for (int i &#x3D; 3; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">    ret &#x3D; pre + prepre;</span><br><span class="line">    prepre &#x3D; pre;</span><br><span class="line">    pre &#x3D; ret;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那是不是所有的递归代码都可以改为这种<strong>迭代循环</strong>的非递归写法呢？</p><p>笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>到此为止，递归相关的基础知识已经讲完了，咱们来看一下开篇的问题：如何找到“最终推荐人”？我的解决方案是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long findRootReferrerId(long actorId) &#123;</span><br><span class="line">  Long referrerId &#x3D; select referrer_id from [table] where actor_id &#x3D; actorId;</span><br><span class="line">  if (referrerId &#x3D;&#x3D; null) return actorId;</span><br><span class="line">  return findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是非常简洁？用三行代码就能搞定了，不过在实际项目中，上面的代码并不能工作，为什么呢？这里面有两个问题。</p><ul><li><p><strong>第一，如果递归很深，可能会有堆栈溢出的问题。</strong></p></li><li><p><strong>第二，如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环</strong></p></li></ul><p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是自动检测 A-B-C-A 这种“环”的存在。如何来检测环的存在呢？后续文章会提到。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>递归是一种非常高效、简洁的编码技巧。只要是满足“三个条件”的问题就可以通过递归代码来解决。</p><p>不过递归代码也比较难写、难理解。编写递归代码的关键就是不要把自己绕进去，正确姿势是<strong>写出递推公式，找出终止条件</strong>，然后再翻译成递归代码。</p><p>递归代码虽然简洁高效，但是，递归代码也有很多弊端。比如，堆栈溢出、重复计算、函数调用耗时多、空间复杂度高等，所以，在编写递归代码的时候，一定要控制好这些副作用。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？</p><p>**<br>调试递归:<br>1.打印日志发现，递归值。<br>2.结合条件断点进行调试。**</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-队列_队列在线程池等有限资源池中的应用</title>
      <link href="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道，CPU 资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><font color="red">当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</font></p><p>实际上，这些问题并不复杂，其底层的数据结构就是我们今天要学的内容，队列（queue）。</p><a id="more"></a><h2 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出，这就是典型的“队列”</strong>。</p><p>我们知道，栈只支持两个基本操作：<strong>入栈 push()</strong>和<strong>出栈 pop()</strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/5f0236a0-180b-4b6d-a906-d3960a451b1f.jpg" alt></p><p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>我们知道了，队列跟栈一样，也是一种抽象的数据结构。它具有先进先出的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？</p><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>我们先来看下基于数组的实现方法。我用 Java 语言实现了一下，不过并不包含 Java 语言的高级语法，而且我做了比较详细的注释，你应该可以看懂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用数组实现的队列</span><br><span class="line">public class ArrayQueue &#123;</span><br><span class="line">  &#x2F;&#x2F; 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; head表示队头下标，tail表示队尾下标</span><br><span class="line">  private int head &#x3D; 0;</span><br><span class="line">  private int tail &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 申请一个大小为capacity的数组</span><br><span class="line">  public ArrayQueue(int capacity) &#123;</span><br><span class="line">    items &#x3D; new String[capacity];</span><br><span class="line">    n &#x3D; capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果tail &#x3D;&#x3D; n 表示队列已经满了</span><br><span class="line">    if (tail &#x3D;&#x3D; n) return false;</span><br><span class="line">    items[tail] &#x3D; item;</span><br><span class="line">    ++tail;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果head &#x3D;&#x3D; tail 表示队列为空</span><br><span class="line">    if (head &#x3D;&#x3D; tail) return null;</span><br><span class="line">    &#x2F;&#x2F; 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了</span><br><span class="line">    String ret &#x3D; items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比起栈的数组实现，队列的数组实现稍微有点儿复杂，但是没关系。我稍微解释一下实现思路，你很容易就能明白了。</p><p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p><p>你可以结合下面这幅图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/23db3e44-166a-4d03-9721-3bc2fc0b027a.jpg" alt></p><p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/7f599d08-48b2-403a-86e4-5bcde716286a.jpg" alt></p><p>你肯定已经发现了，随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？</p><p>你是否还记得，在数组那一节，我们也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。你还记得我们当时是怎么解决的吗？对，用<strong>数据搬移</strong>！但是，每次进行出队操作都相当于删除数组下标为 0 的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的 O(1) 变为 O(n)。能不能优化一下呢？</p><p>实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，就可以轻松解决刚才的问题了。下面是具体的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 入队操作，将item放入队尾</span><br><span class="line">public boolean enqueue(String item) &#123;</span><br><span class="line">  &#x2F;&#x2F; tail &#x3D;&#x3D; n表示队列末尾没有空间了</span><br><span class="line">  if (tail &#x3D;&#x3D; n) &#123;</span><br><span class="line">    &#x2F;&#x2F; tail &#x3D;&#x3D;n &amp;&amp; head&#x3D;&#x3D;0，表示整个队列都占满了</span><br><span class="line">    if (head &#x3D;&#x3D; 0) return false;</span><br><span class="line">    &#x2F;&#x2F; 数据搬移</span><br><span class="line">    for (int i &#x3D; head; i &lt; tail; ++i) &#123;</span><br><span class="line">      items[i-head] &#x3D; items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 搬移完之后重新更新head和tail</span><br><span class="line">    tail -&#x3D; head;</span><br><span class="line">    head &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  items[tail] &#x3D; item;</span><br><span class="line">  ++tail;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1693eeca-8f6b-4495-b3a0-169a7267561e.jpg" alt></p><p>这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？</p><p>接下来，我们再来看下<strong>基于链表的队列实现方法</strong>。</p><p>于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/42053731-b3cb-4e02-bbb7-992864aef8a7.jpg" alt></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>我们刚才用数组来实现队列的时候，在 tail==n 时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。</p><p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/9b12deb4-a8da-4cd6-bce7-b488c3d5b0d0.jpg" alt></p><p>我们可以看到，图中这个队列的大小为 8，当前 head=4，tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/587f42f6-9c59-429c-902f-8a9c80341d81.jpg" alt></p><p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？</p><p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。我画了一张队列满的图，你可以看一下，试着总结一下规律。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/ac3a4d31-8fc6-42ed-a947-2d418a078135.jpg" alt></p><p>就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p><p>你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><p>Talk is cheap，如果还是没怎么理解，那就 show you code 吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CircularQueue &#123;</span><br><span class="line">  &#x2F;&#x2F; 数组：items，数组大小：n</span><br><span class="line">  private String[] items;</span><br><span class="line">  private int n &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; head表示队头下标，tail表示队尾下标</span><br><span class="line">  private int head &#x3D; 0;</span><br><span class="line">  private int tail &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 申请一个大小为capacity的数组</span><br><span class="line">  public CircularQueue(int capacity) &#123;</span><br><span class="line">    items &#x3D; new String[capacity];</span><br><span class="line">    n &#x3D; capacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 入队</span><br><span class="line">  public boolean enqueue(String item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 队列满了</span><br><span class="line">    if ((tail + 1) % n &#x3D;&#x3D; head) return false;</span><br><span class="line">    items[tail] &#x3D; item;</span><br><span class="line">    tail &#x3D; (tail + 1) % n;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 出队</span><br><span class="line">  public String dequeue() &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果head &#x3D;&#x3D; tail 表示队列为空</span><br><span class="line">    if (head &#x3D;&#x3D; tail) return null;</span><br><span class="line">    String ret &#x3D; items[head];</span><br><span class="line">    head &#x3D; (head + 1) % n;</span><br><span class="line">    return ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>面讲的内容理论比较多，看起来很难跟实际的项目开发扯上关系。确实，队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/f6f461e0-f09f-4346-8dba-fcf626289817.jpg" alt></p><p>你应该已经发现了，上述的定义就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p><p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p><p><img src="/2018/10/16/5-%E9%98%9F%E5%88%97-%E9%98%9F%E5%88%97%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AD%89%E6%9C%89%E9%99%90%E8%B5%84%E6%BA%90%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/15ca5036-482f-4240-b31d-4547a021f2b9.jpg" alt></p><p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，<strong>基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列</strong>。这也是循环队列比链式队列应用更加广泛的原因。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>队列的知识就讲完了，我们现在回过来看下开篇的问题。线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p><p>基于<strong>链表</strong>的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于<strong>数组</strong>实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队</strong>。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p><p>循环队列是我们这节的重点。要想写出没有 bug 的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码要能写出来。</p><p>除此之外，我们还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="扩展1"><a href="#扩展1" class="headerlink" title="扩展1"></a>扩展1</h3><p>1.分布式应用中的消息队列，也是一种队列结构<br>2.考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。</p><h3 id="扩展2"><a href="#扩展2" class="headerlink" title="扩展2"></a>扩展2</h3><p>循环队列的长度设定需要对并发数据有一定的预测，否则会丢失太多请求。</p><h3 id="扩展3"><a href="#扩展3" class="headerlink" title="扩展3"></a>扩展3</h3><ol><li>在网卡的收发数据包操作，linux内核协议栈采用循环队列的方式进行处理。</li><li>linux内核态ruc和用户态urcu实现了无锁并发访问共享数据，非常适合于读多写少的场景。其核心思想是，拷贝复制链表数据，原子操作移动链表指针，实现真正的无锁操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-栈_如何实现浏览器的前进和后退功能</title>
      <link href="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>浏览器的前进、后退功能，我想你肯定很熟悉吧？当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p><p><font color="red">假设你是 Chrome 浏览器的开发工程师，你会如何实现这个功能呢？</font></p><p>这就要用到我们今天要讲的“栈”这种数据结构。</p><p><strong>带着这个问题，我们来学习今天的内容。</strong></p><a id="more"></a><h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>关于“栈”，我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出，这就是典型的“栈”结构</strong>。</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/4ada3640-9229-4d23-b48a-18858e953790.jpg" alt></p><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>一次接触这种数据结构的时候，就对它存在的意义产生了很大的疑惑。因为我觉得，相比数组和链表，栈带给我的只有限制，并没有任何优势。那我直接使用数组或者链表不就好了吗？为什么还要用这个“操作受限”的“栈”呢？</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构。</strong></p><h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>从刚才栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。理解了栈的定义之后，我们来看一看如何用代码实现一个栈。</p><p>实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>这里实现一个基于数组的顺序栈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 基于数组实现的顺序栈</span><br><span class="line">public class ArrayStack &#123;</span><br><span class="line">  private String[] items;  &#x2F;&#x2F; 数组</span><br><span class="line">  private int count;       &#x2F;&#x2F; 栈中元素个数</span><br><span class="line">  private int n;           &#x2F;&#x2F;栈的大小</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 初始化数组，申请一个大小为n的数组空间</span><br><span class="line">  public ArrayStack(int n) &#123;</span><br><span class="line">    this.items &#x3D; new String[n];</span><br><span class="line">    this.n &#x3D; n;</span><br><span class="line">    this.count &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 入栈操作</span><br><span class="line">  public boolean push(String item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数组空间不够了，直接返回false，入栈失败。</span><br><span class="line">    if (count &#x3D;&#x3D; n) return false;</span><br><span class="line">    &#x2F;&#x2F; 将item放到下标为count的位置，并且count加一</span><br><span class="line">    items[count] &#x3D; item;</span><br><span class="line">    ++count;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 出栈操作</span><br><span class="line">  public String pop() &#123;</span><br><span class="line">    &#x2F;&#x2F; 栈为空，则直接返回null</span><br><span class="line">    if (count &#x3D;&#x3D; 0) return null;</span><br><span class="line">    &#x2F;&#x2F; 返回下标为count-1的数组元素，并且栈中元素个数count减一</span><br><span class="line">    String tmp &#x3D; items[count-1];</span><br><span class="line">    --count;</span><br><span class="line">    return tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了定义和基本操作，那它的操作的时间、空间复杂度是多少呢？</p><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。</p><p>注意，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指除了原本的数据存储空间外，算法运行还需要额外的存储空间。</p><p>空间复杂度分析是不是很简单？时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，在初始化栈时需要事先指定栈的大小。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 next 指针，内存消耗相对较多。那我们如何基于数组实现一个可以支持动态扩容的栈呢?</p><p>你还记得，我们在数组那一节，是如何来实现一个支持动态扩容的数组的吗？当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p><p>所以，如果要实现一个支持动态扩容的栈，我们只需要底层依赖一个支持动态扩容的数组就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下。</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/6ad3a913-76b7-41b0-bd7e-26002175ad15.jpg" alt></p><p>际上，支持动态扩容的顺序栈，我们平时开发中并不常用到。我讲这一块的目的，主要还是希望带你练习一下前面讲的复杂度分析方法。所以这一小节的重点是复杂度分析。</p><p>你不用死记硬背入栈、出栈的时间复杂度，你需要掌握的是分析方法。能够自己分析才算是真正掌握了。现在我就带你分析一下支持动态扩容的顺序栈的入栈、出栈操作的时间复杂度。</p><p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。</p><p>也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。那平均情况下的时间复杂度又是多少呢？还记得我们在复杂度分析那一节中讲的摊还分析法吗？这个入栈操作的平均情况下的时间复杂度可以用摊还分析法来分析。我们也正好借此来实战一下摊还分析法。</p><p>为了分析的方便，我们需要事先做一些假设和定义：</p><ul><li><p>栈空间不够时，我们重新申请一个是原来大小两倍的数组</p></li><li><p>为了简化分析，假设只有入栈操作没有出栈操作</p></li><li><p>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)</p></li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成。为了让你更加直观地理解这个过程，我画了一张图。</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/c263c364-8879-4d5f-b7a1-46532ecb9051.jpg" alt></p><p>你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，入栈操作的均摊时间复杂度就为 O(1)。</p><p>通过这个例子的实战分析，也印证了前面讲到的，均摊时间复杂度一般都等于最好情况时间复杂度。因为在大部分情况下，入栈操作的时间复杂度 O 都是 O(1)，只有在个别时刻才会退化为 O(n)，所以把耗时多的入栈操作的时间均摊到其他入栈操作上，平均情况下的耗时就接近 O(1)。</p><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>我们现在来看下，栈在软件工程中的实际应用。栈作为一个比较基础的数据结构，应用场景还是蛮多的。其中，比较经典的一个应用场景就是<strong>函数调用栈</strong>。</p><p>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。为了让你更好地理解，我们一块来看下这段代码的执行过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">   int a &#x3D; 1; </span><br><span class="line">   int ret &#x3D; 0;</span><br><span class="line">   int res &#x3D; 0;</span><br><span class="line">   ret &#x3D; add(3, 5);</span><br><span class="line">   res &#x3D; a + ret;</span><br><span class="line">   printf(&quot;%d&quot;, res);</span><br><span class="line">   reuturn 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">   int sum &#x3D; 0;</span><br><span class="line">   sum &#x3D; x + y;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况。</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/4edb18b8-7f77-4f1b-939e-d147a6e60acb.jpg" alt></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>我们再来看栈的另一个常见的应用场景，编译器如何利用栈来实现<strong>表达式求值</strong>。</p><p>为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12/3。对于这个四则运算，我们人脑可以很快求解出答案，但是对于计算机来说，理解这个表达式本身就是个挺难的事儿。如果换作你，让你来实现这样一个表达式求值的功能，你会怎么做呢？</p><p>实际上，编译器就是通过两个栈来实现的。其中一个<strong>保存操作数的栈</strong>，另一个是<strong>保存运算符的栈</strong>。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>我将 3+5*8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程。</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/6b687fce-7133-4653-b2f2-91fd14e85a5b.jpg" alt></p><p>这样用两个栈来解决的思路是不是非常巧妙？你有没有想到呢？</p><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>除了用栈来实现表达式求值，我们还可以借助栈来检查表达式中的括号是否匹配。</p><p>们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{[] ()[{}]}或[{()}([])]等都为合法格式，而{[}()]或[({)]为不合法的格式。那我现在给你一个包含三种括号的表达式字符串，如何检查它是否合法呢？</p><p>里也可以用栈来解决。我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>我们再回来看看开篇的思考题，如何实现浏览器的前进、后退功能？其实，用两个栈就可以非常完美地解决这个问题。</p><p>们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p><p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/48f7ac28-dc7c-4b33-8be0-8bc6925d8b68.jpg" alt></p><p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/4c92a071-6922-4acc-a944-6d4fb8dd183b.jpg" alt></p><p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/33d2c4db-25c7-4086-bfe5-927d92796218.jpg" alt></p><p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p><p><img src="/2018/10/13/4-%E6%A0%88-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%89%8D%E8%BF%9B%E5%92%8C%E5%90%8E%E9%80%80%E5%8A%9F%E8%83%BD/38b8a6e3-7c61-497a-87d4-6cb9bed6c6d9.jpg" alt></p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>栈是一种操作受限的数据结构，只支持入栈和出栈操作。后进先出是它最大的特点。栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。除此之外，我们还讲了一种支持动态扩容的顺序栈，你需要重点掌握它的均摊时间复杂度分析方法。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li><p>我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p></li><li><p>我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？</p></li></ul><p><strong>回答1：</strong></p><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</p><p>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。</p><p>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</p><p>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。</p><p>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</p><p>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p><p><strong>回答2：</strong></p><p>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz学习</title>
      <link href="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p> <strong><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz</a></strong>是一个开放源码的任务调度框架。Quartz功能强大。可以让你的程序在指定时间执行，也可以按照某一个频度执行，支持数据库、监听器</p><a id="more"></a><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="2-1-Maven坐标"><a href="#2-1-Maven坐标" class="headerlink" title="2.1 Maven坐标"></a>2.1 Maven坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-定义任务内容"><a href="#2-2-定义任务内容" class="headerlink" title="2.2 定义任务内容"></a>2.2 定义任务内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line">import java.util.Date;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 任务内容</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MyJob implements Job&#123;</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws</span><br><span class="line">JobExecutionException &#123;</span><br><span class="line">    &#x2F;&#x2F; 输出系统当前时间</span><br><span class="line">    System.out.println(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-构建调度任务"><a href="#2-3-构建调度任务" class="headerlink" title="2.3 构建调度任务"></a>2.3 构建调度任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.JobDetail;</span><br><span class="line">import org.quartz.Scheduler;</span><br><span class="line">import org.quartz.SchedulerException;</span><br><span class="line">import org.quartz.Trigger;</span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;</span><br><span class="line">import static org.quartz.JobBuilder.newJob;</span><br><span class="line">import static org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class="line">import static org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 构建调度任务</span><br><span class="line">*&#x2F;</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line">    public static void main(String[] args) throws SchedulerException &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取调度器器</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        &#x2F;&#x2F; 包装任务内容</span><br><span class="line">        JobDetail job &#x3D; newJob(MyJob.class)</span><br><span class="line">                    .withIdentity(&quot;job1&quot;, &quot;group1&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">        &#x2F;&#x2F; 定义触发器器</span><br><span class="line">        Trigger trigger &#x3D; newTrigger()</span><br><span class="line">                    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(simpleSchedule()</span><br><span class="line">                    .withIntervalInSeconds(40)</span><br><span class="line">                    .repeatForever())</span><br><span class="line">                    .build();</span><br><span class="line">        &#x2F;&#x2F; 组装任务</span><br><span class="line">        scheduler.scheduleJob(job, trigger);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 启动调度器器 开始调度</span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、体系架构"><a href="#三、体系架构" class="headerlink" title="三、体系架构"></a>三、体系架构</h2><ul><li><strong>Job</strong><br>是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务),JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中。</li><li><strong>JobDetail</strong><br>JobDetail 定义的是任务数据，⽽真正的执行逻辑是在Job中。sheduler每次执⾏，都会根据JobDetail创建一个新的Job实例。</li><li><strong>Trigger</strong><br>是一个类，描述触发Job执⾏的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如⼯作日周一到周五的15：00~16：00执⾏调度等</li></ul><p><span style="border-bottom:2px solid;">Cron表达式的格式</span>： 秒 分 时 日 月 周 年(可选)</p><table><thead><tr><th align="center">字段名</th><th align="center">允许的值</th><th align="center">允许的特殊字符</th></tr></thead><tbody><tr><td align="center">秒</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">分</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">时</td><td align="center">0-23</td><td align="center">，- * /</td></tr><tr><td align="center">日</td><td align="center">1-31</td><td align="center">, - * ? / L W C</td></tr><tr><td align="center">月</td><td align="center">1-12 or JAN-DEC</td><td align="center">, - * /</td></tr><tr><td align="center">周</td><td align="center">1-7 or SUN-SAT</td><td align="center">, - * ? / L C # MON FRI</td></tr><tr><td align="center">年</td><td align="center">empty,1970-2099</td><td align="center">, - * /</td></tr></tbody></table><p><span style="border-bottom:2px solid;">允许的特殊字符</span>：</p><ol><li>“?”字符：表示不确定值</li><li>“,”字符：指定数个值</li><li>“-“字符：指定一个值的范围</li><li>“/“字符：指定一个值得增加强度。n/m表示从n开始，每次增加m</li><li>“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X</li><li>“W”字符：指定离给定日期最近的工作日（周一到周五）</li><li>“#”字符：表示该月第一个周X。6#3表示该月第三个周五</li></ol><p><span>Cron表达式范例：</span></p><ol><li>每隔5秒执行一次：  */5 * * * * ?</li><li>每隔1分钟执行一次： 0 */1 * * * *</li><li>每天23点执行一次：  0 0 23 * * ？</li><li>每天凌晨1点执行一次： 0 0 1 * * ?</li><li>每月1号凌晨1点执行一次： 0 0 1 1 * ?</li><li>每月最后一天23点执行一次： 0 0 23 L * ?</li><li>每周星期天凌晨1点执行一次： 0 0 1 ？ * L</li><li>在26分、29分、33分执行一次： 0 26,29,33 * * * ？</li><li>每天的0点、13点、18点、21点执行一次：0 0 0,13,18,21 * * ?</li></ol><ul><li><p><strong>Scheduler</strong><br>代表一个Quartz的独立运行容器。Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，<br>Trigger的组及名称必须唯一，JobDetail的组及名称也必须唯一（但可以和Trigger的组和名称相同，因为他们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</p></li><li><p><strong>JobBuilder</strong><br>用于定义/构建已经定义了Job实例的JobDetail实例</p></li><li><p><strong>TriggerBuilder</strong><br>用于定义/构建Trigger实例。</p></li></ul><h2 id="四、Spring集成"><a href="#四、Spring集成" class="headerlink" title="四、Spring集成"></a>四、Spring集成</h2><h3 id="4-1-Maven坐标"><a href="#4-1-Maven坐标" class="headerlink" title="4.1 Maven坐标"></a>4.1 Maven坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--spring依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-定义任务内容"><a href="#4-2-定义任务内容" class="headerlink" title="4.2 定义任务内容"></a>4.2 定义任务内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class MyJob implements Job&#123;</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throwsJobExecutionException &#123;</span><br><span class="line">           System.out.println(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-配置文件"><a href="#4-3-配置文件" class="headerlink" title="4.3 配置文件"></a>4.3 配置文件</h3><p>如：Spring-quartz.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line"> xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">     &lt;!--创建JobDetail--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">      &lt;!--指定任务类--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;MyJob&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">      &lt;!--当Job在没有可以使用的trigger的情况下 不删除--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;!--注意 spring quartz整合 一个trigger只可以绑定一个JobDetail 一个jobDetail可</span><br><span class="line">以被多个Trigger所使用--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;trigger&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line">      &lt;!--绑定JobDetail--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;0-30 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;trigger1&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;!--绑定JobDetail--&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;45-55 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--注册trigger--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;scheduler&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">       &lt;&#x2F;property&gt;</span><br><span class="line">     &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><p>启动<em>Spring</em>工厂测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/2018-10-31_222450.png" alt="spring方式启动quartz" title="spring方式启动quartz"></p><h2 id="五、存储方式"><a href="#五、存储方式" class="headerlink" title="五、存储方式"></a>五、存储方式</h2><h3 id="5-1-RAMJobStore和JDBCJobStore"><a href="#5-1-RAMJobStore和JDBCJobStore" class="headerlink" title="5.1 RAMJobStore和JDBCJobStore"></a>5.1 RAMJobStore和JDBCJobStore</h3><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RAMJobStore(默认)</td><td>不要外部数据库，配置容易，运行速度快</td><td>因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存⾥里面，所以可以存储多少个Job和Trigger将会受到限制</td></tr><tr><td>JDBCJobStore</td><td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td><td>运行速度的快慢取决与连接数据库的快慢</td></tr></tbody></table><h3 id="5-2-设置JDBCJobStore"><a href="#5-2-设置JDBCJobStore" class="headerlink" title="5.2 设置JDBCJobStore"></a>5.2 设置JDBCJobStore</h3><p>在应用程序中设置使用JDBCJobStore需要两步：首先必须创建作业仓库使用的数据库表。JDBCJobStore 与所有主流数据库兼容。而且Quartz提供了一系列创建表的SQL脚本，能够简化设置过程。可以再Quartz发行包的“docs/dbTables”目录中找到创建的SQL脚本。第二，必须定义一些属性</p><ol><li>创建Quartz数据库表</li><li>在quartz.properties文件中指定JDBCJobStore属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.threadPool.class &#x3D; org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount &#x3D; 10</span><br><span class="line">org.quartz.threadPool.threadPriority &#x3D; 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread &#x3D; true</span><br><span class="line"></span><br><span class="line"># Using RAMJobStore</span><br><span class="line">## if using RAMJobStore, please be sure that you comment out the following</span><br><span class="line">## - org.quartz.jobStore.tablePrefix,</span><br><span class="line">## - org.quartz.jobStore.driverDelegateClass,</span><br><span class="line">## - org.quartz.jobStore.dataSource</span><br><span class="line">#org.quartz.jobStore.class &#x3D; org.quartz.simpl.RAMJobStore</span><br><span class="line"></span><br><span class="line"># Using JobStoreTX</span><br><span class="line">## Be sure to run the appropriate script(under docs&#x2F;dbTables) first to create tables</span><br><span class="line">org.quartz.jobStore.class &#x3D; org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line"></span><br><span class="line"># Configuring JDBCJobStore with the Table Prefix</span><br><span class="line">org.quartz.jobStore.tablePrefix &#x3D; QRTZ_</span><br><span class="line"></span><br><span class="line"># Using DriverDelegate</span><br><span class="line">org.quartz.jobStore.driverDelegateClass &#x3D;</span><br><span class="line">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"></span><br><span class="line"># Using datasource</span><br><span class="line">org.quartz.jobStore.dataSource &#x3D; qzDS</span><br><span class="line"></span><br><span class="line"># Define the datasource to use</span><br><span class="line">org.quartz.dataSource.qzDS.driver &#x3D; com.mysql.jdbc.Driver</span><br><span class="line">org.quartz.dataSource.qzDS.URL &#x3D; jdbc: mysql:&#x2F;&#x2F;localhost:3306&#x2F;quartz</span><br><span class="line">org.quartz.dataSource.qzDS.user &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.password &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.maxConnections &#x3D; 30</span><br></pre></td></tr></table></figure><h3 id="5-3-测试"><a href="#5-3-测试" class="headerlink" title="5.3 测试"></a>5.3 测试</h3><h2 id="六、集群支持"><a href="#六、集群支持" class="headerlink" title="六、集群支持"></a>六、集群支持</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>虽然单个Quartz实例能给予你很好的Job调度能力，但他不能满足典型的企业需求，如可伸缩性、高可靠性满足、假如你需要故障转移的能力并能运行日益增多的JOB，QUARTZ集群势必成为你应用的一部分了。使用Quartz的集群能力可以很好的支持你的业务需求，并且即使是其中一台机器在最糟的时间崩溃了也能确保所有的Job得到执行。</p><p>一个Quartz集群中的每个节点都是一个独立的Quartz应用，它又管理者其他的节点。意思是你必须对每个节点分别启动或者停止。不像许多应用服务器的集群，独立的Quartz节点并不与另一其他的节点或是管理节点通信。Quartz应用是通过数据库表来感知另一应用的。</p><p>图：表示了每个节点直接与数据库通信，若离开数据库将对其他节点一无所知<br>     <img src="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/2018-10-31_231044.png" alt="Quartz集群" title="Quartz集群"></p><h3 id="6-2-搭建步骤"><a href="#6-2-搭建步骤" class="headerlink" title="6.2 搭建步骤"></a>6.2 搭建步骤</h3><ol><li>备配置文件</li><li>修改 spring-quartz。xml</li><li>启动Spring工厂测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceName: TestScheduler</span><br><span class="line">org.quartz.scheduler.instanceId: auto</span><br><span class="line"></span><br><span class="line">org.quartz.scheduler.skipUpdateCheck: true</span><br><span class="line"></span><br><span class="line">org.quartz.threadPool.class &#x3D; org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount &#x3D; 10</span><br><span class="line">org.quartz.threadPool.threadPriority &#x3D; 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread &#x3D; true</span><br><span class="line"></span><br><span class="line"># Using RAMJobStore</span><br><span class="line">## if using RAMJobStore, please be sure that you comment out the following</span><br><span class="line">## - org.quartz.jobStore.tablePrefix,</span><br><span class="line">## - org.quartz.jobStore.driverDelegateClass,</span><br><span class="line">## - org.quartz.jobStore.dataSource</span><br><span class="line">#org.quartz.jobStore.class &#x3D; org.quartz.simpl.RAMJobStore</span><br><span class="line"></span><br><span class="line"># Using JobStoreTX</span><br><span class="line">## Be sure to run the appropriate script(under docs&#x2F;dbTables) first to create tables</span><br><span class="line">org.quartz.jobStore.class &#x3D; org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line">org.quartz.jobStore.isClustered &#x3D; true</span><br><span class="line"></span><br><span class="line"># Configuring JDBCJobStore with the Table Prefix</span><br><span class="line">org.quartz.jobStore.tablePrefix &#x3D; QRTZ_</span><br><span class="line"></span><br><span class="line"># Using DriverDelegate</span><br><span class="line">org.quartz.jobStore.driverDelegateClass &#x3D;</span><br><span class="line">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"></span><br><span class="line"># Using datasource</span><br><span class="line">org.quartz.jobStore.dataSource &#x3D; qzDS</span><br><span class="line"></span><br><span class="line"># Define the datasource to use</span><br><span class="line">org.quartz.dataSource.qzDS.driver &#x3D; com.mysql.jdbc.Driver</span><br><span class="line">org.quartz.dataSource.qzDS.URL &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;quartz</span><br><span class="line">org.quartz.dataSource.qzDS.user &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.password &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.maxConnections &#x3D; 30</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;scheduler&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:quartz.properties&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">          &lt;list&gt;</span><br><span class="line">             &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">             &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">      &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-链表下_如何轻松写出正确的链表代码</title>
      <link href="/2018/10/06/3-%E9%93%BE%E8%A1%A8%E4%B8%8B-%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81/"/>
      <url>/2018/10/06/3-%E9%93%BE%E8%A1%A8%E4%B8%8B-%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想要写好链表代码并不是容易的事儿，尤其是那些复杂的链表操作，比如链表反转、有序链表合并等，写的时候非常容易出错。从我上百场面试的经验来看，能把“链表反转”这几行代码写对的人不足 10%。</p><p>为什么链表代码这么难写？究竟怎样才能比较轻松地写出正确的链表代码呢？</p><p>只要愿意投入时间，我觉得大多数人都是可以学会的。比如说，如果你真的能花上一个周末或者一整天的时间，就去写链表反转这一个代码，多写几遍，一直练到能毫不费力地写出 Bug free 的代码。这个坎还会很难跨吗？</p><p>总结了几个<strong>写链表代码技巧</strong>。如果你能熟练掌握这几个技巧，加上你的主动和坚持，轻松拿下链表代码完全没有问题。</p><a id="more"></a><h2 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h2><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，要想写对链表代码，首先就要理解好指针。</p><p>我们知道，有些语言有“指针”的概念，比如 C 语言；有些语言没有指针，取而代之的是“引用”，比如 Java、Python。不管是“指针”还是“引用”，实际上，它们的意思都是一样的，都是<strong>存储所指对象的内存地址</strong>。</p><p>接下来，我会拿 C 语言中的“指针”来讲解，如果你用的是 Java 或者其他没有指针的语言也没关系，你把它理解成“引用”就可以了。</p><p>实际上，对于指针的理解，你只需要记住下面这句话就可以了：</p><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p><p>这句话听起来还挺拗口的，你可以先记住。我们回到链表代码的编写过程中，我来慢慢给你解释。</p><p>在编写链表代码的时候，我们经常会有这样的代码：p-&gt;next=q。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。</p><p>有一个更复杂的，也是我们写链表代码经常会用到的：p-&gt;next=p-&gt;next-&gt;next。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><p>掌握了指针或引用的概念，你应该可以很轻松地看懂链表代码。</p><h2 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h2><p>不知道你有没有这样的感觉，写链表代码的时候，指针指来指去，一会儿就不知道指到哪里了。所以，我们在写的时候，一定注意不要弄丢了指针。</p><p>指针往往都是怎么弄丢的呢？我拿单链表的插入操作为例来给你分析一下。</p><p><img src="/2018/10/06/3-%E9%93%BE%E8%A1%A8%E4%B8%8B-%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81/c7c05b08-8ac0-4a68-9d65-982a0745e39e.jpg" alt></p><p>如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure><p>初学者经常会在这儿犯错。p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。</p><p>对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以，我们插入结点时，一定要注意操作的顺序，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第 1 行和第 2 行代码的顺序颠倒一下就可以了。</p><p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h2 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h2><p>首先，我们先来回顾一下单链表的插入和删除操作。如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node-&gt;next &#x3D; p-&gt;next;</span><br><span class="line">p-&gt;next &#x3D; new_node;</span><br></pre></td></tr></table></figure><p>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">  head &#x3D; new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看单链表结点删除操作。如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next &#x3D; p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><p>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (head-&gt;next &#x3D;&#x3D; null) &#123;</span><br><span class="line">   head &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的一步一步分析，我们可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。如何来解决这个问题呢？</p><p>技巧三中提到的哨兵就要登场了。哨兵，解决的是国家之间的边界问题。同理，这里说的<strong>哨兵也是解决“边界问题”的，不直接参与业务逻辑</strong>。</p><p>如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫<strong>带头链表</strong>。相反，没有哨兵结点的链表就叫作<strong>不带头链表</strong>。</p><p>我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了。</p><p><img src="/2018/10/06/3-%E9%93%BE%E8%A1%A8%E4%B8%8B-%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81/f15195a4-b7cd-4659-b23a-b4ce62ebb588.jpg" alt></p><p>实际上，这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。这些内容我们后面才会讲，现在为了让你感受更深，我再举一个非常简单的例子。代码我是用 C 语言实现的，不涉及语言方面的高级语法，很容易看懂，你可以类比到你熟悉的语言。</p><p><strong>代码一：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在数组a中，查找key，返回key所在的位置</span><br><span class="line">&#x2F;&#x2F; 其中，n表示数组a的长度</span><br><span class="line">int find(char* a, int n, char key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 边界条件处理，如果a为空，或者n&lt;&#x3D;0，说明数组中没有数据，就不用while循环比较了</span><br><span class="line">  if(a &#x3D;&#x3D; null || n &lt;&#x3D; 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; 这里有两个比较操作：i&lt;n和a[i]&#x3D;&#x3D;key.</span><br><span class="line">  while (i &lt; n) &#123;</span><br><span class="line">    if (a[i] &#x3D;&#x3D; key) &#123;</span><br><span class="line">      return i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码二：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在数组a中，查找key，返回key所在的位置</span><br><span class="line">&#x2F;&#x2F; 其中，n表示数组a的长度</span><br><span class="line">&#x2F;&#x2F; 我举2个例子，你可以拿例子走一下代码</span><br><span class="line">&#x2F;&#x2F; a &#x3D; &#123;4, 2, 3, 5, 9, 6&#125;  n&#x3D;6 key &#x3D; 7</span><br><span class="line">&#x2F;&#x2F; a &#x3D; &#123;4, 2, 3, 5, 9, 6&#125;  n&#x3D;6 key &#x3D; 6</span><br><span class="line">int find(char* a, int n, char key) &#123;</span><br><span class="line">  if(a &#x3D;&#x3D; null || n &lt;&#x3D; 0) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span><br><span class="line">  if (a[n-1] &#x3D;&#x3D; key) &#123;</span><br><span class="line">    return n-1;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp&#x3D;6。</span><br><span class="line">  &#x2F;&#x2F; 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span><br><span class="line">  char tmp &#x3D; a[n-1];</span><br><span class="line">  &#x2F;&#x2F; 把key的值放到a[n-1]中，此时a &#x3D; &#123;4, 2, 3, 5, 9, 7&#125;</span><br><span class="line">  a[n-1] &#x3D; key;</span><br><span class="line">  </span><br><span class="line">  int i &#x3D; 0;</span><br><span class="line">  &#x2F;&#x2F; while 循环比起代码一，少了i&lt;n这个比较操作</span><br><span class="line">  while (a[i] !&#x3D; key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 恢复a[n-1]原来的值,此时a&#x3D; &#123;4, 2, 3, 5, 9, 6&#125;</span><br><span class="line">  a[n-1] &#x3D; tmp;</span><br><span class="line">  </span><br><span class="line">  if (i &#x3D;&#x3D; n-1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果i &#x3D;&#x3D; n-1说明，在0...n-2之间都没有key，所以返回-1</span><br><span class="line">    return -1;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 否则，返回i，就是等于key值的元素的下标</span><br><span class="line">    return i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i&lt;n，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p><p>当然，这只是为了举例说明哨兵的作用，你写代码的时候千万不要写第二段那样的代码，因为可读性太差了。大部分情况下，我们并不需要如此追求极致的性能。</p><h2 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h2><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。</p><p>我经常用来检查链表代码是否正确的边界条件有这样几个：</p><ul><li><p>如果链表为空时，代码是否能正常工作</p></li><li><p>如果链表只包含一个结点时，代码是否能正常工作？</p></li><li><p>只包含两个结点时，代码是否能正常工作？</p></li><li><p>逻辑在处理头结点和尾结点的时候，是否能正常工作？</p></li></ul><p>当你写完链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面我列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p><p>当然，边界条件不止我列举的那些。针对不同的场景，可能还有特定的边界条件，这个需要你自己去思考，不过套路都是一样的。实际上，不光光是写链表代码，你在写任何代码时，也千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况。遇到了应该如何应对，这样写出来的代码才够健壮！</p><h2 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h2><p>对于稍微复杂的链表操作，比如前面我们提到的单链表反转，指针一会儿指这，一会儿指那，一会儿就被绕晕了。总感觉脑容量不够，想不清楚。所以这个时候就要使用大招了，<strong>举例法</strong>和<strong>画图法</strong>。</p><p>你可以找一个具体的例子，把它画在纸上，释放一些脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：</p><p><img src="/2018/10/06/3-%E9%93%BE%E8%A1%A8%E4%B8%8B-%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81/14f25a94-fdb4-4e0c-92f3-2e34058e7eba.jpg" alt></p><p>看图写代码，是不是就简单多啦？而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 Bug。</p><h2 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h2><p>如果你已经理解并掌握了我前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为我最开始学的时候，这种状况也持续了一段时间。就是把常见的链表操作都自己多写几遍，出问题就一点一点调试，熟能生巧！</p><p><strong>5 个常见的链表操作</strong>,你只要把这几个操作都能写熟练，不熟就多写几遍，我保证你之后再也不会害怕写链表代码。</p><ul><li><p>单链表反转</p></li><li><p>链表中环的检测</p></li><li><p>两个有序的链表合并</p></li><li><p>删除链表倒数第 n 个结点</p></li><li><p>求链表的中间结点</p></li></ul><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p><strong>写链表代码是最考验逻辑思维能力的</strong>。因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。所以，这也是很多面试官喜欢让人手写链表代码的原因</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>哨兵可以理解为它可以减少特殊情况的判断，比如判空，比如判越界，比如减少链表插入删除中对空链表的判断，比如例子中对i越界的判断。</p><p>空与越界可以认为是小概率情况，所以代码每一次操作都走一遍判断，在大部分情况下都会是多余的。</p><p>哨兵的巧妙就是提前将这种情况去除，比如给一个哨兵结点，以及将key赋值给数组末元素，让数组遍历不用判断越界也可以因为相等停下来。</p><p>使用哨兵的指导思想应该是将小概率需要的判断先提前扼杀，比如提前给他一个值让他不为null，或者提前预设值，或者多态的时候提前给个空实现，然后在每一次操作中不必再判断以增加效率。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-链表上_如何实现LRU缓存淘汰算法</title>
      <link href="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/"/>
      <url>/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天我们来聊聊“链表（Linked list）”这个数据结构。学习链表有什么用呢？为了回答这个问题，我们先来讨论一个经典的链表应用场景，那就是 <strong>LRU 缓存淘汰算法</strong>。</p><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。</p><p>常见的策略有三种：</p><ul><li><p><strong>先进先出策略 FIFO（First In，First Out）</strong></p></li><li><p><strong>最少使用策略 LFU（Least Frequently Used）</strong></p></li><li><p><strong>最近最少使用策略 LRU（Least Recently Used）</strong></p><a id="more"></a><p>这些策略你不用死记，我打个比方你很容易就明白了。假如说，你买了很多本技术书，但有一天你发现，这些书太多了，太占书房空间了，你要做个大扫除，扔掉一些书籍。那这个时候，你会选择扔掉哪些书呢？对应一下，你的选择标准是不是和上面的三种策略神似呢？</p></li></ul><p>好了，回到正题，我们今天的开篇问题就是：<font color="red">如何用链表来实现 LRU 缓存淘汰策略呢？</font></p><p><strong>带着这个问题，开始今天的内容吧！</strong></p><h2 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h2><p>相比数组，链表是一种稍微复杂一点的数据结构。对于初学者来说，掌握起来也要比数组稍难一些。这两个非常基础、非常常用的数据结构，我们常常将会放到一块儿来比较。所以我们先来看，这两者有什么区别。</p><p>我们先从<strong>底层的存储结构</strong>上来看一看。</p><p>了直观地对比，我画了一张图。从图中我们看到，<strong>数组</strong>需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败。</p><p>而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/9bd1d21f-7370-4ffe-9e32-24871a706355.jpg" alt></p><p>链表结构五花八门，今天我重点给你介绍三种最常见的链表结构，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的<strong>单链表</strong>。</p><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<strong>“结点”</strong>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/b2084ab1-f64f-475d-a55b-e4110b0a98bf.jpg" alt></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<strong>头结点</strong>，把最后一个结点叫作<strong>尾结点</strong>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p><p>与数组一样，链表也支持数据的查找、插入和删除操作。</p><p>我们知道，在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。</p><p>为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/5d3d35b1-434a-49ef-badf-d4e4ee8e9992.jpg" alt></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。</p><p>你可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。</p><p>好了，单链表我们就简单介绍完了，接着来看另外两个复杂的升级版，<strong>循环链表</strong>和<strong>双向链表</strong>。</p><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作“循环”链表。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/7f2367b4-7856-4c85-bc8d-7fd4ccd92fd0.jpg" alt></p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<a href="https://baike.baidu.com/item/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/3857719?fr=aladdin" target="_blank" rel="noopener">约瑟夫问题</a>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><p>单链表和循环链表是不是都不难？接下来我们再来看一个稍微复杂的，在实际的软件开发中，也更加常用的链表结构：<strong>双向链表</strong>。</p><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/099fa10b-ef6f-4754-95b8-2bc77ad998c7.jpg" alt></p><p>从画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。那相比单链表，双向链表适合解决哪种问题呢？</p><p>从结构上来看，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>可能会说，刚讲到单链表的插入、删除操作的时间复杂度已经是 O(1) 了，双向链表还能再怎么高效呢？别着急，刚刚的分析比较偏理论，很多数据结构和算法书籍中都会这么讲，但是这种说法实际上是不准确的，或者说是有先决条件的。我再来带你分析一下链表的两个操作。</p><p>我们先来看<strong>删除操作</strong>。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li><p><strong>删除结点中“值等于某个给定值”的结点</strong></p></li><li><p><strong>删除给定指针指向的结点。</strong></p></li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过前面讲的指针操作将其删除。</p><p>尽管单纯的删除操作时间复杂度是 O(1)，但遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</p><p>但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</p><p>同理，如果我们希望在链表的某个指定结点前面插入一个结点，双向链表比单链表有很大的优势。双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。你可以参照刚刚讲过的删除操作自己分析一下。</p><p>除了插入、删除操作有优势之外，对于一个<strong>有序链表</strong>，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>现在，你有没有觉得双向链表要比单链表更加高效呢？这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过<strong>LinkedHashMap</strong> 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是用<strong>空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>还是开篇缓存的例子。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p><p>了解了循环链表和双向链表，如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong></p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/9a89f8f5-9634-4eaa-90fc-d764d590b915.jpg" alt></p><h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><p>数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反。</p><p><img src="/2018/10/06/2-%E9%93%BE%E8%A1%A8%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/62664f02-5f39-40c6-9f9a-2321e0766bc9.jpg" alt></p><p>不过，数组和链表的对比，并不能局限于时间复杂度。而且，在实际的软件开发中，不能仅仅利用复杂度分析就决定使用哪个数据结构来存储数据。</p><p>数组简单易用，在实现上使用的是连续的内存空间，可你可能会说，我们 Java 中的 ArrayList 容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>以借助 <strong>CPU 的缓存机制，预读数组中的数据，所以访问效率更高</strong>。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。<strong>链表本身没有大小的限制，天然地支持动态扩容</strong>，我觉得这也是它与数组最大的区别。</p><p>你可能会说，我们 Java 中的 ArrayList 容器，也可以支持动态扩容啊？我们上一节课讲过，当我们往支持动态扩容的数组中插入一个数据时，如果数组中没有空闲空间了，就会申请一个更大的空间，将数据拷贝过去，而数据拷贝的操作是非常耗时的。</p><p>我举一个稍微极端的例子。如果我们用 ArrayList 存储了了 1GB 大小的数据，这个时候已经没有空闲空间了，当我们再插入数据的时候，ArrayList 会申请一个 1.5GB 大小的存储空间，并且把原来那 1GB 的数据拷贝到新申请的空间上。听起来是不是就很耗时？</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致<strong>频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）</strong>。</p><p>所以，在我们实际的开发中，针对不同类型的项目，要根据具体情况，权衡究竟是选择数组还是链表。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>关于链表的知识我们就讲完了。我们现在回过头来看下开篇的思考题。如何基于链表实现 LRU 缓存淘汰算法？</p><p>我的思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。</p><ol><li><p>如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</p></li><li><p>如果此数据没有在缓存链表中，又可以分为两种情况：</p></li></ol><blockquote><ul><li><strong>如果此时缓存未满，则将此结点直接插入到链表的头部</strong></li><li><strong>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</strong></li></ul></blockquote><p>这样我们就用链表实现了一个 LRU 缓存。</p><p>现在我们来看下缓存访问的时间复杂度是多少。因为不管缓存有没有满，我们都需要遍历一遍链表，所以这种基于链表的实现思路，缓存访问的时间复杂度为 O(n)。</p><p>实际上，我们可以继续优化这个实现思路，比如引入<strong>散列表</strong>（Hash table）来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。因为要涉及我们还没有学到的数据结构，所以这个优化方案，暂时就不详细说了，等学到散列表的时候，再拿出来讲。</p><p>除了基于链表的实现思路，实际上还可以用数组来实现 LRU 缓存淘汰策略。如何利用数组实现 LRU 缓存淘汰策略呢？我把这个问题留给你思考。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们讲了一种跟数组“相反”的数据结构，链表。它跟数组一样，也是非常基础、非常常用的数据结构。不过链表要比数组稍微复杂，从普通的单链表衍生出来好几种链表结构，比如双向链表、循环链表、双向循环链表。</p><p>和数组相比，链表更适合插入、删除操作频繁的场景，查询的时间复杂度较高。不过，在具体软件开发中，要对数组和链表的各种性能进行对比，综合来选择使用两者中的哪一个。</p><h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><p>如何判断一个字符串是否是回文字符串的问题，我想你应该听过，我们今天的题目就是基于这个问题的改造版本。如果字符串是通过单链表来存储的，那该如何来判断是一个回文串呢？你有什么好的解决思路呢？相应的时间空间复杂度又是多少呢？</p><p><strong>回答1：</strong></p><p>1 快慢指针定位中间节点<br>2 从中间节点对后半部分逆序<br>3 前后半部分比较，判断是否为回文<br>4 后半部分逆序复原</p><p>时间复杂度O（n）, 空间复杂度O(1)<br>如果是双向链表，时间效率更高，看了下LinkedList，底层也是用双向链表实现</p><p><strong>回答2：</strong></p><p>用快慢指针先找到中点，然后把后半段链表reversed，然后一个指针在头部，一个指针再中点，开始逐个比较，时间复杂度是O（n)</p><p><strong>回答3：</strong></p><p>由于回文串最重要的就是对称，那么最重要的问题就是找到那个中心，用快指针每步两格走，当他到达链表末端的时候，慢指针刚好到达中心，慢指针在过来的这趟路上还做了一件事，他把走过的节点反向了，在中心点再开辟一个新的指针用于往回走，而慢指针继续向前，当慢指针扫完整个链表，就可以判断这是回文串，否则就提前退出，总的来说时间复杂度按慢指针遍历一遍来算是O(n),空间复杂度因为只开辟了3个额外的辅助，所以是o(1)</p><p><strong>回答4：</strong></p><p>单链表存储，设置两组指针A和B，从链表头部开始遍历，指针A每次前进一位，指针B每次前进两位；指针A每到一个位置，就将该位置的字符压入栈中，直到指针B到达链表尾部，此时指针A到达字符串的中间位置。然后，每当指针A前进一步，就将栈中的字符弹出一位，比较指针A所指字符与弹出字符是否相等，如果相等，则继续运行；不等，则退出程序，说明该字符串不是回文序列。<br>时间渐进复杂度O（n），空间渐进复杂度O（n）。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>“数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。” 这里的CPU缓存机制指的是什么？为什么就数组更好了？</p><p>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块(这个大小我不太确定。。)并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。</p><p>对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-数组_为什么很多编程语言中数组都从0开始编号</title>
      <link href="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/"/>
      <url>/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到数组，我想你肯定不陌生，甚至还会自信地说，它很简单啊。</p><p>是的，在每一种编程语言中，基本都会有数组这种数据类型。不过，它不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构。尽管数组看起来非常基础、简单，但是我估计很多人都并没有理解这个基础数据结构的精髓。</p><p>在大部分编程语言中，数组都是从 0 开始编号的，但你是否下意识地想过，<font color="red"><strong>为什么数组要从 0 开始编号，而不是从 1 开始呢？</strong></font></p><p>从 1 开始不是更符合人类的思维习惯吗？</p><p><strong>你可以带着这个问题来学习接下来的内容。</strong></p><a id="more"></a><h2 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h2><p>什么是数组？我估计你心中已经有了答案。不过，我还是想用专业的话来给你做下解释。<strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>这个定义里有几个关键词，理解了这几个关键词，我想你就能彻底掌握数组的概念了。下面就从我的角度分别给你“点拨”一下。</p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><p><img src="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/04b5b065-e398-4585-a875-5623849f3570.jpg" alt></p><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/3fd28cec-1347-4bac-8b60-002fcb41980c.jpg" alt></p><p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>说到数据的访问，那你知道数组是如何实现根据下标随机访问数组元素的吗？</p><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/7e0a9009-e943-4089-a9ad-010d9007f1cc.jpg" alt></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的<strong>寻址公式</strong>，计算出该元素存储的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。这个公式非常简单，我就不多做解释了。</p><p>这里我要特别纠正一个“错误”。在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。</p><p>实际上，这种表述是不准确的。<strong>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)</strong>。所以，正确的表述应该是，<strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong>。</p><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><p>前面概念部分我们提到，数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。现在我们就来详细说一下，究竟为什么会导致低效？又有哪些改进方法呢？</p><p>我们先来看<strong>插入操作</strong>。</p><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？你可以自己先试着分析一下。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，<strong>直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置</strong>。</p><p>为了更好地理解，我们举一个例子。假设数组 a[10]中存储了如下 5 个元素：a，b，c，d，e。</p><p>我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2]赋值为 x 即可。最后，数组中的元素如下： a，b，x，d，e，c。</p><p><img src="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/64f663b6-da49-479c-a9d0-f5327a135f23.jpg" alt></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到。</p><p>我们再来看<strong>删除操作</strong>。</p><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>们继续来看例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src="/2018/10/02/1-%E6%95%B0%E7%BB%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%95%B0%E7%BB%84%E9%83%BD%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7/4ebee0b9-091e-4861-b7bc-b4f74b88ab39.jpg" alt></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<strong>当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作</strong>，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解 JVM，你会发现，这不就是 JVM 标记清除垃圾回收算法的核心思想吗？没错，数据结构和算法的魅力就在于此，<font color="red">很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。</font>如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>了解了数组的几个基本操作后，我们来聊聊数组访问越界的问题。</p><p>首先，我请你来分析一下这段 C 语言代码的运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int arr[3] &#x3D; &#123;0&#125;;</span><br><span class="line">    for(; i&lt;&#x3D;3; i++)&#123;</span><br><span class="line">        arr[i] &#x3D; 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界。</p><p>我们知道，<strong>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的</strong>。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p><p>数组越界在 C 语言中是一种<strong>未决行为</strong>，并没有规定数组访问越界时编译器应该如何处理。因为，<strong>访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误</strong>。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug 的难度非常的大。而且，<strong>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞</strong>，来攻击系统，所以写代码的时候一定要警惕数组越界。</p><p>但并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做，像 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 <strong>java.lang.ArrayIndexOutOfBoundsException</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] a &#x3D; new int[3];</span><br><span class="line">a[3] &#x3D; 10;</span><br></pre></td></tr></table></figure><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 ArrayList、C++ STL 中的 vector。在项目开发中，什么时候适合用数组，什么时候适合用容器呢？</p><p>这里我拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList，对它应该非常熟悉。那它与数组相比，到底有哪些优势呢？</p><p>我个人觉得，ArrayList 最大的优势就是可以<strong>将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p><p>不过，这里需要注意一点，因为<strong>扩容操作涉及内存申请和数据搬移</strong>，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在<strong>创建 ArrayList 的时候事先指定数据大小</strong>。</p><p>比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;User&gt; users &#x3D; new ArrayList(10000);</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10000; ++i) &#123;</span><br><span class="line">  users.add(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为高级语言编程者，是不是数组就无用武之地了呢？当然不是，有些时候，用数组会更合适些，我总结了几点自己的经验。</p><ul><li><p><strong>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。</strong></p></li><li><p><strong>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。</strong></p></li><li><p><strong>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt; ArrayList &lt; Object&gt;&gt; array。</strong></p></li></ul><h2 id="简单小结"><a href="#简单小结" class="headerlink" title="简单小结"></a>简单小结</h2><p>对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。</p><h2 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h2><p>现在我们来思考开篇的问题：为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + k * type_size</span><br></pre></td></tr></table></figure><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，<strong>对于 CPU 来说，就是多了一次减法指令</strong>。</p><p><strong>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</strong></p><p>不过个人认为，上面解释得再多其实都算不上压倒性的证明，说数组起始编号非 0 开始不可。所以我觉得最主要的原因可能是历史原因。</p><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天学习了数组。它可以说是最基础、最简单的数据结构了。数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别底层的开发，直接使用数组可能会更合适。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="JVM标记-清除算法"><a href="#JVM标记-清除算法" class="headerlink" title="JVM标记-清除算法"></a>JVM标记-清除算法</h3><p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p><p><strong>不足</strong></p><ul><li><p>效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。</p></li><li><p>空间问题。会产生不连续的内存空间碎片。</p></li></ul><h3 id="二维数组内存寻址："><a href="#二维数组内存寻址：" class="headerlink" title="二维数组内存寻址："></a>二维数组内存寻址：</h3><p>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为(以行为主访问)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">address &#x3D; base_address + ( i * n + j) * type_size</span><br></pre></td></tr></table></figure><p><strong>数组访问无限循环，不同解答</strong></p><ul><li><p>对于数组访问越界造成无限循环，我理解是编译器的问题，对于不同的编译器，在内存分配时，会按照内存地址递增或递减的方式进行分配。上述程序，如果是内存地址递减的方式，就会造成无限循环。</p></li><li><p>对文中示例的无限循环有疑问的话，建议去查函数调用的栈桢结构细节（操作系统或计算机体系结构的教材应该会讲到）。函数体内的局部变量存在栈上，且是连续压栈。在Linux进程的内存布局中，栈区在高地址空间，从高向低增长。变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。当然，前提是i和arr元素同类型，否则那段代码仍是未决行为。</p></li></ul><p><strong>汇总原因：</strong></p><ul><li><p>1 栈空间从高往低依次分配，i占4字节，接着arr占12字节，内存从高往低是这样：存i的4字节|arr[2]|arr[1]|arr[0]，数组访问是通过“baseAddr+index乘typeSize”得到，算下来当index=3时，刚好是i的地址</p></li><li><p>2 这里刚好满足字节对齐，系统为64位系统，字长64，那么字节对齐必须是8字节的倍数，刚好i变量和arr变量占了16字节，对齐了<br>如果这里将arr[3]改为arr[4]，为了对齐，内存从高往低是这样：存i的4字节|空4字节|arr[3]|arr[2]|arr[1]|arr[0]，那么arr[4]刚好是空的4字节，无法影响到i的值，则并不会无限循环</p></li><li><p>附加条件：编译时gcc默认会自动添加越界保护，此处要达到无限循环效果，编译时需加上-fno-stack-protector去除该保护</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析-下部</title>
      <link href="/2018/09/29/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/"/>
      <url>/2018/09/29/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="1-浅析最好、最坏、平均、均摊时间复杂度"><a href="#1-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="1 浅析最好、最坏、平均、均摊时间复杂度"></a>1 浅析最好、最坏、平均、均摊时间复杂度</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最好情况时间法则度</font>(best case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最坏情况时间复杂度</font>(worst case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">平均情况时间复杂度</font>(average case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">均摊时间复杂度</font>(amortized time complexity)</p><a id="more"></a><h2 id="1-1-最好、最坏情况时间复杂度"><a href="#1-1-最好、最坏情况时间复杂度" class="headerlink" title="1.1 最好、最坏情况时间复杂度"></a>1.1 最好、最坏情况时间复杂度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码的功能：在一个无序的数组(array)中，查找变量x出现的位置。如果没有找到，就返回 -1。这段代码的时间复杂度就是 O(n)，其中，n代表数组的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，我们在数组中查找一个数据时，并不需要每次都把整个数据都遍历一遍，因为有可能中途找到提前结束循环了。因此，改写后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这段优化后的代码，时间复杂度还是O(n)吗？很显然，暂时还解决不了这个问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)，但如果数组中不存在变量 x , 那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)，所以，不同情况下，这段代码的时间复杂度是不一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了表示代码在不同情况下的不同时间复杂度，需要3种概念：最好情况时间复杂度、最坏情况时间复杂度、平局情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>最好情况时间复杂度：最理想的情况下，执行这段代码的时间复杂度。</strong>如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这种情况下的时间复杂度即是最好情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，<strong>最坏情况时间复杂度，在最糟糕的情况下，执行这段代码的时间复杂度。</strong>如：在数组中没有要查找的变量 x , 需要把整个数组都遍历一遍才行，这种情况下的时间复杂度即是最坏情况时间复杂度。</p><h2 id="1-2-平均情况时间复杂度"><a href="#1-2-平均情况时间复杂度" class="headerlink" title="1.2 平均情况时间复杂度"></a>1.2 平均情况时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最好情况时间复杂度和最坏请款时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大为了更好地表示平均情况下的复杂度，需要引入一个新的概念：<strong>平均情况时间复杂度</strong>，即平均时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然是上述代码，要查找变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong> 和 <strong>不在数组中</strong>。把每种情况下，查找需要遍历的元素个数累加起来，再除以 n+1，就可以得到需要遍历的元素个数的平均值，即（等数列求和公式）：<br><img src="/2018/09/29/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 大O 标记法中，可以省略掉系数、低阶、常量，所以，简化后的平均时间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结论是正确的，但是计算过程稍稍有点问题，因为有 n+1 种情况，出现的概率并不是一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要查找的变量 x, 要么在数组里，要不不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0<del>n-1 这 n 个位置的概率是一样的，为 1/n，所以，根据概率乘法法则，要查找的数组出现在 0</del> n-1 中任意位置的概率就是 1/(2n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<font color="red">前面推导的存在的最大问题就是，没有讲各种情况发生的概率考虑进去。如果我们把每种情况发生的概率考虑进去，那么平均时间复杂度的计算过程就变成饿了这样：</font><br><img src="/2018/09/29/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/36c0aabdac69032f8a43368f5e90c67f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值就是概率论中的<strong>加权平均值</strong>，即<strong>期望值</strong>，所以平均时间复杂度的全称就是<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入概率之后，上述代码的加权平均值为(3n+1)/4。用 大O 表示法表示，去掉系数和常量，这段代码的加权平均时间复杂仍然是 O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，并不需要区分最好、最坏、平均时间复杂度三种情况。很多时候，只用一种复杂度就可以满足需求。<strong>只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。</strong></p><h2 id="1-3-均摊时间复杂度"><a href="#1-3-均摊时间复杂度" class="headerlink" title="1.3 均摊时间复杂度"></a>1.3 均摊时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>均摊时间复杂度</strong>，一种更加高级的概念，它对应的分析方法，<strong>摊还分析(平摊分析)</strong> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度，听起来与平均时间复杂度有点像。长容易混淆，大部分情况下，并不需要区分最好、最坏、平均时间复杂度。平均复杂度只有在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，用for循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再讲新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最理想的情况下，数组中有空闲空间，只需要将数据插入到数组下表为 count 的为位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况，数组中没有空闲空间了，需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平均时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定数组的长度是 n,根据数据插入的位置的不同，就可以分为 n 种情况，每种情况的时间复杂度都是 O(1),除此之外，还有一种“额外“的情况，就是数组在没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率是一样的，即 1/(n+1)。所以，根据加权平均计算方法，求得的平均情况时间复杂度：<br><img src="/2018/09/29/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/6df62366a60336d9de3bc34f488d8bed.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子的平均时间复杂度其实并不需要这么复杂，并不需要引入概率论的知识。由对比得知，insert() 的例子和 上面的那个 find() 的列子，会发现二者有很大的差别。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，find() 函数在极端情况下，时间复杂度采薇 O(1)。但是 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert() <strong>第一个</strong>区别于find() 的地方。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第二个</strong>，对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，后面紧跟着 n-1 个 O(1) 的插入操作，循环往复。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种特殊场景的复杂度分析，并不需要像之前将平均时间复杂度分析方法那样，找出所有的输入情况以及相应的发生概率，然后在计算加权平均值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度：<strong>均摊时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何用摊还分析发来分析算法的均摊时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续啊观看数组插入数的这个例子，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的<strong>那次操作</strong>均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到，为了方便理解，简单总结他们的应用场景。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">对一个数据结构进行一组连续操作中，大部分情况下的时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好时间复杂度</strong>。</font></p><h1 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h1><p>一、复杂度分析的4个概念<br>1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。<br>2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。<br>3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p><p>二、为什么要引入这4个概念？<br>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><p>三、如何分析平均、均摊时间复杂度？<br>1.平均时间复杂度<br>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>2.均摊时间复杂度<br>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p><hr><h1 id="3-试试分析下面-add-函数"><a href="#3-试试分析下面-add-函数" class="headerlink" title="3 试试分析下面 add()函数"></a>3 试试分析下面 add()函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1. 最好情况时间复杂度为 O(1)<br>2.最坏情况分析：<br>最坏情况代码执行的次数跟每次数组的长度有关<br>第1次调用insert的执行的次数为 n ,<br>第2次调用insert的执行的次数为 2n ,<br>第3次调用insert的执行的次数为 2^2 * n<br>第k次调用insert的执行的次数为 2^(k-1) * n<br>最坏时间复杂度为 O(n)。<br>3. 平均情况分析<br>当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0<del>len-1, len</del>(2len-1),….；<br>插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1，<br>最后求出加权平均时间复杂度为 1<em>p + 2</em>p+ ▪▪▪ + len*p + len * p = O(1) ;<br>4. 均摊时间复杂度 O(1)<br>而均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析-上部</title>
      <link href="/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/"/>
      <url>/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，数据结构与算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，<font color="red">执行效率</font>是算法一个非常重要的考量指标。</p><h2 id="1-为什么需要复杂度分析？"><a href="#1-为什么需要复杂度分析？" class="headerlink" title="1 为什么需要复杂度分析？"></a>1 为什么需要复杂度分析？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将代码跑一遍，通过统计、监控，就能得到算法执行时间个占用的内存大小。为什么要使用空间、时间复杂度分析呢？难道比我实实在在跑一遍得到的数据还要准确吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述评估算法执行效率的方法是正确的。大部分人称它为<strong>事后统计法</strong>，但它有非常大的局限性。</p><a id="more"></a><h3 id="1-1-测试结果非常依赖测试环境"><a href="#1-1-测试结果非常依赖测试环境" class="headerlink" title="1.1 测试结果非常依赖测试环境"></a>1.1 测试结果非常依赖测试环境</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试环境中硬件的不同会对测试结果有很大的影响。比如，用同样一段代码，用I9处理器与I3处理器，效率自然不同。</p><h3 id="1-2-测试结果受数据规模的影响很大"><a href="#1-2-测试结果受数据规模的影响很大" class="headerlink" title="1.2 测试结果受数据规模的影响很大"></a>1.2 测试结果受数据规模的影响很大</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对同一个排序算法，待排序数据的有序度不一样，排序的执行时间会有很大的差别。极端情况下，如果数据已经有序，排序算法不需要做任何操作，执行时间非常短。除此之外，如果测试数据规模小，测试结果可能无法真实的反应算法的性能。如：对于小规模的数据排序，插入排序可能反倒会比快速排序要快！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>–<font color="red">时间、空间复杂度分析方法</font>。</p><h2 id="2-大-O-复杂度表示法"><a href="#2-大-O-复杂度表示法" class="headerlink" title="2 大 O 复杂度表示法"></a>2 大 O 复杂度表示法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法的执行效率，粗略的说，就是算法代码的执行时间。但是，如何在不运行代码的情况下，用 “肉眼” 得到一段代码的执行时间呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从CPU的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行对应的CPU执行的个数、执行的时间都不一样，但是，只是粗略的估计，所以可以假设每行代码的执行时间都一样，为<font color="red"> unit_time</font>。在这个假设的基础上，这段代码的总执行时间是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3行代码分别需要1个unit_time的执行时间，第4、5行代码都运行了n遍，所以需要2n &#42; unit_time的执行时间，所以这段代码总的执行时间就是 (2n+2) &#42;   unit_time</font>。因此， <strong>所有代码的执行时间T(n)与每行代码的执行次数成正比</strong>。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这个思路，再次分析如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依旧假设每个语句的执行时间是 unit_time ，那么这段代码的总执行时间T(n)是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3、4行代码，每行代码都需要1个 unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n &#42; unit_time的执行时间，第7、8行代码循环执行了n<sup>2</sup>遍，所以需要2n<sup>2</sup> &#42; unit_time的执行时间。</font><font color="red">所以，整段代码的执行时间T(n)与每行代码的执行次数n成正比</font>。</p><h2 id="3-大-O-登场"><a href="#3-大-O-登场" class="headerlink" title="3 大 O 登场"></a>3 大 O 登场</h2><p><img src="/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/22900968aa2b190072c985a08b0e92ef.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T(n)已经解释过，表示代码的执行时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为它是一个公式。所以用f(n)来表示。公式中的 O ，表示代码的执行时间T(n) 与 f(n) 表达式成正比。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，第一个例子中的T(n)=O(2n+2)，第二个例子中的T(n)=O(2n<sup>2</sup>+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，因此，也称之为<strong>渐进时间复杂度</strong>(asymptotic time complexity),即<strong>时间复杂度</strong>。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 n 很大时，可以把它想象成10000,10000000。而公式中的<font color="red">低阶、常量、系数</font>三部分并不左右增长趋势，所以可以忽略。因此，只需要记录一个最大量级就可以了，如果用大 O 表示法表示上述两段代码的时间复杂度，既可以记为：T(n)=O(n); T(n)=O(n<sup>2</sup>)</p><h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4 时间复杂度分析"></a>4 时间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了大 O 时间复杂度的由来和表示方法。现在看看如何分析一段代码的时间复杂度？</p><h3 id="4-1-只关注循环执行次数最多的一段代码"><a href="#4-1-只关注循环执行次数最多的一段代码" class="headerlink" title="4.1 只关注循环执行次数最多的一段代码"></a>4.1 只关注循环执行次数最多的一段代码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大 O 这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉工事中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以，<strong>在分析一个算法，一段代码的时间复杂度的时候，只关注循环执行次数最多的那一段代码就可以了。</strong>这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p><h3 id="4-2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#4-2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="4.2 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>4.2 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个代码分为3个部分分别是求sum_1、sum_2、sum_3。分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一段代码的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">这里强调一下，即便这段代码循环了10000次，1亿次，只要是一个已知的数，跟n无关。照样是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉，因为它本身对增长趋势并没有影响。</font><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n) 和 O(n<sup>2</sup>)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合这三段代码的时间复杂度，取其中最大的量级，所以，整段代码的时间复杂度就为O(n<sup>2</sup>)。也就是说：<strong>总的时间复杂度就是等于量级最大的那段代码的时间复杂度</strong>。那可以讲规律抽象为公式：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))。</p><h3 id="4-3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#4-3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="4.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>4.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类比加法法则，乘法法则公式：T1(n)=O(f(n))，T2(n)=O(g(n));那么 T(n)=T1(n) &#42; T2(n)=O(f(n)) &#42; O(g(n))=O(f(n) &#42; g(n))。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设T1(n)=O(n)，T2(n)=O(n<sup>2</sup>)，则T1(n) &#42; T2(n) = O(n<sup>3</sup>)。落实到具体的代码中：可以把乘法法则看成是<strong>嵌套循环</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单独看cal()函数，假设f()只是一个普通的操作，那第4~6行的时间复杂度就是，T1(n) = O(n),但是f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以整个cal()函数的时间复杂度就是：T(n) = T1(n) &#42; T2(n) = O(n &#42; n) = O(n<sup>2</sup>)</p><h2 id="5-几种常见时间复杂度实例分析"><a href="#5-几种常见时间复杂度实例分析" class="headerlink" title="5 几种常见时间复杂度实例分析"></a>5 几种常见时间复杂度实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然代码千差万别，但是常见的复杂度量级并不多，以下几乎涵盖了所有一般代码的复杂度量级。<br><img src="/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述可粗略的分为两类：<strong>多项式量级</strong> 和 <strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度需要再次学习。</p><h3 id="5-1-O-1"><a href="#5-1-O-1" class="headerlink" title="5.1 O(1)"></a>5.1 O(1)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先必须知道，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，比如下面这段代码的时间复杂度就是 O(1)，而不是O(3)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度都记作 O(1)，或者：<strong>一般情况下，只要算法中不存在循环、递归，即使有成千上万行的代码，其时间复杂度也是 O(1)</strong></p><h3 id="5-2-O-logn-、O-nlogn"><a href="#5-2-O-logn-、O-nlogn" class="headerlink" title="5.2 O(logn)、O(nlogn)"></a>5.2 O(logn)、O(nlogn)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第3行代码是循环执行次数最多的。所以，只要能计算出这行代码执行了多少次，就知道整段代码的时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2.当大于n时，循环结束。这就是一个等比数列。如下所示：<br><img src="/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/9b1c88264e7a1a20b5954be9bc4bec9a_20_281_29.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<sup>x</sup>=n 求解这个x这个问题。x=log<sub>2</sub>n。所以这段代码的时间复杂度是O(log<sub>2</sub>n)。<br>下面呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度：O(log<sub>3</sub>n)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，不管是以2位底、还是以3为底，还是以10位底，可以把所有对数阶的时间复杂度都记为O(logn)。为什么呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为对数可以互相转换的。<br>log<sub>3</sub>n = log<sub>3</sub>2 &#42; log<sub>2</sub>n，所以O(log<sub>3</sub>n) = O(C &#42; log<sub>2</sub>n)，其中 C = log<sub>3</sub>2 是一个常量。基于前面的一个理论：采用** 大O标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))** 。 因此，O(log<sub>2</sub>n) 等于 log<sub>3</sub>n，所以在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一标示为O（logn）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此说来，O(nlogn)不难理解，就乘法法则而言，如果一段代码的时间复杂度是O(logn)，循环执行了n遍，其时间复杂度就是O(nlogn)。而且，O(nlogn)是一种非常常见的算法时间复杂度。如：归并排序、快速排序的时间复杂度都是O(nlogn)。</p><h3 id="5-3-O-m-n-、O-m-42-n"><a href="#5-3-O-m-n-、O-m-42-n" class="headerlink" title="5.3 O(m+n)、O(m &#42; n)"></a>5.3 O(m+n)、O(m &#42; n)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果代码的复杂度由<strong>两个数据的规模</strong>来决定的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由代码看出，m和n表示两个数据规模。无法事先评估m和n谁的量极大，所以在表示复杂度的时候，就不能简单的利用加法法则，省略掉一种一个。因此上面代码的时间复杂度就是O(m+n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种情况，原来的加法法则就不在正确，需要将加法法则改写：T1(m)+T2(n) = O(f(m) + g(n))。但是乘法法则依然有效：T1(m)&#42;T2(n) = O(f(m) &#42; f(n))。</p><h2 id="6-空间复杂度分析"><a href="#6-空间复杂度分析" class="headerlink" title="6 空间复杂度分析"></a>6 空间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面得知，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</strong>类比可知，空间复杂度全称就是<strong>渐进空间复杂度</strong>(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仿照时间复杂度，可以得知，第2行代码中，申请了一个空间存储变量 i , 但是它是常量阶，跟数据规模 n 没有关系，所以可以忽略。第 3 行申请了一个大小为n的int类型数组，除此之外剩下的代码都没有占用更多的空间，所以，整段代码的空间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常见的空间复杂度是：O(1)，O(n),O(n<sup>2</sup>)，如O(logn)、O(nlogn)这样的对数阶复杂度平时很难用到。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7 小结"></a>7 小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂度也称为渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，由低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)。<br><img src="/2018/09/28/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/497a3f120b7debee07dc0d03984faf04.jpg" alt></p><hr><h2 id="8-理解"><a href="#8-理解" class="headerlink" title="8 理解"></a>8 理解</h2><p>一、什么是复杂度分析？<br>1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。<br>二、为什么要进行复杂度分析？<br>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<br>三、如何进行复杂度分析？<br>1.大O表示法<br>1）来源<br>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>2）特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br>2.复杂度分析法则<br>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<br>四、常用的复杂度级别？<br>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）<br>五、如何掌握好复杂度分析方法？<br>复杂度分析关键在于多练，所谓孰能生巧</p><hr><h3 id="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"><a href="#项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？" class="headerlink" title="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"></a>项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？</h3><p>我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。</p><p>当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。</p><p>综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法概览</title>
      <link href="/2018/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
      <url>/2018/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h1><p>&nbsp;&nbsp;&nbsp;广义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据结构</strong>：<font color="red">一组数据的存储结构</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法</strong>：<font color="red">操作数据的一组方法</font>。<br>&nbsp;&nbsp;&nbsp;狭义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些<font color="red">著名</font>的数据结构与算法,如队列、栈、堆、二分查找、动态规划等等。</p><h1 id="2-二者关系"><a href="#2-二者关系" class="headerlink" title="2 二者关系"></a>2 二者关系</h1><p>&nbsp;&nbsp;&nbsp;数据结构与算法相辅相成。<font color="red">数据结构是为算法服务的，算法要作用在特定的数据结构之上</font>。因此，孤立而单独的讲解两者毫无意义。<br>&nbsp;&nbsp;&nbsp;比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但是我们选择链表这种数据结构，二分查找就无法工作了，因为链表不支持随机访问。<br>&nbsp;&nbsp;&nbsp;数据结构是<font color="red">静态</font>的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构是没有用的。</p><a id="more"></a><h1 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h1><p>&nbsp;&nbsp;&nbsp;<font color="red">复杂度分析</font>占据了数据结构与算法的半壁江山，是数据结构与算法的精髓。<br>&nbsp;&nbsp;&nbsp;数据结构与算法解决的是如何更省、更快的存储和处理数据的问题，因此，需要考量效率和资源消耗的方法，这就是复杂度分析方法。所以，只掌握了数据结构与算法的特点、用法，没有学会复杂度分析，相当于只知口诀，而无心法，只有把心法了然于胸，才能做到无招胜有招！</p><h1 id="4-学习图"><a href="#4-学习图" class="headerlink" title="4 学习图"></a>4 学习图</h1><p><img src="/2018/09/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/913e0ababe43a2d57267df5c5f0832a7.jpg" alt></p><h1 id="5-20个基础"><a href="#5-20个基础" class="headerlink" title="5 20个基础"></a>5 20个基础</h1><p>&nbsp;&nbsp;&nbsp;<font color="blue">10个数据结构</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</font><br>&nbsp;&nbsp;&nbsp;<font color="blue">10个算法</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</font></p><h1 id="6-策略"><a href="#6-策略" class="headerlink" title="6 策略"></a>6 策略</h1><p>&nbsp;&nbsp;&nbsp;学习 <strong>‘它’</strong> 的<font color="red">来历、自身特点、适合解决的问题、实际应用场景</font>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求与响应</title>
      <link href="/2018/09/17/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
      <url>/2018/09/17/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-Request-Headers"><a href="#1-Request-Headers" class="headerlink" title="1 Request Headers"></a>1 Request Headers</h1><p>origin: 客户端发出请求的地址</p><p>Access-Control-Request-Headers:authorization</p><p>Access-Control-Request-Method:Get</p><a id="more"></a><h1 id="2-Response-Headers"><a href="#2-Response-Headers" class="headerlink" title="2 Response Headers"></a>2 Response Headers</h1><p>Access-Controll-Allow-Origin: httpRequest.getHeader(“Origin”)</p><p>Access-Control-Allow-Headers:<br>Authorization,<br>Content-Type,<br>Depth,<br>User-Agent,<br>X-File-Size,<br>X-Requested-With,<br>X-Requested-By,<br>If-Modified-Since,<br>X-File-Name,<br>X-File-Type,<br>Cache-Control,<br>Origin</p><p>Access-Control-Allow-Methods:<br>POST , GET, OPTIONS, PUT, DELETE</p><p>Access-Control-Max-Age: 3600</p><p>Access-Control-Allow-Credentials: true</p><p>Access-Control-Expose-Headers:<br>Authorization,<br>Content-Disposition</p><h1 id="3-http-中的options-请求是什么鬼？"><a href="#3-http-中的options-请求是什么鬼？" class="headerlink" title="3 http 中的options 请求是什么鬼？"></a>3 http 中的options 请求是什么鬼？</h1><h2 id="3-1-为什么会出现-options-请求呢？"><a href="#3-1-为什么会出现-options-请求呢？" class="headerlink" title="3.1 为什么会出现 options 请求呢？"></a>3.1 为什么会出现 options 请求呢？</h2><ol><li><p>获取目的资源所支持的通信方式<br>黑客有可能经常用到这个；在响应报文中包含一个<strong>Allow</strong>首部字段，该字段的值表明了该服务器支持的<strong>HTTP方法</strong>，</p></li><li><p>跨域请求中，<strong>options</strong>请求是浏览器自发起的 <strong>preflight request(预检请求)</strong>,以检测实际请求是否可以被浏览器接受。</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp; preflight request 请求报文中有两个需要关注测首部字段：</p><p>（1）Access-Control-Request-Method: 告知服务器实际请求所使用的HTTP方法。</p><p>（2）Access-Control-Request-Headers:告知服务器实际请求所携带的自定义首部字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 同时服务器也会添加 origin header，告知服务器实际上请求的客户端地址。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 服务器所返回的 <strong>Access-Control-Allow-Methods</strong>首部字段 将所有允许的请求方法告知客户端，返回  <strong>Access-Control-Allow-Headers</strong>: 将所有允许的客户端自定义请求头告知。此外，服务器还可返回 <strong>Access-Control-Max-Age</strong> 首部字段，允许浏览器在指定时间内，无需再次发送预检请求，直接用本次结果即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 在我们开发中，出现的浏览器自发起的Options请求，实际上是上述第二种情。实际上，跨域请求中的“复杂请求”发出前会进行 一次方法是：options的 preflight request。</p><h2 id="3-2-当跨域请求是简单请求时不会进行-preflight-request，只有复杂请求才会进行-preflight-request。"><a href="#3-2-当跨域请求是简单请求时不会进行-preflight-request，只有复杂请求才会进行-preflight-request。" class="headerlink" title="3.2 当跨域请求是简单请求时不会进行 preflight request，只有复杂请求才会进行 preflight request。"></a>3.2 当跨域请求是简单请求时不会进行 preflight request，只有复杂请求才会进行 preflight request。</h2><p>跨域请求分两种：简单请求、复杂请求</p><p>复杂请求：</p><ol><li>使用方法put 或者 delete</li><li>发送 json 格式的数据（content-type;application/json）</li><li>请求中带有自定义头部</li></ol><p>其他的就是简单请求。</p><h1 id="4-为什么跨域的复杂请求需要-preflight-request"><a href="#4-为什么跨域的复杂请求需要-preflight-request" class="headerlink" title="4 为什么跨域的复杂请求需要 preflight request?"></a>4 为什么跨域的复杂请求需要 preflight request?</h1><p>&nbsp;&nbsp;&nbsp;&nbsp; 复杂请求可能对服务器数据产生副作用。例如：<strong>delete</strong> 或者 <strong>put</strong> ,都会对服务器数据进行修改，所以在请求之前都要先询问服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式的请求，否则不发送正是请求。</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextRank基本了解</title>
      <link href="/2018/09/01/TextRank/"/>
      <url>/2018/09/01/TextRank/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一-TextRank算法介绍"><a href="#一-TextRank算法介绍" class="headerlink" title="一. TextRank算法介绍"></a>一. TextRank算法介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法相对来说，是一种很简单的算法。算法的流程类似于Kleinberg的HITS算法，<font color="red">Google</font>的PageRank算法，不得不说GooglePageRank算法的出现引发了搜索引擎的一次变革。PageRank算法成功运用到互联网上来评估网页的重要性，当用户搜索时，返回与搜索问题相关又有质量的网页。TextRank算法可以说借鉴了PageRank算法的思想，也非常成功的运用到文章的引文提取，关键词提取上。当然一个单纯的算法来提取关键词，可能效果并不如意，可以结合其他算法，比如TF-IDF来筛选有力表达主题/文章中心思想的词语。</p><a id="more"></a><h1 id="二-TextRank算法解析"><a href="#二-TextRank算法解析" class="headerlink" title="二. TextRank算法解析"></a>二. TextRank算法解析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法对文章关键词进行提取的过程，实际就是迭代计算一个由文章中的词语构建的有向有权图G=(V,E) 。其中集合V(图中的节点)有文章中的词语构成，中文我们可以利用ansj_seg进行分词筛选特定词性的词。集合E(图中的边)由文章中的词在特定的滑动窗口下组成。E是一个VxV的子集。图中任意两节点Vi,Vj之间的权重为Wij，而对于一个节点Vi，In(Vi)表示图中指向该节点的其他节点集合，入度。而Out(Vi)为节点Vi指向的其他节点的集合。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于TextRank算法每次迭代是Vi节点的得分的计算公式为：<img src="/2018/09/01/TextRank/6d3a90f9-54f5-411b-bf3d-5e119062f76e.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;其中d是一个阻尼系数，其值在0到1之间。代表从图中一节点指向其他任意一节点的概率, 一般取值为 0.85。上述的公式，表示当前节点Vi的值为所有指向Vi的节点Vj给予的值的和。就相当于，我现在手上有1个苹果，如果我收集了我朋友给我的苹果，我将有多少个苹果的问题。假如我有两个朋友，他们会给我一些苹果，而我现在拥有的苹果数量就是他们给我的苹果数量的和。朋友A有3个苹果，但是同样他有3个朋友，而且需要给苹果给他的朋友，所以只能给我3/3＝1个苹果。朋友B有6个苹果，他有3个朋友，那么他给我6/3=2个苹果。那我现在手头将有1+1+3=5个苹果。实际中还要乘阻尼系数。TextRank算法就是这样迭代计算每个节点的值，而算法停止可以采用指定的迭代次数或者图中节点的值跟上次结果值的误差是否小于一个制定的极限值，一般取值为：0.0001。</p><h1 id="三-TextRank算法文本关键词提取"><a href="#三-TextRank算法文本关键词提取" class="headerlink" title="三. TextRank算法文本关键词提取"></a>三. TextRank算法文本关键词提取</h1><p>主要步骤：</p><ol><li>利用分词工具对文本进行分词</li><li>指定滑动窗口大小</li><li>滑动窗口经过文本词组，构建有向有权图。</li><li>迭代计算有向有权图，直到收敛。</li></ol><p>注意：在构建有向有权图时候，只筛选特定词性的词作为节点，比如名词，动词，形容词等，同时删除停用词。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol><li><p>一个文本，对其进行分词后，词组组成一个集合：<br>T = [S1,S2,S3,S1,S5,S6,S7,S8,S9]</p></li><li><p>指定滑动窗口大小为3</p></li><li><p>窗口里面的词组构建图，每次都是以窗口头结点为主节点。如下图所示：</p></li></ol><p>A：窗口第一次经过的词组，那么组成的边有:(S1,S2),(S2,S1),(S1,S3),(S3,S1)<br><img src="/2018/09/01/TextRank/e78a6e11-0507-4e6e-a289-a6bd1d4365b2.jpg" alt><br>B：窗口第二次经过的词组,组成的边有：(S2,S3),(S3,S1),(S2,S1),(S1,S2)。遇到重叠的边，则权重加1.<br><img src="/2018/09/01/TextRank/59840975-e639-4ab7-970b-171816be466e.jpg" alt><br>C：构建图完成之后，按照textRank算法的执行步骤，迭代计算，直到收敛。</p><p>D：最后对节点的权重排序输出。</p><h1 id="四-TextRank算法Scala代码实现"><a href="#四-TextRank算法Scala代码实现" class="headerlink" title="四. TextRank算法Scala代码实现"></a>四. TextRank算法Scala代码实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法的实现，这里采用scala，分词工具采用ansj_seg，这里scala代码实现的TextRank算法，只实现关键词的提取，没有实现句子提取，后续再补充。代码略。<br>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">object TextRankTest&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val tr &#x3D; new TextRank</span><br><span class="line">    tr.setStopword(Config.STOP_WORDS_FILE)&#x2F;&#x2F;停用词</span><br><span class="line">    val text &#x3D; &quot;机器学习是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。&quot;</span><br><span class="line">    val tags &#x3D; tr.textrank(sentence &#x3D; text,topK &#x3D; 10, allowPOS &#x3D; List(&quot;ns&quot;, &quot;vn&quot;, &quot;n&quot;, &quot;nr&quot;, &quot;nt&quot;, &quot;mama&quot;))</span><br><span class="line">    tags.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(算法,n,1.0)</span><br><span class="line">(学科,n,0.963356)</span><br><span class="line">(理论,n,0.934734)</span><br><span class="line">(分析,vn,0.85816)</span><br><span class="line">(机器学习,n,0.723762)</span><br><span class="line">(数据,n,0.615997)</span><br><span class="line">(规律,n,0.537537)</span><br><span class="line">(设计,vn,0.474728)</span><br><span class="line">(概率论,n,0.466409)</span><br><span class="line">(复杂度,n,0.442039)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(5)Hexo踩坑_主题优化</title>
      <link href="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="0-字体乱码问题"><a href="#0-字体乱码问题" class="headerlink" title="0 字体乱码问题"></a>0 字体乱码问题</h2><p>Windows 上新建的文件一般都是 <strong>gb2312或iso-8859-1</strong>，这样windows下的文件传递到Linux可能会出乱码问题</p><p>用 Git进去文件使用命令查看文件是否是<strong>utf-8</strong> 格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i word.ejs</span><br><span class="line">word.ejs: text&#x2F;html; charset&#x3D;iso-8859-1(或是其他)</span><br></pre></td></tr></table></figure><p><strong>第一种</strong><br>最简单的办法就是  vim  word.ejs</p><a id="more"></a><p>设置 set fileencoding=utf-8，强制保存，此时中文会乱码，再次输入即可</p><p><strong>第二种</strong></p><p>找一个 是 utf-8文件的 直接粘贴到需要位置，改名删除内容，写上自己的内容即可。</p><h2 id="1-图片无法加载"><a href="#1-图片无法加载" class="headerlink" title="1 图片无法加载"></a>1 图片无法加载</h2><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><p>效果如下图：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/83b0faba-efa5-477e-b4bf-be002402fb8b.jpg" alt></p><h2 id="2-点击所有文章-缺失模块"><a href="#2-点击所有文章-缺失模块" class="headerlink" title="2 点击所有文章 缺失模块"></a>2 点击所有文章 缺失模块</h2><p>缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br>npm i hexo-generator-json-content –save</p><p>3、在根目录_config.yml里添加配置：直接粘贴复制即可。（自己手打可能出错）</p><pre q-show="jsonFail" style="box-sizing: border-box; overflow: auto; white-space: pre-wrap; overflow-wrap: break-word; font-family: monospace, monospace; font-size: 12px;">  jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</pre><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9266a57c-8ba0-4ea9-831d-5d868b6de1de.jpg" alt></p><h2 id="3-个人头像及网站图标"><a href="#3-个人头像及网站图标" class="headerlink" title="3 个人头像及网站图标"></a>3 个人头像及网站图标</h2><h3 id="3-1-存放位置"><a href="#3-1-存放位置" class="headerlink" title="3.1 存放位置"></a>3.1 存放位置</h3><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。</p><h3 id="3-2-配置设置"><a href="#3-2-配置设置" class="headerlink" title="3.2 配置设置"></a>3.2 配置设置</h3><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/avatar.png</code>，设置则为<code>avatar: /assets/avatar.png</code>。（图标同理）</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f3f4cf22-244b-4dc6-9ec6-80772d70eeb5.jpg" alt></p><h2 id="4-文章摘要"><a href="#4-文章摘要" class="headerlink" title="4 文章摘要"></a>4 文章摘要</h2><p>目前主要是两种方式在首页显示文章摘要而不是全文</p><h3 id="4-1-方法1"><a href="#4-1-方法1" class="headerlink" title="4.1 方法1 "></a>4.1 方法1 <!--more--></h3><p>ps: 之前最好不要有空格</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/EBX_29_24AY7O_5DK_7EUZCSA2LR1BN.png" alt></p><h3 id="4-2-方法2-description-in-Front-matter"><a href="#4-2-方法2-description-in-Front-matter" class="headerlink" title="4.2 方法2 description in Front-matter"></a>4.2 方法2 description in Front-matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2015-12-03 00:00:00</span><br><span class="line">description: &quot;Welcome to Hexo! This is your very first post.&quot;</span><br><span class="line">---</span><br><span class="line">&lt;Contents&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>description</code> 添加的摘要只能为纯文本</p><p><code>description</code> 中的内容加引号，可以避免一些程序错误，例如当内容里包含英文冒号时。</p><h2 id="5-主菜单"><a href="#5-主菜单" class="headerlink" title="5 主菜单"></a>5 主菜单</h2><p>按下面格式添加侧边栏，菜单前的<font color="red">#</font>表示隐藏该条目<font color="red">themes/yilia/_config.yml</font>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按需求更改</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  所有文章: &#x2F;archives&#x2F;</span><br><span class="line">  #随笔: &#x2F;tags&#x2F;随笔</span><br><span class="line">  标签云: &#x2F;tags&#x2F;</span><br><span class="line">  关于我: &#x2F;about&#x2F;</span><br></pre></td></tr></table></figure><h2 id="6-标签云"><a href="#6-标签云" class="headerlink" title="6 标签云"></a>6 标签云</h2><p>使用 Hexo 命令新建一个tags的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/60e3c4cd-8d7d-43ab-8d6d-70d12b414979.png" alt></p><p>该页面标题可以在 /hexo/source/tags/index.md 中修改</p><p>同一片文章设置多个分类后的问题 <a href="https://github.com/MOxFIVE/hexo-theme-yelee/issues/4" target="_blank" rel="noopener">issue#4</a></p><h2 id="7-关于我"><a href="#7-关于我" class="headerlink" title="7 关于我"></a>7 关于我</h2><p>使用 Hexo 命令新建一个名为 <code>about</code> 的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>该页面内容在文件 <code>\hexo\source\about\index.md</code> 中修改</p><h2 id="8-本地搜索"><a href="#8-本地搜索" class="headerlink" title="8 本地搜索"></a>8 本地搜索</h2><p>使用搜索需先安装对应插件，用于生成索引数据</p><p>插件主页: <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置插件启用为true 到根目录下的_config.yml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line"> on: true</span><br><span class="line"> onload: false</span><br></pre></td></tr></table></figure><p><strong>onload: true：</strong> 索引数据<strong>search.xml</strong>随页面一起加载（效率优先）<br><strong>onload：false：</strong> 当激活搜索框时在下载索引数据（按需加载）</p><h2 id="9-社交图标"><a href="#9-社交图标" class="headerlink" title="9 社交图标"></a>9 社交图标</h2><p>去掉前面的 # 再填写链接即可</p><p><font color="red">themes/yilia/_config.yml</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line"> Email: &quot;haoransunlin@163.com&quot;</span><br><span class="line"> #新浪微博: &quot;sina weibo&quot;</span><br><span class="line"> GitHub: ...</span><br><span class="line"> #RSS: &quot;&#x2F;aotm.xml&quot;</span><br></pre></td></tr></table></figure><p>设置 Email 时保留 <code>mailto:</code> 可考虑加密邮件地址 <a href="http://ctrlq.org/encode/" target="_blank" rel="noopener">http://ctrlq.org/encode/</a></p><p>使用 RSS 需先安装对应插件 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><h2 id="10-网站运行时间-暂时没有配置"><a href="#10-网站运行时间-暂时没有配置" class="headerlink" title="10 网站运行时间(暂时没有配置)"></a>10 网站运行时间(暂时没有配置)</h2><h3 id="10-1-修改-themes-yilia-config-yml-添加如下内容"><a href="#10-1-修改-themes-yilia-config-yml-添加如下内容" class="headerlink" title="10.1 修改 \themes\yilia_config.yml 添加如下内容"></a>10.1 修改 \themes\yilia_config.yml 添加如下内容</h3><p>网站运行时间，格式形如：“本站已安全运行 50 天 12 小时 13 分 41 秒”<br>Runing Time<br>running_time:<br> enable: true<br> create_time: ‘07/25/2019 12:00:00’ #此处修改你的建站时间或者网站上线时间</p><h3 id="10-2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容："><a href="#10-2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容：" class="headerlink" title="10.2 修改\themes\yilia\layout\_partial\footer.ejs，在&lt;/footer&gt;上面添加如下内容："></a>10.2 修改<code>\themes\yilia\layout\_partial\footer.ejs</code>，在<code>&lt;/footer&gt;</code>上面添加如下内容：</h3><!--《添加网站运行时间  <br/>--><p>&lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time){ %&gt;<br>    <span id="timeDate">载入天数…</span><span id="times">载入时分秒…</span><br>    <script><br>    var now = new Date();<br>    function createtime() {<br>        //此处修改你的建站时间或者网站上线时间<br>        var create_time = '<%- theme.running_time.create_time %>';<br>        now.setTime(now.getTime() + 250);<br>        days = (now - grt) / 1000 / 60 / 60 / 24;<br>        dnum = Math.floor(days);<br>        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);<br>        hnum = Math.floor(hours);<br>        if (String(hnum).length == 1) {<br>            hnum = "0" + hnum;<br>        }<br>        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);<br>        mnum = Math.floor(minutes);<br>        if (String(mnum).length == 1) {<br>            mnum = "0" + mnum;<br>        }<br>        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);<br>        snum = Math.round(seconds);<br>        if (String(snum).length == 1) {<br>            snum = "0" + snum;<br>        }<br>        document.getElementById("timeDate").innerHTML = " | 本站已安全运行 " + dnum + " 天 ";<br>        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";<br>    }<br>    setInterval("createtime()", 250);<br>    </script><br>&lt;% } %&gt;</p><!-- 添加网站运行时间》--><h2 id="11-背景图片"><a href="#11-背景图片" class="headerlink" title="11 背景图片"></a>11 背景图片</h2><p>*<em>推荐大小：700 x 1200 *</em></p><h3 id="11-1-找到-themes-lilia-目录下的-config-yml-修改配置如下："><a href="#11-1-找到-themes-lilia-目录下的-config-yml-修改配置如下：" class="headerlink" title="11.1 找到 themes\lilia\目录下的 _config.yml,修改配置如下："></a>11.1 找到 themes\lilia\目录下的 _config.yml,修改配置如下：</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/2488f7cb-b9a9-4f5e-b191-8b9fd0200767.png" alt></p><h3 id="11-2-将选好的背景图片放入-themes-yilia-source-assets-目录下"><a href="#11-2-将选好的背景图片放入-themes-yilia-source-assets-目录下" class="headerlink" title="11.2 将选好的背景图片放入 themes\yilia\source\assets 目录下"></a>11.2 将选好的背景图片放入 themes\yilia\source\assets 目录下</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/a9d8f38d-868e-48ba-8299-1f2dd027adaa.jpg" alt></p><h3 id="11-3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）"><a href="#11-3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）" class="headerlink" title="11.3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）"></a>11.3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）</h3><p><strong>ctrl + f 搜索：.left-col{ 、.left-col .overlay{ 、#mobile-nav .overlay</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/aeda14f1-204f-4735-a71a-b5df19eb9bc4.png" alt></p><p>里面添加 <strong>background-image:url(“图片地址”)即可</strong></p><p>字体颜色需要自己根据背景图片来调配</p><p>搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.left-col #header a&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header a:hover&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header .header-subtitle&#123;</span><br></pre></td></tr></table></figure><h3 id="11-4-打开-yilia-layout-partial-left-col-ejs"><a href="#11-4-打开-yilia-layout-partial-left-col-ejs" class="headerlink" title="11.4 打开 yilia\layout_partial\left-col,ejs"></a>11.4 打开 yilia\layout_partial\left-col,ejs</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9c9a363b-d5e2-4785-b13d-5b4e4945b8ce.png" alt></p><p>重新部署即可看到效果</p><h2 id="12-文章目录"><a href="#12-文章目录" class="headerlink" title="12 文章目录"></a>12 文章目录</h2><h3 id="12-1-添加-CSS-样式"><a href="#12-1-添加-CSS-样式" class="headerlink" title="12.1 添加 CSS 样式"></a>12.1 添加 CSS 样式</h3><p>打开 <code>themes\yilia\source</code> 下的 <code>main.234bc0.css</code> 文件，直接在后面添加如下代码：</p><p>/<em>新添加的</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#container .show-toc-btn,#container .toc-article&#123;display:block&#125;</span><br><span class="line">.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http:&#x2F;&#x2F;7xtawy.com1.z0.glb.clouddn.com&#x2F;show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;</span><br><span class="line">.toc-article li ol, .toc-article li ul &#123;</span><br><span class="line">    margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.toc-article ol, .toc-article ul &#123;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-修改-article-ejs-文件"><a href="#12-2-修改-article-ejs-文件" class="headerlink" title="12.2 修改 article.ejs 文件"></a>12.2 修改 article.ejs 文件</h3><p>打开 <code>themes\yilia\layout\_partial</code> 文件夹下的 <code>article.ejs</code> 文件, 在 <code>&lt;/header&gt; &lt;% } %&gt;</code> 下面加入如下内容（注意位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目录内容 --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;show-toc-btn&quot; id&#x3D;&quot;show-toc-btn&quot; onclick&#x3D;&quot;showToc();&quot; style&#x3D;&quot;display:none&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-bg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-text&quot;&gt;文章导航&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;toc-article&quot; class&#x3D;&quot;toc-article&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;toc-close&quot; class&#x3D;&quot;toc-close&quot; title&#x3D;&quot;隐藏导航&quot; onclick&#x3D;&quot;showBtn();&quot;&gt;×&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;toc-title&quot;&gt;文章目录&lt;&#x2F;strong&gt;</span><br><span class="line">           &lt;%- toc(post.content) %&gt;</span><br><span class="line">         &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function showToc()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    function showBtn()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">&lt;!-- 目录内容结束 --&gt;</span><br></pre></td></tr></table></figure><p>想要温江显示目录，在每篇文章开头加入：toc: true 即可。</p><h2 id="13-版权"><a href="#13-版权" class="headerlink" title="13 版权"></a>13 版权</h2><p>待定</p><h2 id="14-友情链接"><a href="#14-友情链接" class="headerlink" title="14 友情链接"></a>14 友情链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 编辑友链</span><br><span class="line">friends:</span><br><span class="line">  Hexo: https:&#x2F;&#x2F;hexo.io</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;pages.github.com&#x2F;</span><br><span class="line">  MOxFIVE: http:&#x2F;&#x2F;moxfive.xyz&#x2F;</span><br><span class="line"></span><br><span class="line">## 关闭友链</span><br><span class="line">friends: false</span><br></pre></td></tr></table></figure><h2 id="15-关于我"><a href="#15-关于我" class="headerlink" title="15 关于我"></a>15 关于我</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启“关于我”。</span><br><span class="line">aboutme: 专注于前端</span><br><span class="line"></span><br><span class="line"># 关闭“关于我”</span><br><span class="line">aboutme: false</span><br></pre></td></tr></table></figure><h2 id="16-评论"><a href="#16-评论" class="headerlink" title="16 评论"></a>16 评论</h2><p><strong>GitHub OAuth授权：Settings/Developer settings/OAuth Apps</strong></p><p><a href="https://github.com/settings/applications/1265561" target="_blank" rel="noopener">https://github.com/settings/applications/1265561</a></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0_3_C@_7EZ_609_5DF_4_7E1_240_24S0L5.png" alt></p><h3 id="16-1-在layout-partial-post目录下新增gitalk-ejs文件"><a href="#16-1-在layout-partial-post目录下新增gitalk-ejs文件" class="headerlink" title="16.1 在layout/_partial/post目录下新增gitalk.ejs文件"></a>16.1 在<code>layout/_partial/post</code>目录下新增<code>gitalk.ejs</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot; style&#x3D;&quot;padding: 0px 30px 0px 30px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">if(&lt;%&#x3D;theme.gitalk.enable%&gt;)&#123;</span><br><span class="line"> var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line"> clientID: &#39;&lt;%&#x3D;theme.gitalk.ClientID%&gt;&#39;,</span><br><span class="line"> clientSecret: &#39;&lt;%&#x3D;theme.gitalk.ClientSecret%&gt;&#39;,</span><br><span class="line"> repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line"> owner: &#39;&lt;%&#x3D;theme.gitalk.githubID%&gt;&#39;,</span><br><span class="line"> admin: [&#39;&lt;%&#x3D;theme.gitalk.adminUser%&gt;&#39;],</span><br><span class="line"> id: &#39;&lt;%&#x3D; page.date %&gt;&#39;,</span><br><span class="line"> distractionFreeMode: &#39;&lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="16-2-修改source-src-css-目录下comment-scss文件"><a href="#16-2-修改source-src-css-目录下comment-scss文件" class="headerlink" title="16.2 修改source-src/css/目录下comment.scss文件"></a>16.2 修改<code>source-src/css</code>/目录下<code>comment.scss</code>文件</h3><p>注意第一行最后添加了 #gitalk-container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container &#123;</span><br><span class="line"> padding: 0 30px !important;</span><br><span class="line"> min-height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#SOHUCS &#123;</span><br><span class="line"> #SOHU_MAIN .module-cmt-list .block-cont-gw &#123;</span><br><span class="line"> border-bottom: 1px dashed #c8c8c8 !important;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码："><a href="#16-3-在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码：" class="headerlink" title="16.3 在layout/_partial目录下的article.ejs文件内新增gitalk相关的配置代码："></a>16.3 在<code>layout/_partial</code>目录下的<code>article.ejs</code>文件内新增<code>gitalk</code>相关的配置代码：</h3><p>在最后一行 &lt;% } %&gt; 前加入，如下图所示<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9f43f555-78c6-44fa-a465-3b55891297fd.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable)&#123; %&gt;</span><br><span class="line"> &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line"> key: post.slug,</span><br><span class="line"> title: post.title,</span><br><span class="line"> url: config.url+url_for(post.path)</span><br><span class="line"> &#125;) %&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="16-4-最后在yilia主题配置文件中新增gitalk相关的配置："><a href="#16-4-最后在yilia主题配置文件中新增gitalk相关的配置：" class="headerlink" title="16.4 最后在yilia主题配置文件中新增gitalk相关的配置："></a>16.4 最后在<code>yilia</code>主题配置文件中新增<code>gitalk</code>相关的配置：</h3><p>属性名要与 配置文件中保持一致 ,如：<br>theme.gitalk.client_id  要与配置文件中 client_id 这几个字母一致<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/63179418-0e08-4864-bc85-b444e6067360.png" alt></p><p><strong>githubID：是自己的GitHub账户名称，如我的是JavaSsun</strong><br><strong>repo：是新建的评论仓库名称</strong><br><strong>adminuser:是自己的账户名称JavaSsun</strong></p><p>更新一下即可。</p><p><strong>基本完成，现在解决常见问题</strong>.</p><h2 id="17-文章字数及统计阅读时长-注意乱码"><a href="#17-文章字数及统计阅读时长-注意乱码" class="headerlink" title="17 文章字数及统计阅读时长(注意乱码)"></a>17 文章字数及统计阅读时长(注意乱码)</h2><h3 id="17-1-安装-hexo-wordcount"><a href="#17-1-安装-hexo-wordcount" class="headerlink" title="17.1 安装 hexo-wordcount"></a>17.1 安装 hexo-wordcount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h3 id="17-2-文件配置"><a href="#17-2-文件配置" class="headerlink" title="17.2 文件配置"></a>17.2 文件配置</h3><p>在theme\yilia\layout_partial\post下创建word.ejs文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top:10px;&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &amp;nbsp; | &amp;nbsp;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后在 themes/yilia/layout/_partial/article.ejs中添加(在 /header 之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;article-inner&quot;&gt;</span><br><span class="line">    &lt;% if (post.link || post.title)&#123; %&gt;</span><br><span class="line">      &lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class="line">        &lt;% if (!post.noDate)&#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">        &lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">        &lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">        &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">          &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">        &lt;!-- 添加完成 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      &lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure><h3 id="17-3-开启功能"><a href="#17-3-开启功能" class="headerlink" title="17.3 开启功能"></a>17.3 开启功能</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e0da8fad-4be8-436b-9491-b943d26853f1.png" alt></p><p>效果如图所示：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0c5c293d-95ac-47c3-a2cc-b3a589682a23.png" alt></p><h2 id="18-添加背景音乐"><a href="#18-添加背景音乐" class="headerlink" title="18 添加背景音乐"></a>18 添加背景音乐</h2><h3 id="18-1-打开网易云音乐首页，然后搜索要添加的背景音乐"><a href="#18-1-打开网易云音乐首页，然后搜索要添加的背景音乐" class="headerlink" title="18.1 打开网易云音乐首页，然后搜索要添加的背景音乐"></a>18.1 打开网易云音乐首页，然后搜索要添加的背景音乐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/65d6c7e8-80bf-45c9-8092-a46d177d5dfa.jpg" alt></p><h3 id="18-2-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#18-2-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="18.2 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>18.2 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/19e4d9b9-e95b-4313-947f-5f0fc33bea71.png" alt></p><h3 id="18-3-复制外链播放器的代码"><a href="#18-3-复制外链播放器的代码" class="headerlink" title="18.3 复制外链播放器的代码"></a>18.3 复制外链播放器的代码</h3><p>打开 /yilia/layout/_partia/left-col.ejs 文件 <strong>nav标签中添加代码</strong><br>注：放在<code>&lt;nav&gt;</code>和<code>&lt;/nav&gt;</code>之内</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9dd56bf0-40f8-46ae-acb7-764d7074be59.png" alt><br>[========]</p><h2 id="19-鼠标点击桃心效果"><a href="#19-鼠标点击桃心效果" class="headerlink" title="19 鼠标点击桃心效果"></a>19 鼠标点击桃心效果</h2><p>在 themes/yilia/source文件夹下，建立resources文件夹，再新建click.js文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">! function(e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e &#x3D; 0; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick &#x3D; function(e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText &#x3D; e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d &#x3D; [];</span><br><span class="line">    e.requestAnimationFrame &#x3D; function() &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure><p>然后在themes/yilia/layout/_partial文件夹下的after-footer.ejs中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&lt;%&#x3D;config.root%&gt;.&#x2F;resources&#x2F;click.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/68ee37c3-7cb5-49b0-9d82-d670cf2bf98c.png" alt></p><p>重新部署即可</p><h2 id="20-添加网站运行时间"><a href="#20-添加网站运行时间" class="headerlink" title="20 添加网站运行时间"></a>20 添加网站运行时间</h2><h2 id="21-Hexo博客添加-helper-live2d动态模型插件"><a href="#21-Hexo博客添加-helper-live2d动态模型插件" class="headerlink" title="21 Hexo博客添加 helper-live2d动态模型插件"></a>21 Hexo博客添加 helper-live2d动态模型插件</h2><h3 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h3><ul><li>yilia主题</li><li>插件地址 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener" title="hexo-helper-live2d">hexo-helper-live2d</a></li><li><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></li></ul><h3 id="21-1-安装模块"><a href="#21-1-安装模块" class="headerlink" title="21.1 安装模块"></a>21.1 安装模块</h3><p>在hexo根目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h3 id="21-2-下载模型"><a href="#21-2-下载模型" class="headerlink" title="21.2 下载模型"></a>21.2 下载模型</h3><p>作者各种模型包展示 ➡️ <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener" title=" hexo live2d插件 2.0 !">hexo live2d插件 2.0 !</a></p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haru/02</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code> 黑猫</li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code> 白猫</li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>使用<code>npm install {packagename}</code>安装模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install live2d-widget-model-hibiki</span><br></pre></td></tr></table></figure><h3 id="21-3-详细配置"><a href="#21-3-详细配置" class="headerlink" title="21.3 详细配置"></a>21.3 详细配置</h3><p>在Hexo的 <code>_config.yml</code> 文件中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  #enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hibiki</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure><p>hexo g | hexo s即可</p><h2 id="22-Hexo添加访问量统计"><a href="#22-Hexo添加访问量统计" class="headerlink" title="22 Hexo添加访问量统计"></a>22 Hexo添加访问量统计</h2><ul><li>主题 yilia</li><li>访问统计量使用 <strong><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener" title="不蒜子">不蒜子</a></strong></li></ul><h3 id="22-1-配置是否开启不蒜子访问量统计功能"><a href="#22-1-配置是否开启不蒜子访问量统计功能" class="headerlink" title="22.1 配置是否开启不蒜子访问量统计功能"></a>22.1 配置是否开启不蒜子访问量统计功能</h3><p>在 <strong>themes/yilia/_config.yml</strong> 添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启访问量统计功能（不蒜子）</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="22-2-引入不蒜子并添加站点访问量"><a href="#22-2-引入不蒜子并添加站点访问量" class="headerlink" title="22.2 引入不蒜子并添加站点访问量"></a>22.2 引入不蒜子并添加站点访问量</h3><p>在<code>themes/yilia/layout/_partial/footer.ejs</code>末尾添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/760ffbaf-8a71-415e-8869-74c555cddcf8.png" alt></p><h3 id="22-3-添加文章访问量"><a href="#22-3-添加文章访问量" class="headerlink" title="22.3 添加文章访问量"></a>22.3 添加文章访问量</h3><p>在<code>themes/yilia/layout/_partial/post/date.ejs</code>开头添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/daf13bfc-f651-4963-99bd-3cec83a0b71a.png" alt></p><meta charset="utf-8"><h3 id="22-4-注意事项"><a href="#22-4-注意事项" class="headerlink" title="22.4 注意事项"></a>22.4 注意事项</h3><ul><li><p>两种方法选择一种使用即可，都使用可能会出现无法显示的问题</p></li><li><p>使用<code>hexo s</code>部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用<code>localhost:4000</code>进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p></li></ul><h2 id="23-RSS"><a href="#23-RSS" class="headerlink" title="23 RSS"></a>23 RSS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/fafa6df3-68ca-4b15-aaa9-b8ebb2ea0dec.png" alt></p><h2 id="24-Hexo设置-标签-分类-归档"><a href="#24-Hexo设置-标签-分类-归档" class="headerlink" title="24 Hexo设置 标签 分类 归档"></a>24 Hexo设置 标签 分类 归档</h2><p>举例：</p><h3 id="24-1-添加-分类页面"><a href="#24-1-添加-分类页面" class="headerlink" title="24.1 添加 分类页面"></a>24.1 添加 分类页面</h3><p>使用：<code>hexo new page categories</code> 新建一个 分类 页面。</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/50a49785-9652-4252-af8d-f67fbc85784c.png" alt></p><p>添加 type: “categories”<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/ac3196b3-f7f0-4483-8f0b-581b673c3e04.png" alt></p><p>tags类似：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/db61e102-242e-404a-8f6e-9026770bcf82.png" alt></p><p>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/24627704-f7a0-4686-9c87-bd3ecc9d433e.png" alt></p><h2 id="25-Hexo博客优化之文章置顶-置顶标签"><a href="#25-Hexo博客优化之文章置顶-置顶标签" class="headerlink" title="25 Hexo博客优化之文章置顶+置顶标签"></a>25 Hexo博客优化之文章置顶+置顶标签</h2><h3 id="25-1-博文置顶"><a href="#25-1-博文置顶" class="headerlink" title="25.1 博文置顶"></a>25.1 博文置顶</h3><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index  --save </span><br><span class="line">$ npm install hexo-generator-index-pin-top  --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：<br>注意有 <strong>空格</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/062b9442-ca03-4376-b1c2-52287944889b.png" alt></p><h3 id="25-2-配置置顶标准"><a href="#25-2-配置置顶标准" class="headerlink" title="25.2 配置置顶标准"></a>25.2 配置置顶标准</h3><p>打开：/themes/*/layout（/_macro）/post.ejs<br>直接在最前面加入以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.top) &#123; %&gt;</span><br><span class="line"> &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line"> &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line"> &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="25-3-配置文章"><a href="#25-3-配置文章" class="headerlink" title="25.3 配置文章"></a>25.3 配置文章</h3><p>然后在需要置顶的文章的Front-matter中加上top选项即可<br>top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> title: (5)Hexo踩坑_主题优化</span><br><span class="line"> date: 2018-08-21 17:15:09</span><br><span class="line"> tags: Hexo-yilia</span><br><span class="line"> categories: Hexo</span><br><span class="line"> top: 5</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><h3 id="25-4-优先级配置"><a href="#25-4-优先级配置" class="headerlink" title="25.4 优先级配置"></a>25.4 优先级配置</h3><p>修改根目录配置文件/_config.yml,top值-1标示根据top值倒序（正序设置为1即可），同样date也是根据创建日期倒序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line"> path: &#39;&#39;</span><br><span class="line"> per_page: 10</span><br><span class="line"> order_by:</span><br><span class="line"> top: -1</span><br><span class="line"> date: -1</span><br></pre></td></tr></table></figure><h3 id="25-5-设置置顶标志"><a href="#25-5-设置置顶标志" class="headerlink" title="25.5 设置置顶标志"></a>25.5 设置置顶标志</h3><p>暂时用默认的</p><h2 id="26-去掉配置文件中的-more"><a href="#26-去掉配置文件中的-more" class="headerlink" title="26 去掉配置文件中的 more"></a>26 去掉配置文件中的 more</h2><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/957764e6-d0ac-4b0c-8cc2-4b05f6327872.png" alt></p><h2 id="27-在左侧显示总文章数"><a href="#27-在左侧显示总文章数" class="headerlink" title="27 在左侧显示总文章数"></a>27 在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class&#x3D;&quot;header-menu&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line"> &lt;% for (var i in theme.menu)&#123; %&gt;</span><br><span class="line"> &lt;li&gt;&lt;a href&#x3D;&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%&#x3D; i %&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;%&#125;%&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav style&#x3D;&quot;color: #7FFFD4;&quot;&gt;总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><h2 id="28-Hexo博客绑定个人域名"><a href="#28-Hexo博客绑定个人域名" class="headerlink" title="28 Hexo博客绑定个人域名"></a>28 Hexo博客绑定个人域名</h2><h3 id="28-1-购买域名"><a href="#28-1-购买域名" class="headerlink" title="28.1 购买域名"></a>28.1 购买域名</h3><p>阿里云或者腾讯云购买，步骤省略。</p><h3 id="28-2-域名解析"><a href="#28-2-域名解析" class="headerlink" title="28.2 域名解析"></a>28.2 域名解析</h3><h4 id="28-2-1-方法1（不推荐）"><a href="#28-2-1-方法1（不推荐）" class="headerlink" title="28.2.1 方法1（不推荐）"></a>28.2.1 方法1（不推荐）</h4><p>首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：</p><hr><p>本人Ip是： xxx.xxx.xxx.xxx<br>通过域名解析将购买的域名指向 github的二级域名：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/35ca50f9-eac8-442b-a9e4-077c30fc26a7.png" alt></p><p>之后如图所示记为成功：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f9f80e1e-7684-4810-99aa-24e77adb447f.png" alt></p><h4 id="28-2-2-方法2（推荐）"><a href="#28-2-2-方法2（推荐）" class="headerlink" title="28.2.2 方法2（推荐）"></a>28.2.2 方法2（推荐）</h4><p>直接解析域名的CNAME记录到你的Git二级域名，不要使用方法一中的A记录，因为ip地址可能会一段时间之后会改变，所以建议记录类型选择CNAME进行解析，<a href="http://xn--username-273mz98dvpjuoju9wmi6c0myd.github.io/" target="_blank" rel="noopener">记录值填的就是username.github.io</a>，比如：</p><hr><h4 id="28-3-设置CNAME"><a href="#28-3-设置CNAME" class="headerlink" title="28.3 设置CNAME"></a>28.3 设置CNAME</h4><p>在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如：<br>blog.enjoytoshare.club</p><p>在 github 上面，打开 <a href="http://username.github.io/" target="_blank" rel="noopener">username.github.io</a> 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e3d7dfeb-116d-4e35-94b3-4fee60ff37ec.png" alt></p><p>好了，新域名配置完成，可以访问了。</p><h2 id="29-Hexo-d-部署后重新修改域名？"><a href="#29-Hexo-d-部署后重新修改域名？" class="headerlink" title="29 Hexo d 部署后重新修改域名？"></a>29 Hexo d 部署后重新修改域名？</h2><ol><li>在source目录下（不是hexo根目录下），创建一个CNAME文件，可以用sublime创建，然后保存成（All files格式）<br>CNAME文件里写自己新的域名<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/18f0c754-8461-4294-870e-dfba518b16b8.jpg" alt></li></ol><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haoran.tech</span><br></pre></td></tr></table></figure><ol start="2"><li><p>hexo g 重新生成一下</p></li><li><p>hexo d 部署到github上</p></li></ol><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/13cc17e1-13a2-46ff-ab2a-7b3898cbb87f.png" alt></p><p>此时可以通过域名访问了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(4)Hexo撰写文章</title>
      <link href="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
      <url>/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><img src="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/60bbee39-dccc-48d2-9fb5-149a40253315.png" alt></p><a id="more"></a><h3 id="一-创建文章"><a href="#一-创建文章" class="headerlink" title="一 创建文章"></a>一 创建文章</h3><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 <code>title</code> 为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <strong>source/_post</strong> 文件夹下创建一个文件，命名为：<strong>title.md</strong></p><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h3 id="二-编写文章（基于Markdown）"><a href="#二-编写文章（基于Markdown）" class="headerlink" title="二 编写文章（基于Markdown）"></a>二 编写文章（基于Markdown）</h3><h4 id="1-Markdown基本语法略"><a href="#1-Markdown基本语法略" class="headerlink" title="1 Markdown基本语法略"></a>1 <strong>Markdown基本语法略</strong></h4><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2 说明："></a>2 <strong>说明：</strong></h4><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><h4 id="3-高级设置"><a href="#3-高级设置" class="headerlink" title="3 高级设置"></a>3 高级设置</h4><p><strong>1 模板设置</strong></p><p>当我们使用命令 <strong>hexo new “title”</strong> 创建文章时，Hexo 会根据 <strong>/scaffolds/post.md</strong> 对新文章进行初始化</p><p>换言之，<strong>/scaffolds/post.md</strong> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories</span><br></pre></td></tr></table></figure><p><strong>2 头部设置</strong></p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置<strong>文章标题</strong>、<strong>发布日期</strong>等基础信息外，还可以为文章<strong>添加标签</strong>、<strong>分类</strong>等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><font color="red"><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</font></p><p><strong>3 首页显示</strong></p><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，<strong>表示只会显示标志前面的内容</strong></p><h3 id="三-部署发布"><a href="#三-部署发布" class="headerlink" title="三 部署发布"></a>三 部署发布</h3><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h3 id="四-Hexo一篇文章多个categories"><a href="#四-Hexo一篇文章多个categories" class="headerlink" title="四 Hexo一篇文章多个categories"></a>四 Hexo一篇文章多个categories</h3><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写一篇 《Servlet笔记》，我既想将它放在 <strong>Java</strong> 这个分类中，又想将它放入 <strong>Servlet</strong> 这个分类。</p><p>  按照官方的解释，<code>categories</code> 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h4 id="4-1-子分类"><a href="#4-1-子分类" class="headerlink" title="4.1 子分类"></a>4.1 子分类</h4><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Java</span><br><span class="line">  - Servlet</span><br></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [Java, Servlet]</span><br></pre></td></tr></table></figure><h4 id="4-2-多个分类"><a href="#4-2-多个分类" class="headerlink" title="4.2 多个分类"></a>4.2 多个分类</h4><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java]</span><br><span class="line">  -[Servlet]</span><br></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。</p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java, Servlet]</span><br><span class="line">  -[Programming]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(3)Hexo常用命令详解</title>
      <link href="/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><strong>Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</strong><br><strong>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</strong><br><strong>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</strong><br><strong>不同的主题会有不同的主题配置文件，由主题作者所提供</strong>.</p><a id="more"></a><h3 id="1-hexo-init"><a href="#1-hexo-init" class="headerlink" title="1 hexo init"></a>1 hexo init</h3><p><strong>hexo init</strong> 命令用于初始化本地文件夹为网站的根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><ul><li><strong>folder</strong> 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录</li></ul><h3 id="2-hexo-new"><a href="#2-hexo-new" class="headerlink" title="2 hexo new"></a>2 hexo new</h3><p><strong>hexo new</strong> 命令用于新建文章，一般可以简写为<strong>hexo n</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>layout</strong> 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</p></li><li><p><strong>title</strong> 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</p></li></ul><h3 id="3-hexo-generate"><a href="#3-hexo-generate" class="headerlink" title="3 hexo generate"></a>3 hexo generate</h3><p><strong>hexo generate</strong> 命令用于生成静态文件，一般可以简写为 hexo g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong> 选项，指定生成后部署，与 <strong>hexo d -g</strong> 等价</li></ul><p>详细信息请参考：<a href="https://hexo.io/docs/generating" target="_blank" rel="noopener">https://hexo.io/docs/generating</a></p><h3 id="4-hexo-server"><a href="#4-hexo-server" class="headerlink" title="4 hexo server"></a>4 hexo server</h3><p><strong>hexo server</strong> 命令用于启动本地服务器，一般可以简写为 <strong>hexo s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><ul><li><p>-p 选项，指定服务器端口，默认为 4000</p></li><li><p>-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</p></li><li><p>-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p></li></ul><p>说明 ：运行服务器前需要安装 hexo-server 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">https://hexo.io/docs/server.html</a></p><h3 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5 hexo deploy"></a>5 hexo deploy</h3><p><strong>hexo deploy</strong> 命令用于部署网站，一般可以简写为 hexo d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><ul><li><strong>-g</strong> 选项，指定生成后部署，与 hexo g -d 等价</li></ul><p>说明 ：部署前需要修改 _config.yml 配置文件，下面以 git 为例进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: &lt;repository url&gt;</span><br><span class="line">    branch:    master</span><br><span class="line">    message: 自定义提交消息，默认为Site updated: &#123;&#123; now(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><h3 id="6-hexo-clean"><a href="#6-hexo-clean" class="headerlink" title="6 hexo clean"></a>6 hexo clean</h3><p><strong>hexo clean</strong> 命令用于清理缓存文件，是一个比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>网站显示异常时可尝试此操作</p><h3 id="7-Option"><a href="#7-Option" class="headerlink" title="7 Option"></a>7 Option</h3><p><strong>（1）hexo –safe</strong></p><p><strong>hexo –safe</strong> 表示安全模式，用于禁用加载插件和脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>安装新插件时遇到问题可尝试此操作</p><p><strong>（2）hexo –debug</strong></p><p><strong>hexo –debug</strong> 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p><strong>（3）hexo –silent</strong></p><p><strong>hexo –silent</strong> 表示静默模式，用于静默输出到终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Hexo配置文件详解</title>
      <link href="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p>Hexo 是一款极为优秀的博客框架，使用 Hexo 搭建一个个人博客后，还需要编写位于站点根目录下的 <code>_config.yml</code> 文件来满足定制化的需求。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:&#x2F;&#x2F;elfwalk.github.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line">#发布设置</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;elfwalk&#x2F;elfwalk.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1d62242a-d3b1-417a-bf11-e69e000b36f1.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/c95a5140-a299-4492-9006-3827168ab8e9.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/6ef267ec-cfd0-411b-891a-15de0966c39b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/92065ad3-a506-4066-8ccf-0dc4f6804458.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/97fd8861-b2b9-48a8-8c6a-545d0f31b2d0.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/7fdb3429-0dd3-4363-bf04-c03636d1702b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/d3ea4182-f75f-4576-904c-71883facc176.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/cb23844c-160e-47e9-97d3-753d06414ab8.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/801539a4-704b-4a63-b4f3-b824a474f7cd.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Firewalld二三事</title>
      <link href="/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>文章来源：<br><a href="http://www.excelib.com/article/287/show/#u0pW4f" target="_blank" rel="noopener">http://www.excelib.com/article/287/show/#u0pW4f</a></p><h3 id="1-Firewalld简介"><a href="#1-Firewalld简介" class="headerlink" title="1 Firewalld简介"></a>1 Firewalld简介</h3><p>Centos7中默认将原来的防火墙iptables升级为了firewalld，firewalld跟iptables比起来至少有两大好处：</p><ol><li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效；</li><li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。<a id="more"></a><h3 id="2-iptables-五表"><a href="#2-iptables-五表" class="headerlink" title="2 iptables 五表"></a>2 iptables 五表</h3>大部分iptables的资料都介绍说iptables包含四张表、五条链，不过实际上iptables还有第五张表——security表，但是这张表需要和selinux结合使用，而selinux虽然已经发布了十多年了但是直到现在还有很多人对他的理解不够透彻，甚至有很多人会将其关闭！</li></ol><p>其实selinux的设计理念在安全上来说是非常优秀的，而且理解了其设计理念之后再去使用也没那么复杂，只不过其内置的规则是非常复杂的，有机会再说。现在还回到iptables的五张表，他们分别是<strong>filter、nat、mangle、raw和security</strong>。</p><p>filter表就是我们最常使用的过滤表；nat表主要用于数据包转发，比如局域网的电脑如果想连接互联网，那么就可以使用nat给转发一下；mangle表的规则可以对数据包进行修改，比如修改ttl值等；raw表主要是为了提高效率使用的，raw本身的含义是指“原生的”、“未经过加工的”，符合raw表所对应规则的数据包将会跳过一些检查，这样就可以提高效率，当然，raw表的优先级也是最高的；security是跟selinux相关的MAC模式的安全过滤。</p><h3 id="3-firewalld和iptables的关系"><a href="#3-firewalld和iptables的关系" class="headerlink" title="3 firewalld和iptables的关系"></a>3 firewalld和iptables的关系</h3><p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样罢了。</p><h3 id="4-firewalld的配置文件结构"><a href="#4-firewalld的配置文件结构" class="headerlink" title="4 firewalld的配置文件结构"></a>4 firewalld的配置文件结构</h3><p>在具体介绍firewalld配置文件结构之前先介绍一下firewalld的配置模式，firewalld的配置模式设计的非常巧妙，而且这种设计思路也非常值得我们借鉴和学习。</p><h4 id="4-1-firewalld的配置模式"><a href="#4-1-firewalld的配置模式" class="headerlink" title="4.1 firewalld的配置模式"></a>4.1 firewalld的配置模式</h4><p>firewalld的配置文件以xml格式为主（主配置文件firewalld.conf例外），他们有两个存储位置</p><p>1.<code>/etc/firewalld/</code></p><p>2.<code>/usr/lib/firewalld/</code></p><p>使用时的规则是这样的：当需要一个文件时firewalld会首先到第一个目录中去查找，如果可以找到，那么就直接使用，否则会继续到第二个目录中查找。</p><p>firewalld的这种配置文件结构的主要作用是这样的：在第二个目录中存放的是firewalld给提供的通用配置文件，如果我们想修改配置，那么可以copy一份到第一个目录中，然后再进行修改。这么做有两个好处：首先我们日后可以非常清晰地看到都有哪些文件是我们自己创建或者修改过的，其次，如果想恢复firewalld给提供的默认配置，只需要将自己在第一个目录中的配置文件删除即可，非常简单，而不需要像其他很多软件那样在修改之前还得先备份一下，而且时间长了还有可能忘掉之前备份的是什么版本。</p><p>当然，这种配置模式也并不是firewalld的首创，在其他很多地方也都有用到，比如java中用于记录日志的logback也是这种模式，他在查找配置文件时会首先在根目录下找logback-test.xml文件，如果可以找到就直接使用，如果找不到就会接着找logback.xml文件，如果还找不到就会使用自己包里边自带的配置文件，这样使用起来就非常方便了，比如我们可以把logback-test.xml和logback.xml两个文件都创建出来，在开发机上使用logback-test.xml文件，然后在往服务器部署的时候直接将其删掉就可以了！</p><h4 id="4-2-配置文件结构"><a href="#4-2-配置文件结构" class="headerlink" title="4.2 配置文件结构"></a>4.2 配置文件结构</h4><p>firewalld的配置文件结构非常简单，主要有两个文件和三个目录：<br>文件：firewalld.conf、lockdown-whitelist.xml<br>目录：zones、services、icmptypes</p><p>另外，如果使用到direct，还会有一个direct.xml文件。我们要注意，在保存默认配置的目录 <code>/usr/lib/firewalld/</code> 中只有我们这里所说的目录，而没有firewalld.conf、lockdown-whitelist.xml和direct.xml这三个文件，也就是说这三个文件只存在于 <code>/etc/firewalld/</code> 目录中。</p><h4 id="4-3-文件和目录的作用"><a href="#4-3-文件和目录的作用" class="headerlink" title="4.3 文件和目录的作用"></a>4.3 文件和目录的作用</h4><ul><li><p>irewalld.conf：firewalld的主配置文件，是键值对的格式，不过非常简单，只有五个配置项</p></li><li><p>DefaultZone：默认使用的zone，关于zone学生稍后给大家详细介绍，默认值为public；</p></li><li><p>MinimalMark： 标记的最小值，linux内核会对每个进入的数据包都进行标记，目的当然是为了对他们进行区分，前面给大家补充iptables五张表相关的内容时候介绍说符合raw表规则的数据包可以跳过一些检查，那么是怎么跳过的呢？这里其实就是使用的标记，当然对数据包的标记还有很多作用。这里所设置的 MinimalMark值就是标记的最小值，默认值为100，一般情况下我们不需要对其进行修改，但是如果我们有特殊需要的时候就可以通过对其进行修改来告诉linux所使用标记的最小值了，比如我们需要给符合某条件的数据包标记为123，这时候为了防止混淆就需要将MinimalMark设置为一个大于123的值了；</p></li><li><p>CleanupOnExit：这个配置项非常容易理解，他表示当退出firewalld后是否清除防火墙规则，默认值为yes；</p></li><li><p>Lockdown： 这个选项跟D-BUS接口操作firewalld有关，firewalld可以让别的程序通过D-BUS接口直接操作，当Lockdown设置为yes的 时候就可以通过lockdown-whitelist.xml文件来限制都有哪些程序可以对其进行操作，而当设置为no的时候就没有限制了，默认值为 no；</p></li><li><p>IPv6_rpfilter：其功能类似于rp_filter，只不过是针对ipv6版的，其作用是判断所接受到的包是否是伪造的，检查方式主要是通过路由表中的路由条目实现的，更多详细的信息大家可以搜索uRPF相关的资料，这里的默认值为yes。</p></li><li><p>lockdown-whitelist.xml：当Lockdown为yes的时候用来限制可以通过D-BUS接口操作firewalld的程序</p></li><li><p>direct.xml：通过这个文件可以直接使用防火墙的过滤规则，这对于熟悉iptables的用户来说会非常顺手，另外也对从原来的iptables到firewalld的迁移提供了一条绿色通道</p></li><li><p>zones：保存zone配置文件</p></li><li><p>services：保存service配置文件</p></li><li><p>icmptypes：保存和icmp类型相关的配置文件</p></li></ul><h3 id="5-zone"><a href="#5-zone" class="headerlink" title="5 zone"></a>5 zone</h3><p>firewalld默认提供了九个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、home.xml、internal.xml、public.xml、trusted.xml、work.xml，他们都保存在 <code>/usr/lib/firewalld/zones/</code> 目录下。这些zone之间是什么关系？他们分别适用用哪些场景呢？</p><p>防火墙就相当于一个门卫，门卫对具体某个来访的人判断是否应该放行是依靠规则来判断的，而我们这里的zone其实就是一套规则集，或者说是一套判断的方案</p><p>理解了这层含义firewalld就容易了，比如上面的九个zone其实就是九种方案，而且起决定作用的其实是每个xml文件所包含的内容，而不是文件名，所以大家不需要对每种zone（每个文件名）的含义花费过多的精力，比如trusted这个zone会信任所有的数据包，也就是说所有数据包都会放行，但是public这个zone只会放行其中所配置的服务，其他的一律不予放行，其实我们如果将这两个文件中的内容互换一下他们的规则就换过来了，也就是public这个zone会放行所有的数据包，下面我们来看一下这两个文件的内容</p><p>public.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">  &lt;short&gt;Public&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;ssh&quot;&#x2F;&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;dhcpv6-client&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>trusted.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone target&#x3D;&quot;ACCEPT&quot;&gt;</span><br><span class="line">  &lt;short&gt;Trusted&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;All network connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>我们要特别注意trusted.xml中zone的target，就是因为他设置为了ACCEPT，所以才会放行所有的数据包，而public.xml中的zone没有target属性，这样就会默认拒绝通过，所以public这个zone（这种方案）只有其中配置过的服务才可以通过。</p><h4 id="5-1-service"><a href="#5-1-service" class="headerlink" title="5.1 service"></a>5.1 service</h4><p>service是firewalld中另外一个非常重要的概念，不过其含义是非常简单的。还是拿门卫的例子来给大家做解释，在iptables的时代我们给门卫下达规则时需要告诉他“所有到22号楼的人全部予以放行”、“所有到80号楼的人全部予以放行”等等，不过到了firewalld的时代就不需要这样了，而是可以直接下达像“到销售部的全部予以放行”这样的命令，然后门卫再一查发现销售部在80号楼，那么所有到80号楼的人门卫就都会放行了。我们这里的楼牌号和端口号相对应，部门名和服务名相对应，这样大家应该就可以理解service的作用了。</p><p>从端口号改为服务名主要有两个好处：首先是使用服务名配置的语义清晰，不容易出错；其次在对某个服务的端口号进行修改的时候只需要修改相应的service文件就可以了，而不需要再修改防火墙方案——zone。这其实跟DNS将ip地址和域名关联了起来是一样的道理。下面学生再来给大家介绍一下service的配置文件。</p><p>service配置文件的命名规则是&lt;服务名&gt;.xml，比如ssh的配置文件是ssh.xml，http的配置文件是http.xml等，他们默认保存在<code>/usr/lib/firewalld/services/</code>目录下，常见的服务其中都可以找到，如果我们想修改某个服务的配置，那么可以复制一份到<code>/etc/firewalld/services/</code>目录下然后进行修改就可以了，要想恢复默认配置直接将我们自己的配置文件删除就可以了。我们来看一下ssh服务的ssh.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;short&gt;SSH&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;22&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure><p>可以看到这里配置了tcp的22号端口，所以将ssh服务配置到所使用的zone（默认public）中后tcp的22号端口就开放了。如果我们想将ssh的端口修改为222，那么只需要将ssh.xml复制一份到“<code>/firewalld/</code>services/”中，然后将端口号修改为222就可以了。当然直接修改“/usr/lib/firewalld/services/”中的配置文件也可以实现，但是强烈建议不要那么做，原因相信大家都明白。</p><p>明白原理之后使用起来就可以非常灵活了，比如我们将“<code>/etc/firewalld/</code>services/ssh.xml”文件复制一份到“<code>/etc/firewalld/</code>services/”中，然后将名字改为abc.xml，并且将abc这个服务配置到所使用的zone中，这时22端口就会开放。也就是说在zone中所配置的服务其实跟实际的服务并不存在直接联系，而是和相应配置文件中配置的内容有关系。</p><h3 id="6-配置方法"><a href="#6-配置方法" class="headerlink" title="6 配置方法"></a>6 配置方法</h3><p>firewalld的配置方法主要有三种：firewall-config、firewall-cmd和直接编辑xml文件，其中firewall-config是图形化工具，firewall-cmd是命令行工具，而对于linux来说大家应该更习惯使用命令行方式的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)Hexo博客搭建</title>
      <link href="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一-搭建GitHub-Pages"><a href="#一-搭建GitHub-Pages" class="headerlink" title="一 搭建GitHub Pages"></a>一 搭建GitHub Pages</h2><h3 id="1-注册一个GitHub账号，且登录"><a href="#1-注册一个GitHub账号，且登录" class="headerlink" title="1 注册一个GitHub账号，且登录"></a>1 注册一个GitHub账号，且登录</h3><h3 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2 创建仓库"></a>2 创建仓库</h3><p>1、点击 “NEW”</p><a id="more"></a><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_24_5DH_7B_5DR_7DU5PLM_602_7BV_29_24GMOCB.png" alt></p><p>2、填写的仓库名为”用户名.github.io”，用户名要与左边用户名一致，否则后面会报错</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7CKL_252_5DIX_25UYRE7_6K_5D16VK.png" alt></p><h3 id="3-启用Github-Pages"><a href="#3-启用Github-Pages" class="headerlink" title="3 启用Github Pages"></a>3 启用Github Pages</h3><p>1、点击”Settings”进入设置</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4FW_60V5O_7EEU_5D_DXF_7BD_7DQ_5B__G.png" alt></p><p>2、往下拉找到”GitHub Pages”,显示如图所示，即表明已经开启（一般创建完成后会默认自动开启）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_298GL_28RD@J3TIU5_5DN_24YGQUZC.png" alt></p><h3 id="4-选择主题"><a href="#4-选择主题" class="headerlink" title="4 选择主题"></a>4 选择主题</h3><p>1、点击 “Choose a theme”选择主题</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/AXQ5_5DWYAVR_5B2U3_X4KV6_5B3M.png" alt></p><p>2、任意选择一个主题，然后点击”select theme”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/DCVLHREVPA_7EZDM_V86_60C_WI.png" alt></p><h3 id="5-下载安装Node-js和Git"><a href="#5-下载安装Node-js和Git" class="headerlink" title="5 下载安装Node.js和Git"></a>5 下载安装Node.js和Git</h3><p>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/G_7B_29SB4U_5B2JZTZ_28OVV_243YXKQ.png" alt></p><p>2、安装Git和配置好Git环境</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3_28_24R8E_24Y_25D_29GX_7BCCX_24W002D.png" alt></p><h2 id="二-Hexo"><a href="#二-Hexo" class="headerlink" title="二 Hexo"></a>二 Hexo</h2><h3 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1 安装Hexo"></a>1 安装Hexo</h3><p>1、在自己认为合适的地方创建文件夹，然后在此文件夹中打开 Git命令行，即右击鼠标，选择”Git Bash here”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/R59B_29DJVG8CWW8R295GJ9_252.png" alt></p><p>2、输入 npm install -g hexo 进行安装</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/T@JPUVO_5BMOEO3E8IOLQX_29CK.png" alt></p><p>然后使用 hexo -v，出现下面界面说明安装成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/CK1_28_29ELV_5DWSZMIE1QLVOW_7EQ.png" alt></p><p>3、输入 hexo init  初始化文件夹（漫长等待<del>~</del> ）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9L_7E7EU_7E_7E2YODCLXO_250_7DTS_25K.png" alt></p><p>看到最后的”Start blogging with Hexo! “，表示成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/JN9YT_7BBQNQ5_60E_60BA89EX_T41586526832595.png" alt></p><p>4、输入 npm install，安装所需组件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SLIJWA4ITMT_25NDREFVWOITN.png" alt></p><p>5、输入 hexo g, 生成源文件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/TXXGDI6ZN_25HZM_5BQM7K@_24Z_7DI.png" alt></p><p>6、输入 hexo s,启动本地服务器，通过访问 <strong><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></strong>,正式体验 Hexo</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5D_7BH_24LAXS3ZCI_29F_7DJ1DM_7BL_28E.png" alt>\</p><p>成功界面如下所示</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/C_5BB075IG7XK_5DT0VNFR_60L1WR.png" alt></p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h3><p>1、安装主题（yilia）</p><p>使用命令</p><p>hexo clean</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>clone后面跟着的是主题的git repo地址，而themes/yilia则表示要将该主题克隆到blob/themes/yilia目录中</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/8OMPT6DL_7DD5RSCMCDNTR_5B_5DL.png" alt></p><p>2、启动主题</p><p>找到目录下的_config.yml文件，打开找到 theme:属性，并设置为 yilia</p><p>3、更新主题</p><p>好像没有用到下面这两个命令<br>cd themes/yilia<br>git pull</p><p>hexo g</p><p>hexo s</p><p>使用 localhost:4000 查新新主题</p><h2 id="三-部署到GitHub"><a href="#三-部署到GitHub" class="headerlink" title="三 部署到GitHub"></a>三 部署到GitHub</h2><h3 id="1-使用Hexo-deploy-部署到GitHub"><a href="#1-使用Hexo-deploy-部署到GitHub" class="headerlink" title="1 使用Hexo deploy 部署到GitHub"></a>1 使用Hexo deploy 部署到GitHub</h3><p>1、编辑根目录下_config.yml文件，添加如下代码（JavaSsun换成自己的用户名），并进行保存</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5_Z78JY_60M0M1KL21UV_24OH_H.png" alt></p><p>2、安装一个扩展</p><p>npm install hexo-deployer-git –save</p><h3 id="2-检查SSH-Keys设置"><a href="#2-检查SSH-Keys设置" class="headerlink" title="2 检查SSH Keys设置"></a>2 检查SSH Keys设置</h3><p>1、输入 cd ~/.ssh</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5BWC_7D_28_5BOXTZI_X_28U_5B10BQPU0.png" alt></p><p>如果没有rsa文件，输入 ssh-keygen -t rsa -C “<a href="mailto:xxxxxxx@qq.com">xxxxxxx@qq.com</a>“(自己邮箱)</p><p>2、输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/NRKM5_7EPRMR9B6TTSF2Z_28SAF.png" alt></p><p>3、再输入 ssh-add ~/.ssh/id_rsa ,添加生成的SSH Key到 ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_28_28K6H4_29IJE0N9XO716_7DXTJQ.png" alt></p><p>4 添加 SSH Key 到GitHub</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SN_1UT78G_250HN_5DJ_293T_5B6_7BLG.png" alt></p><p>5 输入 ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明添加成功了（有一个会让输入yes）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_25YT4_7D_601_601_283MW__7D_7B3_29_28_60I@A.png" alt></p><p>6 设置个人账号信息</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QV1PTZ_25XP966E3RO_7E0_7DZ_246H.png" alt></p><h3 id="3-部署到GitHub"><a href="#3-部署到GitHub" class="headerlink" title="3 部署到GitHub"></a>3 部署到GitHub</h3><p>hexo d -g</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7e9d1463-32aa-42f1-b3de-f627a98136fa.png" alt></p><h2 id="四-日常维护"><a href="#四-日常维护" class="headerlink" title="四 日常维护"></a>四 日常维护</h2><p>当部署成功后，日常只需</p><ol><li>新建文章(new)</li><li>找到生成的.md然后编辑并保存</li><li>生成博客（generate）</li><li>部署（deploy）</li></ol><p>即可完成新文章的发布</p><p>日常使用命令如下：</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/71900d3f-350a-4750-8a47-4bff361282d3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Vim_tab为4个空格</title>
      <link href="/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/"/>
      <url>/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>为了 vim 更好的支持 python写代码，修改tab默认4个空格的两种设置方法：</strong></p><ul><li><p><strong>vim /etc/vimrc</strong><br>set ts=4<br>set sw=4</p></li><li><p><strong>vim/etc/vimrc</strong><br>set ts=4<br>set expandtab<br>set autoindent</p></li></ul><p>推荐第二种，按 tab 键时产生4个空格，兼容性更好。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOs7防火墙开端口测试</title>
      <link href="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="1-防火墙"><a href="#1-防火墙" class="headerlink" title="1 防火墙"></a>1 防火墙</h2><p>CentOS7之后，无法使用 iptables控制 Linux的端口，而是换成了<strong>firewalld</strong>。</p><ul><li><strong>查看防火墙状态</strong><br>systemctl status firewalld</li></ul><a id="more"></a><ul><li><p><strong>开启防火墙</strong><br>systemctl start firewalld</p></li><li><p><strong>关闭防火墙</strong><br>systemctl stop firewalld</p></li><li><p><strong>开机启用防火墙</strong><br>systemctl enable firewalld</p></li><li><p><strong>禁止开机启动防火墙</strong><br>systemctl disable firewalld</p></li><li><p><strong>查看当前firewall状态</strong><br>firewall-cmd --state</p></li><li><p><strong>重启防火墙</strong><br>firewall-cmd --reload</p></li></ul><h2 id="2-开启端口"><a href="#2-开启端口" class="headerlink" title="2 开启端口"></a>2 开启端口</h2><ul><li><p><strong>查看那已经开放的端口</strong><br>firewall-cmd --list-ports</p></li><li><p><strong>删除指定端口</strong><br>firewall-cmd --zone=public --remove-port=80/tcp --permanent</p></li><li><p>*<em>查看已启动的服务列表 *</em><br>systemctl list-unit-files|grep enabled</p></li><li><p><strong>查看启动失败的服务列表</strong><br>systemctl --failed</p></li><li><p><strong>查看内核版本</strong><br>uname -r</p></li><li><p><strong>查看版本</strong><br>firewall-cmd --version</p></li><li><p><strong>查看所有打开的端口</strong><br>firewall-cmd --zone=public --list-ports</p></li><li><p><strong>查看区域信息</strong><br>firewall-cmd --get-active-zones</p></li><li><p><strong>查看指定接口所属区域</strong><br>firewall-cmd --get-zone-of-interface=eth0</p></li><li><p><strong>开启端口</strong><br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br>命令含义：<br>--zone 作用域<br>--add-port=80/tcp 添加端口 ，格式为：端口/通讯协议<br>--permanent 永久生效，没有此参数重启后失效</p></li></ul><p><strong>开启端口后，需要重启防火墙</strong><br>firewall-cmd --reload</p><h2 id="3-测试端口"><a href="#3-测试端口" class="headerlink" title="3 测试端口"></a>3 测试端口</h2><p>在开启的端口中启动一个服务，如 nginx 或者 可运行 jar包.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">nohup java jar -Dserver.port&#x3D;80 xxx.jar &gt; console.log 2&gt;&amp;1 &amp;</span><br><span class="line">tail -f console.log</span><br></pre></td></tr></table></figure><p><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/ac8de13d-3c1c-4959-8a85-c89d3288175f.png" alt></p><p>在 windows下 打开 cmd telnet 服务器ip 80（刚开的端口），如下界面表示端口开启成功。<br><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/d785cee1-1fc9-4afa-8358-a3ddc085eae0.png" alt></p><h2 id="4-查看端口占用"><a href="#4-查看端口占用" class="headerlink" title="4 查看端口占用"></a>4 查看端口占用</h2><p>netstat -tunlp命令——查看端口占用</p><p>t：表示查看tcp</p><p>u：表示查看udp</p><p>n：表示端口以数字形式表示，没有n直接显示服务名。</p><p>l：表示显示所监听的端口</p><p>p：表示占用端口的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep xx：xx可以是端口号、服务名称或者ip地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis所需安装包及各种依赖</title>
      <link href="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/"/>
      <url>/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>安装包在个人云盘中，还在想办法分享出来。</p><p><img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/redis-cluster.png" alt></p><a id="more"></a><p><img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/5a60af17fb059969a94b73f89dee43de.png" alt>)<img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/5338a60e2cf7cae3ce1bdfc4eedce0c1.png" alt>)<img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/284346cec5dd86104255a44561167c51.png" alt>    </p><p>安装包：</p><p>gcc.zip</p><p>java操作redis所需jar包.zip</p><p>redis cluster.zip</p><p>redis-3.2.6.tar.gz</p><p>redis-desktop-manager-0.9.3.817.exe</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习</title>
      <link href="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author:haoransun<br>Wechat:SHR—97</p><h2 id="1-Redis技术简介"><a href="#1-Redis技术简介" class="headerlink" title="1 Redis技术简介"></a>1 Redis技术简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Redis</strong> 是一个开源免费的基于内存的Key-value存储系统，它可以用作<font color="red">数据库、缓存、消息中间件</font>。它支持多种类型的数据结构，如：字符串（string）,散列（hash）,列表（list）,集合（set），有序集合（sorted set）与范围查询和地理空间（geospatial）索引半径查询等。<strong>Redis</strong>特性丰富，客户端支持现阶段流行的大多数编程语音。</p><a id="more"></a><h3 id="1-1-Redis的特点"><a href="#1-1-Redis的特点" class="headerlink" title="1.1 Redis的特点"></a>1.1 Redis的特点</h3><ol><li><strong>Redis</strong>是一个高性能的key/value<strong>内存型</strong>数据库</li><li><strong>Redis</strong>数据类型丰富（string list set zset hash等）</li><li><strong>Redis</strong>支持数据持久化（AOF和RDB两种持久化方式）</li><li><strong>Redis</strong>读写性能优异，单线程运行效率高。</li></ol><h3 id="1-2-Redis的安装"><a href="#1-2-Redis的安装" class="headerlink" title="1.2 Redis的安装"></a>1.2 Redis的安装</h3><ol><li>准备环境<br>1.1  VMware11<br>1.2  CentOS6.5<br>1.3  安装Redis依赖gcc(64位）<br>&nbsp;rpm -Uvh<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-common-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;libgcc-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;tzdata-2018e-3.el6.noarch.rpm<br>&nbsp;rpm -ivh<br>&nbsp;&nbsp;&nbsp;&nbsp;cloog-ppl-0.15.7-1.2.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;cpp-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;libgomp-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;mpfr-2.4.1-6.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;ppl-0.10.2-11.el6.x86_64.rpm<br>&nbsp;rpm -ivh<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc-4.4.7-18.el6_9.2.x86_64.rpm</li><li>下载Redis<br>wget <a href="http://download.redis.io/releases/redis-3.2.8.tar.gz" target="_blank" rel="noopener"><u>http://download.redis.io/releases/redis-3.2.8.tar.gz</u></a></li><li>安装<br>&nbsp;&nbsp;解压<br>&nbsp;&nbsp;tar -zxvf redis-3.2.8.tar.gz<br>&nbsp;&nbsp;移动解压文件<br>&nbsp;&nbsp;mv redis-3.2.8 /usr/local/<br>&nbsp;&nbsp;编译<br>&nbsp;&nbsp;cd /usr/local/redis-3.2.8/<br>&nbsp;&nbsp;make<br>&nbsp;&nbsp;安装<br>&nbsp;&nbsp;make PREFIX=/usr/local/redis install<br>&nbsp;&nbsp;安装目录文件图解<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6C64.tmp.jpg" alt><br>&nbsp;&nbsp;启动<br>&nbsp;&nbsp; cp /usr/local/redis-3.2.8/redis.conf /usr/local/redis/<br>&nbsp;&nbsp; ./bin/redis-server redis.conf<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD1DD.tmp.jpg" alt><br>&nbsp;&nbsp; 使用客户端连接<br>&nbsp;&nbsp; 本机换用不用加 ip 和 port<br>&nbsp;&nbsp; ./bin/redis-cli [-h ipaddr] [-p port]<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3D50.tmp.jpg" alt><br>&nbsp;&nbsp; 配置redis服务端以后台守护进程运行<br>&nbsp;&nbsp; 修改redis.conf配置文件<br>&nbsp;&nbsp; <font color="red"> daemonize yes</font><h2 id="2-Redis-基本操作"><a href="#2-Redis-基本操作" class="headerlink" title="2 Redis 基本操作"></a>2 Redis 基本操作</h2><h3 id="2-1-Redis中常用的与数据库有关的指令"><a href="#2-1-Redis中常用的与数据库有关的指令" class="headerlink" title="2.1 Redis中常用的与数据库有关的指令"></a>2.1 Redis中常用的与数据库有关的指令</h3><font color="red">注意：Redis默认会存在16个数据库,编号从0-15，默认使用0号库</font><br>&nbsp;&nbsp;&nbsp; 1. 选择数据库: select index[0-15]<br>&nbsp;&nbsp;&nbsp; 2. 数据库操作<br>&nbsp;&nbsp;&nbsp; 清空当前数据库数据 flushdb<br>&nbsp;&nbsp;&nbsp; 清空所有数据库数据 flushall<h3 id="2-2-Redis对于key的操作命令"><a href="#2-2-Redis对于key的操作命令" class="headerlink" title="2.2 Redis对于key的操作命令"></a>2.2 Redis对于key的操作命令</h3><ol><li>del key1 key2 …keyn<br>作用：删除1个或多个键<br>返回值：不存在的key忽略掉，返回真正删除的key的数量</li><li>rename key newkey<br>作用：给key赋一个新的key名<br>注意：如果newkey已存在，则newkey的原值会被覆盖</li><li>move key db<br>作用：移动key到指定的数据库<br>返回值：移动成功返回1，失败返回0</li><li>keys pattern<br>作用：查找所有符合给定模式pattern的key<br>keys * 匹配数据库中所有key<br>keys h?llo 占位匹配符合条件一个字符key,如：hello、hallo、hxllo等<br>keys h*llo 通配匹配一个或多个字符key,如：hllo heeeello等。<br>keys h[ae]llo 选择匹配一个或多个字符key,如：hello hallo等<br>特殊符号：用 \ 隔开<br>返回值：符合条件的key列表</li><li>random key<br>作用：返回随机key<br>返回值：数据库为空返回nil,不为空返回key名</li><li>exists key<br>作用：判断key是否存在<br>返回值：存在返回1，不存在返回0</li><li>type key<br>作用：返回key存储的值类型<br>返回值：string list set zset hash</li><li>ttl key<br>作用：查询key的生命周期<br>返回值：<br>当key不存在时，返回-2<br>没有设置剩余生存时间时，返回-1<br>否则，以秒为单位，返回key的剩余生存时间</li><li>expire key<br>作用：设置key的生命周期，以秒为单位<br>返回值：<br>如果生存时间设置成功，返回1<br>当key不存在或者没办法设置生存时间，返回0<br>同理：<br>pexpire key 毫秒数，设置生命周期<br>pttl key, 以毫秒为单位返回生命周期</li><li>persist key<br>作用：把指定key置为永久有效<h2 id="3-Redis数据类型操作"><a href="#3-Redis数据类型操作" class="headerlink" title="3 Redis数据类型操作"></a>3 Redis数据类型操作</h2><h3 id="3-1-string类型操作"><a href="#3-1-string类型操作" class="headerlink" title="3.1 string类型操作"></a>3.1 string类型操作</h3></li></ol></li></ol><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| set  | 设置一个key/value  |<br>| get  | 根据key获得对应的value  |<br>| mset  | 一次设置多个key value  |<br>| mget  | 一次获得多个key的value  |<br>| getset  | 获得原始key的值，同时设置新值  |<br>| strlen  | 获得对应key存储value的长度  |<br>| append  | 为对应key的value追加内容  |<br>| getrange  |截取value的内容   |<br>| setex  | 设置一个key存活的有效期（秒）  |<br>| psetex  |设置一个key存活的有效期（毫秒）  |<br>| setnx  | 存在不做任何操作，不存在则添加  |<br>| msetnx  |同时设置多个key,只要有一个存在则都不保存   |<br>| decr  | 进行数值类型的-1操作  |<br>| decrby  |根据提供的数据进行减法操作   |<br>| incr  | 进行数值类型的+1操作  |<br>| incrby  |根据提供的数据进行加法操作   |<br>| incrbyfloat  |根据提供的数据加入浮点数   |</p><h3 id="3-2-list类型的操作"><a href="#3-2-list类型的操作" class="headerlink" title="3.2 list类型的操作"></a>3.2 list类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps455C.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| lpush  | 将某个值加入到一个key列表头部  |<br>| lpushx  | 同lpush，但是必须保证key存在  |<br>| rpush  | 将某个值加入到一个key列表末尾  |<br>| rpushx  |同rpush，但是必须保证key存在  |<br>| lpop  | 返回和移除列表的第一个元素  |<br>| rpop  | 返回和移除列表的最后一个元素  |<br>| lrange  | 获取某一个下标区间内的元素  |<br>| llen  |获取列表元素个数  |<br>| lset  | 设置某一个指定索引的值（索引必须存在）  |<br>| lindex  |获取某一个指定索引位置的元素 |<br>| lrem | 删除重复元素  |<br>| ltrim  |保留列表中特定区间内的元素   |<br>| linsert | 在某一个元素之前，之后插入新元素 |</p><h3 id="3-3-set类型的操作"><a href="#3-3-set类型的操作" class="headerlink" title="3.3 set类型的操作"></a>3.3 set类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD626.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| sadd  | 为集合添加元素  |<br>| smembers  | 显示集合中所有元素（无序）  |<br>| scard  | 返回集合中元素的个数  |<br>| spop  | 随机返回一个元素 |<br>| smove  | 从一个集合中向另一个集合移动元素  |<br>| srem  | 从集合中删除一个元素  |<br>| sismember  | 判断一个集合中是否含有这个元素  |<br>| srandmember  |随机返回元素 |<br>| sdiff  | 去掉第一个集合中其他集合含有相同的元素  （求差集）|<br>| sinter  |求交集 |<br>| sunion | 求和集  |</p><h3 id="3-4-zset类型的操作"><a href="#3-4-zset类型的操作" class="headerlink" title="3.4 zset类型的操作"></a>3.4 zset类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1877.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| zadd  | 添加一个元素至有序集合中 |<br>| zcard  | 返回有序集合中元素的个数  |<br>| zrange  | 随机返回一个范围内的元素 |<br>| zrangebyscore  | 按照分数查找一个范围内的元素  |<br>| zrank  | 返回排名 |<br>| zrevrank  | 倒序排名  |<br>| zscore  |返回某一个元素的分数 |<br>| zrem  | 移除某一个元素|<br>| zincrby  |给某个特定元素加分 |</p><h3 id="3-5-hash类型的操作"><a href="#3-5-hash类型的操作" class="headerlink" title="3.5 hash类型的操作"></a>3.5 hash类型的操作</h3><p>图示： <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsCB8D.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| hset  | 设置一个key/value对  |<br>| hget  | 获得一个key对应的value  |<br>| hgetall  | 获得所有key/value对 |<br>| hdel  | 删除某一个key/value对 |<br>| hexists  | 判断一个key是否存在  |<br>| hkeys  | 获得所有的key  |<br>| hvals  | 获得所有的value  |<br>| hmset  |设置多个key/value |<br>| hmget  | 获得多个key的value|<br>| hsetnx  |设置一个不存在的key的值 |<br>| hincrby | 为value进行加法运算  |<br>| hincrbyfloat | 为value加入浮点值  |</p><h2 id="4-Java-API操作Redis"><a href="#4-Java-API操作Redis" class="headerlink" title="4 Java API操作Redis"></a>4 Java API操作Redis</h2><h3 id="4-1-使用方法"><a href="#4-1-使用方法" class="headerlink" title="4.1 使用方法"></a>4.1 使用方法</h3><ol><li>导入jar包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps68E0.tmp.jpg" alt></li><li>测试</li></ol><ul><li>测试连接redis<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试redis连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 创建jedis连接池配置对象</span></span><br><span class="line">    JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">//最小空闲数</span></span><br><span class="line">    jpc.setMinIdle(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//最大空闲数</span></span><br><span class="line">    jpc.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    jpc.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大等待时间</span></span><br><span class="line">    jpc.setMaxWaitMillis(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//创建连接池</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jpc,<span class="string">"192.168.0.0"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试结果：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1593.tmp.jpg" alt><br><font color="red">注意：出现此异常，是因为redis服务端默认只允许127.0.0.1连接，如何允许其他网络地址访问服务端呢？只需修改redis.conf配置文件</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps10B8.tmp.jpg" alt></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">JedisTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 测试redis连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建jedis连接池配置对象</span></span><br><span class="line">    JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">//最小空闲数</span></span><br><span class="line">    jpc.setMinIdle(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//最大空闲数</span></span><br><span class="line">    jpc.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    jpc.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大等待时间</span></span><br><span class="line">    jpc.setMaxWaitMillis(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//创建连接池</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jpc,<span class="string">"192.168.0.0"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试Redis 基本相关操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBasicAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//选择数据库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取所有key集合</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str:keys)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空数据库</span></span><br><span class="line">        <span class="comment">//jedis.flushDB();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//存放string类型的key/value</span></span><br><span class="line">        jedis.set(<span class="string">"age"</span>,<span class="string">"18"</span>);</span><br><span class="line">        </span><br><span class="line">        jedis.append(<span class="string">"age"</span>,<span class="string">"岁"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key的value</span></span><br><span class="line">        String value = jedis.get(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"> <strong>Redis的相关命令，对应Jedis中的方法。使用时需要什么命令，调用Jedis对应方法即可</strong></font></p><h2 id="5-Redis持久化机制"><a href="#5-Redis持久化机制" class="headerlink" title="5 Redis持久化机制"></a>5 Redis持久化机制</h2><p><strong>说明：Redis提供了两种不同的持久化方法来将数据存储到硬盘里面</strong></p><ol><li><font color="red">快照（snapshotting）快照文件</font><br>这种方式可以将某一时刻的所有数据都写入硬盘中，当然这也是redis的默认持久化方式，<br>保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB快照文件持久化方式.</li><li><font color="red">AOF（append only file）追加文件</font><br>这种方式可以将所有客户端执行的写命令记录到日志文件中，保存的日志文件以.aof结尾<h3 id="5-1-RDB快照持久化"><a href="#5-1-RDB快照持久化" class="headerlink" title="5.1 RDB快照持久化"></a>5.1 RDB快照持久化</h3></li></ol><ul><li>快照持久化也是redis中的默认开启的持久化方案，根据redis.conf中的配置，快照将被写入dbfilename指定的文件里面(默认写入到名为dump.rdb文件中)<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps37C1.tmp.jpg" alt></li><li>指定dump.rdb快照文件的保存目录（默认保存在配置文件所属目录，aof日志文件默认也保存在此目录）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps232B.tmp.jpg" alt></li><li>RDB持久化原理<br>每隔<font color="red">几分钟</font>或者<font color="red">N次写</font>操作后，将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。压缩放在备份目录。当因为宕机或者断电等原因造成redis内存数据丢失时，再将rdb快照文件中保存数据载入到内存中。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps9CCC.tmp.jpg" alt></li><li>RDB持久化触发时机<ol><li>手动触发（客户端命令bgsave或者save）<br>save命令（不推荐使用）：save操作是在主线程中保存快照，由于redis是用一个主线程来处理所有客户端请求，这种方式会阻塞所有客户端请求。<br>bgsave命令：当接收到客户端的bgsave命令时，redis会调用fork来创建一个子进程，父进程继续处理client请求，子进程负责将内存内容写入到临时文件。 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li><li>自动触发<br>触发条件：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps2685.tmp.jpg" alt><br>执行机制：<br><font color="red">如果用户在redis.conf中设置了save配置选项，redis会在save选项条件满足之后自动触发一次bgsave命令，如果设置多个save配置选，当任意一个save配置选项条件满足,redis也会触发一次bgsave命令</font><table><tr><td bgcolor="#7FFFD4">注意：每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步脏数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。</td></tr></table>缺点由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof持久化方式。### 5.2 AOF追加日志持久化</li></ol></li><li>AOF持久化机制默认没有开启，<table><tr><td bgcolor="red">使用aof持久化方式时，redis会将每一个收到的写命令都通过write函数追加到文件中(默认是appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</td></tr></table></li><li>原理图：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA7CF.tmp.jpg" alt></li></ul><ol><li><p>开启AOF持久化机制，需要修改redis.conf的配置文件</p><ol><li>通过修改redis.conf配置中appendonly yes来开启AOF持久化</li><li>通过appendfilename指定日志文件名字(默认为:appendonly.aof)</li><li>通过appendfsync指定日志记录频率</li></ol></li><li><p>AOF日志记录频率的选项<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps28AE.tmp.jpg" alt></p></li><li><p>AOF日志文件重写<br>aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写机制。</p><ol><li><font color="red">aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里</font></li><li>手动重写aof文件     客户端执行命令bgrewriteaof</li><li>自动重写aof文件     配置redis.conf<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5BD6.tmp.jpg" alt></li><li>AOF日志文件重写原理<br>redis调用fork，创建子进程。子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令。 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。<br>注意：<font color="red">重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</font></li><li>常见问题<br>问：恢复时rdb和aof哪个恢复数据快<br>答：rdb快，因为其是数据的内存映射二进制文件，直接载入到内存，而aof    是命令，需要逐条执行<br>问：如果rdb文件，和aof文件都存在，优先用谁来恢复数据<br>答：aof<br>问：在dump rdb过程中，aof如果停止同步，会不会丢失数据<br>答：会，所有的操作缓存在内存的队列里， dump完成后，统一操作。</li></ol><h2 id="6-Redis-应用"><a href="#6-Redis-应用" class="headerlink" title="6. Redis 应用"></a>6. Redis 应用</h2><h3 id="6-1-使用Redis作为Cache-以Mybatis-二级缓存为例"><a href="#6-1-使用Redis作为Cache-以Mybatis-二级缓存为例" class="headerlink" title="6.1 使用Redis作为Cache(以Mybatis 二级缓存为例)"></a>6.1 使用Redis作为Cache(以Mybatis 二级缓存为例)</h3><p>在Mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。Mybatis的缓存分为了一级缓存和二级缓存，一级缓存的生命周期和SqlSession相同。二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，也可配置如encache等的第三方缓存。<br><font color="red">原理：缓存结构为key value格式存储，符合redis存储数据特征，并且mybatis提供了Cache接口，我们只需要自定义缓存类实现Cache接口，并将缓存结果保存在redis中即可。</font></p><ol><li>导包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5B39.tmp.jpg" alt></li><li>自定义cache类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span> 使用redis作为mybatis缓存管理</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readwriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCache</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cache instance require an ID"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在进行 insert update delete 时需要清空缓存</span></span><br><span class="line">        getRedis.flushDB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存对象的唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存对象中获取key对应的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] value = getRedis().get(</span><br><span class="line">            SerializationUtils.serialize((Serializable)key);</span><br><span class="line">            <span class="comment">//反序列化 返回的value</span></span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> SerializationUtils.deserialize(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A ReaderWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReaderWriteLock <span class="title">getReaderWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> readerWriteLock;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存对象中存储的键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">geSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取redis中key、value数。返回Long的结果，需转换为int类型返回</span></span><br><span class="line">        Long size = <span class="keyword">new</span> Long(getRedis().dbSize());</span><br><span class="line">        <span class="keyword">return</span> size.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存key/value到缓存对象中 key可以是任意对，但一般是CacheKey对象 value是查询结果，为List类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//序列化存储key，value为byte[],并保存在redis中</span></span><br><span class="line">        getRedis().set(SerializationUtils.serialize((Serializable)key,</span><br><span class="line">            SerializationUtils.serialize((Serializable)value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试<br>a) 需要在xxxMapper.xml中开启缓存<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps89BB.tmp.jpg" alt><br>b) 测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试redis缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCacheTest</span></span>&#123;</span><br><span class="line">    SqlSession session = nul;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span>throw IOException</span>&#123;</span><br><span class="line">        InputStream is = Resource.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        SqlSessionFactory ssf = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        session = ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查一个 新增一条缓存到redis中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = userDao.findUserById(id);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查所有，新增一条记录到redis中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisCache1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; users = userDao.findUser();</span><br><span class="line">        <span class="keyword">for</span>(User user:users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试新增动作 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlushRedisDB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"张三丰"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 二级缓存（2）**<br>导入相关jar包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6F1F.tmp.jpg" alt><br>Mybatis与redis整合时所需要的配置文件<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD4C0.tmp.jpg" alt><br>在mybatis的mapper文件中设置缓存服务器<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps43F5.tmp.jpg" alt></p><h3 id="6-2-使用Redis管理HttpSession"><a href="#6-2-使用Redis管理HttpSession" class="headerlink" title="6.2 使用Redis管理HttpSession"></a>6.2 使用Redis管理HttpSession</h3><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6748.tmp.jpg" alt><br>使用负载均衡服务器Nginx，Nginx配置为non-sticky运行模式，请求会随机的分配到Tomcat集群中某一节点，且每台Tomcat的Session会话都保存到Redis数据库中.</p><ol><li>准备环境（准备两台tomcat，版本需为6.0.xx，修改server.xml端口号，保证两台tomcat同时启动端口号不占用）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1519.tmp.jpg" alt></li><li>将所需jar包分别导入到tomcat的lib目录<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8CBB.tmp.jpg" alt></li><li>配置（分别在每台tomcat的context.xml中加入如下配置）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps92F.tmp.jpg" alt></li><li>修改页面（分别修改tomcat1\webapps\ROOT目录的index.jsp页面）<br>Tomcat1如下：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsE121.tmp.jpg" alt><br>Tomcat2如下：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3ACB.tmp.jpg" alt></li><li>测试<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA917.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsCCEC.tmp.jpg" alt></li></ol><h2 id="7-Redis事务"><a href="#7-Redis事务" class="headerlink" title="7 Redis事务"></a>7 Redis事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>2 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>3 一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8CD0.tmp.jpg" alt><br>从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF426.tmp.jpg" alt><br>先输入MULTI最后输入EXEC表示中间的命令属于一个事务，不同的是中间输入的命令有一个错误(set写成了sett)，这样因为有一个错误的命令导致事务中的其他命令都不执行了(通过后续的get命令可以验证)。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5B8C.tmp.jpg" alt><br>语法本身没错，但适用对象有问题。比如sadd 操作string类型，Exec之后，会执行正确的语句，并跳过有不适当的语句。这个问题是调用了错误的类型，由程序员负责。</li></ul></li></ol><ul><li>watch命令（乐观锁）<br><font color="red">Redis的事务中，启用的是乐观锁，只负责监控key是否被改动。如果改动回滚事务，<br>  未改动提交事务。</font></li><li>unwatch<br>取消 WATCH 命令对所有 key 的监视。</li></ul><h2 id="8-Redis发布订阅"><a href="#8-Redis发布订阅" class="headerlink" title="8.Redis发布订阅"></a>8.Redis发布订阅</h2><p><font color="red">Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis作为一个pub/sub server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道(channel)。当发布者通过publish命令向redis server发送特定类型的消息时。订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的。一个client可以订阅多个 channel,也可以向多个channel发送消息。</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1BA7.tmp.jpg" alt><br>工作流程如上图：当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端。</p><ol><li>相关命令</li></ol><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| subscribe  | 订阅给定的一个或多个频道的信息  |<br>| publish  | 将信息 message 发送到指定的频道 channel  |<br>| psubscribe  | 订阅一个或多个符合给定模式的频道|<br>| punsubscribe  | 退订所有给定模式的频道 |<br>| unsubscribe  | 指退订给定的频道  |<br>| pubsub  | 查看订阅与发布系统状态  |</p><ul><li>订阅频道<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8E44.tmp.jpg" alt></li><li>消息发布<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3D90.tmp.jpg" alt></li><li>模糊订阅<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB060.tmp.jpg" alt></li></ul><h2 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9. Redis集群"></a>9. Redis集群</h2><h3 id="9-1-Redis主从复制集群"><a href="#9-1-Redis主从复制集群" class="headerlink" title="9.1 Redis主从复制集群"></a>9.1 Redis主从复制集群</h3><p>一般来说，要将Redis运用于工程项目中，使用一台Redis是万万不能的，原因如下：</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>考虑如下一种场景：<br>电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是“多读少写”。对于这种场景，我们可以使如下这种架构：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps41C5.tmp.jpg" alt></li></ol><p>如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p><ol><li>读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量。</li><li>解决单节点故障问题，数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。<br><font color="red"> 在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</font></li></ol><ul><li>Redis 主从环境搭建<br>配置：Redis主从复制架构，主数据库不需要做任何配置，只需要在从数据库配置文件中加入以下命令<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA44F.tmp.jpg" alt></li><li>测试<br>分别启动主数据库master 、从数据库slave<br>./bin/redis-server 6379.conf<br>./bin/redis-server 6380.conf</li></ul><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5792.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB8ED.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF480.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps23CE.tmp.jpg" alt><br><font color="red">注意：默认从数据库是只读的，如果在从数据库写数据会报错，可以修改配置允许从数据库写数据，不建议从数据库设置为可写</font></p><ul><li>原理<br>当一个从数据库启动时，会向主数据库发送SYNC命令，主数据库收到命令后会开始在后台保存快照（即RDB持久化过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和缓存的命令发给从数据库，从数据库收到数据后，会载入快照文件并执行缓存的命令。以上过程称为<font color="red">复制初始化。</font>复制初始化之结束后，主数据库每收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致，这一过程称为<font color="red">复制同步阶段</font>。</li></ul><h3 id="9-2-Redis集群Cluster"><a href="#9-2-Redis集群Cluster" class="headerlink" title="9.2 Redis集群Cluster"></a>9.2 Redis集群Cluster</h3><ol><li>Redis集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis内存K/V服务。redis的集群支持节点的自动发现、支持slave-master选举、集群容错、支持在线分片、集群管理等特性。</li><li>Redis cluster架构<br>a) redis-cluster架构图<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6EF3.tmp.png" alt><br>架构细节:<br>(1) 所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。<br>(2) 节点的fail是通过集群中超过半数的master节点检测失效时才生效。    客户端与redis节点直连，不需要中间proxy层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。<br>(3) redis-cluster把所有的物理节点映射到[0-16383]slot上，cluster 负责维护node&lt;-&gt;slot&lt;-&gt;key<br>b) redis-cluster选举和容错<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps42D9.tmp.png" alt><br>(1) 领着选举过程是集群中所有master参与，如果半数以上master节点与故障节点通信超过(cluster-node-timeout)，认为该节点故障，自动触发故障转移操作。<br>(2) 什么时候整个集群不可用(cluster_state:fail)?<br>如果集群任意master挂掉，且当前master没有slave。集群进入fail状态，也可以理解成集群的slot映射[0-16383]不完成时进入fail状态。Ps： redis-3.0.0.rc1加入cluster-require-full-coverage参数，默认关闭，打开集群兼容部分失败。<br>如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态。<br>当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误。</li><li>Redis的cluster搭建<br>a) 集群需要安装ruby环境<br>  aa) 互联网安装<pre><code>yum install -y ruby rubygemsgem install redis</code></pre>  bb) 本地安装<br>  1）上传ruby安装文件<br>  <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsEBDD.tmp.jpg" alt><br>  2）安装<br>  cd ruby-64<br>  rpm -ivh *<br>  cd rubygems-64<br>  rpm -ivh *<br>  cd redisgems<br>  gem install redis<br>  b) redis环境搭建<br>  注：redis服务端在启动时，需要指定一个redis.conf，表示一个进程，所以可以在     同一台主机上模拟出多个redis进程（也可以使用多台主机搭建环境）<br>   aa) 创建文件夹<br>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB45A.tmp.jpg" alt><br>   bb) 每个文件夹中都复制一份redis.conf，如：<br>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps241C.tmp.jpg" alt><br>   cc) 修改每一个redis.conf配置文件，如：</li></ol><p>vi  6380.conf</p><p>修改：<br>port 6380      //修改每个配置文件端口号，如6380、6381…<br>daemonize yes  //后台守护进程启动<br>cluster-enabled  yes                 //开启集群模式<br>cluster-config-file  nodes.conf     //集群节点配置文件<br>cluster-node-timeout  5000          //集群节点超时时间<br>appendonly  yes                   //开启AOF持久化</p><p>c)redis集群配置<br>     aa) 分别启动redis server  (6380、6381、6382、6383、6384、6385、6386)<br>        cd 6380<br>        ../bin/redis-server 6380.conf<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps43F6.tmp.jpg" alt><br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6A3C.tmp.jpg" alt><br>     bb) 创建集群<br>     cd /usr/local/redis-3.2.8/src<br>     ./redis-trib.rb create –replicas 1 192.168.128.133:6380 192.168.128.133:6381 192.168.128.133:6382 192.168.128.133:6383         192.168.128.133:6384 192.168.128.133:6385<br>     <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps68B2.tmp.jpg" alt><br>     cc) 集群基本操作<br>      1）客户端访问集群<br>      ./bin/redis-cli -c -h 192.168.128.133 -p 6384</p><p>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6226.tmp.jpg" alt><br>      2）查看集群节点状态<br>      ./redis-trib.rb check 192.168.128.133:6382</p><p>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF8F8.tmp.jpg" alt><br>      3）节点状态说明<br>      <font color="red"><br>          主节点:<br>        1、主节点存在hash slots,且主节点的hash slots 没有交叉<br>        2、主节点不能删除<br>        3、一个主节点可以有多个从节点<br>        4、主节点宕机时多个副本之间自动选举主节点<br>        从节点：<br>        1、从节点没有hash slots<br>        2、从节点可以删除<br>        3、从节点不负责数据的写,只负责数据的同步<br>    </font><br>  4）集群节点操作</p><ol><li>集群中添加一个主节点<br> 命令：<font color="red">启动一台 redis server</font><br> ../bin/redis-server 6386.conf</li></ol><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps73F2.tmp.jpg" alt></p><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA786.tmp.jpg" alt><br><font color="red">将新启动的redis server加入到集群中</font><br>./redis-trib.rb add-node 192.168.128.133:6386 192.168.128.133:6381<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps524E.tmp.jpg" alt><br><font color="red">查看新加入集群的主节点信息</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps9867.tmp.jpg" alt><br> 注意：<br>1、 该节点必须以集群模式启动<br>2、 默认情况下该节点就是以master节点形式添加，但是该节点没有hashslots。<br>2. 集群中添加一个从节点<br>     命令：<br>    <font color="red">启动一台redis server</font><br>    ../bin/redis-server 6387.conf<br>    <font color="red">将新启动的redis server加入到集群中</font><br>    ./redis-trib.rb add-node –slave 192.168.128.133:6387   192.168.128.133:6381<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8E6B.tmp.jpg" alt><br>     注意：<br>    当添加副本节点时没有指定主节点，redis会随机给副本节点较少的主节点添加当前从节点。<br>3. 为指定主节点添加从节点<br>    命令：<br>    ./redis-trib.rb add-node –slave –master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 192.168.128.133:6387 192.168.128.133:6381<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsAD88.tmp.jpg" alt><br>4. 删除从节点<br>    命令：<br>    ./redis-trib.rb del-node 192.168.128.133:6387 4c5744d8f6c784cd4589149a8ce5f49dd22b86c5<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps4F38.tmp.jpg" alt><br>5. 主节点从新分片（为新加入主节点重新分配哈希槽）<br>    命令：<br>     ./redis-trib.rb reshard 192.168.128.133:6381<br>     <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF676.tmp.jpg" alt><br>注意：<br>1、需指定移动哈希槽数量<br>2、需指定接收哈希槽主节点id<br>3、需指定源节点id，确定完成后，输入all或者done完成重新分片。</p><ol start="6"><li>Java程序操作redis集群<br> a) 测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *集群环境测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tetCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> Hashset&lt;HostAndPort&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6381</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6382</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6383</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6384</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6385</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6387</span>));</span><br><span class="line">        JedisCluster cluster = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            cluster.set(<span class="string">"aa"</span>+i,<span class="string">"bb"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        String value = cluster.get(<span class="string">"aa66"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 测试结果<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8967.tmp.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK三剑客</title>
      <link href="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/"/>
      <url>/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">转载出处</a></p><h2 id="1-awk简介"><a href="#1-awk简介" class="headerlink" title="1 awk简介"></a>1 awk简介</h2><p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><p>awk 是一种很棒的语言，它适合<strong>文本处理和报表生成</strong>，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。</p><a id="more"></a><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2 使用方法"></a>2 使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125;</span><br></pre></td></tr></table></figure><p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p><p>awk语言的最基本功能是<strong>在文件或者字符串中基于指定规则浏览和抽取信息</strong>，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p><p>通常，<strong>awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本</strong>。</p><h2 id="3-awk-的原理"><a href="#3-awk-的原理" class="headerlink" title="3 awk 的原理"></a>3 awk 的原理</h2><p>通过一个简短的命令，我们来了解其工作原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin</span><br><span class="line">.....................................................</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo hhh|awk &#39;&#123;print &quot;hello,world&quot;&#125;&#39;</span><br><span class="line">hello,world</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# awk &#39;&#123;print &quot;hiya&quot;&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">...............................................</span><br></pre></td></tr></table></figure><p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p><p>所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。</p><p>解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p><p><strong><font color="red">再次说明， awk 对输入文件中的每一行都执行这个脚本。</font></strong></p><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126222420597-662074402.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &quot; &quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print &quot;username: &quot; $1 &quot;\t\tuid:&quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>-F 参数：指定分隔符，可指定一个或多个</p><p>print 后面做字符串的拼接</p><h2 id="4-实战了解awk工作原理"><a href="#4-实战了解awk工作原理" class="headerlink" title="4 实战了解awk工作原理"></a>4 实战了解awk工作原理</h2><h3 id="4-1-实例一：只查看test-txt文件（100行）内第20到第30行的内容"><a href="#4-1-实例一：只查看test-txt文件（100行）内第20到第30行的内容" class="headerlink" title="4.1 实例一：只查看test.txt文件（100行）内第20到第30行的内容"></a>4.1 实例一：只查看test.txt文件（100行）内第20到第30行的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;if (NR&gt;&#x3D;20 &amp;&amp; NR&lt;&#x3D;30) print $1&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/3c5bee5c-ab0c-4985-ac20-b4a6c0dcc752.png" alt></p><h3 id="4-2-实例二：已知test-txt文件内容为："><a href="#4-2-实例二：已知test-txt文件内容为：" class="headerlink" title="4.2 实例二：已知test.txt文件内容为："></a>4.2 实例二：已知test.txt文件内容为：</h3><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ae59ac8d-9292-48e9-b271-8f715ae6f106.png" alt></p><p>请从该文件中过滤出’Poe’字符串与xxxx，最后输出的结果为：Poe xxxx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F &#39;[ ,]+&#39; &#39;&#123;print $3 &quot; &quot; $7&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/27ee340d-594c-4956-8d2b-e68b4fdae633.png" alt></p><h2 id="5-BEGIN-和-END-模块"><a href="#5-BEGIN-和-END-模块" class="headerlink" title="5 BEGIN 和 END 模块"></a>5 BEGIN 和 END 模块</h2><p>通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许定义一个 BEGIN 块。</p><p>因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p><p>awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p><h3 id="5-1-实例一：统计-etc-passwd的账户人数"><a href="#5-1-实例一：统计-etc-passwd的账户人数" class="headerlink" title="5.1 实例一：统计/etc/passwd的账户人数"></a>5.1 实例一：统计/etc/passwd的账户人数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/41d660b8-756b-45f5-bd17-fba6f535aa99.png" alt></p><p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;count&#x3D;0;print &quot;[start] user count is &quot;,count&#125; &#123;count&#x3D;count+1;print $0&#125; END&#123;print &quot;[end] user count is&quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a5855665-c30a-42a4-9d90-75c1eae79a7c.png" alt></p><h3 id="5-2实例二：统计某个文件夹下的文件占用的字节数"><a href="#5-2实例二：统计某个文件夹下的文件占用的字节数" class="headerlink" title="5.2实例二：统计某个文件夹下的文件占用的字节数"></a>5.2实例二：统计某个文件夹下的文件占用的字节数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/b3fd5eaa-5af4-4a4e-82c4-1456c99aec5e.png" alt></p><p>如果以M为单位显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#x2F;1024&#x2F;1024,&quot;M&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/5ece48af-16b1-491a-b0e3-fc2e698a7242.png" alt></p><h2 id="6-awk运算符"><a href="#6-awk运算符" class="headerlink" title="6 awk运算符"></a>6 awk运算符</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126224150269-207487187.jpg" alt></p><h3 id="6-1-awk-赋值运算符"><a href="#6-1-awk-赋值运算符" class="headerlink" title="6.1 awk 赋值运算符"></a>6.1 awk 赋值运算符</h3><p>awk 赋值运算符：a+=5;等价于： a=a+5;其他同类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;5;a+&#x3D;5;print a&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/9e725b31-125a-4837-9e11-8d8d4806566f.png" alt></p><h3 id="6-2-awk逻辑运算符："><a href="#6-2-awk逻辑运算符：" class="headerlink" title="6.2 awk逻辑运算符："></a>6.2 awk逻辑运算符：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;1;b&#x3D;2;print(a&gt;2 &amp;&amp; b&gt;1,a&#x3D;1||b&gt;1)&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ff0172a3-07e4-4b77-bcb6-23bb947fa0b6.png" alt></p><h3 id="6-3-awk正则运算符："><a href="#6-3-awk正则运算符：" class="headerlink" title="6.3 awk正则运算符："></a>6.3 awk正则运算符：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;;if(a~&#x2F;100&#x2F;)&#123;print &quot;ok&quot;&#125;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo | awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;&#125; a~&#x2F;test&#x2F;&#123;print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8c085f3b-6749-4097-a370-3c4a43cae515.png" alt></p><h3 id="6-4-关系运算符："><a href="#6-4-关系运算符：" class="headerlink" title="6.4 关系运算符："></a>6.4 关系运算符：</h3><p>如： &gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;11&quot;;if(a&gt;&#x3D;9)&#123;print &quot;ok&quot;&#125;&#125;&#39; #无输出</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;11;if(a&gt;&#x3D;9)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a;if(a&gt;&#x3D;b)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/11e24ac8-1bde-4456-9c4c-4453b2688bd4.png" alt></p><h3 id="6-5-awk-算术运算符："><a href="#6-5-awk-算术运算符：" class="headerlink" title="6.5 awk 算术运算符："></a>6.5 awk 算术运算符：</h3><p>所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a++,++a&#125;&#39;</span><br><span class="line">0 2</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++;++a&#125;&#39;</span><br><span class="line">20</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++,++a&#125;&#39;</span><br><span class="line">20 22</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8afa7f71-52cb-4fbf-a979-08e0e007d195.png" alt></p><h3 id="6-6-三目运算符"><a href="#6-6-三目运算符" class="headerlink" title="6.6 三目运算符 ?:"></a>6.6 三目运算符 ?:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;c&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">err</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e6da1f28-ff78-4933-8914-5c0b6fec6fd1.png" alt></p><h2 id="7-常用-awk-内置变量"><a href="#7-常用-awk-内置变量" class="headerlink" title="7 常用 awk 内置变量"></a>7 常用 awk 内置变量</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126225731300-1873454323.jpg" alt><br>注：内置变量很多，参阅相关资料</p><h3 id="7-1-字段分隔符-FS"><a href="#7-1-字段分隔符-FS" class="headerlink" title="7.1 字段分隔符 FS"></a>7.1 字段分隔符 FS</h3><p>FS=”\t+” 一个或多个 Tab 分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">ww CC IDD</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;\t+&quot;&#125;&#123;print $1,$2,$3&#125;&#39; test.txt </span><br><span class="line">ww CC IDD</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c865da77-e766-40ea-a7f4-6f2d8093013f.png" alt></p><p>FS=[[:space:]+] 一个或多个空白空格，默认的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [[:space:]+] &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1cec6d3e-d39a-4173-bb21-4b54f51e73fe.png" alt></p><p>FS=[“ “:]+ 以一个或多个空格或：分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [&quot; &quot;:]+ &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/d833df93-0259-4fa9-9069-dcc9f9393bd7.png" alt></p><p>字段数量 NF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk -F &quot;:&quot; &#39;NF&#x3D;&#x3D;8&#123;print $0&#125;&#39; test.txt </span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/393eb9b6-011c-475e-b90a-97ee7bbb7256.png" alt></p><p>记录数量 NR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk -F [&quot; &quot;:]+ &#39;NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br><span class="line"></span><br><span class="line">## NR&#x3D;&#x3D;2即是取第二行数据</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/32a25c64-0e99-40f1-a668-3f8c77937b5d.png" alt></p><p>RS 记录分隔符变量</p><p>将 FS 设置成”\n”告诉 awk 每个字段都占据一行。通过将 RS 设置成””，还会告诉 awk每个地址记录都由空白行分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p>ps:** 凡是被#!注释的，统统是加载器(解释器)的路径。#!/bin/awk :指定使用此程序来运行本文件。**</p><p>OFS 输出字段分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat hello.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125;&#123;print $1&quot;,&quot;$2&quot;,&quot;$3&#125;&#39; hello.txt </span><br><span class="line">root,x,0</span><br><span class="line">bin,x,1</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;;OFS&#x3D;&quot;#&quot;&#125;&#123;print $1,$2,$3&#125;&#39; hello.txt </span><br><span class="line">root#x#0</span><br><span class="line">bin#x#1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c1f049a7-edea-4bb8-b786-356de8bbd561.png" alt></p><p>ORS 输出记录分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">    ORS&#x3D;&quot;\n\n&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c4e9909e-c851-448d-affe-8d5acfd9ad66.png" alt></p><h2 id="8-awk正则"><a href="#8-awk正则" class="headerlink" title="8 awk正则"></a>8 awk正则</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126232437800-1355193233.jpg" alt></p><h3 id="8-1-正则应用"><a href="#8-1-正则应用" class="headerlink" title="8.1  正则应用"></a>8.1  正则应用</h3><p>规则表达式<br>awk ‘/REG/{action} ‘ file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd  ##匹配所有包含root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">operator:x:11:0:operator:&#x2F;root:&#x2F;sbin&#x2F;nologin</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# awk -F: &#39;$5~&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd ## 以冒号作为分隔符，匹配第5个字段是root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk &#39;BEGIN&#123;FS&#x3D;&quot;[[:space:]:]+&quot;&#125; NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/460ee8cf-76ae-41ce-8448-c212c858c5a9.png" alt></p><p>布尔表达式<br>awk ‘布尔表达式{action}’ file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F : &#39;$1&#x3D;&#x3D;&quot;root&quot; &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">[root@haoransun demo]#</span><br><span class="line">[root@haoransun demo]# awk -F : &#39;($1&#x3D;&#x3D;&quot;root&quot;)&amp;&amp;($5&#x3D;&#x3D;&quot;root&quot;) &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/53f21771-aef3-4683-a415-1839a4939df3.png" alt></p><h2 id="9-awk-的-if、循环和数组"><a href="#9-awk-的-if、循环和数组" class="headerlink" title="9 awk 的 if、循环和数组"></a>9 awk 的 if、循环和数组</h2><h3 id="9-1-条件语句"><a href="#9-1-条件语句" class="headerlink" title="9.1 条件语句"></a>9.1 条件语句</h3><p>awk 提供了非常好的类似于 C 语言的 if 语句。<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/cb35a7a2-c225-4d92-ad58-5f7d7dc977a0.png" alt></p><p>使用 if 语句还可以将代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! &#x2F;matchme&#x2F; &#123;print $1 $3 $4&#125;</span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if($0 !~ &#x2F;matchme&#x2F; )&#123;</span><br><span class="line">        print $1 $3 $4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-循环结构"><a href="#9-2-循环结构" class="headerlink" title="9.2 循环结构"></a>9.2 循环结构</h3><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有”do…while”循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。</p><p>它类似于其它语言中的”repeat…until”循环。以下是一个示例：<br>do…while 示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    count &#x3D; do&#123;</span><br><span class="line">        print &quot;xxxxx&quot;</span><br><span class="line">    &#125;while(count !&#x3D;1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-for-循环"><a href="#9-3-for-循环" class="headerlink" title="9.3 for 循环"></a>9.3 for 循环</h3><p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (initial assignment; comparation; increment)&#123;</span><br><span class="line">    code block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(x&#x3D;1;x&lt;&#x3D;4;x++)&#123;</span><br><span class="line">    print &quot;iteration&quot;,x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iteration1</span><br><span class="line">iteration2</span><br><span class="line">iteration3</span><br><span class="line">iteration4</span><br></pre></td></tr></table></figure><h3 id="9-4-break-和-continue"><a href="#9-4-break-和-continue" class="headerlink" title="9.4 break 和 continue"></a>9.4 break 和 continue</h3><p>此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a425efad-8bdf-4bf8-8379-cfd3cb2f6930.png" alt></p><p>以下只执行10次<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e1f4652e-1c8c-4031-8fa5-19a84853429c.png" alt></p><p>这里， break 语句用于“逃出”最深层的循环。 “break”使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e5cd9ad0-3212-4d52-8c60-ad07febf338b.png" alt></p><h3 id="9-5-数组"><a href="#9-5-数组" class="headerlink" title="9.5 数组"></a>9.5 数组</h3><p>AWK 中的数组都是关联数组,数字索引也会转变为字符串索引<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/06c347db-0e28-45cc-a3f6-a51ce62523bd.png" alt><br>for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</p><h3 id="9-6-数组的典型应用"><a href="#9-6-数组的典型应用" class="headerlink" title="9.6 数组的典型应用"></a>9.6 数组的典型应用</h3><p>用 awk 中查看服务器连接状态并汇总</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# netstat -an|awk &#39;&#x2F;^tcp&#x2F;&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;&#39;</span><br><span class="line">LISTEN 4</span><br><span class="line">ESTABLISHED 1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/2c9f17b2-4bf8-4fcc-8ff8-49b6a160c7c0.png" alt></p><p>统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/065c3870-c2e8-4acc-9596-35d91ae183d1.png" alt></p><h2 id="10-常用字符串函数"><a href="#10-常用字符串函数" class="headerlink" title="10 常用字符串函数"></a>10 常用字符串函数</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126235509019-257728577.jpg" alt></p><h3 id="10-1-字符串函数的应用"><a href="#10-1-字符串函数的应用" class="headerlink" title="10.1 字符串函数的应用"></a>10.1 字符串函数的应用</h3><p>替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;gsub(&#x2F;[0-9]+&#x2F;,&quot;!&quot;,info);print info&#125;&#39;</span><br><span class="line">this is a test!test!</span><br><span class="line"></span><br><span class="line">在info中查找满足正则表达式， &#x2F;[0-9]+&#x2F; 用 “！”替换，并且赋值给 info值，默认是$0</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>匹配查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print match(info,&#x2F;[0-9]+&#x2F;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">如果查找到数字匹配成功返回 ok</span><br></pre></td></tr></table></figure><p>截取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#39;</span><br><span class="line">s is a tes</span><br><span class="line">从第4个字符开始，截取10个长度字符串。</span><br></pre></td></tr></table></figure><p>分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#39;</span><br><span class="line">4</span><br><span class="line">4 test</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">分割 info,动态创建数组tA,awk for ...循环 是一个无序的循环，并不是从数组下表1...n开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql安装</title>
      <link href="/2018/06/20/MySql%E5%AE%89%E8%A3%85/"/>
      <url>/2018/06/20/MySql%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-第一种方式"><a href="#1-第一种方式" class="headerlink" title="1 第一种方式"></a>1 第一种方式</h1><p>linux设置动态ip连接外网  yum=centos独有的指令，自动安装所有依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-server mysql mysql-deve</span><br></pre></td></tr></table></figure><h1 id="2-第二种方式"><a href="#2-第二种方式" class="headerlink" title="2 第二种方式"></a>2 第二种方式</h1><p>rpm安装，需要持有rmp文件，见目录：附件</p><p><font color="red">安装过程：</font><br>2.1 将rpm复制到linux的 /x/xx中<br>rpm -ivh perl*<br>rpm -Uvh mysql-libs-5.1.73-7.el6.x86_64.rpm<br>rpm -ivh mysql-5.1.73-7.el6.x86_64.rpm mysql-server-5.1.73-7.el6.x86_64.rpm</p><p>安装mysql的主服务</p><a id="more"></a><h1 id="3-第三种方式"><a href="#3-第三种方式" class="headerlink" title="3 第三种方式"></a>3 第三种方式</h1><p>使用虚拟机克隆：打开提供好的克隆虚拟机即可。其中已经安装好所有依赖，可直接使用。</p><hr><h1 id="4-MySQL-初始化"><a href="#4-MySQL-初始化" class="headerlink" title="4 MySQL 初始化"></a>4 MySQL 初始化</h1><h2 id="4-1-MySQL启动：service-mysqld-start"><a href="#4-1-MySQL启动：service-mysqld-start" class="headerlink" title="4.1 MySQL启动：service mysqld start"></a>4.1 MySQL启动：service mysqld start</h2><h2 id="4-2-MySQL远程连接：Navicat软件（见soft文件夹）"><a href="#4-2-MySQL远程连接：Navicat软件（见soft文件夹）" class="headerlink" title="4.2 MySQL远程连接：Navicat软件（见soft文件夹）"></a>4.2 MySQL远程连接：Navicat软件（见soft文件夹）</h2><p>默认只允许localhost mysql―server</p><p>无法远程连接mysql，解决方案：</p><p>5.1 mysql -u root -p 打开mysql客户端    默认打开主机为 localhsot<br>或者：<br> mysql -u root -h ‘192.168.1.68’ -p  打开主机为 192.168.1.68</p><p> 5.2 use mysql 选择库：mysql<br> 5.3 将库mysql中的user表中的数据除了host为127.0.0.1的其他数据删除<br> 5.4 将user表中的host改为”%”<br> 5.5 flush privileges  //刷新权限<br> 5.6 关闭linux的防火墙</p><h1 id="5-为mysql的root用于分配登陆密码："><a href="#5-为mysql的root用于分配登陆密码：" class="headerlink" title="5 为mysql的root用于分配登陆密码："></a>5 为mysql的root用于分配登陆密码：</h1><p>mysql&gt;SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘123’);</p><p>如下命令，在初次开启mysql服务后，会提示给用户：<br>   [root@haoransun mysql_rpm]# mysqladmin -u root password ‘123’;<br>   如果已经有密码存在，要修改的话：<br>   [root@haoransun mysql_rpm]# mysqladmin -u root -p password ‘123’; 之后输入旧密码即可</p><h1 id="6-MySQL-操作"><a href="#6-MySQL-操作" class="headerlink" title="6 MySQL 操作"></a>6 MySQL 操作</h1><h2 id="6-1-客户端访问"><a href="#6-1-客户端访问" class="headerlink" title="6.1 客户端访问"></a>6.1 客户端访问</h2><p>mysql -u root -p 回车 输入密码回车 即可<br>  7.2 数据库查看：show databases;<br>  7.3 数据库选择：use xx;</p><h2 id="6-2-乱码解决："><a href="#6-2-乱码解决：" class="headerlink" title="6.2 乱码解决："></a>6.2 乱码解决：</h2><p>  8.1 建库时指定utf-8<br>  8.2 url中指定urt-8</p><h2 id="6-3-找到-etc-my-cnf-在此文件中添加如下"><a href="#6-3-找到-etc-my-cnf-在此文件中添加如下" class="headerlink" title="6.3 找到 /etc/my.cnf 在此文件中添加如下"></a>6.3 找到 /etc/my.cnf 在此文件中添加如下</h2><p>[client]<br>default-character-set=utf8<br>防止命令行乱码，此配置仅作用于用命令行操作数据时的乱码解决。<br>常规的应用运行乱码解决和此无关。</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java定时任务</title>
      <link href="/2018/05/13/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/05/13/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Author: haoranSun<br>Wechat: SHR—97</p><h3 id="一、什么是定时任务："><a href="#一、什么是定时任务：" class="headerlink" title="一、什么是定时任务："></a>一、什么是定时任务：</h3><blockquote><p>定时任务是指调度程序在指定的时间或周期触发执行的任务<br>使用场景：发送邮件、统计、状态修改、消息推送、活动开启、增量索引</p></blockquote><a id="more"></a><h3 id="二、定时任务实现技术："><a href="#二、定时任务实现技术：" class="headerlink" title="二、定时任务实现技术："></a>二、定时任务实现技术：</h3><ol><li><strong>Java自带的java.util.Time类，这个类允许你调度一个java.util.TimerTask任务。使用这种方法可以让你的程序按照某一个频度执行，但不能在指定时间运行。使用较少。</strong></li><li><strong>Spring3.0以后自主开发的定时任务工具Spring task，使用简单，支持线程池，可以高效处理许多不同的定时任务，除Spring相关的包外不需要额外的包，支持注解和配置文件两种形式。不能处理过于复杂的任务。</strong></li><li><strong>专业的定时任务框架Quartz，功能强大，可以让你的程序在指定时间执行，也可以按照某一个频度执行，支持数据库、监听器、插件、集群。</strong></li></ol><h3 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h3><p><strong>* 1. Timer单线程*</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * java timer  测试类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTimer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//  创建定时器</span></span><br><span class="line">          Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  添加调度任务</span></span><br><span class="line">          <span class="comment">//  安排指定的任务在指定的时间开始进行重复的 固定延迟执行</span></span><br><span class="line">          timer.schedule(<span class="keyword">new</span> MyTask(),<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-06-24 22:31:10"</span>),<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">          <span class="comment">//  安排指定的任务在指定的延迟后开始进行重复的 固定速率执行</span></span><br><span class="line">          <span class="comment">//timer.scheduleAtFixedRate(new MyTask(),new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2017-06-24 22:31:10"),10*1000);</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  定义调度任务</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"log2:"</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>* 2. Spring Task4个标签+1个注解*</strong></p><ul><li>基于配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Spring Task  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTask</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m1:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-task.xml 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springTask"</span> <span class="attr">class</span>=<span class="string">"com.haoran.task.SpringTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册调度任务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 延迟 8 秒 执行任务 --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;task:scheduled ref="springTask" method="m1" fixed-delay="8000" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 固定速度 5 秒 执行任务 --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;task:scheduled ref="springTask" method="m2" fixed-rate="5000"/&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           使用 cron 表达式 指定触发时间</span></span><br><span class="line"><span class="comment">           spring task  只支持 6 位的 cron 表达式 秒 分 时 日 月 星期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"springTask"</span> <span class="attr">method</span>=<span class="string">"m3"</span> <span class="attr">cron</span>=<span class="string">"50-59 * * ? * *"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 执行器配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"threadPoolTaskExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> <span class="attr">keep-alive</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">task:executor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 调度器配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"threadPoolTaskScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">task:scheduler</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Spring Task  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAnnotationTask</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH: mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* @Scheduled(fixedDelay = 8000)</span></span><br><span class="line"><span class="comment">       public void m1()&#123;</span></span><br><span class="line"><span class="comment">            System.out.println("m1:"+simpleDateFormat.format(new Date()));</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       @Scheduled(fixedRateString = "5000")</span></span><br><span class="line"><span class="comment">       public void m2()&#123;</span></span><br><span class="line"><span class="comment">            System.out.println("m2:"+simpleDateFormat.format(new Date()));</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="meta">@Scheduled</span>(cron = <span class="string">"0-30 * * * * ?"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启基于注解的 spring task--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">task:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springAnnotationTask"</span> <span class="attr">class</span>=<span class="string">"com.haoranSun.task.SpringAnnotationTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>* 3. Quartz*</strong></p><ul><li><p>下载 <a href="http://www.quartz-scheduler.org/downloads/" target="_blank" rel="noopener">http://www.quartz-scheduler.org/downloads/</a></p></li><li><p>导入lib或者Maven依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>核心接口<br>a. Scheduler 调度器<br>b. Job 任务<br>c. Trigger 触发器<br>d. JobDetail 任务信息</p></li><li><p>Trigger触发器<br>a. SimpleTrigger // 功能简单 指定时间、周期<br>b. CronTrigger   // 基于cron表达式触发器</p><blockquote><p>cron表达式：秒 分 时 日 月 周 年</p></blockquote></li><li><p>简单入门</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.  创建调度器工厂</span></span><br><span class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.  获取调度器</span></span><br><span class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.  创建任务详情</span></span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.  启动 10 秒后的时间</span></span><br><span class="line">            Date futureDate = DateBuilder.futureDate(<span class="number">10</span>, DateBuilder.IntervalUnit.SECOND);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.  创建触发器</span></span><br><span class="line">            Trigger trigger =</span><br><span class="line">TriggerBuilder.newTrigger().withIdentity(<span class="string">"myTrigger"</span>,<span class="string">"default"</span>).startAt(futureDate).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.  注册任务详情和触发器</span></span><br><span class="line">            scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//7.  启动调度任务</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"log:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于simpleSchedule的定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  简单触发器 调度程序</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25 .</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">           Scheduler scheduler = factory.getScheduler();</span><br><span class="line"></span><br><span class="line">           JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").build();</span><br><span class="line">           <span class="comment">//  指定触发器</span></span><br><span class="line">           <span class="comment">// lucene  唐诗</span></span><br><span class="line">           <span class="comment">// 1.  获取数据库每天新增的诗</span></span><br><span class="line">           <span class="comment">// 2.  定时任务 每天零点触发</span></span><br><span class="line">           <span class="comment">// 3.  任务方法 增量索引</span></span><br><span class="line">           <span class="comment">//  简单定时 SimpleTrigger 间隔或者重复调用</span></span><br><span class="line">           Trigger trigger = TriggerBuilder.newTrigger().withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">10</span>).withRepeatCount(<span class="number">10</span>)).build();</span><br><span class="line"></span><br><span class="line">           scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">           scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于CronSchedule的定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  基于 CronTrigger</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronTriggerScheduler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">            Scheduler scheduler = factory.getScheduler();</span><br><span class="line"></span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").</span><br><span class="line">usingJobData(<span class="string">"id"</span>,<span class="number">1</span>).usingJobData(<span class="string">"name"</span>,<span class="string">"zs"</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              *  在 cron 表达式中 日和周中不能同时出现 *</span></span><br><span class="line"><span class="comment">              * quartz cron 表达式 6 位或者 7 位</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             Trigger trigger = TriggerBuilder.newTrigger().withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * ? * * 2017-2020"</span>)).</span><br><span class="line">withIdentity(<span class="string">"myTrigger"</span>,<span class="string">"default"</span>).build();</span><br><span class="line"></span><br><span class="line">             scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">             scheduler.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Quartz和Spring集合</p><ul><li>依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>任务类继承QuartzJobBean或实现Job接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Created by  haoranSun on 2017/6/25 0025.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringQuartz</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring.xml配置</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;User&quot;&gt;&lt;&#x2F;bean&gt;--&gt;</span><br><span class="line">&lt;!-- 创建 JobDetail--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">     &lt;!-- 指定任务类 --&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;com.haoran.quartz4.MyJob&quot;&gt;      &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 指定 job 中 spring 工厂的名字 指定后 可以在 job 类中获取 spring 工厂 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;applicationContextJobDataKey&quot; value&#x3D;&quot;applicationContext&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;property name&#x3D;&quot;jobDataAsMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;!--&lt;entry key&#x3D;&quot;user&quot; value-ref&#x3D;&quot;user&quot;&gt;&lt;&#x2F;entry&gt;--&gt;</span><br><span class="line">         &lt;&#x2F;map&gt;</span><br><span class="line">      &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 当 Job 在没有可以使用的 trigger 的情况下 不删除 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;jobDetail1&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">       &lt;!-- 指定任务类 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;com.haoran.quartz4.MyJob1&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">       &lt;!-- 当 Job 在没有可以使用的 trigger 的情况下 不删除 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">创建触发器</span><br><span class="line">    Simple</span><br><span class="line">    Cron</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注意 spring quartz 整合 一个 trigger 只可以绑定一个 JobDetail 一个 jobDetail 可以被多个 Trigger 所使用 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;trigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- 绑定 JobDetail--&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">       &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;0-30 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;trigger1&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 绑定 JobDetail--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;45-55 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册 trigger--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;scheduler&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">              &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">              &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">       &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程瞎侃</title>
      <link href="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/"/>
      <url>/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://www.cnblogs.com/aoyeyuyan/p/5495219.html" target="_blank" rel="noopener">https://www.cnblogs.com/aoyeyuyan/p/5495219.html</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;那些年，空气中仿佛还能闻到汉唐盛世的余韵，因此决不允许自己的脸上有油光，时刻保持活力。然而，你一定称为那些“高深术语”感到过困惑。也许时至今日，你仍对他们一知半解。不过今天，讲以一种全新的高清视角进入奇妙的编程世界，领略涵涌在这些“高深术语”中活泼的底气，以及蹁跹于青萍之末的云水禅心。</p><a id="more"></a><h1 id="1-内聚"><a href="#1-内聚" class="headerlink" title="1 内聚"></a>1 内聚</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;内聚，通俗的来讲，就是自己的东西自己保管，自己的事情自己做。<br>&nbsp;&nbsp;&nbsp;&nbsp;经典理论告诉我们，程序的两大要素：一个是<strong>数据</strong>（data），一个是<strong>操作</strong>（opration）。而 PASCAL之父Nicklaus Wirth则进一步提出了<strong>“程序 = 数据结构 + 算法”</strong>的著名公式。虽然提法上有所差异，但是其根本内涵却是一致的，微妙的差别在于，<font color="red">“数据 + 操作”是微观的视域，</font> <font color="red">“数据结构 + 算法”则是中观的视域</font>。而在<strong>宏观的视域</strong>下，我认为<font color="red"><strong>“程序 = 对象 + 消息”</strong></font>。对象是什么？对象就是保管好自己的东西，做好自己的事情的程序模块——这就是内聚！传统的面向过程编程方法由于割裂了数据结构和算法，使得软件的内聚性普遍低迷，曾一度引发了软件危机。试想，大家都自己的东西不好好保管，自己的事情也不好好做，不引发危机才怪呢！当然，对象的内聚只是内聚的一个层次，在不同的尺度下其实都有内聚的要求，比如方法也要讲内聚，架构也要讲内聚。<br>&nbsp;&nbsp;&nbsp;&nbsp;《周易·彖传》中讲“乾道变化，各正性命，保合太和，乃利贞”，就是要求每一个个体因循着各自的禀赋而努力成就各自的品性，然后各自保全，彼此和合，最终达成宇宙的完满状态。《论语·宪问》中，子路问君子。子曰：“修己以敬。”曰：“如斯而已乎？”曰：“修己以安人”，更是明确的教导我们要不断提高自身的内聚性，最大限度地减少给他人造成的麻烦，从而达到安人、安百姓、安天下的目标。我想，成长的过程就是一个不断提升内聚的过程。“自己的东西自己保管，自己的事情自己做”，这些孩提时代的教诲，放到今天仍能让不少“大人”脸红不已。太多的人保管不好自己的“东西”，保管不好自己的身体，保管不好自己的婚姻，更保管不好自己如蛛丝般震颤飘荡的狂乱的心。至于做好自己的事情，则更是惘然，甚至很多人连自己的事情是什么都搞不清楚，因此浑浑噩噩，饱食终日。内聚，是一个值得我们好好反思的问题。</p><h1 id="2-依赖-耦合"><a href="#2-依赖-耦合" class="headerlink" title="2 依赖-耦合"></a>2 依赖-耦合</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程中，对象自身是内聚的，是保管好自己的数据，完成好自己的操作的，而对外界呈现出自己的状态和行为。但是，没有绝对的自力更生，对外开放也是必要的！一个对象，往往需要跟其他对象打交道，既包括获知其他对象的状态，也包括仰赖其他对象的行为，而一旦这样的事情发生时，我们便称该对象依赖于另一对象。只要两个对象之间存在一方依赖一方的关系，那么我们就称这两个对象之间存在耦合。 比如妈妈和baby，妈妈要随时关注baby的睡、醒、困、哭、尿等等状态，baby则要仰赖妈妈的喂奶、哄睡、换纸尿裤等行为，从程序的意义上说，二者互相依赖，因此也存在耦合。首先要说，耦合是必要的。我们来看以下这个实验。<br><strong>【王阳明与山中之花</strong>】<br>&nbsp;&nbsp;&nbsp;&nbsp;由于王阳明这个对象不依赖山花这个对象，又没有其他的方式来获知山花的盛开状态，所以他要么选择不说，要么瞎说，但不说编译是通不过，而瞎说作为王阳明来讲也是通不过的，所以这个系统是无法成立的。要想系统成立，必须要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> bool <span class="title">admireFlowers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flower.IsBloomed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;无论这个山花对象是怎么来的，作为参数传入还是作为属性设置、还是在内部构造出来，总之，王阳明与山花之间发生了依赖，二者之间产生了耦合。 当然，这是一个很浅显的问题。有趣的是王阳明对此事的看法：“你未看花时，花与你同寂；你来看花，花于你则一时分明起来。可见心外无物！”王阳明讲的是对的！“心外无物”翻译技术语言是这样的：不存在耦合的两个对象必然拿不到对方的引用！</p><h1 id="3-耦合度-解耦合"><a href="#3-耦合度-解耦合" class="headerlink" title="3 耦合度-解耦合"></a>3 耦合度-解耦合</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;耦合的程度就是耦合度，也就是双方依赖的程度。上文所说的妈妈和baby就是强耦合。而你跟快递小哥之间则是弱耦合。一般来说耦合度过高并不是一件好事。就拿作为IT精英的你来说吧，上级随时敦促你的工作进度，新手频繁地需要你指导问题，隔三差五还需要参加酒局饭局，然后还要天天看领导的脸色、关注老婆的心情，然后你还要关注代码中的bug 、bug、bug，和需求的变化、变化、变化，都够焦头烂额了，还猝不及防的要关注眼睛、颈椎、前列腺和头发的状态，然后你再炒个股，这些加起来大概就是个强耦合了。从某种意义上来说，耦合天生就与自由为敌，无论是其他对象依赖于你，还是你依赖其他对象。比如有人嗜烟、酗酒，你有多依赖它们就有多不自由；比如有人家里生了七八个娃，还有年迈的父母、岳父母，他们有多依赖你，你就有多不自由。所以老子这样讲：“五音令人耳聋，五色令人目盲，驰骋狩猎令人心发狂，难得之货令人行妨。”卢梭也是不无悲凉的说“人生而自由，却又无往而不在枷锁中”。因此，要想自由，就必须要降低耦合，而这个过程就叫做解耦和。</p><h1 id="4-依赖倒置（Dependence-Inversion-Principle）"><a href="#4-依赖倒置（Dependence-Inversion-Principle）" class="headerlink" title="4 依赖倒置（Dependence Inversion Principle）"></a>4 依赖倒置（Dependence Inversion Principle）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;解耦合最重要的原则就是依赖倒置原则：<br><strong>高层模块不应该依赖底层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;《资本论》中都曾阐释依赖倒转原则——在商品经济的萌芽时期，出现了物物交换。假设你要买一个IPhone，卖IPhone的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的APP来换他一头猪，他说换猪可以，但是得用一条金项链来换——所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了。</p><h1 id="5-控制反转（Inversion-Of-Control）"><a href="#5-控制反转（Inversion-Of-Control）" class="headerlink" title="5 控制反转（Inversion Of Control）"></a>5 控制反转（Inversion Of Control）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;控制反转跟依赖倒置是如出一辙的两个概念，当存在依赖倒置的时候往往也存在着控制反转。但是控制反转也有自己的独特内涵。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先我们要区分两个角色，server 跟 Client，也就是服务方和客户方。提供服务端的一方称为服务方，请求服务的一方称为客户方。我们最熟悉的例子就是分布式应用的C/S架构，服务端和客户端。其实除此之外，C/S关系处处可见。比如在TCP/IP协议栈中，我们知道，每层协议为上一层提供服务，那么这里就是一个C/S关系。当我们使用开发框架时，开发框架就是作为服务方，而我们自己编写的业务应用就是客户方。当Client调用server时，这个叫做一般的控制；而当server调用Client时，就是我们所说的控制反转，同时我们也将这个调用称为“回调”。控制反转跟依赖倒置都是一种编程思想，依赖倒置着眼于调用的形式，而控制反转则着眼于程序流程的控制权。一般来说，程序的控制权属于server，而一旦控制权交到Client，就叫控制反转。比如你去下馆子，你是Client餐馆是server。你点菜，餐馆负责做菜，程序流程的控制权属于server；而如果你去自助餐厅，程序流程的控制权就转到Client了，也就是控制反转。<br><img src="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/81f9baa4235055faf8e17d371dd44774_r.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;控制反转的思想体现在诸多领域。比如事件的发布/ 订阅就是一种控制反转，GOF设计模式中也多处体现了控制反转，比如典型的模板方法模式等。而开发框架则是控制反转思想应用的集中体现。比如之前所举的ESFramework通信框架的例子，通信引擎回调用户自定义的消息处理器，这就是一个控制反转。以及ESFramework回调用户自定义的群组关系和好友关系，回调用户自定义的用户管理器以管理在线用户相关状态，回调用户自定义的登陆验证处理，等等不一而足。再比如与ESFramework一脉相承轻量级通信引擎StriveEnginetarget，通过回调用户自定义的通信协议来实现更加灵活的通信<br>&nbsp;&nbsp;&nbsp;&nbsp;由此我们也可以总结出开发框架与类库的区别：使用开发框架时，框架掌握程序流程的控制权，而使用类库时，则是应用程序掌握程序流程的控制权。或者说，使用框架时，程序的主循环位于框架中，而使用类库时，程序的主循环位于应用程序之中。框架会回调应用程序，而类库则不会回调应用程序。ESFramework和StriveEngine中最主要的对象都以engine来命名，我们也可以看出框架对于程序主循环的控制——它会为你把握方向、眼看前方、轻松驾驭！</p><h1 id="6-依赖注入（Dependency-Injection）"><a href="#6-依赖注入（Dependency-Injection）" class="headerlink" title="6 依赖注入（Dependency Injection）"></a>6 依赖注入（Dependency Injection）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;依赖注入与依赖倒置、控制反转的关系仍旧是一本万殊。依赖注入，就其广义而言，即是通过“注入”的方式，来获得依赖。我们知道，A对象依赖于B对象，等价于A对象内部存在对B对象的“调用”，而前提是A对象内部拿到了B对象的引用。B对象的引用的来源无非有以下几种：A对象内部创建（无论是作为字段还是作为临时变量）、构造器注入、属性注入、方法注入。后面三种方式统称为“依赖注入”，而第一种方式我也生造了一个名词，称为“依赖内生”，二者根本的差异即在于，我所依赖的对象的创建工作是否由我自己来完成。当然，这个是广义的依赖注入的概念，而我们一般不会这样来使用。我们通常使用的，是依赖注入的狭义的概念。不过，直接陈述其定义可能会过于诘屈聱牙，我们还是从具体的例子来看。<br><img src="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/e3305283d36861d16c1985c8edf6b53c_hd.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;比如<font color="red">OMCS网络语音视频框架</font>，它实现了多媒体设备（麦克风、摄像头、桌面、电子白板）的采集、编码、网络传送、解码、播放（或显示）等相关的一整套流程，可以快速地开发出视频聊天系统、视频会议系统、远程医疗系统、远程教育系统、网络监控系统等等基于网络多媒体的应用系统。然而，OMCS直接支持的是通用的语音视频设备，而在某些系统中，需要使用网络摄像头或者特殊的视频采集卡作为视频源，或者其它的声音采集设备作为音频源，OMCS则提供了扩展接口——用户自己实现这个扩展的接口，然后以“依赖注入”的方式将对象实例注入到OMCS中，从而完成对音、视频设备的扩展。<br>&nbsp;&nbsp;&nbsp;&nbsp;“依赖注入”常常用于扩展，尤其是在开发框架的设计中。从某种意义上来说，任何开发框架，天生都是不完整的应用程序。因此，一个优秀的开发框架，不仅要让开发者能够重用这些久经考验的的卓越的解决方案，也要让开发者能够向框架中插入自定义的业务逻辑，从而灵活自由地适应特定的业务场景的需要——也就是说要具备良好的可扩展性。比如上面提到的OMCS网络语音视频框架可应用于音、视频聊天系统、视频会议系统、远程医疗系统、远程教育系统、网络监控系统等等基于网络多媒体的应用系统；以及ESFramework通信框架能够应用于即时通讯系统，大型多人在线游戏、在线网页游戏、文件传送系统、数据采集系统、分布式OA系统等任何需要分布式通信的软件系统中——这种良好的扩展性都与“依赖注入”的使用密不可分！</p><h1 id="7-面向接口编程"><a href="#7-面向接口编程" class="headerlink" title="7 面向接口编程"></a>7 面向接口编程</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;谈到最后，“面向接口编程”已经是呼之欲出。无论是依赖倒置、控制反转、还是依赖注入，都已经蕴含着“面向接口编程”的思想。面向接口，就意味着面向抽象。作为哲学范畴而言，规定性少称为抽象，规定性多称为具体。而接口，就是程序中的一种典型的“抽象”的形式。面向抽象，就意味着面向事物的本质规定性，摆脱感性杂多的牵绊，从而把握住“必然”——而这本身就意味着自由，因为自由就是对必然的认识。<br>&nbsp;&nbsp;&nbsp;&nbsp;也许以上的这段论述太过“哲学”，但是“一本之理”与“万殊之理”本身就“体用不二”——总结来看，依赖倒置、控制反转、依赖注入都围绕着“解耦和”的问题，而同时自始至终又都是“面向接口编程”的方法——因此，“面向接口编程”天生就是“解耦和”的好办法。由此也印证了从“抽象”到“自由”的这一段范畴的辩证衍化。<br>&nbsp;&nbsp;&nbsp;&nbsp;“面向对象”与“面向接口”并非两种不同的方法学，“面向接口”其实是“面向对象”的内在要求，是其一部分内涵的集中表述。我们对于理想软件的期待常被概括为“高内聚，低耦合”，这也是整个现代软件开发方法学所追求的目标。面向对象方法学作为现代软件开发方法学的代表，本身就蕴含着“高内聚，低耦合”的思想精髓，从这个意义上来说，“面向对象”这个表述更加侧重于“高内聚”，“面向接口”的表述则更加侧重于“低耦合”——不过是同一事物的不同侧面罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>Practice makes perfect</strong></p><h1 id="Vim-的前生今世"><a href="#Vim-的前生今世" class="headerlink" title="Vim 的前生今世"></a>Vim 的前生今世</h1><p>Vi 最初是由 Bill Joy 在 1976 年编码实现的。而 Vim (Vi IMproved) 则是改进的 Vi，由 Bram Moolenaar 在 1991 年开发并发布。Vi/Vim 是所有 Unix/Linux 操作系统默认配备的编辑器。因其强大的功能和高效的操作，Vi/Vim 也成为众多 Unix/Linux 用户、管理员必须掌握并熟练使用的编辑工具之一。尤其是在没有图形界面的情况下，更是离不开 Vi/Vim。Vi/Vim 命令非常多、用法极为灵活，掌握起来有一定的难度。本文为入门教程，关于 Vi/Vim 各种定制后的功能不在本文讨论范围之列。</p><a id="more"></a><h1 id="Vi和Vim"><a href="#Vi和Vim" class="headerlink" title="Vi和Vim"></a>Vi和Vim</h1><p>在 Linux 的世界中，绝大部分的配置文件都是以 ASCII 的<strong>纯文本</strong>形态存在，因此利用简单的文字编辑软件就能够修改！ 与微软 Windows 系统不同的是，如果你用惯了 Microsoft Word 的话，在 Linux 的文本模式下，会觉得文书编辑程序都没有窗口接口来的直观与方便，那么问题来了，干嘛还要学这个不是很友善和方便的vi编辑器呢？因为：</p><ul><li>跨平台无所不在。所有的 Unix 和 Linux 系统都会内建 vi 文本编辑器，其他的编辑器则不一定会有而且你无需担心到了其他平台需要学习新编辑器，除了Linux/Mac OS X外Windows系统也都可用。</li><li>很多个别软件的编辑接口都会主动调用 vi ；</li><li>可扩展性。你可以只用它来编辑配置文件，也可以将它当做你的开发平台。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；</li><li>程序简单、功能强大、运行飞快</li></ul><h1 id="什么是Vim呢？"><a href="#什么是Vim呢？" class="headerlink" title="什么是Vim呢？"></a>什么是Vim呢？</h1><p>其实你可以将 vim 视作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。 举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是shell script程序时，vim 会依据档案的扩展名或者是档案内的开头信息， 判断该档案的内容而自动调用该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说， 这个 vim 已经是个『程序编辑器』了！甚至一些 Linux 基础配置文件内的语法，都能用 vim 来检查！<br> 简单来说， vi 是老式的文本处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim 则可以说是程序开发者的『程序编辑器』了，就连 vim 的<a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">官网</a>也说 vim 是一个『程序开发工具』而不是文本处理软件。 因为 vim 里面加入了很多额外的功能，例如支持正规表示法的搜寻架构、多档案编辑、区块复制等等。</p><p><strong>学习 <a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">vim</a> 并且它可能会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用</strong>。</p><p><strong>提示</strong>：在 Linux 下，如果以 root 用户登录系统的话，通过 vi 命令打开的 Vim 编辑器往往只加载最基本的功能，像语法加亮着色的功能基本上没有。在 root 用户下使用 Vim 所有功能的技巧是用 vim 命令打开 Vim 编辑器。</p><h1 id="如何进入Vim"><a href="#如何进入Vim" class="headerlink" title="如何进入Vim?"></a>如何进入Vim?</h1><p>可以在终端（不明白什么是终端的，请自行谷歌命令行、终端、shell、bash了解）输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim [filename]</span><br></pre></td></tr></table></figure><p>其中<code>filename</code>是文件的路径。如果文件不存在，它将为你建立一个新文件。</p><h1 id="Vim的三种操作模式"><a href="#Vim的三种操作模式" class="headerlink" title="Vim的三种操作模式"></a>Vim的三种操作模式</h1><p>Vim编辑程序有三种操作模式，分别称为<strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>。</p><p><strong>编辑模式</strong>：用以执行命令，也称为Normal正常模式，也是进入Vim的缺省模式。进入Vim后会直接进入编辑模式(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来操作文本， 也可以使用『复制、剪切、粘贴』来处理文本数据，删除正文和插入新的正文。但是却是无法编辑文本内容的！</p><p><strong>插入模式</strong>：即 Insert 模式，用来输入文本，就像你用“记事本”一样。进入Vim后会直接进入编辑模式，要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进行编辑，可以输入字符。而如果要回到一般模式时， 则必须要按下『Esc』这个按键才可退出编辑模式。</p><p><strong>命令模式</strong>：用来执行冒号命令。在编辑模式下输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中，可以进行保存、查找、替换、显示行号、退出、配置Vim操作等等的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i → Insert 模式，按 ESC 回到 Normal 模式。</span><br><span class="line">x → 删当前光标所在的一个字符。</span><br><span class="line">dd → 删除当前行，并把删除的行存到剪贴板里。</span><br><span class="line">p → 粘贴剪贴板。</span><br><span class="line">:wq → 存盘 + 退出 (:w 存盘后可以跟文件名，:q 退出，:q!强制退出)</span><br><span class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。</span><br></pre></td></tr></table></figure><p><strong>推荐</strong>：<br>强例推荐使用hjkl键盘移动光标，但不必需，你也可以使用光标键 (←↓↑→)移动。<br>以 : 开始的命令你需要输入 <enter> 回车结束，例如我写成 :q 也就是说你要输入 :q然后回车。</enter></p><h1 id="编辑模式下命令"><a href="#编辑模式下命令" class="headerlink" title="编辑模式下命令"></a>编辑模式下命令</h1><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k或↑              上移</span><br><span class="line">j或↓               下移</span><br><span class="line">h或←            左移</span><br><span class="line">l或→             右移</span><br></pre></td></tr></table></figure><p>上面这４个键将光标位置每次移动一行或一个字符 。Vim还提供稍大范围移动光标的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f         在文件中前移一页（相当于 page down）</span><br><span class="line">ctrl+b        在文件中后移一页（相当于 page up）</span><br><span class="line">ctrl+d        屏幕向下移动半页</span><br><span class="line">ctrl+u        屏幕向上移动一页</span><br></pre></td></tr></table></figure><p>更大范围的移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*          当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</span><br><span class="line">#          当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</span><br><span class="line">(&#x2F;)        移动到 前&#x2F;后 句 的开始；</span><br><span class="line">&#123;&#x2F;&#125;        跳转到 当前&#x2F;下一个 段落 的开始。</span><br><span class="line">g_         到本行最后一个不是 blank 字符的位置。</span><br><span class="line">fa         到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</span><br><span class="line">t,         到逗号前的第一个字符。逗号可以变成其它字符。</span><br><span class="line">3fa        在当前行查找第三个出现的 a。</span><br><span class="line">F&#x2F;T        和 f 和 t 一样，只不过是相反方向;</span><br></pre></td></tr></table></figure><p>在屏幕中找到需要的 一页 时，可以用下面的命令快速移动光标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H                  将光标移到屏幕上的起始行（或最上行）</span><br><span class="line">M                  将光标移到屏幕中间</span><br><span class="line">L                  将光标移到屏幕最后一行</span><br><span class="line">G                  将光标定位到文件最后一行起始位置</span><br><span class="line">NG或Ngg            将光标定位到第 N 行的起始位置</span><br><span class="line">gg                 将光标定位到文件第一行起始位置</span><br><span class="line">N(ENTER)           光标下移N行</span><br></pre></td></tr></table></figure><p>同样需要注意字母的大小写。H 和 L 命令还可以加数字。如 2H 表示将光标移到屏幕的第２行，3L 表示将光标移到屏幕的倒数第3行。<br>当将光标移到所要的行是，行内移动 光标可以用下面的命令来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w                右移光标到下一个字的开头；</span><br><span class="line">e                右移光标到一个字的末尾；</span><br><span class="line">b                左移光标到前一个字的开头；</span><br><span class="line">0                数字０，左移光标到本行的开始；</span><br><span class="line">$                右移光标，到本行的末尾；</span><br><span class="line">^                移动光标，到本行的第一个非空字符。</span><br><span class="line">+                光标移动到非空格符的下一行；</span><br><span class="line">-                光标移动到非空格符的上一行n；</span><br><span class="line">n                n表示数字，按下数字后按空格键，光标右移n个字符，会跨行移动。</span><br></pre></td></tr></table></figure><h2 id="查找。搜索匹配"><a href="#查找。搜索匹配" class="headerlink" title="查找。搜索匹配"></a>查找。搜索匹配</h2><p>和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 / ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 ? 取代 / ，可以实现反向搜索（朝文件开头方向）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;str1                正向搜索字符串 str1；</span><br><span class="line">n                    继续搜索，重复之前的查找，但是向上重复查找；</span><br><span class="line">N                    继续搜索，重复之前的查找，但是向下重复查找；</span><br><span class="line">?str2                反向搜索字符串 str2 。</span><br><span class="line">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g   这个操作代表在n1与n2行之间查找word1并用word2来代替它</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;g     这个操作是从第一行到最后一行进行查找替换</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;gc    与上面一样只不过多了个确认confirm</span><br></pre></td></tr></table></figure><p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。<br>Vim中执行搜索匹配最强大的地方是结合 正则表达式 来搜索，</p><h2 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h2><p>Vim常规的删除命令是 d、 x (前者删除 行 ，后者删除 字符 ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rc                 用 c 替换光标所指向的当前字符；</span><br><span class="line">nrc                用 c 替换光标所指向的前 n 个字符；</span><br><span class="line">5rA                用 A 替换光标所指向的前 5 个字符；</span><br><span class="line">x                  删除光标所指向的当前字符；</span><br><span class="line">nx                 删除光标所指向的前 n 个字符；</span><br><span class="line">3x                 删除光标所指向的前 3 个字符；</span><br><span class="line">dw                 删除光标右侧的字；</span><br><span class="line">ndw                删除光标右侧的 n 个字；</span><br><span class="line">3dw                删除光标右侧的 3 个字；</span><br><span class="line">db                 删除光标左侧的字；</span><br><span class="line">ndb                删除光标左侧的 n 个字；</span><br><span class="line">5db                删除光标左侧的 5 个字；</span><br><span class="line">dd                 删除光标所在行，并去除空隙；</span><br><span class="line">ndd                删除（剪切） n 行内容，并去除空隙；</span><br><span class="line">3dd                删除（剪切） 3 行内容，并去除空隙；</span><br></pre></td></tr></table></figure><p>其他常用的删除命令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d$                从当前光标起删除字符直到行的结束；</span><br><span class="line">d0                从当前光标起删除字符直到行的开始；</span><br><span class="line">J                 删除本行的回车符（CR），并和下一行合并。</span><br></pre></td></tr></table></figure><p>Vim常规的替换命令有 c 和 s ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由<strong>编辑模式</strong>进入<strong>插入模式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s                用输入的正文替换光标所指向的字符；</span><br><span class="line">S                删除当前行，并进入编辑模式；</span><br><span class="line">ns               用输入的正文替换光标右侧 n 个字符；</span><br><span class="line">nS               删除当前行在内的 n 行，并进入编辑模式；</span><br><span class="line">cw               用输入的正文替换光标右侧的字；</span><br><span class="line">cW               用输入的正文替换从光标到行尾的所有字符（同 c$ )；</span><br><span class="line">ncw              用输入的正文替换光标右侧的 n 个字；</span><br><span class="line">cb               用输入的正文替换光标左侧的字；</span><br><span class="line">ncb              用输入的正文替换光标左侧的 n 个字；</span><br><span class="line">cd               用输入的正文替换光标的所在行；</span><br><span class="line">ncd              用输入的正文替换光标下面的 n 行；</span><br><span class="line">c$               用输入的正文替换从光标开始到本行末尾的所有字符；</span><br><span class="line">c0               用输入的正文替换从本行开头到光标的所有字符。</span><br></pre></td></tr></table></figure><h2 id="临时显示行号"><a href="#临时显示行号" class="headerlink" title="临时显示行号"></a>临时显示行号</h2><p>如果只是临时显示vim的行号，只须按ESC键退出编辑内容模式，输入“：set number” / “:set nu”后按回车键，就可以显示行号了。行号显示只是暂时的，退出vim后再次打开vim就不显示行号了。</p><h2 id="永久显示行号"><a href="#永久显示行号" class="headerlink" title="永久显示行号"></a>永久显示行号</h2><p>果想让vim永久显示行号，则需要修改vim配置文件vimrc。whereis vimrc</p><p>如果没有此文件可以创建一个 vimrc<br>在打开的vimrc文件中最后一行输入：set number ，然后保存退出。再次用vim打开文件时，就会显示行号了。</p><h2 id="多区域选择"><a href="#多区域选择" class="headerlink" title="多区域选择"></a>多区域选择</h2><p>选中一个起始点后，按 ctrl+v 可以看到左下角出现 区块选择，然后点击上下左右选择即可。按下y即可剪切，按下p粘贴刚才剪切的内容.</p><p>在命令模式下输入 :files 可以列出目前这个vim开启到的所有档案。</p><h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>当我有一个档案非常的大，我查阅到后面的数据时，想要『对照』前面的数据， 是否需要使用 [ctrl]+f 与 [ctrl]+b (或 pageup, pagedown 功能键) 来跑前跑后查阅？</p><p>我有两个需要对照着看的档案，不想使用前面提到的多档案编辑功能；</p><p>在一般窗口接口下的编辑软件大多有『分割窗口』或者是『冻结窗口』的功能来将一个档案分割成多个窗口的展现， 那么 vim 能不能达到这个功能啊？可以啊！但是如何分割窗口并放入档案呢？ 很简单啊！在指令列模式输入『:sp {filename}』即可！那个 filename 可有可无， 如果想要在新窗口启动另一个档案，就加入档名，否则仅输入 :sp 时， 出现的则是同一个档案在两个窗口间！</p><p>还可以利用『[ctrl]+w+↑』及『[ctrl]+w+↓』 在两个窗口之间移动呢！这样的话，复制啊、查阅啊等等的，就变的很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:sp [filename] </span><br><span class="line"></span><br><span class="line">开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ j  [ctrl]+w+↓</span><br><span class="line"></span><br><span class="line">按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ k  [ctrl]+w+↑</span><br><span class="line"></span><br><span class="line">同上，不过光标移动到上面的窗口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ q</span><br><span class="line"></span><br><span class="line">其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊！</span><br></pre></td></tr></table></figure><p><a href="https://link.jianshu.com/?t=http://blog.jobbole.com/86132/" target="_blank" rel="noopener">Vim 入门教程</a><br><a href="https://link.jianshu.com/?t=http://cn.linux.vbird.org/linux_basic/0310vi.php" target="_blank" rel="noopener">vim 程序编辑器</a><br><a href="https://www.jianshu.com/p/7678a7e6973e" target="_blank" rel="noopener">http://www.jianshu.com/p/7678a7e6973e</a><br><a href="https://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="noopener">http://www.jianshu.com/p/bcbe916f97e1</a><br><a href="https://link.jianshu.com/?t=http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时任务Crontab详解</title>
      <link href="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="noopener">文章出处</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux系统是由cron（crond）这个系统服务来控制的。Linux系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。</p><a id="more"></a><h1 id="一-crond简介"><a href="#一-crond简介" class="headerlink" title="一 crond简介"></a>一 crond简介</h1><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>/etc/crontab文件包括下面几行：<br><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/e8696488-4891-4358-a0ed-22f305460374.png" alt></p><p>前 四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行 命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p><p>使用者权限文件：</p><p>/etc/cron.deny<br>说明：<br>该文件中所列用户不允许使用crontab命令</p><p>/etc/cron.allow<br>说明：<br>该文件中所列用户允许使用crontab命令</p><p>/var/spool/cron/<br>说明：<br>所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><p>minute hour day month week command<br>其中：</p><p>minute： 表示分钟，可以是从0到59之间的任何整数。</p><p>hour：表示小时，可以是从0到23之间的任何整数。</p><p>day：表示日期，可以是从1到31之间的任何整数。</p><p>month：表示月份，可以是从1到12之间的任何整数。</p><p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p><p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p><p><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/513841-20160812102124078-171184924.png" alt></p><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h1 id="二-crontab命令详解"><a href="#二-crontab命令详解" class="headerlink" title="二 crontab命令详解"></a>二 crontab命令详解</h1><h2 id="2-1-命令格式："><a href="#2-1-命令格式：" class="headerlink" title="2.1 命令格式："></a>2.1 命令格式：</h2><p>crontab [-u user] file</p><p>crontab [-u user] [ -e | -l | -r ]</p><h2 id="2-2-命令功能："><a href="#2-2-命令功能：" class="headerlink" title="2.2 命令功能："></a>2.2 命令功能：</h2><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><h2 id="2-3-命令参数："><a href="#2-3-命令参数：" class="headerlink" title="2.3 命令参数："></a>2.3 命令参数：</h2><p>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</p><p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</p><p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</p><p>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</p><p>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</p><p>-i：在删除用户的crontab文件时给确认提示。</p><h2 id="2-4-常用方法："><a href="#2-4-常用方法：" class="headerlink" title="2.4 常用方法："></a>2.4 常用方法：</h2><h3 id="2-4-1-创建一个新的crontab文件"><a href="#2-4-1-创建一个新的crontab文件" class="headerlink" title="2.4.1 创建一个新的crontab文件"></a>2.4.1 创建一个新的crontab文件</h3><p>在 考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其 中加入这样一行：</p><p>EDITOR=vi; export EDITOR</p><p>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</user></user></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># (put your own initials here)echo the date to the console every</span><br><span class="line"></span><br><span class="line"># 15minutes between 6pm and 6am</span><br><span class="line"></span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo ‘date’ &gt; &#x2F;dev&#x2F;console</span><br></pre></td></tr></table></figure><p>保存并退出。确信前面5个域用空格分隔。</p><p>在 上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab davecron</span><br></pre></td></tr></table></figure><p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。</p><p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p><h3 id="2-4-2-列出crontab文件"><a href="#2-4-2-列出crontab文件" class="headerlink" title="2.4.2 列出crontab文件"></a>2.4.2 列出crontab文件</h3><p>为了列出crontab文件，可以用：</p><p>$ crontab -l</p><p>0,15,30,45,18-06 * * * /bin/echo <code>date</code> &gt; dev/tty1</p><p>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：</p><p>$ crontab -l &gt; $HOME/mycron</p><p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><h3 id="2-4-3-编辑crontab文件"><a href="#2-4-3-编辑crontab文件" class="headerlink" title="2.4.3 编辑crontab文件"></a>2.4.3 编辑crontab文件</h3><p>如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为：</p><p>$ crontab -e</p><p>可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p><p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line"></span><br><span class="line">30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name “core’ -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"></span><br><span class="line"># (crondave installed on Tue May 4 13:07:43 1999)</span><br><span class="line"></span><br><span class="line"># DT:ech the date to the console every 30 minites</span><br><span class="line"></span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo &#96;date&#96; &gt; &#x2F;dev&#x2F;tty1</span><br><span class="line"></span><br><span class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line"></span><br><span class="line">30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name “core’ -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-删除crontab文件"><a href="#2-4-4-删除crontab文件" class="headerlink" title="2.4.4 删除crontab文件"></a>2.4.4 删除crontab文件</h3><p>要删除crontab文件，可以用：</p><p>$ crontab -r</p><h3 id="2-4-5-恢复丢失的crontab文件"><a href="#2-4-5-恢复丢失的crontab文件" class="headerlink" title="2.4.5 恢复丢失的crontab文件"></a>2.4.5 恢复丢失的crontab文件</h3><p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：</username></username></p><p>$ crontab <filename></filename></p><p>其中，<filename>是你在$ H O M E目录中副本的文件名。</filename></p><p>我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。</Ctrl-D></p><h1 id="三-使用实例"><a href="#三-使用实例" class="headerlink" title="三 使用实例"></a>三 使用实例</h1><p>实例1：每1分钟执行一次command<br>命令：</p><ul><li><ul><li><ul><li><ul><li><ul><li>command</li></ul></li></ul></li></ul></li></ul></li></ul><p>实例2：每小时的第3和第15分钟执行<br>命令：<br>3,15 * * * * command</p><p>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * * command</p><p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 */2 * * command</p><p>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * 1 command</p><p>实例6：每晚的21:30重启smb<br>命令：<br>30 21 * * * /etc/init.d/smb restart</p><p>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<br>45 4 1,10,22 * * /etc/init.d/smb restart</p><p>实例8：每周六、周日的1 : 10重启smb<br>命令：<br>10 1 * * 6,0 /etc/init.d/smb restart</p><p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<br>0,30 18-23 * * * /etc/init.d/smb restart</p><p>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<br>0 23 * * 6 /etc/init.d/smb restart</p><p>实例11：每一小时重启smb<br>命令：</p><ul><li>*/1 * * * /etc/init.d/smb restart</li></ul><p>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：</p><ul><li>23-7/1 * * * /etc/init.d/smb restart</li></ul><p>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<br>0 11 4 * mon-wed /etc/init.d/smb restart</p><p>实例14：一月一号的4点重启smb<br>命令：<br>0 4 1 jan * /etc/init.d/smb restart</p><p>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<br>01 * * * * root run-parts /etc/cron.hourly<br>说明：<br>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p><h1 id="四-使用注意事项"><a href="#四-使用注意事项" class="headerlink" title="四 使用注意事项"></a>四 使用注意事项</h1><p>注意环境变量问题<br>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p><p>在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。</p><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><p>1）脚本中涉及文件路径时写全局路径；</p><p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export RUN_CONF&#x3D;&#x2F;home&#x2F;d139&#x2F;conf&#x2F;platform&#x2F;cbp&#x2F;cbp_jboss.conf</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;jboss-4.0.5&#x2F;bin&#x2F;run.sh -c mev &amp;</span><br></pre></td></tr></table></figure><p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><p>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p><p>注意清理系统用户的邮件日志<br>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p><p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p><p>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p><p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p><p>系统级任务调度与用户级任务调度<br>系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。</p><p>其他注意事项<br>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p><p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用插件及乱码</title>
      <link href="/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-清空文件"><a href="#1-清空文件" class="headerlink" title="1. 清空文件"></a>1. 清空文件</h1><blockquote><p>filename 或者 : &gt; filename</p></blockquote><h1 id="2-configure-make-make-install"><a href="#2-configure-make-make-install" class="headerlink" title="2. ./configure make make install"></a>2. ./configure make make install</h1><ul><li><p>./configure 检测安装平台的目标特征的。如会检测是不是有CC或者GCC，并不是需要CC或者GCC，它是个shell脚本，生成Makefile,为下一步的编译做准备。</p><a id="more"></a></li><li><p>make 用来编译的，它从 Makefile读取指令，然后编译。</p></li><li><p>make install 用来安装。他也从 Makefile中读取指令，安装到指定的位置。</p></li></ul><h2 id="2-1-configure"><a href="#2-1-configure" class="headerlink" title="2.1 ./configure"></a>2.1 ./configure</h2><p>一般用来生成 Makefile，为下一步的编译做准备。</p><p>你可以通过在 configure 后加上参数来对安装进行控制，比如代码:</p><p>./configure –prefix=/usr<br>意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin)，资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。<br>同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><h2 id="2-2-make"><a href="#2-2-make" class="headerlink" title="2.2 make"></a>2.2 make</h2><p>make 的作用是开始进行源代码编译，</p><p>以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。</p><p>如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行）。</p><p>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。</p><p>一般情况下，他所使用的 Makefile ，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><h2 id="2-3-make-install"><a href="#2-3-make-install" class="headerlink" title="2.3 make install"></a>2.3 make install</h2><p>安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（sudo make install</p><h1 id="3-搜索安装包路径"><a href="#3-搜索安装包路径" class="headerlink" title="3. 搜索安装包路径"></a>3. 搜索安装包路径</h1><p>whereis 安装包<br>如：whereis vim<br>    whereis tree</p><h1 id="4-编辑器"><a href="#4-编辑器" class="headerlink" title="4. 编辑器"></a>4. 编辑器</h1><p>yum instsall vim</p><h1 id="5-树形目录"><a href="#5-树形目录" class="headerlink" title="5. 树形目录"></a>5. 树形目录</h1><p>yun install tree</p><h1 id="6-通用下载方式"><a href="#6-通用下载方式" class="headerlink" title="6. 通用下载方式"></a>6. 通用下载方式</h1><p>yum install wget</p><h1 id="7-上传下载下工具"><a href="#7-上传下载下工具" class="headerlink" title="7. 上传下载下工具"></a>7. 上传下载下工具</h1><p>yum install lrzsz</p><h1 id="8-CentOS6-中文乱码解决"><a href="#8-CentOS6-中文乱码解决" class="headerlink" title="8. CentOS6 中文乱码解决"></a>8. CentOS6 中文乱码解决</h1><h2 id="8-1-安装语言包"><a href="#8-1-安装语言包" class="headerlink" title="8.1 安装语言包"></a>8.1 安装语言包</h2><p>yum groupinstall chinese-support</p><h2 id="8-2-设置字符集"><a href="#8-2-设置字符集" class="headerlink" title="8.2 设置字符集"></a>8.2 设置字符集</h2><h3 id="8-2-1临时生效-好像不管用"><a href="#8-2-1临时生效-好像不管用" class="headerlink" title="8.2.1临时生效(好像不管用)"></a>8.2.1临时生效(好像不管用)</h3><p>export LANG=”zh_CN.UTF-8” ## 设置为中文<br>export LANG=”en-US.UTF-8” ## 设置为英文</p><h3 id="8-2-2永久生效"><a href="#8-2-2永久生效" class="headerlink" title="8.2.2永久生效"></a>8.2.2永久生效</h3><p>vi /etc/sysconfig/i18n(最好reboot下)<br>LANG =”zh_CN.UTF-8”</p><p>或者<br>vi /etc/profile配置文件，添加一行<br>export LANG=”zh_CN.UTF-8”<br>重新载入<br>./etc/profile</p><p>查看当前字符集<br>echo $LANG</p><h1 id="9-CentOS7中英文乱码解决"><a href="#9-CentOS7中英文乱码解决" class="headerlink" title="9. CentOS7中英文乱码解决"></a>9. CentOS7中英文乱码解决</h1><h2 id="9-1-安装中文库"><a href="#9-1-安装中文库" class="headerlink" title="9.1 安装中文库"></a>9.1 安装中文库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure><h2 id="9-2-检查是否有中文语言包"><a href="#9-2-检查是否有中文语言包" class="headerlink" title="9.2 检查是否有中文语言包"></a>9.2 检查是否有中文语言包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure><h2 id="9-3-查看当前系统语言环境"><a href="#9-3-查看当前系统语言环境" class="headerlink" title="9.3 查看当前系统语言环境"></a>9.3 查看当前系统语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale</span><br></pre></td></tr></table></figure><h2 id="9-4-修改本机语言环境"><a href="#9-4-修改本机语言环境" class="headerlink" title="9.4 修改本机语言环境"></a>9.4 修改本机语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locale -a | grep &quot;zh_CN&quot;</span><br><span class="line"></span><br><span class="line">一个一个试。目前是 zh_CN有效果</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;locale.conf</span><br><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">source &#x2F;etc&#x2F;locale.conf</span><br></pre></td></tr></table></figure><h2 id="9-5-重启系统"><a href="#9-5-重启系统" class="headerlink" title="9.5 重启系统"></a>9.5 重启系统</h2><p>个人电脑可以，公司还需谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装常用软件</title>
      <link href="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="mysql国内镜像下载网址"><a href="#mysql国内镜像下载网址" class="headerlink" title="mysql国内镜像下载网址"></a>mysql国内镜像下载网址</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><h1 id="开源镜像站点汇总"><a href="#开源镜像站点汇总" class="headerlink" title="开源镜像站点汇总"></a>开源镜像站点汇总</h1><p><a href="http://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000375848</a></p><p><a href="https://opsx.alibaba.com/mirror/search?q=mysq5.7&lang=zh-CN" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror/search?q=mysq5.7&amp;lang=zh-CN</a></p><p><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p><h1 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h1><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">java包</a></p><h2 id="手动解压"><a href="#手动解压" class="headerlink" title="手动解压"></a>手动解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;</span><br><span class="line">make java</span><br><span class="line">[root@haoransun java]# wget https:&#x2F;&#x2F;download.oracle.com&#x2F;otn&#x2F;java&#x2F;jdk&#x2F;8u211-b12&#x2F;478a62b7d4e34b78b671c754eaaf38ab&#x2F;jdk-8u211-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">此方式不推荐使用。</span><br><span class="line"></span><br><span class="line">或者直接将jar由 winSCP包传导至Linux指定目录</span><br><span class="line"></span><br><span class="line">配置环境变量</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">将下列配置文件添加，保存退出(一定要去掉等号两边的空格)</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">export CLASSPATH&#x3D;.$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line">:wq</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">java -version 或者 jps 验证即可</span><br></pre></td></tr></table></figure><p>wget 方式不推荐使用，会出现无法解压的情况，用wget命令直接下载的JDK，这是问题的根源。</p><p>去Oracle官网下载过jdk的童鞋应该都知道，下载之前需要同意Oracle的安装协议，不然不能下载，但是用wget的方式，默认是不同意，虽然能下载下来，但是下载下来的文件会有问题，所以在Linux上解压一直失败。</p><p>后来去官网下载好，然后传到服务器上，再解压就没有问题了。</p><hr><h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum search java | grep jdk</span><br><span class="line">yum install java-1.8.0-openjdk</span><br><span class="line">默认安装在 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;</span><br><span class="line">配置环境变量及验证安装</span><br></pre></td></tr></table></figure><hr><h2 id="rpm-安装"><a href="#rpm-安装" class="headerlink" title="rpm 安装"></a>rpm 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh  指定安装包</span><br><span class="line">配置环境变量。验证安装</span><br></pre></td></tr></table></figure><h1 id="CentOS7-安装-MySQL5-7"><a href="#CentOS7-安装-MySQL5-7" class="headerlink" title="CentOS7 安装 MySQL5.7"></a>CentOS7 安装 MySQL5.7</h1><p>安装环境：CentOS7 64位 mini版，安装MySQL5.7</p><p>mysql-client和server的区别：<br><strong>本质上的区别是：server是执行一个crud操作，client是发送一个crud操作</strong></p><p>server是把sql语句翻译成对内存和文件的操作，也就是说，server是直接操作文件的。</p><p>而client是对数据库/表进行操作，不是直接对文件进行操作。</p><p>举个例子：<br>①client：我用一个Navicat去链接一个数据库，这个Navicat就是client。</p><p>②server：我有多个mysql服务实例，他们可以位于不同的端口（这句不重要），但是他们是挂载在了宿主机同一个目录下的（这句重要，对内存/文件进行操作了），而且数据共享（这句也不重要）。</p><p>小知识点：</p><p>①sql只是去知道server如何去操作数据。</p><p>②即使C/S在同一台机器上，他们也是通过网络通讯的。</p><h2 id="1-配置-YUM源"><a href="#1-配置-YUM源" class="headerlink" title="1. 配置 YUM源"></a>1. 配置 YUM源</h2><p>在<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">MySQL</a>官网中下载YUM源rpm安装包：<a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/repo/yum/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载mysql源安装包</span><br><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">安装mysql源</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong><font color="red">由于某些原因，下载过慢，可以参考最上方的国内网址进行下载，</font>如下所示：</strong><br><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/060fa4bb-b320-4095-bd6c-aab5b5f1f232.png" alt></p><ul><li><strong>1</strong> 右键选择，复制链接地址，到Linux中  wget 链接地址，下载 xxx.rpm安装包<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/a7aa735c-9414-4e83-beae-d17b54ce252e.png" alt></li><li><strong>2</strong> sudo rpm -ivh 上述mysql安装包</li><li><strong>3</strong> 安装MySql sudo yum install mysql-server<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/adb53ba1-80e5-413e-8cf0-16cd3b40b621.png" alt></li></ul><p>看到上图所示，则表示安装成功。</p><h2 id="2-启动MySQL服务"><a href="#2-启动MySQL服务" class="headerlink" title="2. 启动MySQL服务"></a>2. 启动MySQL服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL的启动状态<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/c8cbc2ec-f7aa-4adb-8729-3abbb7b9396b.png" alt></p><h2 id="3-开机启动"><a href="#3-开机启动" class="headerlink" title="3. 开机启动"></a>3. 开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="4-修改root默认密码"><a href="#4-修改root默认密码" class="headerlink" title="4. 修改root默认密码"></a>4. 修改root默认密码</h2><p>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/5bbf95fd-6e34-40ef-a1c7-ad57bea532e0.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">mysql &gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Sun@123456!&#39;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;MyNewPass4!&#39;);</span><br></pre></td></tr></table></figure><p>注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示：</p><p>通过msyql环境变量可以查看密码策略的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%password%&#39;;</span><br></pre></td></tr></table></figure><p> validate_password_policy：密码策略，默认为MEDIUM策略  validate_password_dictionary_file：密码策略文件，策略为STRONG才需要  validate_password_length：密码最少长度  validate_password_mixed_case_count：大小写字符长度，至少1个  validate_password_number_count ：数字至少1个  validate_password_special_char_count：特殊字符至少1个  _上述参数是默认策略MEDIUM的密码检查规则。</p><p>共有以下几种密码策略：</p><table><thead><tr><th>策略</th><th>检查规则</th></tr></thead><tbody><tr><td>0 or LOW</td><td>Length</td></tr><tr><td>1 or MEDIUM</td><td>Length; numeric, lowercase/uppercase, and special characters</td></tr><tr><td>2 or STRONG</td><td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td></tr><tr><td>MySQL官网密码策略详细说明：<a href="http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy</a></td><td></td></tr></tbody></table><h4 id="修改密码策略"><a href="#修改密码策略" class="headerlink" title="修改密码策略"></a>修改密码策略</h4><p>在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</span><br><span class="line">validate_password_policy&#x3D;0</span><br></pre></td></tr></table></figure><p>如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate_password &#x3D; off</span><br></pre></td></tr></table></figure><p>重新启动mysql服务使配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h2 id="5-添加远程登录用户"><a href="#5-添加远程登录用户" class="headerlink" title="5. 添加远程登录用户"></a>5. 添加远程登录用户</h2><p>默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sunhaoran&#39;@&#39;%&#39; IDENTIFIED BY &#39;Sun@123456&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h2 id="6-配置默认编码为-utf8"><a href="#6-配置默认编码为-utf8" class="headerlink" title="6. 配置默认编码为 utf8"></a>6. 配置默认编码为 utf8</h2><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure><p>重新启动mysql服务，查看<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">数据库</a>默认编码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;character%&#39;;</span><br></pre></td></tr></table></figure><p><strong>默认配置文件路径：</strong>  配置文件：/etc/my.cnf  日志文件：/var/log//var/log/mysqld.log  服务启动脚本：/usr/lib/systemd/system/mysqld.service  socket文件：/var/run/mysqld/mysqld.pid</p><h3 id="mysql-基本操作"><a href="#mysql-基本操作" class="headerlink" title="mysql 基本操作"></a>mysql 基本操作</h3><h4 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 回车</span><br><span class="line">输入密码回车即可</span><br><span class="line">数据库查看：show databases;</span><br><span class="line">数据库选择：use xx;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Host-Vm相互ping不同到的解决办法</title>
      <link href="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天总结一下前段时间出现的一些虚拟机问题，之前配置的宿主机ping虚拟机以及虚拟机ping外网没有什么问题，但是后来不知道什么原因突然就ping不通了，经过网上各种找资料，研究了下VM0,1,8的区别，为了防止遗忘在此记录。</p><a id="more"></a><h2 id="两机互ping的问题"><a href="#两机互ping的问题" class="headerlink" title="两机互ping的问题"></a>两机互ping的问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VMnet0使用的是桥接模式，安装VM后默认的就是这种模式，这种模式一般是只需要一台虚拟机与宿主机可以互通，并且虚拟机可以访问外网。VMnet1是使用host-only模式，即虚拟机只能与主机构成内部通信，无法对外网进行通信。<font color="red">VMnet8使用的是NAT网络模式，这种模式一般是一台宿主机以及多台虚拟机，在构建hadoop分布式集群的时候就是采用这种模式的。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了上面三个的区别，下面就可以亲手实验一番了。首先看下自己创建的虚拟机的网关地址，看下面2张图，选择创建的虚拟机，在编辑中选择<font color="red">虚拟网络编辑器，选择VMnet8,点击NAT设置，可以看到虚拟机的网关地址是192.168.80.2</font><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/d1702534-20f1-4b7c-a261-e485335b1c32.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/51b2659f-8316-46d5-b5d2-2f4f519da6fe.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是找到宿主机的网关地址，看下面两个图，在控制面板的网络连接中找到VMnet8，右键选择属性，在网络中找到IPv4选项再次点击属性，<font color="red">这里出现的问题时我这里不知道为什么手动选择IP地址下面的全成空了，</font>这就是我为什么出现ping不同的原因了，这里配置IP地址为192.168.80.1，子网掩码与虚拟机的子网掩码保持一致即可，保存。<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a5aeda05-11b2-4236-96e1-878a0e475db2.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/bd88b882-dec1-412b-85c5-c141dee5eba1.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后修改虚拟机的网络适配器模式为NAT模式，选择创建好的虚拟机，在网络适配器中选中即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来进入虚拟机，修改配置文件，</p><ol><li>CentOS6.5 vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/91c717c7-f0a5-45fb-ae74-58cbaba603e7.png" alt></li><li>修改ifcfg-ens33配置文件，这里用的是CentOS7，按具体情况来，根据之前查到的虚拟机网关及子网掩码配置如下：<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a375362f-3899-4f21-b131-daf5fecc9009.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存之后，通过 service network restart重启即可，在宿主机与虚拟机分别用ping命令测试发现可以ping通，OK。<h2 id="虚拟机上网问题"><a href="#虚拟机上网问题" class="headerlink" title="虚拟机上网问题"></a>虚拟机上网问题</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以在宿主机使用xshell进行虚拟机连接了，方便操作，还有一个问题是之前虚拟机可以ping通外网的，现在突然连不上了，这样如果在虚拟机中下载一些软件安装包就会出现问题，查找了一下资料，发现:<font color="red">是因为没有设置dns服务器导致的，修改/etc/resolv.conf配置文件即可</font>，向里面加入dns服务器地址，它是DNS客户机配置文件，用于设置DNS服务器的IP地址地址及DNS域名，添加如下两个地址即可ping通外网了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 168.95.1.1</span><br><span class="line">nameserver 168.95.192.1</span><br></pre></td></tr></table></figure>测试一下，ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 发现ping通，OK</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
