<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3-3-Docker容器用法</title>
      <link href="/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h2><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><a id="more"></a><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;</span><br><span class="line">Unable to find image &#39;ubuntu:14.04&#39; locally 14.04: Pulling from  library&#x2F;ubuntu cb56c90f0b30: Pull complete 0acc551e5716: Pull complete 8956dcd35143: Pull complete 908242721214: Pull complete b44ff14dd3bb: Pull complete Digest: sha256:5faf6cb681da2be979a177b60d8c18497f962e3d82268c49db6c74008d0c294d Status: Downloaded newer image for ubuntu:14.04 Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 &#x2F;bin&#x2F;bash root@af8bae53bdd3:&#x2F;#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@af8bae53bdd3:&#x2F;# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:&#x2F;# ps</span><br><span class="line">PID  TTY  TIME  CMD  </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="查看正在运行中的容器"><a href="#查看正在运行中的容器" class="headerlink" title="查看正在运行中的容器"></a>查看正在运行中的容器</h3><p>利用 <code>docker ps</code> 命令可以查看正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  25 minutes ago Exited (0) 25 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><h3 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h3><p>可以利用 <code>docker start</code> 命令和上面使用 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，直接将一个已经终止的容器启动运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker start relaxed_kilby</span><br><span class="line"></span><br><span class="line">relaxed_kilby</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  45 minutes ago Exited (0) 3 seconds ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><p>这里把 <strong>新建并启动</strong> 章节中的容器又启动了一次,这次这个容器和之前不一样,他启动之后就会被终止,不会输出一个 “Hello World”，之后才终止容器。可以看 <code>STATUS</code> 输出,这个容器的确被启动过.</p><h3 id="容器后台运行"><a href="#容器后台运行" class="headerlink" title="容器后台运行"></a>容器后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; </span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果(STDOUT)打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和docker run指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 命令来查看容器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">77b2dc01fe0f ubuntu:14.04 &#x2F;bin&#x2F;sh -c &#39;while tr 2 minutes ago Up 1 minute agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs [container ID  or  NAMES] hello world </span><br><span class="line">hello world </span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop web2 </span><br><span class="line"></span><br><span class="line">web2</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot; About an hour ago Exited (0) 15 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Exited (0) 3  seconds ago web2 71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world &quot;&#x2F;hello&quot;  2 days ago Exited (0) 2 days ago peaceful_brown</span><br></pre></td></tr></table></figure><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止</p><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p><code>docker restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，有很多种方法，包括使用 <code>docker attach</code> 命令或 <code>nsenter</code> 工具等。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><p><code>docker attach</code> 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550  </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><p>是使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h3 id="nsenter-命令"><a href="#nsenter-命令" class="headerlink" title="nsenter 命令"></a>nsenter 命令</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><code>nsenter</code> 工具在 util-linux 包2.23版本后包含。<br>可以使用 <code>nsenter -V</code> 查看系统是否安装了 <code>nsenter</code> 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter -V</span><br><span class="line"></span><br><span class="line">nsenter from util-linux  2.23.2</span><br></pre></td></tr></table></figure><p>如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; curl https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;utils&#x2F;util-linux&#x2F;v2.24&#x2F;util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24; </span><br><span class="line">$ .&#x2F;configure --without-ncurses </span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>senter</code> 启动一个新的shell进程(默认是/bin/bash), 同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限。</p><p>为了连接到容器，你还需要找到容器的第一个进程的 PID，可以通过下面的命令获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID&#x3D;$(docker inspect --format  &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个 PID，就可以连接到这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $PID  --mount  --uts  --ipc  --net  --pid</span><br></pre></td></tr></table></figure><p>如果无法通过以上命令连接到这个容器，有可能是因为宿主的默认 shell 在容器中并不存在，比如zsh，可以使用如下命令显式地使用bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $pid  --mount  --uts  --ipc  --net  --pid  --  &#x2F;usr&#x2F;bin&#x2F;env  \  --ignore-environment  HOME&#x3D;&#x2F;root  &#x2F;bin&#x2F;bash  --login</span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubunt</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  </span><br><span class="line">243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia $ PID&#x3D;$(docker-pid 243c32535da7) 10981 </span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid </span><br><span class="line">root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><h2 id="导出和导入容器快照"><a href="#导出和导入容器快照" class="headerlink" title="导出和导入容器快照"></a>导出和导入容器快照</h2><h3 id="导出容器快照"><a href="#导出容器快照" class="headerlink" title="导出容器快照"></a>导出容器快照</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">7691a814370e ubuntu:14.04  &quot;&#x2F;bin&#x2F;bash&quot;  36 hours ago Exited (0) 21 hours ago test </span><br><span class="line">$ sudo docker export  7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test&#x2F;ubuntu v1.0  </span><br><span class="line">9d37a6082e97 About a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure><p>*注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也$sudo docker rm trusting_newton trusting_newton要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker rm trusting_newton trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="清理所有处于终止状态的容器-不建议使用"><a href="#清理所有处于终止状态的容器-不建议使用" class="headerlink" title="清理所有处于终止状态的容器(不建议使用)"></a>清理所有处于终止状态的容器(不建议使用)</h2><p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的 <code>docker rm</code> 默认并不会删除运行中的容器</p><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用阿里云这样的公共仓库可能不方便，用户可以创建一个本地仓库供自己使用。</p><h3 id="如何使用本地仓库"><a href="#如何使用本地仓库" class="headerlink" title="如何使用本地仓库"></a>如何使用本地仓库</h3><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器中运行-docker-registry"><a href="#容器中运行-docker-registry" class="headerlink" title="容器中运行 docker-registry"></a>容器中运行 docker-registry</h4><p>在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 registry 镜像来启动本地的私有仓库。<br>用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run \ </span><br><span class="line">-e SETTINGS_FLAVOR&#x3D;s3 \ </span><br><span class="line">-e AWS_BUCKET&#x3D;acme-docker \ </span><br><span class="line">-e STORAGE_PATH&#x3D;&#x2F;registry \ </span><br><span class="line">-e AWS_KEY&#x3D;AKIAHSHB43HS3J92MXZ \ </span><br><span class="line">-e AWS_SECRET&#x3D;xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \ </span><br><span class="line">-e SEARCH_BACKEND&#x3D;sqlalchemy \ </span><br><span class="line">-p 5000:5000 \ </span><br><span class="line">registry</span><br></pre></td></tr></table></figure><p>此外，还可以指定本地路径（如 <code>/home/user/registry-conf</code> ）下的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;home&#x2F;user&#x2F;registry-conf:&#x2F;registry-conf  -e DOCKER_REGISTRY_CONFIG&#x3D;&#x2F;registry-conf&#x2F;config.yml registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>（v1 中是<code>/tmp/registry</code>）下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry</span><br></pre></td></tr></table></figure><h4 id="本地安装-docker-registry"><a href="#本地安装-docker-registry" class="headerlink" title="本地安装 docker-registry"></a>本地安装 docker-registry</h4><p>对于 CentOS 发行版，可以直接通过源安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel </span><br><span class="line">$ sudo python-pip install docker-registry</span><br></pre></td></tr></table></figure><p>也可以从 <a href="https://link.jianshu.com/?t=https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a> 项目下载源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev </span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-registry.git </span><br><span class="line">$ cd docker-registry </span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>然后修改配置文件，主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp config&#x2F;config_sample.yml config&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>之后启动 Web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn -c contrib&#x2F;gunicorn.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn --access-logfile  -  --error-logfile  -  -k gevent -b  0.0.0.0:5000  -w  4  --max-requests  100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功</p><p>*注：<code>config/config_sample.yml</code> 文件是示例配置文件。</p><h3 id="在私有仓库上传、下载、搜索镜像"><a href="#在私有仓库上传、下载、搜索镜像" class="headerlink" title="在私有仓库上传、下载、搜索镜像"></a>在私有仓库上传、下载、搜索镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 <code>192.168.7.26:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用<code>docker tag</code> 将 <code>ba58</code> 这个镜像标记为 <code>192.168.7.26:5000/test</code>（格式为 <code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag ba58 192.168.7.26:5000&#x2F;test</span><br><span class="line">root ~ # docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.7.26:5000&#x2F;test</span><br><span class="line">The push refers to  a repository [192.168.7.26:5000&#x2F;test] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository 192.168.7.26:5000&#x2F;test (1 tags)</span><br><span class="line">Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping</span><br><span class="line">Pushing tag for rev [ba5877dc9bec] on &#123;http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;repositories&#x2F;test&#x2F;tags&#x2F;latest&#125;</span><br></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;search</span><br><span class="line">&#123;&quot;num_results&quot;:  7, &quot;query&quot;:  &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;tomcat&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu_office&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;desktop_ubu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;dockerfile&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;test&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code>，表明镜像已经被成功上传了。</p><p>现在可以到另外一台机器去下载这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull 192.168.7.26:5000&#x2F;test</span><br><span class="line">Pulling repository 192.168.7.26:5000&#x2F;test</span><br><span class="line">ba5877dc9bec: Download complete </span><br><span class="line">511136ea3c5a: Download complete </span><br><span class="line">9bad880da3d2: Download complete </span><br><span class="line">25f11f5fb0cb: Download complete </span><br><span class="line">ebc34468f71d: Download complete </span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><h1 id="Docker-数据管理"><a href="#Docker-数据管理" class="headerlink" title="Docker 数据管理"></a>Docker 数据管理</h1><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li><li>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。<h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3></li></ul><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>*注意：也可以在 Dockerfile 中使用 <code>VOLUME</code> 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个<a href="https://github.com/moby/moby/pull/8484" target="_blank" rel="noopener">PR</a>。</p><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>-v</code> 标记也可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code><br>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><p>*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>:ro</code> 之后，就挂载为只读了。</p><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看指定容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的<code>/var/lib/docker/volumes/</code>下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123; &quot;&#x2F;webapp&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;fac362...80535&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123; &quot;&#x2F;webapp&quot;: true &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的<code>/mnt/sda1/var/lib/docker/volumes/....</code>下面了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mounts&quot;: [ </span><br><span class="line">    &#123; </span><br><span class="line">        &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, </span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&#x2F;_data&quot;, </span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;webapp&quot;, </span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;, </span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;, </span><br><span class="line">        &quot;RW&quot;: true, </span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot; </span><br><span class="line">    &#125; </span><br><span class="line">] </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>-v</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><p>*注意：如果直接挂载一个文件，很多文件编辑工具，包括 <code>vi</code> 或者 <code>sed --in-place</code>，可能会造成文件 inode 的改变，从 Docker 1.1<br>.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>首先，创建一个名为 dbdata 的数据卷容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -v &#x2F;dbdata --name dbdata training&#x2F;postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure><p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training&#x2F;postgres </span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>可以使用超过一个的 <code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷。<br>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db3 --volumes-from db1 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。<br>这可以让用户在容器之间升级和移动数据卷。</p><h2 id="利用数据卷容器来备份、恢复、迁移数据卷"><a href="#利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="利用数据卷容器来备份、恢复、迁移数据卷"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><p>可以利用数据卷对其中的数据进行进行备份、恢复和迁移</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 <code>backup.tar</code> 的文件。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</span><br></pre></td></tr></table></figure><p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run  --volumes-from dbdata2 busybox &#x2F;bin&#x2F;ls &#x2F;dbdata</span><br></pre></td></tr></table></figure><h2 id="Docker-中的网络功能介绍"><a href="#Docker-中的网络功能介绍" class="headerlink" title="Docker 中的网络功能介绍"></a>Docker 中的网络功能介绍</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P training&#x2F;webapp python app.py</span><br><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">bc533791f3f5 training&#x2F;webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000&#x2F;tcp nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f nostalgic_morse</span><br><span class="line">* Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F;</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F; HTTP&#x2F;1.1&quot;  200 -</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;  404 -</span><br></pre></td></tr></table></figure><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 udp 标记来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 使用 &#96;docker port&#96; 来查看当前映射的端口配置，也可以查看到绑定的地址127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -p  3000:80 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li></ul><p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p><p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有2个好处</p><ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul><p>使用 <code>--name</code> 标记可以为容器自定义命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>使用 <code>docker ps</code> 来验证设定的命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f  &quot;&#123;&#123; .Name &#125;&#125;&quot; aed84ee21bde</span><br><span class="line">&#x2F;web</span><br></pre></td></tr></table></figure><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用<code>docker rm</code> 来删除之前创建的同名容器。</p><p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code>参数不能同时使用。</p><h3 id="容器互联-1"><a href="#容器互联-1" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p><p>下面先创建一个新的数据库容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>除之前创建的 web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f web</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web --link db:db training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。</p><p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p><p>使用 <code>docker ps</code> 来查看容器的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">349169744e49 training&#x2F;postgres:latest su postgres -c &#39;&#x2F;usr About a minute ago Up About a minute 5432&#x2F;tcp db, web&#x2F;db </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 16 hours ago Up 2 minutes 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p><p>Docker 通过 2 种方式为容器公开连接信息</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件<br>使用 <code>env</code> 命令来查看 web 容器的环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training&#x2F;webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME&#x3D;&#x2F;web2&#x2F;db DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP_PROTO&#x3D;tcp DB_PORT_5000_TCP_PORT&#x3D;5432 DB_PORT_5000_TCP_ADDR&#x3D;172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</li></ul><p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training&#x2F;webapp &#x2F;bin&#x2F;bash</span><br><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">. . . </span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 </p><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# apt-get install -yqq inetutils-ping root@aed84ee21bde:&#x2F;opt&#x2F;webapp# ping db  </span><br><span class="line">PING db (172.17.0.5):  48 data bytes </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.267 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.250 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.256 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试db容器，它会解析成 <code>172.17.0.5</code>。<br>*注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2-Docker镜像用法</title>
      <link href="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><a id="more"></a><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx&#x2F;</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p><h2 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h2 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 <code>RUN</code>指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每一层构建需要的命令写出来,比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make&#39;  \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y  $buildDeps  \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.5.tar.gz&quot;  \  &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1  \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/23fb64e2-2346-432d-8f39-dad51df5c6a3.png" alt></p><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2/2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>785a648f6b86</code>，执行了所要求的命令，并最后提交了这一层 <code>3974e15fde03</code>，随后删除了所用到的这个容器 <code>785a648f6b86</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，我原本以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是_相对路径_。这也是新人经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 . </span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code>命令了。</p><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。<br><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo  $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。0</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>NTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run myip -i </span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通 </span><br><span class="line">$ docker run myip -i </span><br><span class="line">HTTP&#x2F;1.1  200 OK </span><br><span class="line">Server: nginx&#x2F;1.8.0  </span><br><span class="line">Date: Tue, 22 Nov 2016  05:12:40 GMT </span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8 </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2 </span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6 </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Via: 1.1  cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4  </span><br><span class="line">... </span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis </span><br><span class="line">... </span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] </span><br><span class="line"></span><br><span class="line">EXPOSE 6379 CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">... </span><br><span class="line"># allow the container to be started with &#96;--user&#96;  </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39;  -a  &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then </span><br><span class="line">chown -R redis . </span><br><span class="line">exec su-exec redis &quot;$0&quot;  &quot;$@&quot;  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec  &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \ </span><br><span class="line">NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ </span><br><span class="line">&amp;&amp; curl -SLO  &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \ </span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ </span><br><span class="line">&amp;&amp; grep  &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c -\ </span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \ </span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ </span><br><span class="line">&amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量引用： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v mydata:&#x2F;data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app </span><br><span class="line">RUN echo  &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常.</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code>格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \ </span><br><span class="line">CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker  run  -d  --name  web  -p 80:80  myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  3  seconds ago Up 2  seconds (health: starting) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  18  seconds ago Up 16  seconds (healthy) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code></p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool </span><br><span class="line">&#123; </span><br><span class="line">    &quot;FailingStreak&quot;: 0, </span><br><span class="line">    &quot;Log&quot;: [ </span><br><span class="line">        &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, </span><br><span class="line">        &quot;ExitCode&quot;: 0, </span><br><span class="line">        &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;&#x2F;p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.org&#x2F;\&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;\nCommercial support is available at\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.com&#x2F;\&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&quot;, </span><br><span class="line">        &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; </span><br><span class="line">    &#125; </span><br><span class="line">], </span><br><span class="line">&quot;Status&quot;: &quot;healthy&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ONBUILD-镜像复用及项目环境管理"><a href="#ONBUILD-镜像复用及项目环境管理" class="headerlink" title="ONBUILD 镜像复用及项目环境管理"></a>ONBUILD 镜像复用及项目环境管理</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F; </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。�第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新</p><p>么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">ONBUILD COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">ONBUILD COPY . &#x2F;app&#x2F;</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker rmi</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><em>注意 <code>docker rm</code> 命令是删除容器，不要混淆</em></p><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。<br>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY  TAG  IMAGE  ID  CREATED  SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5  MB redis alpine 501ad78535f0  3 weeks ago 21.03  MB docker latest cf693ec9b5c7 3 weeks ago 105.1  MB nginx latest e43d811ce2f4 5 weeks ago 181.5  MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 501</span><br><span class="line">Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi centos </span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged:centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c </span><br><span class="line">Deleted:sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted:sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests </span><br><span class="line">REPOSITORY  TAG  DIGEST  IMAGE  ID  CREATED  SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214  MB  $ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="用-docker-images-命令来配合"><a href="#用-docker-images-命令来配合" class="headerlink" title="用 docker images 命令来配合"></a>用 docker images 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。如删除虚悬镜像的指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1-Docker用法</title>
      <link href="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/"/>
      <url>/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="开启docker服务"><a href="#开启docker服务" class="headerlink" title="开启docker服务"></a>开启docker服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动并加入开机启动</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line">验证安装是否成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">有 client 和 server两部分即表示安装成功。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="获取镜像命令-docker-pull"><a href="#获取镜像命令-docker-pull" class="headerlink" title="获取镜像命令 docker pull"></a>获取镜像命令 docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，而镜像名称的格式：</p><ul><li><p>Docker Registry地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，既 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像.一定要配置镜像加速器,不然下载速度很慢。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="pull下来的-镜像-存储在哪里呢？"><a href="#pull下来的-镜像-存储在哪里呢？" class="headerlink" title="pull下来的 镜像 存储在哪里呢？"></a>pull下来的 镜像 存储在哪里呢？</h3></li></ul><p>1 进入 docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">ls</span><br><span class="line">builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>2 进入containers,每一个序列号，都是一个镜像，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd containers&#x2F;</span><br><span class="line"></span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a</span><br><span class="line">a0356a312020a4941b257ada41d72efb041f7034a70a987ec3d0f44e9cc19402</span><br><span class="line">b81decb15c1f1f821d1c56bdadc15b62506b6cc102a6f083ec7a9b5f89c2685b</span><br><span class="line">ea1236fd8c7f4ce919c0f56b87b642487ecd2bbec243d416dd1e34b313b27b92</span><br></pre></td></tr></table></figure><p>3 进入其中一个镜像，发现目录结构如下，这就是这个镜像的内容了，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun 61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a]# ls</span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a-json.log  hostconfig.json  mounts</span><br><span class="line">checkpoints                                                                hostname         resolv.conf</span><br><span class="line">config.v2.json                                                             hosts            resolv.conf.hash</span><br></pre></td></tr></table></figure><p>4 在containers同级目录，有个叫image的文件夹，进入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd images&#x2F;aufs</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution imagedb layerdb repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br><span class="line"></span><br><span class="line">如果image没有aufs目录的，可能是这样的</span><br><span class="line"></span><br><span class="line">cd image&#x2F;overlay2&#x2F;</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution  imagedb  layerdb  repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br></pre></td></tr></table></figure><h2 id="查看已下载的镜像-docker-images"><a href="#查看已下载的镜像-docker-images" class="headerlink" title="查看已下载的镜像 docker images"></a>查看已下载的镜像 docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">列表 包含了仓库名、标签、镜像ID、创建时间、所占空间。</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               2c5e00d77a67        3 weeks ago         188MB</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">[root@haoransun docker]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9de828f70b6d:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.6 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">root@9de828f70b6d:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令</p><ul><li><p><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:14.04</code>：这是指用<code>ubuntu:14.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 14.04.5 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="定制镜像"><a href="#定制镜像" class="headerlink" title="定制镜像"></a>定制镜像</h2><p>以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址,还要配置安全组放通对应的端口。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/749278bc-1a21-42ee-9643-a541b55dd3b5.png" alt></p><p>现在，改动这个欢迎页面，改成<code>Hello, Docker!</code>，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker exec -it webserver bash</span><br><span class="line">root@6415ebcbd369:&#x2F;# echo &#39;&lt;h1&gt;Hello,Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">root@6415ebcbd369:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e2cf02a5-8db5-451b-ad15-7144d09e93f2.png" alt></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff webserver</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/dd927ddb-c0ba-47dc-96fa-e7a5f48e5d4f.png" alt></p><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><p>现在已经定制好了,那我们如何把它保存下来形成镜像?</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而<strong>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>下面的命令将容器保存为镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker commit --author &#39;haoransun&lt;xxxx@qq.com&gt;&#39; --message &#39;修改Nginx欢迎页面&#39; webserver nginx:v2</span><br><span class="line">sha256:cef47606fca7dd6a5ee72986d18641ac754973120312a7015bb228dee64cc02a</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/d21dbdd8-e230-4888-b179-46ba0b5d22fd.png" alt></p><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。</p><p>可以用 <code>docker images</code> 命令看到这个新定制的镜像：</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e168773c-e547-4d5a-86fb-d72e60cee08d.png" alt></p><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/782171db-773a-4ade-8335-092e6da4d2d6.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。否则访问 虚拟机的地址如：192.168.121.100:81。</p><p>完成了第一次定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用  docker commit"></a>慎用  docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心没有清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p><code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制行为应该使用 <code>Dockerfile</code> 来完成。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2-Docker启动报错</title>
      <link href="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
      <url>/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>出处：<a href="https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA</a></p><h2 id="Docker虚拟化故障"><a href="#Docker虚拟化故障" class="headerlink" title="Docker虚拟化故障"></a>Docker虚拟化故障</h2><p>Docker虚拟化主要有三类故障：<br><strong>应用故障：</strong>应用执行状态与预期不一致。</p><p><strong>容器故障：</strong>无法正确创建、停止、更新容器等。</p><p><strong>集群故障：</strong>集群创建失败、更新失败、无法连接等。</p><a id="more"></a><h2 id="Docker-虚拟化故障排错"><a href="#Docker-虚拟化故障排错" class="headerlink" title="Docker 虚拟化故障排错"></a>Docker 虚拟化故障排错</h2><p>所有的Docker虚拟化故障排查诊断，都可以通过Docker命令行工具或者Web控制台来完成。</p><p>通过WEB控制台查看，需要自建控制台，对于Docker运维管理员来说，命令行工具排错是一个不错的帮手。</p><h3 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h3><p><strong>案例描述：</strong><br>生产环境，全新安装的Docker无法启动，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  docker.service</span><br><span class="line">Job for docker.service failed because the control process exited with  error code.See</span><br><span class="line">&quot;systemctl status docker.service&quot;  and  &quot;journalctl -xe&quot;  for details</span><br></pre></td></tr></table></figure><p>通过journalctl -xe命令查看启动的详细日志，启动daemon错误，因为Selinux不支持，Selinux阻挡了Docker引擎的启动，如图所示：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/bffe455a-b137-4cd1-b009-874dbeaaebf8.jpg" alt></p><p><strong>解决方案：</strong><br>如上问题，解决方法有两种：</p><p>1.Selinux主配置文件：</p><p>/etc/selinux/config，将配置文件中enforcing设置为disabled，然后重启系统，然后重启docker引擎即可。</p><p>2.docker主配置文件：</p><p>/etc/sysconfig/docker，将配置文件中–selinux-enabled选项为false，改成：–selinux-enabled=false即可。</p><h3 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  socket at step GROUP: No such process</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/3bf44228-5466-47a3-a7fb-eae0c2c85e13.jpg" alt></p><p><strong>解决方案：</strong><br>如上错误提示是因为Docker无法找到Group组信息，docker组有可能被误删除，解决方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.创建宿主机docker组即可，命令：groupadd docker；</span><br><span class="line">2.&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket文件，SocketGroup&#x3D;修改为root也可以；</span><br></pre></td></tr></table></figure><h3 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/4c8256fb-0669-4cc5-9381-30b95b45422f.jpg" alt></p><p>如上错误提示是因为Linux操作系统没有更多的Loopback 设备给Docker使用。</p><p><strong>解决方案：</strong><br>创建更多的Loopback设备即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i inseq 0 6;do mknod -m 0660 &#x2F;dev&#x2F;loop$i b 7 $i;done</span><br></pre></td></tr></table></figure><h3 id="案例4"><a href="#案例4" class="headerlink" title="案例4"></a>案例4</h3><p><strong>案例描述：</strong></p><p>Docker命令执行，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:</span><br><span class="line">&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>根据如上错误提示，该错误很明显可能是docker没有启动。</p><p><strong>解决方案：</strong></p><p>检测docker进程是否启动，ps -ef|grep docker，如果没有启动，启动Docker即可。</p><p>检测Docker进程存在，但是无法连接，可以重启一下Docker服务，检测一下Sock路径是否正确；<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/0e4560e9-3eff-484b-8da3-96e821d660ab.jpg" alt></p><h3 id="案例5"><a href="#案例5" class="headerlink" title="案例5"></a>案例5</h3><p><strong>案例描述：</strong><br>Docker获取远程镜像，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: dial tcp: lookup registry-1.docker.io</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/57f33576-3246-41b0-be58-c5382485a341.png" alt></p><p>该错误表示无法连接远程仓库Docker.io。</p><p><strong>解决方案：</strong></p><p>查看本地是否配置DNS，能否ping通docker.io；</p><p>如果能够ping通，但是下载还是比较慢，可以修改Docker仓库源为国内或者自建的仓库源；</p><p>Docker镜像修改方法，vim /etc/docker/daemon.json，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at&gt;&#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="案例6"><a href="#案例6" class="headerlink" title="案例6"></a>案例6</h3><p><strong>案例描述：</strong><br>启动Docker容器，报错信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;&#x2F;bin&#x2F;bash\&quot;: executable file not found in $PATH&quot;.</span><br></pre></td></tr></table></figure><p>如上报错，通常是由于容器启动时，不支持该命令：/bin/bash。</p><p><strong>解决方案：</strong></p><p>解决方法有如下两种：</p><p>修改启动命令为正确的Docker容器启动命令，例如修改为：/bin/sh或者sleep 99999d等；</p><p>Docker镜像自身问题或者Docker引擎版本比较低导致，可以升级Docker引擎版本服务；</p><h3 id="案例7"><a href="#案例7" class="headerlink" title="案例7"></a>案例7</h3><p><strong>案例描述：</strong><br>Docker虚拟化运行中，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br></pre></td></tr></table></figure><p>如上错误，表示Docker虚拟化引擎平台，没有多月的空间设备所使用，证明容器磁盘不足或者物理机磁盘不足。</p><p><strong>解决方案：</strong></p><p>手工删除Docker容器占用数据比较大的目录；</p><p>或者通过docker system prune自动删除一些日志目录，此种方法会停止所有容器；</p><p>或者临时增加Docker存储硬盘等；</p><h3 id="案例8"><a href="#案例8" class="headerlink" title="案例8"></a>案例8</h3><p><strong>案例描述：</strong><br>Docker push上传镜像至本地仓库报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [106.12.133.186:5000&#x2F;busybox] Get https:&#x2F;&#x2F;106.12.133.186:5000&#x2F;v1&#x2F;_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>根据如上错误提示，错误是由于客户端采用https，docker registry未采用https服务所致。一种处理方式是把客户对地址“106.12.133.186:5000”请求改为http。</p><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件。</span><br><span class="line">在文件中写入：&#123; &quot;insecure-registries&quot;:[&quot;106.12.133.186:5000&quot;] &#125; 。</span><br></pre></td></tr></table></figure><p>保存退出后，重启docker服务，问题即可解决。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-Docker安装与部署</title>
      <link href="/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.</p><a id="more"></a><figure class="highlight plain"><figcaption><span>库必须启用。默认情况下，此存储库已启用，但是如果将其禁用，则需要**重启启用它**。（自行搜索）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">overlay2 建议使用存储驱动程序。</span><br></pre></td></tr></table></figure><p>uname -r # 可查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 卸载旧版本</span><br><span class="line">旧版本的Docker被称为 docker 或 docker-engine。如果已安装这些，请卸载它们及相关的依赖项、</span><br></pre></td></tr></table></figure><p>$ sudo yum remove docker <br>                  docker-client <br>                  docker-client-latest <br>                  docker-common <br>                  docker-latest <br>                  docker-latest-logrotate <br>                  docker-logrotate <br>                  docker-engine</p><p>如果 yum报告没有安装这些软件包，则可以了、<br>/var/lib/docker/ 保留包括图像、容器、卷和网络在内的内容。现在调用Docker CE包  docker-ce。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">## 安裝 Docker</span><br><span class="line">参考0-Docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Docker 通过运行 hello-world 映像验证是否正确安装。**</span><br></pre></td></tr></table></figure><p>docker run hello-world</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此命令下载测试镜像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。如果你没有配置镜像加速器的话,运行 hello-world 命令来验证也是不会成功的.因为国内网络的原因,无法下载测试镜像,更别说运行测试镜像了,&lt;font color&#x3D;red&gt;配置镜像加速器--参考0&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">## 查看当前Docker版本</span><br></pre></td></tr></table></figure><p>docker -v</p><p>docker version</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Docker缘由</title>
      <link href="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/"/>
      <url>/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>作者：雪雁<br><a href="https://www.cnblogs.com/codelove/p/10030439.html" target="_blank" rel="noopener">文章转载出自这里</a>：<a href="https://www.cnblogs.com/codelove/" target="_blank" rel="noopener">https://www.cnblogs.com/codelove/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着生产力的发展尤其是弹性架构的广泛应用（如微服务），许多一流开发者都将应用托管到了应用容器上，如Google、微软、亚马逊、阿里、京东、新浪等等。</p><a id="more"></a><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093206616-399407280.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093217472-1718656903.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093230803-632908603.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093244576-449593766.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093301329-915864692.png" alt></p><p>从未来的发展方向来看，容器引擎将会越来越成为主流，哪怕不是弹性架构，托管到应用容器也将是一种趋势——因为更低的开发运维和托管成本以及对服务器资源的优化配置，而且未来一个很大的趋势是————<strong>无服务器计算服务</strong></p><p>因为相对于软件、硬件在本地设备上的分裂，云计算的一大特性就是将服务构建在云上，供多种设备同时无缝调用。但事实上，云服务在发展的过程中还没能实现<strong>共融共通</strong>的理想————比如，各家的云服务是相对割裂的，开发者基于Google云服务构建的软件拿到亚马逊的AWS上也许就不能用了，阿里云的应用迁移到腾讯云可能就存在问题了；在任务执行层面，为防止互相干扰，云服务厂商在同一台服务器上执行多个任务时也会将他们隔离进行、很明显，这样的实例情况和云服务器的初始理念相去甚远。而利用容器技术，软件可以快速在各类云服务和基础设施上转换。而且，当割裂问题被解决后，软件也有希望在瞬间获取大量的计算能力。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093417505-465374977.png" alt></p><p>而Docker,就是容器引擎中的佼佼者，并且已经得到了广泛的实践和应用。有了Docker之后，软件的开发工作将会变得更加容易。如：开发者在笔记本电脑上写完一个软件后，可以将它转移到云服务上运行而无需做出更改；无论是自己的服务器、数据中心还是Google、微软、阿里云的云计算服务器，开发人员都可以按自己的想法在任何基础设施之间转移自己的软件。这也是未来的一个愿景——————<strong>机器和基础设施之间是可以互相替代的，整个互联网就是一个巨大的计算机</strong>。</p><p>Docker是如此的令人向往和引人深入，但是在国内，开发者普遍迁移到云端基本上也都是只用到了虚拟机等基础设施，其实大家都听过Docker,但是有一些偏见：</p><ul><li>缺乏完整的系统的教程和实践。开发者普遍认为使用Docker很麻烦，只有大公司用，门槛高‘</li><li>云端容器服务产品用户体验不多，对于初学者门槛太高——————此处是指消化这列概念和理念，并且能够掌握和可控。</li><li>对容器服务的认知还不够，对它的好处及吸引之处不太了解。</li><li>认为对现有系统、架构改造太大，成本太高；</li><li>认为Docker只是一种单纯的相对先进的技术，并不能给现有的开发带来什么概念；</li></ul><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译通过的容器可以批量的在生产环境中部署，包括VMs(虚拟机)、bare metal、OpenStack集群和其他的基础应用平台。</p><p>简单理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093811704-1643592196.png" alt></p><p>因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器就充当着 软件部署 的标准单元，其中可以包含不同的代码和依赖项。按照这种方式的容器化软件。开发人员和IT专业人员只需要进行极少修改或者不修改，即可将其部署到不同的环境。</p><p>总而言这，Docker是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA和生产环境之间进行高效的应用程序生命周期管理。</p><h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093906502-569967575.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093915205-139200956.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093934953-2128627412.png" alt></p><p>如上图所示，由于容器所需的资源要少很多（例如，他们不需要一个完整的OS），所以它们易于部署且可以快速启动、这使得你能够具有更高部署密度。即<strong>允许在同一硬件单元上运行更多服务，从而降低了成本。</strong></p><p>在同一内核上运行的时候，你获得的隔离比VM少。</p><p><font color="red">镜像的主要目标是使环境（依赖项）在不同的部署中保持不变。</font>，即可以在计算机上调试它，然后将其部署到保证具有相同环境的另一台计算机上。</p><p>借助容器镜像，可打包应用或者服务 并采用可靠且可重现的方式对其进行部署。可以说Docker不只是一种技术，还是一种原理和过程。</p><p>在使用Docker之前，经常听到，“这个问题在开发环境是正常的！”。而在使用Docker后，你不会听到开发人员说：“为什么它能在我的计算机上使用却不能用在生产中？”。开发人员只需要说 “它在Docker上运行”，因为打包的Docker应用程序可在任何支持的Docker环境上执行，而且它在所有部署目标（开发、QA、暂停和生产）上都按期运行。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a>镜像：一个特殊的文件系统</h2><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂在root文件系统为其提供用户空间支持。而Docker镜像相当于是一个root文件系统。</p><p><strong>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（匿名卷、环境变量、用户等）。</strong></p><p>镜像是不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时。就充分利用 <strong>Union FS</strong>技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如：删除前一层文件的操作，实际上不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像时，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变得更为容易，甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的容器，构建新的镜像。</p><h2 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a>容器：镜像运行时的实体</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中 类 和 实例一样，镜像时静态的定义，容器是进行运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己独立的命名空间，前面说过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按着Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态变化。</p><p>所有文件的写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094117580-274999612.png" alt></p><p><strong><font color="red">注意：</font></strong><br>容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。最重要的优点是可在开发和运营之间提供隔离。</p><h2 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a>仓库：集中存放镜像文件的地方</h2><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。<strong>Docker Registry</strong>就是这样的服务。</p><p>一个Docker Registry 中可以包含多个仓库（Repository）:每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。</p><p>所以说，镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以latest作为默认标签。</p><p>这里补充一下：Docker Registry公开服务和私有 Docker Registry 的概念。</p><p>一般这类公共服务允许用户免费上传、下载公开镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常用的Registry 公开服务是官方的 <a href="hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>在国内访问Docker Hub可能比较慢，国内有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了公开服务外，用户还可以在本地搭建私有Docker Registry。Docker官方提供了 Docker Registry 镜像，可以直接使用作为私有Registry服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API的服务端实现，足以支持Docker命令，不影响使用，但不含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h2 id="Docker的主要应用场景"><a href="#Docker的主要应用场景" class="headerlink" title="Docker的主要应用场景"></a>Docker的主要应用场景</h2><h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p><p>简单来说，容器镜像打包完成后，它就是个独立的个体了，丢到哪里都能跑，而无需针对各个平台去独立配置。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094246244-759574629.png" alt></p><h2 id="代码流水线（Code-Pipeline）管理"><a href="#代码流水线（Code-Pipeline）管理" class="headerlink" title="代码流水线（Code Pipeline）管理"></a>代码流水线（Code Pipeline）管理</h2><p>前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094322089-159857776.png" alt></p><h2 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h2><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想要快速搭建开发环境。</p><p>使用Docker非常简单的就能实现这两点，哪怕是开发环境的机器配置一般的情况下搭建多个生产服务应用。一台一般配置服务器或者开发机器也能轻松的跑起多个Docker应用，而无需额外增加机器配置。因为Docker有个非常NB的特性，<strong>拥有虚拟化的特性</strong>，而几乎没有额外的开销。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094410700-1435124978.png" alt></p><h2 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h2><p>很多情况下，我们需要在一台服务器上运行多个不同的应用，比如上面提到的提高开发效率的场景等。</p><p>考虑三点：一是因为要降低成本而进行服务器整合，二是讲一个整体式的应用拆分成松耦合的单个服务（如微服务架构），三是还需要考虑应用之间的兼容性。而对于Docker来说，支持起来非常简单。同一台机器，可以同时运行N个Docker Web应用，托管到不同的Web服务器（Kestrel、Nginx、Tomcat），而无需担心他们会搞起3Q大战，也不用担心开发机器跑步起来。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094456537-87357208.png" alt></p><h2 id="整合服务器"><a href="#整合服务器" class="headerlink" title="整合服务器"></a>整合服务器</h2><p>虚拟机可以整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p><p>这意味着资源得到更有效的利用——————可以做更多的衣服，而且没有边角料，成本更低。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094534267-1497649789.png" alt></p><h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Docker提供很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多功能，包含可以设置容器检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094617391-1947396056.png" alt></p><h2 id="多租户环境"><a href="#多租户环境" class="headerlink" title="多租户环境"></a>多租户环境</h2><p>在多租户的应用中，它可以避免关键应用的重写。比如IoT(物联网)的应用中，开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间、也浪费金钱。</p><p>使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。</p><p>就如同我们现在写了一个不支持多租户的业务程序，而实际的业务中经常会出现需要支持多租户或者有新客户需要使用的场景，这时们通常的简单是——————部署一套新的代码。当站点达到一定量的适合，要么重写程序，要么维护人员Game Over。</p><h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。</p><p>你可以在服务器中或云端创建销毁资源而无需担心重新启动带来的开销。通常情况下，服务器的资源利用率只有30%，而通过使用Docker并进行有效的资源分配可以提高资源的利用率。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094717810-819940111.png" alt></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094748866-356935721.png" alt></p><p>Docker 带来的敏捷性（响应速度和灵活性）吸引了越来越多的开发者。他们不仅能知道容器内部到底跑了什么，也能进一步理解 Docker 如何加速了软件开发进程。另外，41% 的用户表示应用的可移植性是他们决定使用 Docker 的关键因素。</p><p><strong>通过 DevOps 的实践，Docker 正在给应用交付带来很多可以量化的提升</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094834979-29905994.png" alt></p><p>大约一半的受访者表示已经采用了持续集成（CI）和 DevOps，并且希望把这些实战经验应用到生产环境的持续交付中。剩下的受访者则准备尽快跟上步伐，尽快尝试 DevOps 和持续集成。另外，据调查显示，用户使用 Docker 发布应用的频率平均提升了 13 倍。</p><p><strong>Docker 对混合云策略至关重要，它使得用户可以根据需求自由选择私有和公有环境</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094910142-643670153.png" alt></p><p>通过容器来交付的应用可以在任何基础设施之上灵活迁移，同时这些基础设施又可以提供不同层次的应用管理方式，而当业务在多个服务供应商之中寻求混合云或全云模式时，又可以完美避免被平台捆绑。</p><p>对于按需部署或部署到云环境，Docker 提供了独一无二的选择。 80% 的用户表示 Docker 已经成为他们云策略的一部分，超过 35% 的用户使用 Docker 来避免被云服务供应商绑定。</p><p><strong>Docker 实现了微服务架构，也让遗留的单体应用转变为现代应用</strong></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094948673-1019599700.png" alt></p><p>Docker 使得微服务架构的快速发展成为可能，同时它也将传统的业务迁移到容器环境中，以此使得应用程序变得更加可移植。<strong>使用微服务架构进行交付是 Docker 的关键优势！</strong></p><h2 id="Docker改变了什么？"><a href="#Docker改变了什么？" class="headerlink" title="Docker改变了什么？"></a>Docker改变了什么？</h2><ul><li><p>Docker改变了云服务，使云服务的共融共通的理想逐步成为了可能。并且Docker 已经是云策略的一部分，许多开发者正在计划使用 Docker 将业务迁移到云端。另外，为了避免被云服务供应商绑定，Docker成为很多开发者的首选。</p></li><li><p>Docker改变了产品交付，为产品的整个生命周期提供了一整套的解决方案和流程。</p></li><li><p>Docker改变了开发方式，提供了简化的环境配置、封装的运行环境以及统一的环境。并且提供了快速部署的方式。</p></li><li><p>Docker改变了测试，多版本测试变得极为方便，快速构建测试环境也变得更加简单并且无需开发人员干预或者搭建。</p></li><li><p>Docker改变了运维，环境的一致性让运维变得更加简单，同时热更新的支持让运维不再需要半夜加班部署更新，更新可以随时进行。当出现重大问题时，还能快速回滚到指定版本。</p></li><li><p>Docker改变了架构，自动化扩容支持让架构变得更加简单，分布式系统也更加易于搭建和支持。同时遗留的单体应用也很易于转变为现代应用。</p></li></ul><p>总之，在某种程度上，Docker改变了产品开发中的一些游戏规则。虽然Docker是一项技术，但是它也带来了新的思维，新的流程和工作方法，Docker在推动行业的发展，Docker已经在改变世界，并且在逐步的变为事实……<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128095105560-528324521.png" alt></p><h1 id="Docker持续开发工作流"><a href="#Docker持续开发工作流" class="headerlink" title="Docker持续开发工作流"></a>Docker持续开发工作流</h1><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203093658359-1691324108.png" alt></p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094045768-1316009773.png" alt></p><p>虽然我们可以通过docker commit命令来手动创建镜像，但是通过Dockerfile文件，可以帮助我们自动创建镜像，并且能够自定义创建过程。本质上，Dockerfile就是由一系列<strong>命令</strong>和<strong>参数</strong>构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它简化了从头到尾的构建流程并极大的简化了部署工作。使用dockerfile构建镜像有以下好处：</p><ul><li><p>像编程一样构建镜像，支持分层构建以及缓存；</p></li><li><p>可以快速而精确地重新创建镜像以便于维护和升级；</p></li><li><p>便于持续集成；</p></li><li><p>可以在任何地方快速构建镜像</p></li></ul><h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><p>Dockerfile 指令为 Docker 引擎提供了创建容器映像所需的步骤。这些指令按顺序逐一执行。</p><h4 id="1-FROM"><a href="#1-FROM" class="headerlink" title="1.FROM"></a><strong>1.FROM</strong></h4><p>ROM 指令用于设置在新镜像创建过程期间将使用的容器映像。<br>格式：FROM<br>示例：<br>FROM nginx</p><h4 id="2-RUN"><a href="#2-RUN" class="headerlink" title="2.RUN"></a><strong>2.RUN</strong></h4><p>RUN 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。<br>格式：<br>RUN [“”, “”, “”]<br>RUN<br>示例：<br>RUN apt-get update<br>RUN mkdir -p /usr/src/redis<br>RUN apt-get update &amp;&amp; apt-get install -y libgdiplus<br>RUN [“apt-get”,”install”,”-y”,”nginx”]</p><p>注意：<font color="red">每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。使用换行符时，可能会遇到一些问题，具体可以参阅下节的转义字符</font>。</p><h4 id="3-COPY"><a href="#3-COPY" class="headerlink" title="3.COPY"></a><strong>3.COPY</strong></h4><p>COPY 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 Dockerfile 的路径中。<br>式：<br>COPY<br>如果源或目标包含空格，请将路径括在方括号和双引号中。<br>COPY [“”, “”]<br>示例：<br>COPY . .<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY . /usr/share/nginx/html<br>COPY hom* /mydir/</p><h4 id="4-ADD"><a href="#4-ADD" class="headerlink" title="4.ADD"></a><strong>4.ADD</strong></h4><p>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。<br>格式：<br>ADD<source> <destination><br>示例：<br>ADD <a href="https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe</a> /temp/python-3.5.1.exe<br>此示例会将 Python for Windows下载到容器映像的 c:\temp 目录。</destination></p><h4 id="5-WORKDIR"><a href="#5-WORKDIR" class="headerlink" title="5.WORKDIR"></a><strong>5.WORKDIR</strong></h4><p>WORKDIR 指令用于为其他 Dockerfile 指令（如 RUN、CMD）设置一个工作目录，并且还设置用于运行容器映像实例的工作目录。<br>格式：<br>WORKDIR<br>示例：<br>WORKDIR /app</p><h4 id="6-CMD"><a href="#6-CMD" class="headerlink" title="6.CMD"></a><strong>6.CMD</strong></h4><p>CMD指令用于设置部署容器映像的实例时要运行的默认命令。例如，如果该容器将承载 NGINX Web 服务器，则 CMD 可能包括用于启动Web服务器的指令，如 nginx.exe。 如果 Dockerfile 中指定了多个CMD 指令，只会计算最后一个指令。<br>格式：<br>CMD [“&lt;executable”, “<br>CMD<br>示例：<br>CMD [“c:\Apache24\bin\httpd.exe”, “-w”]<br>CMD c:\Apache24\bin\httpd.exe -w</p><h4 id="7-ENTRYPOINT"><a href="#7-ENTRYPOINT" class="headerlink" title="7.ENTRYPOINT"></a><strong>7.ENTRYPOINT</strong></h4><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。<br>格式：<br>ENTRYPOINT [“”, “”]<br>示例：<br>ENTRYPOINT [“dotnet”, “Magicodes.Admin.Web.Host.dll”]</p><h4 id="8-ENV"><a href="#8-ENV" class="headerlink" title="8.ENV"></a><strong>8.ENV</strong></h4><p>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。<br>格式：<br>ENV==…<br>示例：<br>ENV VERSION=1.0 DEBUG=on <br>NAME=”Magicodes”</p><h4 id="9-EXPOSE"><a href="#9-EXPOSE" class="headerlink" title="9.EXPOSE"></a><strong>9.EXPOSE</strong></h4><p>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。<br>格式：<br>EXPOSE<br>示例：<br>EXPOSE 80<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094342684-400475059.png" alt></p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>有几点值得注意的是：</p><ol><li><p>不能忽视dockerfile的优化，通常情况下，我们可以忽略那些细小的优化，但是我们需要知道优化的原理，为什么要优化</p></li><li><p>不能为了优化而优化。镜像的构建过程视业务情况情况不同，指令就有多到少的区别，在很多情况下，我们先要以满足业务目标为准，而不是镜像层数。如果需要减少镜像的层数，我们一定要选择合适的基础镜像，或者创建符合我们需要的基础镜像。</p></li></ol><p>优化准则：</p><ul><li><p>选择合适的基础镜像</p><p>这点相对最为重要。为什么这么说，我们结合现实社会也可以看到，在大部分情况下，一个人一生的成就更多的是看出身。很多情况下，基因和出身决定了你的高度和终点，这点拿到技术层面来说，也是有很大道理的，因此我们需要选择合适的父母——一个合适的镜像。</p><p>一个合适的基础镜像是指能满足运行应用所需要的最小的镜像，理论上是能用小的就不要用大的，能用轻量的就不要用重量级的，能用性能好的就不要用性能差的。这里有时候还需要考虑那些能够减少我们构建层数的基础镜像。</p></li><li><p>优化指令顺序</p><p>Docker会缓存Dockerfile中尚未更改的所有步骤，但是，如果更改任何指令，将重做其后的所有步骤。也就是指令3有变动，那么4、5、6就会重做。因此，我们需要将最不可能产生更改的指令放在前面，按照这个顺序来编写dockerfile指令。这样，在构建过程中，就可以节省很多时间。比如，我们可以把WORKDIR、ENV等命令放前面，COPY、ADD放后面。</p></li><li><p>合并指令</p><p>前面其实我们提到过这点，甚至还特地讲到了转义字符，其实主要是为此服务。前面我们说到了，每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p></li><li><p>删除多余文件和清理没用的中间结果</p><p>这点很易于理解，通常来讲，体积更小，部署更快！因此在构建过程中，我们需要清理那些最终不需要的代码或文件。比如说，临时文件、源代码、缓存等等。</p></li><li><p>使用 .dockerignore</p><p>.dockerignore文件用于忽略那些镜像构建时非必须的文件，这些文件可以是开发文档、日志、其他无用的文件。例如:<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094654908-278191045.png" alt></p></li></ul><h2 id="创建自定义Docker镜像"><a href="#创建自定义Docker镜像" class="headerlink" title="创建自定义Docker镜像"></a>创建自定义Docker镜像</h2><p>创建了Dockerfile之后，需为应用程序中的每项服务创建一个相关镜像。如果应用程序由单个服务或 Web 应用程序组成，则只需创建一个镜像。</p><p>我们可以使用docker build命令来创建镜像，例如：<br>docker build ./ -t {镜像名称}</p><p>镜像打包好后，我们使用docker image ls命令即可查看当前镜像。</p><p>注意：Docker镜像使用分层存储的架构，也就是说镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。因为分层存储的特征，使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。所以，当我们使用Docker images命令，会列出这么多的镜像，我们可以定期清理那些无用的镜像。</p><h2 id="在-docker-compose-yml中定义服务"><a href="#在-docker-compose-yml中定义服务" class="headerlink" title="在 docker-compose.yml中定义服务"></a>在 docker-compose.yml中定义服务</h2><h3 id="关于-Compose"><a href="#关于-Compose" class="headerlink" title="关于 Compose"></a>关于 Compose</h3><p>Compose是一个用于定义和运行多Docker应用程序的工具。使用Compose，我们可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，我们就可以从配置中创建并启动所有服务。</p><p>Compose适用于所有环境：生产环境、模拟（演示）环境、开发环境和测试环境以及CI工作流程。</p><p>主要功能和特性：</p><ul><li><p>单个主机上的多个隔离环境</p><p>Compose使用项目名称来隔离环境，因此可以根据不同的环境要求来进行定义。</p></li><li><p>创建容器时保留卷数据</p><p>Compose会保留服务使用的所有卷和数据。当使用docker-compose up命令运行时，如果发现该服务之前运行过，它会将进行增量操作，可确保在卷中创建的数据都不会丢失。</p></li><li><p>仅重新创建已更改的容器</p><p>Compose存在缓存，可用于创建容器。当重新启动未更改的服务时，Compose将重用现有容器。</p></li><li><p>可以定义变量，而且可以根据不同环境不同用户之间进行组合使用</p><p>Compose支持Compose文件的变量定义，我们可以使用这些变量为不同环境或不同用户进行自定义组合。</p></li></ul><p>另外，Compose能够通过命令管理应用程序的整个生命周期，通过命令可以：</p><ul><li><p>启动，停止和重建服务等</p></li><li><p>查看正在运行的服务的状态</p></li><li><p>通过流输出正在运行的服务的日志</p></li><li><p>对某个服务执行命令</p></li></ul><h2 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h2><ul><li><p>开发或本地环境运行多个服务</p><p>在开发过程时，在隔离环境中运行应用程序并与之交互的能力至关重要。Compose命令行工具可用于创建环境并与之交互。比如通过Compose文件，配置所有应用程序的服务依赖（数据库，消息队列，高速缓存，Web服务的API，等等），然后使用单个命令（docker-compose up）为每个依赖项创建和启动一个或多个容器，使整个程序能够正常运行起来。</p></li><li><p>自动化测试环境</p><p>任何持续部署或持续集成过程的一个重要部分是自动化测试套件。自动化端到端测试需要一个运行测试的环境。Compose提供了一种方便的方法来创建和销毁隔离的测试环境。我们只需要通过在Compose文件，即可定义完整环境，并且可以在几个命令中创建和销毁这些环境，如下所示：</p></li></ul><h2 id="使用Compose"><a href="#使用Compose" class="headerlink" title="使用Compose"></a>使用Compose</h2><p>使用Compose有以下三个步骤：</p><ol><li><p>使用Dockerfile定义应用环境，以便在任意地方进行复制</p></li><li><p>在 docker-compose.yml 中定义组合应用，以便它们可以在隔离的环境中一起运行</p></li><li><p>最后，执行docker-compose up命令，Compose 将启动并运行整个应用程序。</p></li></ol><h2 id="了解docker-compose-yml"><a href="#了解docker-compose-yml" class="headerlink" title="了解docker-compose.yml"></a>了解docker-compose.yml</h2><p>借助 docker-compose.yml 文件，我们可以定义一组相关服务，通过部署命令将其部署为组合应用程序。简单的说，我们可以通过docker-compose.yml来定义多个服务，以便一次执行。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094402699-10239551.png" alt></p><h2 id="了解YAML语言"><a href="#了解YAML语言" class="headerlink" title="了解YAML语言"></a>了解YAML语言</h2><p>YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p><p>这里提供一个YAML语法验证网站：<a href="http://nodeca.github.io/js-yaml/" target="_blank" rel="noopener">http://nodeca.github.io/js-yaml/</a></p><p>基本规则</p><ol><li><p>大小写敏感</p></li><li><p>使用缩进表示层级关系</p></li><li><p>禁止使用tab缩进，只能使用空格键</p></li><li><p>缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级</p></li><li><p>使用#表示注释</p></li><li><p>字符串可以不用引号标注</p></li></ol><p>YAML中允许表示三种格式，分别是常量值，对象和数组，如下所示：<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094613899-1061816782.png" alt></p><h2 id="docker-compose-yml文件配置项"><a href="#docker-compose-yml文件配置项" class="headerlink" title="docker-compose.yml文件配置项"></a>docker-compose.yml文件配置项</h2><p>docker-compose.yml 文件不仅指定正在使用的容器，还指定如何单独配置各容器。常用的配置项如下所示：</p><ul><li><p>uild：定义镜像生成，可以指定Dockerfile文件所在的目录路径，支持绝对路径和相对路径；</p></li><li><p>image：从指定的镜像中启动容器，可以是存储仓库、标签以及镜像 ID，如果镜像不存在，Compose 会自动拉去镜像；</p></li><li><p>environment：定义环境变量和配置；</p></li><li><p>ports：定义端口映射，比如上面配置中将容器上的公开端口 80 转接到主机上的外部端口 9901和9902；</p></li><li><p>depends_on，定义依赖关系。此定义会让当前服务处于等待状态，直到这些依赖服务启动。比如某个服务依赖数据库服务，那么通过此配置解决了服务的启动顺序的问题；</p></li><li><p>volumes，挂载一个目录或者一个已存在的数据卷容器，可以直接使用 HOST:CONTAINER 这样的格式，或者使用 HOST:CONTAINER:ro 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统；</p></li><li><p>context，指定Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url；</p></li><li><p>args,指定构建参数，这些参数只能在构建过程中访问；</p></li><li><p>target，定义构建指定的阶段Dockerfile，比如针对不同阶段使用不同的dockerfile，开发阶段使用支持编译调试的dockerfile，而生产环境，则使用轻量级的dockerfile；command，覆盖默认命令；</p></li><li><p>container_name，指定自定义容器名称，而不是生成的默认名称。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094653278-1319182904.png" alt></p></li></ul><p>小技巧：</p><ul><li><p>可以通过配置项depends_on来定义依赖关系，这点对于控制服务的执行顺序尤为重要，比如先启动数据库然后再启动web服务。</p></li><li><p>如何使用JSON文件进行配置？可以指定文件名称，如下所示：</p><p>docker-compose -f docker-compose.json up</p></li><li><p>如何分阶段构建？推荐使用target配置项。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-Docker配置国内免费registry_mirror</title>
      <link href="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/"/>
      <url>/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内特殊的网络环境，往往我们从 <strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></strong>中拉取镜像并不能成功，而且速度特别慢。</p><p>那么我们可以给Docker配置一个国内的registry mirror，当我们需要的镜像在mirror中则直接返回，如果没有则从Docker Hub中拉取。<font color="red">是否使用registry mirror对Docker用户来说是透明的</font>。</p><p>DaoCloud在国内提供了首个Docker Hub镜像服务，而且免费，大大提高了国内Docker用户的使用热情。</p><a id="more"></a><h2 id="DaoCloud使用方法"><a href="#DaoCloud使用方法" class="headerlink" title="DaoCloud使用方法"></a>DaoCloud使用方法</h2><p>修改Docker配置文件/etc/default/docker如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;aad0405c.m.daocloud.io&quot;</span><br></pre></td></tr></table></figure><p>使用<code>service docker restart</code>重启Docker服务即可。</p><p>在使用docker下载镜像时，在国内使用官方的Docker registry下载时速度很慢，庆幸国内还镜像加速服务。目前支持Docker镜像的有阿里云和DaoCloud两家。本文将详细讲解镜像服务的具体配置方法。</p><h2 id="Docker使用阿里云镜像库加速（推荐）"><a href="#Docker使用阿里云镜像库加速（推荐）" class="headerlink" title="Docker使用阿里云镜像库加速（推荐）"></a>Docker使用阿里云镜像库加速（推荐）</h2><p>注册阿里云开发者账号<br><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></p><p>登陆后取得专属加速器地址，类似这样 <code>https://9mpi2k3r.mirror.aliyuncs.com</code></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-安装-升级Docker客户端"><a href="#1-安装-升级Docker客户端" class="headerlink" title="1 安装/升级Docker客户端"></a>1 安装/升级Docker客户端</h4><p>推荐安装1.10.0以上版本的Docker客户端，参考文档 <a href="https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.13be1991qOQrLG" target="_blank" rel="noopener">docker-ce</a></p><h5 id="Docker-CE镜像源站"><a href="#Docker-CE镜像源站" class="headerlink" title="Docker CE镜像源站"></a>Docker CE镜像源站</h5><p>官网下载手册</p><h5 id="CentOS7（使用yum进行安装-阿里云）"><a href="#CentOS7（使用yum进行安装-阿里云）" class="headerlink" title="CentOS7（使用yum进行安装-阿里云）"></a>CentOS7（使用yum进行安装-阿里云）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># Step 3: 更新并安装 Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"># Step 4: 开启Docker服务</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">注意：其他注意事项在下面的注释中</span><br><span class="line"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line"># vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br><span class="line">#   将 [docker-ce-test] 下方的 enabled&#x3D;0 修改为 enabled&#x3D;1</span><br><span class="line">#</span><br><span class="line"># 安装指定版本的Docker-CE:</span><br><span class="line"># Step 1: 查找Docker-CE的版本:</span><br><span class="line"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="line">#   Loading mirror speeds from cached hostfile</span><br><span class="line">#   Loaded plugins: branch, fastestmirror, langpacks</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   Available Packages</span><br><span class="line"># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span><br><span class="line"># sudo yum -y install docker-ce-[VERSION]</span><br><span class="line"># 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。</span><br><span class="line"># yum list docker-ce-selinux- --showduplicates | sort -r</span><br><span class="line"># sudo yum -y install docker-ce-selinux-[VERSION]</span><br><span class="line"></span><br><span class="line"># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令</span><br><span class="line"># 经典网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># VPC网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.could.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h5 id="安装校验"><a href="#安装校验" class="headerlink" title="安装校验"></a>安装校验</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><h4 id="2-配置镜像加速器"><a href="#2-配置镜像加速器" class="headerlink" title="2 配置镜像加速器"></a>2 配置镜像加速器</h4><p>针对Docker客户端版本大于 1.10.0 的用户</p><p><img src="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/1f87538c-e8a2-455e-af33-8e0b3ff4a3f9.png" alt></p><p>您可以通过修改daemon配置文件（没有的话，需手动创建）<code>/etc/docker/daemon.json</code>来使用加速器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker </span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: # 此处使用自己的加速器[&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;]&#125;EOF </span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="daemon-json"><a href="#daemon-json" class="headerlink" title="daemon.json"></a>daemon.json</h2><p><strong>docker安装后默认是没有 daemon.json此配置文件的，需手动创建。</strong></p><p>daemon.json文件可配置的参数表，我们在配置的过程中，只需要设置我们需要的参数即可，不必全部写出来。详细参考官网。</p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#options</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;api-cors-header&quot;:&quot;&quot;,</span><br><span class="line">&quot;authorization-plugins&quot;:[],</span><br><span class="line">&quot;bip&quot;: &quot;&quot;,</span><br><span class="line">&quot;bridge&quot;:&quot;&quot;,</span><br><span class="line">&quot;cgroup-parent&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store-opts&quot;:&#123;&#125;,</span><br><span class="line">&quot;cluster-advertise&quot;:&quot;&quot;,</span><br><span class="line">&quot;debug&quot;: true, #启用debug的模式，启用后，可以看到很多的启动信息。默认false</span><br><span class="line">&quot;default-gateway&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-gateway-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-runtime&quot;:&quot;runc&quot;,</span><br><span class="line">&quot;default-ulimits&quot;:&#123;&#125;,</span><br><span class="line">&quot;disable-legacy-registry&quot;:false,</span><br><span class="line">&quot;dns&quot;: [&quot;192.168.1.1&quot;], # 设定容器DNS的地址，在容器的 &#x2F;etc&#x2F;resolv.conf文件中可查看。</span><br><span class="line">&quot;dns-opts&quot;: [], # 容器 &#x2F;etc&#x2F;resolv.conf 文件，其他设置</span><br><span class="line">&quot;dns-search&quot;: [], # 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜</span><br><span class="line">索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。</span><br><span class="line"> </span><br><span class="line">&quot;exec-opts&quot;: [],</span><br><span class="line">&quot;exec-root&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;graph&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃已废弃，使用data-root代替,这个主要看docker的版本</span><br><span class="line">&quot;data-root&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃Docker运行时使用的根路径,根路径下的内容稍后介绍，默认&#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line">&quot;group&quot;: &quot;&quot;, #Unix套接字的属组,仅指&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">&quot;hosts&quot;: [], #设置容器hosts</span><br><span class="line">&quot;icc&quot;: false,</span><br><span class="line">&quot;insecure-registries&quot;: [], #配置docker的私库地址</span><br><span class="line">&quot;ip&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;iptables&quot;: false,</span><br><span class="line">&quot;ipv6&quot;: false,</span><br><span class="line">&quot;ip-forward&quot;: false, #默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看</span><br><span class="line"> </span><br><span class="line">&quot;ip-masq&quot;:false,</span><br><span class="line">&quot;labels&quot;:[&quot;nodeName&#x3D;node-121&quot;], # docker主机的标签，很实用的功能,例如定义：–label nodeName&#x3D;host-121</span><br><span class="line"> </span><br><span class="line">&quot;live-restore&quot;: true,</span><br><span class="line">&quot;log-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-level&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-opts&quot;: &#123;&#125;,</span><br><span class="line">&quot;max-concurrent-downloads&quot;:3,</span><br><span class="line">&quot;max-concurrent-uploads&quot;:5,</span><br><span class="line">&quot;mtu&quot;: 0,</span><br><span class="line">&quot;oom-score-adjust&quot;:-500,</span><br><span class="line">&quot;pidfile&quot;: &quot;&quot;, #Docker守护进程的PID文件</span><br><span class="line">&quot;raw-logs&quot;: false,</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;xxxx&quot;], #镜像加速的地址，增加后在 docker info中可查看。</span><br><span class="line">&quot;runtimes&quot;: &#123;</span><br><span class="line">&quot;runc&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;runc&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;custom&quot;: &#123;</span><br><span class="line">&quot;path&quot;:&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;my-runc-replacement&quot;,</span><br><span class="line">&quot;runtimeArgs&quot;: [</span><br><span class="line">&quot;--debug&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;selinux-enabled&quot;: false, #默认 false，启用selinux支持</span><br><span class="line"> </span><br><span class="line">&quot;storage-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;storage-opts&quot;: [],</span><br><span class="line">&quot;swarm-default-advertise-addr&quot;:&quot;&quot;,</span><br><span class="line">&quot;tls&quot;: true, #默认 false, 启动TLS认证开关</span><br><span class="line">&quot;tlscacert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;ca.pem，通过CA认证过的的certificate文件路径</span><br><span class="line">&quot;tlscert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;cert.pem ，TLS的certificate文件路径</span><br><span class="line">&quot;tlskey&quot;: &quot;&quot;, #默认~&#x2F;.docker&#x2F;key.pem，TLS的key文件路径</span><br><span class="line">&quot;tlsverify&quot;: true, #默认false，使用TLS并做后台进程与客户端通讯的验证</span><br><span class="line">&quot;userland-proxy&quot;:false,</span><br><span class="line">&quot;userns-remap&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是官网docs提供的一个示例配置，我们可以参考，选择性的配置其中的部分内容。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>1、如何配置 registry 私库相关的参数<br>涉及以下2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [],  #这个私库的服务地址</span><br><span class="line">&quot;registry-mirrors&quot;: [],    #私库加速器</span><br></pre></td></tr></table></figure><p>2.配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line"># 配置阿里云镜像加速器 ：此处需使用自己个人加速器</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;],</span><br><span class="line"></span><br><span class="line"># 私库服务地址：个人一般用不到</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;https:&#x2F;&#x2F;ower.site.com&quot;]，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 重载配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"># 重启docker服务</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"># 查看状态</span><br><span class="line">sudo systemctl status docker -i</span><br><span class="line"># 查看服务</span><br><span class="line">sudo docker info</span><br><span class="line"># 当我们需要对docker服务进行调整配置时，不用去修改主文件 docker.service的参数，通过daemon.json配置文件来管理，更为安全、合理。</span><br></pre></td></tr></table></figure><h2 id="docker-hub官网提供国内镜像"><a href="#docker-hub官网提供国内镜像" class="headerlink" title="docker hub官网提供国内镜像"></a>docker hub官网提供国内镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;registry.docker-cn.com</span><br></pre></td></tr></table></figure><h2 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h2><p>如果 加速器太慢，可以更改加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"># 如果看到如下，则表示配置成功</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-GitLab简单操作</title>
      <link href="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-国内为什么普遍使用GitLab"><a href="#1-国内为什么普遍使用GitLab" class="headerlink" title="1.国内为什么普遍使用GitLab"></a>1.国内为什么普遍使用GitLab</h2><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">https://about.gitlab.com/</a><br>大公司有能力自己基于GitLab做二次开发，有利于将代码保存在自己手中。</p><a id="more"></a><h2 id="2-GitLab上有哪些核心功能"><a href="#2-GitLab上有哪些核心功能" class="headerlink" title="2.GitLab上有哪些核心功能"></a>2.GitLab上有哪些核心功能</h2><p>几乎包含一个项目的所有开发流程。<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/f06b4b21-3b4a-4c7b-b3a7-5ef2d7a60ce4.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/79e63bc0-48e9-4b18-bb60-1ebbc1745ace.png" alt></p><h2 id="3-GitLab如何做项目管理"><a href="#3-GitLab如何做项目管理" class="headerlink" title="3.GitLab如何做项目管理"></a>3.GitLab如何做项目管理</h2><p>主要是通过 <strong>issues</strong> 对项目进行追踪管理<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/24bbbb0d-d736-4783-90d9-c6f063636555.png" alt></p><p>也可以看仪表盘等等。</p><h2 id="4-GitLab怎样做-code-review"><a href="#4-GitLab怎样做-code-review" class="headerlink" title="4.GitLab怎样做 code review"></a>4.GitLab怎样做 code review</h2><p><strong>Merge Requests</strong></p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e0577ac-52cb-4cd8-b700-633abb8d59aa.png" alt></p><p><strong>仓库设置及变更保护</strong><br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/3f1d9ab7-f837-4b7c-a463-b3004d9a02a7.jpg" alt></p><h2 id="5-GitLab怎样保证集成质量"><a href="#5-GitLab怎样保证集成质量" class="headerlink" title="5.GitLab怎样保证集成质量"></a>5.GitLab怎样保证集成质量</h2><p>配置.gitlab-ci.yml文件 + 跑 runners</p><p><strong>GitLab</strong> 有自己的<strong>CI</strong><br>通过源文件可以查看</p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/aa33cc03-7b0f-405e-8203-8e0ea05d0644.png" alt></p><p>在自己的项目中可以看到 Runners：就是跑CI/CD的代理，类似于管家，有了它之后，GitLab自身的CI才能运行起来、<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/834dfa86-48f3-474f-a4ca-a2cfa2e1ca68.jpg" alt></p><p>跑一套之后的效果（做一个完备的检查）<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a88563d3-da82-4ecc-a297-c27baf6646c7.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/39ad396c-484a-4e12-a44a-cbfdea758b81.jpg" alt></p><h2 id="6-如何把应用部署到AWS上"><a href="#6-如何把应用部署到AWS上" class="headerlink" title="6.如何把应用部署到AWS上"></a>6.如何把应用部署到AWS上</h2><p>见 GitLab Help文档</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-基于GitHub进行团队协作</title>
      <link href="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
      <url>/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-创建团队项目"><a href="#1-创建团队项目" class="headerlink" title="1.创建团队项目"></a>1.创建团队项目</h2><p>先在settings中创建组织类型的托管。然后在组织中创建团队的仓库。</p><a id="more"></a><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/64446d90-2b9c-449f-a087-5f965818e04e.png" alt><br>点击 Create后出现当前画面</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e2f857e9-f884-4e0c-9add-09e13a4c4d6f.png" alt></p><p>给予不同的人不同的权限</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31adef54-e872-40b9-899a-b1de0bc43a23.png" alt></p><hr><p>创建Team</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/205f2e23-e3a9-4ef3-9ead-a885002f398b.png" alt></p><h2 id="2-选择适合自己团队的工作流"><a href="#2-选择适合自己团队的工作流" class="headerlink" title="2.选择适合自己团队的工作流"></a>2.选择适合自己团队的工作流</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a8c719c7-af57-49cd-be78-22c37ef1a453.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/20094dc9-d19f-4455-bcf6-a6cd1ba16704.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/ca8f17b4-8f25-4a4b-9f72-3fa4220767c9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/86497509-61d6-475f-9e09-644a4c11269b.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fd472e76-3fdf-41d3-99f4-cfa77888cc46.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/36620676-47e4-41be-9609-c4511a38485e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/10ed3ecd-acac-457e-862b-520139270bd8.jpg" alt></p><h2 id="3-挑选合适的分支集成策略"><a href="#3-挑选合适的分支集成策略" class="headerlink" title="3.挑选合适的分支集成策略"></a>3.挑选合适的分支集成策略</h2><p>Insights &gt;&gt; Network 中可以查看版本树的演进。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/49ab1fe1-5685-40f2-aa6c-27e585533b76.jpg" alt></p><p>集成策略：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/051f3a09-38a5-4957-9510-dfcbb34c93d2.png" alt></p><p>有的团队希望最后的历史树像<strong>一条线</strong>一样，应选择 *<em>Allow rebase merging 或者 squash *</em></p><p><font color="red"><strong>Beijing为例</strong></font></p><p><strong>Merge</strong>：特性分支合并到base分支上</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a9ee48f2-74ca-4d36-9461-ff631b46c870.jpg" alt></p><p><strong>Squash</strong>: 特性分支不动，base分支自动添加特性分支的所有变更为1个（如特性分支上有5个commit，base分支会5合1）</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5b3df45b-80df-4c4c-93a8-81b8c641fa1a.jpg" alt></p><p><strong>Rebase</strong>: 不改变特性分支，base分支会自动添加特性分支的所有变更，且<strong>不会</strong>合成一个</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3010b401-fd66-4425-b675-4556c67cb407.jpg" alt></p><h2 id="4-启用issue跟踪需求和任务"><a href="#4-启用issue跟踪需求和任务" class="headerlink" title="4.启用issue跟踪需求和任务"></a>4.启用issue跟踪需求和任务</h2><p>选用 stars:&gt;100000 的开源项目来查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/16e07275-4d2b-402a-a50e-0648631716e4.png" alt></p><p>点击 Lables 以 标签的形式查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0a6cc850-3f29-4abd-b282-26daee4a2e06.png" alt></p><p>如何启用issue呢？</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfe21652-2b4e-46e1-b534-4c02ec6dd531.png" alt></p><p>建立 issue后会出现类似的文件</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/186c0666-1dfa-4ced-b588-ece60d6c9605.png" alt></p><h2 id="5-使用project管理issue"><a href="#5-使用project管理issue" class="headerlink" title="5.使用project管理issue"></a>5.使用project管理issue</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fc10fa87-3b54-48a4-9a20-1723d6b72ed3.png" alt></p><p>不同的看板类型 显示效果不一样，以bug为例：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/1ecccc60-40dd-40be-b6ed-2befb2a266ad.png" alt></p><p>可以对任务分发，项目进度把握进行观察</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/026076bc-ccd1-4208-ae96-196c3982138e.png" alt></p><h2 id="6-项目内部如何-code-review"><a href="#6-项目内部如何-code-review" class="headerlink" title="6.项目内部如何 code review"></a>6.项目内部如何 code review</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c53619b8-9fdc-4d69-8d0b-436f94468ad2.png" alt></p><p>根据需求对匹配到的不同分支做限制。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b0768be8-0078-4c68-8538-0197138b47a6.png" alt></p><p>下面做了限制，防止对远端代码造成破坏。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/2c20094b-8f8e-405c-90e5-65521154518c.png" alt></p><h2 id="7-团队协作如何做多分支的集成"><a href="#7-团队协作如何做多分支的集成" class="headerlink" title="7.团队协作如何做多分支的集成"></a>7.团队协作如何做多分支的集成</h2><p>特性分支总是有先有后的合成到base分支上，看看GitHub上是如何做</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b118050-ca7b-4d73-a633-2f02ae35ad12.jpg" alt></p><p><strong>Merge</strong>:</p><p>beijing merge 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e3a600d5-8897-42c2-bcaf-1f138379e255.jpg" alt></p><p>shanghai  也要 merge 到 base:</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/075b0539-7ff0-49aa-ba54-01f29e128bf4.jpg" alt></p><p>在线编辑解决冲突。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/770e44a3-857c-4cc6-810b-05eee2d4640c.jpg" alt></p><p>此时的代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b1137354-7eef-4570-8d51-5be16c5b72a8.jpg" alt></p><p>pull request 选择 merge 后查看代码树的变化：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfec3bde-f53e-4737-bb7a-08ff0189c793.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8d941049-4846-4bac-9876-0c50d213395a.jpg" alt></p><p>为了演示，将分支回退到之前的版本，实际上禁止这样处理</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/275f14ab-7c2e-4403-bd7b-63d28bc0ace3.jpg" alt></p><p><font color="red">此时 master 回退</font></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d645c180-1732-4ec9-a945-263f855089fa.jpg" alt></p><p><strong>Squash</strong>:</p><p>beijing  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55844bec-4ee4-4da7-aa6e-2242bf65c3db.jpg" alt></p><p>将 beijing 特性分支上做的3次变更 集成到 master分支上，且3合1<br>新生成1个commit,不会改动特性分支。</p><p>shanghai  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f7b90cae-d238-40a6-8895-fb271e1f7ab9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55521f26-e985-4afb-bbb1-5eb2375edf5e.jpg" alt></p><p>选中后就会报错 不能自动的merge,需要手动处理冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/70de5e05-2d68-44b3-9a05-ea28bf2ab4df.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d096a3d6-a46e-4b96-99f8-03635923aa0f.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c88f62c3-680b-49c3-b6f7-12777c634d2f.jpg" alt></p><hr><p>手动解决冲突后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5828e5a1-55a6-496c-a2f6-9b1e609e5eaa.jpg" alt></p><hr><p>冲突解决，但还没有接收时的代码树</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/69ea69db-7c60-424b-8a16-7eed94c30365.jpg" alt></p><hr><p>点击 Squash按钮后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9db23230-b878-4b45-acf0-7fc0f9c371a5.jpg" alt></p><hr><p>查看当前代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7d9e5cd9-21fe-4eff-9752-e8b9c2786ca1.jpg" alt></p><p><font color="red">master 再次回退</font></p><p>回到初始的状态：<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d43b9b20-2748-454c-85ba-ab06784a9b30.jpg" alt></p><p><strong>Rebase</strong>:</p><p>beijing  rebase 到 base后：<br>不改变特性分支，将 beijing分支的变更如实更新到 master分支上，不做合成。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f84fabeb-04ca-4b79-b384-3ee85c5447ec.jpg" alt></p><p>shanghai  rebase 到 base后：<br>会发生冲突，解决冲突后但还没有接收squash：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/babdf2f4-c1d6-475b-9f81-d33e8bbbfbf0.jpg" alt></p><p>此时 pull request 已经走到死胡同，不能再往下走了</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dc90bc8a-b9d6-4e46-99b9-46ff0b5d10cb.jpg" alt></p><p>此时 Github 已经无能为力，但团队还是坚持要用 rebase。<br>可以将 shanghai 回退到 s这个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av  &#x2F;&#x2F;确保本地分支在 s节点</span><br><span class="line">git push -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6a45a1fa-e5f2-4a3d-a427-beb97e84abb7.jpg" alt></p><p>我们应该回到ShangHai分支，让 ShangHai分支执行变基的操作，基于远端的master分支进行变基。</p><p><strong>繁琐处理：</strong><br>在本地做这件事，需要将远端的 master 拉取到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0dad0ce9-8fb5-49af-a819-02504d24859f.jpg" alt></p><p>切换到需要变基的分支，即 ShangHai分支，基于远端的 Master分支进行变基。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;master &#x2F;&#x2F;自然会报冲突 readme文件出了冲突</span><br><span class="line"></span><br><span class="line">vi readme &#x2F;&#x2F;解决冲突即可</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理，直到没有冲突</span><br><span class="line"></span><br><span class="line">git status &#x2F;&#x2F; 工作区是干净的即可</span><br><span class="line">gitk --all &#x2F;&#x2F; 查看分支树</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31e04eb9-1c49-4316-83be-475ed0fd6e80.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/4678ec2a-0cea-4d3d-8ff2-e2708c2d1ee0.jpg" alt></p><p>继续推送即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git push origin Shanghai &#x2F;&#x2F; 会报 非 fast-forwards</span><br><span class="line"></span><br><span class="line">同分支的本地往远端推送，必须是 fast-forwards才行</span><br><span class="line"></span><br><span class="line">除非加上 -f</span><br><span class="line"></span><br><span class="line">git push  -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9ad43201-005f-4c37-ae62-fca6815ba55e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/08d08193-5c71-429f-aeca-660996a4ebea.jpg" alt></p><p>此时，代码树发生了变化</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfde1fd2-0a28-4abe-9b15-9136dbb27095.jpg" alt></p><p>再次查看 pull request发现可以 Rebase<br>即 远端的 master分支 与 远端的 ShangHai分支处理 Fast-Forward状态，不会再有冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b46166ab-7e19-4488-aae2-a2f54768c735.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f03a16a-3dae-41f5-9247-5a348f33a90f.jpg" alt></p><hr><p>有两个头像，一个是源文件的作者，一个是该文件的提交者。<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/cf7e6f21-0886-46c1-a51a-fe2f04c70abf.jpg" alt></p><p><strong>特殊处理：</strong></p><p>Git官网：找到 Documentation —&gt;&gt; Pro Git book 选择 简体中文<br><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/df38e4ff-6c68-4d2b-bc30-46d62c978bb7.png" alt></p><p>因为经过繁琐处理已经没有冲突，需要将ShangHai版本恢复到 远端 s节点继续演示</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/95fc6d9d-5048-4e44-8358-518ccc9f6b49.jpg" alt></p><p>Master 分支也需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/965989da-0f55-4cfb-bc05-7aff3973a755.jpg" alt></p><p>开启 rerere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global rerere.enabled true</span><br><span class="line">git checkout ShangHai</span><br><span class="line">git merge master &#x2F;&#x2F;  只有看到Recorded resolution for ... 才算开始记录解决冲突的办法     当前报冲突，解决冲突</span><br><span class="line">vim readme</span><br><span class="line">git add .</span><br><span class="line">git commit -am &quot;temp&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/24000499-5018-466d-8553-0d3c12da0a50.jpg" alt></p><p>因为只是为了记录解决冲突的方法，temp 这个 commit并不需要，所以需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e0fa0fb5-c7cb-42c3-bcdb-7a4d7ec91854.jpg" alt></p><p>现在 ShangHai  等待着与 远端的 Master 做 rebase，并且使用 rerere<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8444c3f4-821d-4ea5-846e-2a784608b009.jpg" alt></p><p>基于 master(7425314) 做 rebase</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8a6e2f89-ecea-4176-ae48-843348aa2b7d.jpg" alt></p><p>虽然报了冲突，但进去 readme看后发现 冲突内容被自动解决了<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f1a0406-9d6b-4222-876d-afd6a0d9e767.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git rebase  --continue</span><br><span class="line">vi readme &#x2F;&#x2F;冲突也没有 根据提示 添加 readme</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status  &#x2F;&#x2F;一直到不再报冲突为止</span><br><span class="line"></span><br><span class="line">git log -n5  &#x2F;&#x2F; 查看commit是否如实更新上去</span><br></pre></td></tr></table></figure><h2 id="8-如何保证集成质量"><a href="#8-如何保证集成质量" class="headerlink" title="8.如何保证集成质量"></a>8.如何保证集成质量</h2><p>通过 settings 中的 各种保险设置进行控制</p><p>也可在 市场中搜索各种 插件 APP 进行集成管控自己的代码。</p><h2 id="9-产品如何发布到GitHub上"><a href="#9-产品如何发布到GitHub上" class="headerlink" title="9.产品如何发布到GitHub上"></a>9.产品如何发布到GitHub上</h2><p><strong>Release</strong><br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/83c9516e-1095-4441-adcb-fb43d32f54e9.png" alt></p><p>如果是以 travis为例，需要在 .travis.yml文件中编写deploy的各种配置<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/88dbd0f3-6076-4eb1-9195-d55b17dffd1d.jpg" alt></p><hr><p>api_key 不能暴露， 通过变量方式获取<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b822c8e-5eef-4bb5-a123-879c578f650a.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/434cac1a-1033-4a93-b1e4-2b15e43e3e99.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5a4f266e-313d-40fb-a626-d64e1f6b7996.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7cad2344-3d21-445e-a558-9cbe2cc12142.jpg" alt></p><p>name 是yml文件中的变量名称</p><p>value 在如下图中：在个人 setting 的 token中</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b568e180-66fc-4606-9fe2-891c81a305a1.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8042988e-13b1-4398-99ae-b54c5a8e7d97.jpg" alt></p><hr><p>pull request merge到主分支</p><p>经过 travis ci 各种审查后，点击 release即可看到<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6fde5cb5-4e6e-4894-8079-6426d91dd358.jpg" alt></p><p>即通过 travis ci 通过 配置 travis.yml文件 将 java 工程部署到GitHub的 release中，期间要配置Token。</p><h2 id="10-如何给项目添加详细的指导文档-Wiki"><a href="#10-如何给项目添加详细的指导文档-Wiki" class="headerlink" title="10.如何给项目添加详细的指导文档 (Wiki)"></a>10.如何给项目添加详细的指导文档 (Wiki)</h2><p><strong>GitHub提供了 Wiki 功能</strong></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0b05b38d-5d3a-49b4-a38e-82c28270a5a1.jpg" alt></p><p>挑选别的开源项目中 wiki写的比较好的 下载下来，推送到自己的项目中才能进行各种 edit。</p><p>此时远端的 wiki 中 会出现别人的 wiki<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7a33688d-e6b3-4177-9b88-0c9a405dbe47.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-GitHub的认识与使用</title>
      <link href="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-GitHub为什么会火"><a href="#1-GitHub为什么会火" class="headerlink" title="1.GitHub为什么会火"></a>1.GitHub为什么会火</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/53d51f84-9a62-4dde-9be4-7cbb9d0b1dae.jpg" alt></p><a id="more"></a><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/fbc94ced-1d7f-4a8d-9efb-22dbc218846e.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/7dbd21e1-01d8-4279-b7dd-0b5735565315.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/68ad18d1-6b50-49fb-82cb-0c64ea04cd9d.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a0c7cf11-f98f-40e9-9a73-b965ec8584c5.jpg" alt></p><h2 id="2-GitHub都有哪些核心功能"><a href="#2-GitHub都有哪些核心功能" class="headerlink" title="2.GitHub都有哪些核心功能"></a>2.GitHub都有哪些核心功能</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/89cbfdee-4587-495e-82eb-983f400ed9cc.png" alt></p><hr><p><strong>CI/CD</strong>：持续集成Continuous Integration（CI）和持续交付Continuous Delivery（CD）</p><p><strong>安全开发</strong><br><strong>代码审查</strong><br><strong>应用程序</strong><br><strong>托管代码</strong><br><strong>项目管理</strong><br><strong>团队管理</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/3cb0ab88-815b-4ad4-9c5b-89f1b59abea5.png" alt></p><h2 id="3-怎么快速淘到感兴趣的开源项目"><a href="#3-怎么快速淘到感兴趣的开源项目" class="headerlink" title="3.怎么快速淘到感兴趣的开源项目"></a>3.怎么快速淘到感兴趣的开源项目</h2><p>通过搜索匹配<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4b02d18e-520c-411a-8f1b-3d38afb83285.png" alt></p><p>或者使用<strong>高级搜索</strong></p><p><strong>git 最好学习资料 in:readme stars:&gt;1000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a7f07365-78c6-4406-bc0e-a8badd887228.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8d66d247-f9d2-4b44-9809-f0ff9af00b91.png" alt></p><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/e0a543a9-3b11-4b7b-94e2-71cb628b8f7f.png" alt></p><p>如果不登录去搜索的话，code 后会跟着 ？ 提示必须登录后才能享受代码的功能</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/1511493f-8f4e-4be8-8bb2-e91d1313ea5c.png" alt></p><h2 id="4-怎样在GitHub上搭建个人博客"><a href="#4-怎样在GitHub上搭建个人博客" class="headerlink" title="4.怎样在GitHub上搭建个人博客"></a>4.怎样在GitHub上搭建个人博客</h2><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p>此处以 <a href="https://github.com/barryclark" target="_blank" rel="noopener">barryclark</a>/<strong><a href="https://github.com/barryclark/jekyll-now" target="_blank" rel="noopener">jekyll-now</a></strong> 为例进行搭建。</p><p>按照步骤</p><ol><li>fork 到自己的仓库中，然后修改仓库名字</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4e3677f9-8877-40b8-86bf-dfbf3e6e56c6.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/839c82a3-253a-436a-aa2c-2b8df57bc2c3.png" alt></p><ol start="2"><li>修改配置文件</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/42ba975b-f1b0-4736-ae7a-3dda0f2493ce.png" alt></p><p>根据需求自己做调整</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2d59fd09-1072-47de-bc65-8fd2e7b06287.png" alt></p><ol start="3"><li>修改_post文件</li></ol><p>可以直接修改 2014-3-3-Hello-World.md 文件<br>或者<br>Create new file 文件<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/0b11316b-70c3-40bc-91ad-6bf75f768c45.png" alt></p><ol start="4"><li>有效日期+标题 2018-12-24-HaoRan-First-Blob.md</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a8784c54-f7a4-42bf-a3e0-9499b47a336b.png" alt></p><p>5.域名在settings中查找</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/6ff2ad0f-c4c6-47da-85bd-4e5486d8b547.png" alt></p><p>6.个人Blob展示</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/71e8cffb-3861-4936-a53e-66ce6f73d2a4.png" alt></p><h2 id="5-开源项目怎么保证代码质量"><a href="#5-开源项目怎么保证代码质量" class="headerlink" title="5.开源项目怎么保证代码质量"></a>5.开源项目怎么保证代码质量</h2><p>进入GitHub主页，点击 pull request</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/5b9b398f-0281-48b8-a47e-fb6ec287203d.jpg" alt></p><p>被merge吸纳的是紫色的，被拒绝的是红色的</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4289a643-491e-4fd5-b8d0-462039459ff2.jpg" alt></p><p>可以看到，有代码审查，有智能监测，owner在做了一系列检查后，才决定是否将他人的request merge到 master上来。</p><h2 id="6-为何需要组织类型的仓库"><a href="#6-为何需要组织类型的仓库" class="headerlink" title="6.为何需要组织类型的仓库"></a>6.为何需要组织类型的仓库</h2><p>在个人 porfile中 会有组织这种类型的仓库。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8aa1d29e-38ec-447a-9442-a772f0d0ef97.jpg" alt></p><p>举一个例子：<br>现阶段，我可能在A公司工作，A公司有一些公共开源的项目在GitHub上托管。过段时间，又加入到B公司的开源项目中工作。根据组织的成员也在流动中，所以需要组织类型的仓库对成员进行管理。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/cf97a418-e69a-4362-aa8c-dd3232217ec2.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f55a9a52-345a-4102-bc92-04ef177994db.jpg" alt></p><p><strong>邀请成员</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f18431a3-248e-4591-b865-8adb5025ae98.jpg" alt></p><p><strong>Team</strong>可以对仓库进行精细化的管控</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2c3267ca-ec77-4685-a2a0-49e63e697928.jpg" alt></p><p>可以加入教师团队的人员</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/32809d24-79a6-47e3-8abe-dcafff4219d9.jpg" alt></p><p>可以给人员分配仓库不同的权限</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/142f6b99-9f3e-49e6-8dd1-fe543d886344.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Git集成使用禁忌</title>
      <link href="/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/"/>
      <url>/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-禁止向集成分支执行push-f-操作"><a href="#1-禁止向集成分支执行push-f-操作" class="headerlink" title="1.禁止向集成分支执行push -f 操作"></a>1.禁止向集成分支执行push -f 操作</h2><p><strong>git push -f：会强制推送，对团队造成危害（虽然远程仓库有特殊机制制止这种变更）</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --hard 回退到某个古老的ID号</span><br><span class="line">git push -f &#x2F;&#x2F;会销毁远端最新最近的提交，所以禁止执行这个命令</span><br></pre></td></tr></table></figure><h2 id="2-禁止向集成分支执行变更历史的操作"><a href="#2-禁止向集成分支执行变更历史的操作" class="headerlink" title="2.禁止向集成分支执行变更历史的操作"></a>2.禁止向集成分支执行变更历史的操作</h2><p>团队协同工作时，<strong>公共分支严禁拉取到本地做rebase变基活动的</strong>，公共分支是团队一起一天天积累下来的，只能往前走，不能做历史变更。</p><p><strong>集成分支不能被改变历史</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Git多人单分支集成协作时的常见场景</title>
      <link href="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-不同人修改不同文件如何处理"><a href="#1-不同人修改不同文件如何处理" class="headerlink" title="1.不同人修改不同文件如何处理"></a>1.不同人修改不同文件如何处理</h2><p><strong>JavaSsun用户修改 readme文件</strong><br><strong>haoran用户修改index文件</strong><br><strong>远端仓库新建一个名字为 feature/add_git_commands的分支</strong></p><p>为了在单机模拟两个人做操作，需要从远端克隆一个 命名为 git_learning_02 以 JavaSsun为用户的仓库</p><a id="more"></a><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/462c8fe6-41e9-448d-811b-af9aea07d29f.png" alt></p><p>再变更email</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/64daaa82-8983-411c-914a-61cc63b451e5.png" alt></p><p>基于远端刚才新建的分支在本地新建一个分支，并切换到该分支上（二者联系起来）</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/cc5a524a-5f7e-4b81-8c97-b773ac2f3224.png" alt></p><p>JavaSsun在git_learning_02仓库中修改readme文件，commit后 推送到远端仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push   即可（为什么不用加分支名了呢，因为上面命令中本地分支与远端分支做了关联）</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/0c2fe061-aebc-4a6e-ad4e-e191f9c57912.png" alt></p><p>远端仓库也有了最新的变更</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/c8d976b1-c8ee-4e78-900b-d01fe34540d4.png" alt></p><p><strong>至此，JavaSsun开发人员修改完了readme，并提交到了远程仓库。</strong></p><p>切换到haoran所属的git_learning 仓库，查看后发现没有 feature/add_git_commands分支，需要拉取下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git fetch github</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/16f7fea5-27cc-43cc-b7cc-1ed31bc51048.png" alt></p><p>将本地新建分支并与远端的分支做关联（名字最好一致，并查看hash值后发现确实是一致的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;add_git_commands github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/fba96bf8-4ef8-4dfb-8edf-c0004c9c1b76.png" alt></p><p><font color="red">Hash值都是 27582a7</font></p><p>haoran用户修改index文件，commit完成。<br>JavaSsun用户又修改了readme文件，并且push到远程。<br>此时，haoran用户push自己的index文件到远端，会报错，如下图：</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/7286fc61-21d2-43b1-884c-c86d466a2394.png" alt></p><p>如何解决呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch github  尝试拉取远端的最新变更</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/95006c82-d402-4b55-a1b4-a26869cad23d.png" alt></p><p>发现有一个是 ahead 1 , behind 1 即本地比远端多一个，远端也比本地多一个。</p><p><strong>如果团队不要求用线性树的模式的话，可以用merge 与远端的进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/86e9dc79-a8f3-4759-a9b1-5d7311f7b625.png" alt></p><p>查看readme文件，发现将JavaSsun用户提交的内容都合了进来。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/6e46ee55-4829-4bf3-b871-082e599fb039.png" alt></p><p>此时在使用 <strong>git push github</strong> 就不会报错</p><h2 id="2-不同人修改同文件不同区域如何处理"><a href="#2-不同人修改同文件不同区域如何处理" class="headerlink" title="2.不同人修改同文件不同区域如何处理"></a>2.不同人修改同文件不同区域如何处理</h2><p>开发之前都需要将自己的分支与远端做一次同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>haoran</strong>：  对index.html文件做了变更，并做了commit<br><strong>JavaSsun</strong>: 对index.html文件做了变更，并做了commit</p><p><strong>haoran</strong>用户将自己的变更推送到了远端。此时 JavaSsun用户并不知道远端发生了新变更，也想推送自己的变更，自然就被拒绝。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/ac9f49fa-3b5c-4606-be44-1157432c6d45.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/340a928c-76a7-45fd-b5c8-fd34a7fca38d.png" alt></p><p>出现比远端做一个commit，同时比远端少一个commit,做merge即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git merge origin&#x2F;feature&#x2F;add_git_commands(远端分支或者分支ID号)</span><br></pre></td></tr></table></figure><p>默认缺省即可，查看发现有了其他人添加的内容。</p><h2 id="3-不同人修改同文件同一区域如何处理"><a href="#3-不同人修改同文件同一区域如何处理" class="headerlink" title="3.不同人修改同文件同一区域如何处理"></a>3.不同人修改同文件同一区域如何处理</h2><p>工作区先进行同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>都对index.html文件的同一区域做了相同的变更，JavaSsun用户将自己的变更推送到了远端，haoran用户想推送自己的变更时被拒绝了。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/954bba88-adef-4176-9d20-f77bfcb8d8df.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果用 merge 直接与远端进行合并，又发现 Already up to date，但又push不上去。</span><br><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p>此时，需要用 git pull 命令,出现了冲突（需手动解决）<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/07f361a2-d594-4c27-84e9-ae0abfafec0e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/100853e3-cee0-4abe-8583-8575cde7c76e.png" alt></p><p><strong>&lt;&lt;&lt;&lt;&lt;HEAD 到 ===========是自己的变更</strong><br><strong>=========到&gt;&gt;&gt;&gt;&gt;&gt;&gt;是别人的变更</strong></p><p>留下双方都需要的变更<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/e869d140-31d9-4126-8225-bcbd683321fd.png" alt></p><p>使用 <strong>git status</strong> 出现提示信息<br><strong>git commit 保留二者的变更。 **<br>**git merge –abort 不想让这两个分支merge，恢复到merge之前的状态。</strong></p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/57b10dc7-595f-4c3f-a5cc-97f6922ab404.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push github 推送即可</span><br><span class="line"></span><br><span class="line">另一个人</span><br><span class="line">git pull  拉取远端最新的变更即可</span><br></pre></td></tr></table></figure><h2 id="4-同时变更了文件名和文件内容如何处理"><a href="#4-同时变更了文件名和文件内容如何处理" class="headerlink" title="4.同时变更了文件名和文件内容如何处理"></a>4.同时变更了文件名和文件内容如何处理</h2><p>A变更了文件名，B变更了文件内容，但还是按照原来的文件名推送。</p><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git mv index.html index.htm</span><br><span class="line">git status</span><br><span class="line">git commit -am &quot;Mv index.html to index.htm&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/08718508-fa10-4155-8729-c6735a141a07.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -am &quot;....&quot;</span><br><span class="line">git push  &#x2F;&#x2F;会报错</span><br><span class="line">git pull  &#x2F;&#x2F; 默认缺省值 :wq</span><br><span class="line">ll -al   &#x2F;&#x2F;文件名已经更改过来 index.htm</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/82033f41-57ba-40ec-b694-0002adfa4244.png" alt></p><h2 id="5-同一文件改成了不同的文件名如何处理"><a href="#5-同一文件改成了不同的文件名如何处理" class="headerlink" title="5.同一文件改成了不同的文件名如何处理"></a>5.同一文件改成了不同的文件名如何处理</h2><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index2.html</span><br><span class="line">git commit -am &quot;Mv index to index2&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/b2ff7258-bf35-4458-ad39-32d94e263c1b.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index1.html</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push &#x2F;&#x2F;报错</span><br><span class="line">git pull &#x2F;&#x2F;报冲突</span><br><span class="line">ll -al   &#x2F;&#x2F;发现出现两个文件</span><br><span class="line">diff index1.htm index2.htm  &#x2F;&#x2F;只是文件名不同，内容是一致的</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f685d46e-0796-4f75-9f98-67064df101dd.png" alt></p><p>查看状态，需要协作者一起协商文件名的选取</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/aaca27e6-94be-4348-b12a-72e295a477ef.png" alt></p><p>如果选择 index1.htm这个名字，需要按以下命令更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git rm index.htm index2.htm</span><br><span class="line">git add index1.htm</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f7faceed-f423-43e3-bbd6-9813f5e448a2.png" alt></p><p>远端的已经变成了index1.htm<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/33006191-16a2-4668-ba75-aba5a7837028.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Git与GitHub简单同步</title>
      <link href="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-注册一个GitHub账号"><a href="#1-注册一个GitHub账号" class="headerlink" title="1.注册一个GitHub账号"></a>1.注册一个GitHub账号</h2><p>略<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/3f130bd8-80ca-4c71-973a-0c3bd9146ea3.png" alt></p><a id="more"></a><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/2f0d55c7-f1f5-463a-9c1d-503aea9d7070.png" alt></p><p>将公钥粘贴到GitHub上来，方便推送。</p><h2 id="2-配置公私钥"><a href="#2-配置公私钥" class="headerlink" title="2.配置公私钥"></a>2.配置公私钥</h2><p><strong>查看是否之前有过公私钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ll -al</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/27b6c3ca-54d0-4f78-9fd0-d4efc9cc81b9.png" alt></p><p><strong>如果没有配置过，是不会出现 id_rsa 与 id_rsa.pub这两个文件的</strong></p><p><strong>生成公私钥命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;2642487764@qq.com&quot;</span><br><span class="line">一路回车即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/79ea4449-83f0-4a0c-9920-d8ff5cf7902b.jpg" alt></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/b21dc469-dfff-40c2-abfd-c661b11de310.png" alt></p><p>复制到GitHub的账户上即可、<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a35abfab-8c9d-4e94-a132-f502155abb62.png" alt></p><p><strong>好处</strong>：ssh协议做push活动时不需要再输入用户名密码，可以智能识别，允许自己往对应的GitHub账户上推送内容。</p><h2 id="3-GitHub上创建个人仓库"><a href="#3-GitHub上创建个人仓库" class="headerlink" title="3.GitHub上创建个人仓库"></a>3.GitHub上创建个人仓库</h2><p><strong>MIT License 可以直接拿过来用</strong></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/c7414606-ca57-4231-be64-3d36af153932.png" alt></p><p>点开会拥有 MIT lecense标识<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/07a92364-782e-48a4-8d2f-c0744488765b.png" alt></p><h2 id="4-本地仓库同步到GitHub"><a href="#4-本地仓库同步到GitHub" class="headerlink" title="4.本地仓库同步到GitHub"></a>4.本地仓库同步到GitHub</h2><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a9b74e0a-dc0e-4a35-9b3d-0de613b6569b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add github git@github.com:JavaSsun&#x2F;git_learning.git</span><br><span class="line"></span><br><span class="line">添加远程站点 并更名为  github</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/adf9277a-96d2-4318-a877-134fd63b77cb.png" alt></p><p><strong>有了上述github后 即可与远端建立联系</strong></p><p>因为 远端有了 License文件 ，在本地直接push的时候会报错，提示push前需要把远端的先pull下来。</p><p><strong>没有pull之前的版本树</strong><br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/617d8530-f5e2-447f-b4b9-a9976b5a926f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github master  拉取远端 master上的文件到本地，仅仅是拉取，没有与本地分支做merge</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6d78b45d-b26e-4c80-9596-9268d916ce74.png" alt></p><p>此时 远端的 LICENSE已经被fetch下来</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d21ef24-88fc-48de-a48d-ff36c39e4efa.png" alt></p><p>将本地master与远端master进行merge，但是会报错<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/4eff67a2-224d-4ed5-ac26-b46ca787549f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge -h  查找帮助</span><br><span class="line">git merge --allow-unrelated-histories github&#x2F;master</span><br><span class="line">在交互界面使用默认缺省值即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/8efd7ace-e75e-4fcb-8fb6-95d762d59e44.png" alt></p><p>查看merge后的当前树（发现有两个父亲，rebase则是线性的，只有一个）</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d37e621-8bac-43f7-b421-33b8974df6f5.png" alt></p><p>此时再将本地push到远方，不会再报错</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6b3b24b8-517f-417d-b87d-c04e67347a95.png" alt></p><p>查看当前树</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a48de224-c5cd-428b-a7c0-66acd18e58bb.png" alt></p><p>查看远端仓库</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/da932435-ce0a-4a69-ab63-161987e1bb6d.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Git常用场景</title>
      <link href="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-删除无用分支"><a href="#1-删除无用分支" class="headerlink" title="1.删除无用分支"></a>1.删除无用分支</h2><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cbe35443-f8b1-43e6-a798-b0828a836ef3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name             &#x2F;&#x2F; 删除分支(会有提示是否确认删除)</span><br><span class="line">git branch -D branch_name             &#x2F;&#x2F; 删除分支（确认删除情况下）</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-修改本地最新commit的messagee"><a href="#2-修改本地最新commit的messagee" class="headerlink" title="2.修改本地最新commit的messagee"></a>2.修改本地最新commit的messagee</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend               &#x2F;&#x2F;可以对最新的commit的message做变更</span><br></pre></td></tr></table></figure><h2 id="3-修改本地老旧commit的message"><a href="#3-修改本地老旧commit的message" class="headerlink" title="3.修改本地老旧commit的message"></a>3.修改本地老旧commit的message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  待修改commit的父ID号        &#x2F;&#x2F; -i交互式</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/caa4ac95-c0c9-491e-b4df-26f9c7faf1ba.png" alt><br>将第一个 pick 改为 reword / r 然后保存,会再次进入交互界面。</p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/8c965b60-3093-4927-b588-f07df7b8ef5d.png" alt></p><p>修改变更的信息后保存，查看信息。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/61baa9ed-06a6-4f23-b99a-442093cfbe82.png" alt></p><h2 id="4-连续多个本地commit整理成1个"><a href="#4-连续多个本地commit整理成1个" class="headerlink" title="4.连续多个本地commit整理成1个"></a>4.连续多个本地commit整理成1个</h2><p>将中间两个合并成一个commit<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f95841b5-9286-4c80-a1b9-2db49e5b147d.png" alt></p><p>此时，应该基准是中间两个的父ID号，即 7f7e472c30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c30</span><br></pre></td></tr></table></figure><p>选用 squash 或者 s 进行合并<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/e7eec623-3f36-4ca8-b02d-8f36a2f92b0d.png" alt></p><p>添加合并信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f2c191d1-ebab-4b52-b01b-fa120ae984a1.png" alt></p><p>git log –graph            //查看日志<br><strong>会对整理后的commit生成一个新的ID号</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/032b9093-e06b-4dbe-80c4-dd35b5ab5300.png" alt></p><h2 id="4-多个本地-间隔commit整理成1个"><a href="#4-多个本地-间隔commit整理成1个" class="headerlink" title="4.多个本地 间隔commit整理成1个"></a>4.多个本地 间隔commit整理成1个</h2><p><strong>将最新的一个与第一个合成一个commit</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/b9d3b699-43ee-4d12-b475-94be40a3bac9.png" alt></p><p>因为最早的一个没有父亲，所以直接使用rebase变更命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/5db8b72f-677d-4a87-acf5-ecad61863d6d.png" alt></p><p>添加   pick 7f7e471c 命令      //最古老的那一个    <strong>合并上限</strong><br>将        s 96764b86 添加到上面命令的下一行  //    <strong>合并下限</strong><br>删除   pick 96764b8  命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue   &#x2F;&#x2F;继续  使用这个继续操作</span><br><span class="line">git rebase --abort      &#x2F;&#x2F;舍弃</span><br></pre></td></tr></table></figure><p>添加变更信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/59279101-2af0-414e-9235-7ad4bdab712d.png" alt></p><p>合并成功，生成新的commit ID号<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/3b7309ee-3845-4d28-9106-cff524594bd5.png" alt></p><p>此时出现两个（树）根 可以看情况删除非master所在的根<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/6e3b571f-984d-4c1a-be95-15d2c6d66dbf.png" alt></p><h2 id="5-比较暂存区与HEAD所含文件的差异"><a href="#5-比较暂存区与HEAD所含文件的差异" class="headerlink" title="5.比较暂存区与HEAD所含文件的差异"></a>5.比较暂存区与HEAD所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变更内容后使用 git add 添加到暂存区</span><br><span class="line">git status</span><br><span class="line">git diff --cached            &#x2F;&#x2F;查看暂存区与HEAD所指向文件的具体变化</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/832bbece-3ea4-4ef6-a4d2-ff94c99a10b0.png" alt></p><h2 id="6-比较暂存区与工作区所含文件的差异"><a href="#6-比较暂存区与工作区所含文件的差异" class="headerlink" title="6.比较暂存区与工作区所含文件的差异"></a>6.比较暂存区与工作区所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff                    &#x2F;&#x2F;默认查看工作区与暂存区所有文件的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name      &#x2F;&#x2F;查看指定文件在工作区与暂存区的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name1 file_name2  file_nameN</span><br></pre></td></tr></table></figure><h2 id="7-将暂存区恢复成HEAD所处状态-变暂存区用-reset"><a href="#7-将暂存区恢复成HEAD所处状态-变暂存区用-reset" class="headerlink" title="7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)"></a>7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区有了新的优化方案。此前暂存区的内容不想保留，想回溯到之前的HEAD所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD                &#x2F;&#x2F;取消暂存区中的文件（文件由绿变红）</span><br><span class="line">git diff --cached             &#x2F;&#x2F;比较暂存区与HEAD 返回为空，即撤销成功</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/4da5296d-6b61-4e5e-92db-15f3430d4179.png" alt></p><h2 id="8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）"><a href="#8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）" class="headerlink" title="8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）"></a>8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区做了变化后，发现没有暂存区的好。<br>想舍弃工作区当前的更改，回溯到暂存区所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file_name   &#x2F;&#x2F; 舍弃工作区的变更，恢复为暂存区的内容</span><br><span class="line">git diff file_name          &#x2F;&#x2F; 没有返回信息，工作区与暂存区一致</span><br></pre></td></tr></table></figure><h2 id="9-取消暂存区部分文件的更改"><a href="#9-取消暂存区部分文件的更改" class="headerlink" title="9.取消暂存区部分文件的更改"></a>9.取消暂存区部分文件的更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- file_name1 file_name2</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/58261fc0-c409-42c7-9c92-9a22d67bc86a.png" alt></p><h2 id="10-消除最近的几次提交"><a href="#10-消除最近的几次提交" class="headerlink" title="10.消除最近的几次提交"></a>10.消除最近的几次提交</h2><p>恢复到提交的前几次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  ID                &#x2F;&#x2F;  回退到指定的commit的ID号</span><br></pre></td></tr></table></figure><h2 id="11-不同提交、分支的指定文件的差异化比较"><a href="#11-不同提交、分支的指定文件的差异化比较" class="headerlink" title="11.不同提交、分支的指定文件的差异化比较"></a>11.不同提交、分支的指定文件的差异化比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff branch_name1 branch_name2    &#x2F;&#x2F;比较两个分支的差异</span><br><span class="line">git diff branch_name1 branch_name2 -- file_name   &#x2F;&#x2F;比较指定文件在指定分支上的差异</span><br><span class="line"></span><br><span class="line">git diff 分支1对应的commit的ID号 分支2对应的commit的ID号   &#x2F;&#x2F;与上述一致</span><br></pre></td></tr></table></figure><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>常规做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm  指定文件名    &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git status       &#x2F;&#x2F;变红色，说明仅仅是删除了工作区中的，</span><br><span class="line">git rm 指定文件名 &#x2F;&#x2F;删除暂存区文件</span><br><span class="line">git status       &#x2F;&#x2F;变绿色，说明暂存区中文件被删除</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD  &#x2F;&#x2F;废除刚才所有变动</span><br></pre></td></tr></table></figure><p><strong>git 做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 指定文件名</span><br><span class="line">git status &#x2F;&#x2F; 变绿色</span><br></pre></td></tr></table></figure><h2 id="13-开发中临时添加紧急任务（stash）"><a href="#13-开发中临时添加紧急任务（stash）" class="headerlink" title="13.开发中临时添加紧急任务（stash）"></a>13.开发中临时添加紧急任务（stash）</h2><p>工作区与暂存区中的内容暂时还不能提交，但是当前又有一个更为紧急的任务需要完成时，可以把工作区与暂存区中的内容存放到另一个空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff       &#x2F;&#x2F; 工作区与暂存区是有差异的</span><br><span class="line">git stash      &#x2F;&#x2F; 将未commit的内容存放另一个空间</span><br><span class="line">git stash list &#x2F;&#x2F; 可以看到类似于存放在有ID号的堆栈中</span><br><span class="line">git status     &#x2F;&#x2F; 工作区与暂存区是干净的</span><br></pre></td></tr></table></figure><p><strong>此时可以处理紧急任务，add到暂存区，commit到仓库后，再回来继续当前开发，需要将之前存储在另一个空间的内容恢复出来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash apply &#x2F;&#x2F; 将内容弹出，但不删除空间中的内容，可反复使用</span><br><span class="line">git stash list  &#x2F;&#x2F; 依然存在</span><br><span class="line">git stash pop   &#x2F;&#x2F; 弹出且删除空间中的内容</span><br><span class="line">git stash list  &#x2F;&#x2F; 什么也没有</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/348f60ab-06f0-4957-8551-9c7dae0ef36c.png" alt></p><p><strong>处理完紧急任务后弹出内容</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/9578d032-8074-4f0c-b3d6-5d30c9bfd9bb.png" alt></p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cf033f3f-a3b8-4607-826a-f034b1aee126.png" alt></p><h2 id="14-指定不需要Git管理的文件"><a href="#14-指定不需要Git管理的文件" class="headerlink" title="14.指定不需要Git管理的文件"></a>14.指定不需要Git管理的文件</h2><p><strong>建立一个文件，指定文件名为 .gitignore</strong></p><p>在文件中添加需要Git版本忽略的文件即可。</p><p>可在GitHub上查看<br><a href="https://github.com/github-tools/github/blob/master/.gitignore" target="_blank" rel="noopener">https://github.com/github-tools/github/blob/master/.gitignore</a></p><h2 id="15-备份Git仓库到本地"><a href="#15-备份Git仓库到本地" class="headerlink" title="15.备份Git仓库到本地"></a>15.备份Git仓库到本地</h2><p>常用的传输协议<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/be6aa585-e6f5-4670-95d0-f34a4c1623d7.jpg" alt></p><p><strong>哑协议与智能协议</strong></p><p><strong>直观区别</strong>：哑协议传输进度不可见；智能协议传输可见。<br><strong>传输速度</strong>：智能协议比哑协议传输速度快。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/35a50a7b-3fbb-4413-9cec-692c4b2bdb72.jpg" alt></p><p><strong>哑协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git ya.git</span><br><span class="line">从本地另一个Git仓库中克隆一个文件到当前仓库</span><br><span class="line">--bare 是只克隆仓库中的内容，不可隆工作区中的内容</span><br><span class="line">将 .git 文件更名为 ya.git文件</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/ac7afc75-38b6-48e2-a671-8c6c719c2199.png" alt></p><p><strong>智能协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git zhineng.git</span><br><span class="line"></span><br><span class="line">前面添加    file:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/a1a209cd-6efb-40d7-9b5c-e090082711ed.png" alt></p><p><strong>本地推远端仓库（demo）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add zhineng file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;666-backup&#x2F;zhineng.git</span><br><span class="line">git brach -av</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Git安装及简单操作</title>
      <link href="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p>图片来源：极客时间，需个人购买教程。</p><h2 id="Git下载路径-https-git-scm-com"><a href="#Git下载路径-https-git-scm-com" class="headerlink" title="Git下载路径 https://git-scm.com/"></a>Git下载路径 <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></h2><h4 id="廖雪峰-Git文档"><a href="#廖雪峰-Git文档" class="headerlink" title="廖雪峰 Git文档"></a>廖雪峰 Git文档</h4><h2 id="https-www-liaoxuefeng-com-wiki-896043488029600"><a href="#https-www-liaoxuefeng-com-wiki-896043488029600" class="headerlink" title="https://www.liaoxuefeng.com/wiki/896043488029600"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version     &#x2F;&#x2F;可查看版本即安装成功</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-使用Git前的小配置"><a href="#1-使用Git前的小配置" class="headerlink" title="1.使用Git前的小配置"></a>1.使用Git前的小配置</h3><h4 id="配置User信息-（user-name-和-user-email）"><a href="#配置User信息-（user-name-和-user-email）" class="headerlink" title="配置User信息  （user.name 和 user.email）"></a>配置User信息  （user.name 和 user.email）</h4><p>方便代码变更时展示变更人信息 及 通知协作者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure><h4 id="config-作用域"><a href="#config-作用域" class="headerlink" title="config 作用域"></a><font color="red">config 作用域</font></h4><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6075a03d-a390-4546-ad59-1b2a2a5c1795.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br><span class="line">git config --local user.name</span><br><span class="line">git config --local user.email</span><br></pre></td></tr></table></figure><h3 id="2-建Git仓库"><a href="#2-建Git仓库" class="headerlink" title="2.建Git仓库"></a>2.建Git仓库</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/025b15b1-6dd2-4a50-9d4d-b152d763370d.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git add                 &#x2F;&#x2F; 添加文件到暂存区</span><br><span class="line">git commit -m &#39;变更内容&#39; &#x2F;&#x2F; 添加文件到Git仓库</span><br><span class="line">git status              &#x2F;&#x2F; 查看文件状态</span><br><span class="line">git log                 &#x2F;&#x2F; 查看提交日志</span><br><span class="line"></span><br><span class="line">git checkout branc_name &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b branch_name &#x2F;&#x2F;创建并切换新分支</span><br><span class="line"></span><br><span class="line">git commit -am &#39;变更信息&#39; &#x2F;&#x2F;直接推到仓库，跳过暂存区，不推荐使用</span><br></pre></td></tr></table></figure><h4 id="local-优先级高于-global，即全局设置的global会被某一个local仓库的信息给覆盖"><a href="#local-优先级高于-global，即全局设置的global会被某一个local仓库的信息给覆盖" class="headerlink" title=" local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖"></a><font color="red"> local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖</font></h4><h3 id="3-工作区与暂存区"><a href="#3-工作区与暂存区" class="headerlink" title="3.工作区与暂存区"></a>3.工作区与暂存区</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/0ea1afe7-4fd5-4f90-825e-d0f280c38dbb.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u            &#x2F;&#x2F; 可以将已修改的 Git所管理的文件 一起提到暂存区，如下所示</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9ff91e2a-397a-450e-b95c-5d266c60d2e3.jpg" alt></p><h3 id="4-Git-中的文件重命名"><a href="#4-Git-中的文件重命名" class="headerlink" title="4.Git 中的文件重命名"></a>4.Git 中的文件重命名</h3><p>常规步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv old_name  new_name       &#x2F;&#x2F; 重命名</span><br><span class="line">git add  new_name           &#x2F;&#x2F; 添加新文件进入暂存区</span><br><span class="line">git rm old_name             &#x2F;&#x2F; 删除暂存区中旧的文件</span><br><span class="line">git status                  &#x2F;&#x2F; Git智能的认为是文件重命名</span><br><span class="line">---  太繁琐  ---</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/cf8ae066-98f1-4e68-bbe9-7839f0e8fba7.png" alt></p><p><font color="red">Git方式重命名</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name  new_name  &#x2F;&#x2F; Git重命名文件   3合1</span><br><span class="line">git status                 &#x2F;&#x2F; 查看状态</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e6ad4c3-298d-4359-92df-fe65f2eb8ee5.png" alt></p><h3 id="5-git-log-查看版本演变历史"><a href="#5-git-log-查看版本演变历史" class="headerlink" title="5.git log 查看版本演变历史"></a>5.git log 查看版本演变历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git log                        &#x2F;&#x2F; 查看当前分支详细版本历史</span><br><span class="line"></span><br><span class="line">git log --oneline              &#x2F;&#x2F; 查看当前分支简略版本历史</span><br><span class="line"></span><br><span class="line">git log -n2                    &#x2F;&#x2F; 查看当前分支最近的两次版本提交记录</span><br><span class="line">git log -n2 --oneline          &#x2F;&#x2F; 组合使用</span><br><span class="line"></span><br><span class="line">git branch -a                  &#x2F;&#x2F; 查看有多少分支(简略)</span><br><span class="line">git branch -v                  &#x2F;&#x2F; 查看有多少分支(详细)</span><br><span class="line">git branch -av                 &#x2F;&#x2F; 常用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log                        &#x2F;&#x2F; 查看当前分支版本</span><br><span class="line"></span><br><span class="line">git log temp                   &#x2F;&#x2F; 查看指定分支temp的历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline temp         &#x2F;&#x2F; 查看指定分支temp的简略历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline --all temp   &#x2F;&#x2F; 此时 依然是查看所有分支的历史版本，temp不再起作用</span><br><span class="line"></span><br><span class="line">git log --all                  &#x2F;&#x2F; 查看所有分支版本历史</span><br><span class="line"></span><br><span class="line">git log --all --graph          &#x2F;&#x2F; 以图形化的方式查看所有分支（父子关系分支）关系</span><br></pre></td></tr></table></figure><p><font color="red">按需求组合：</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5db3e9f7-aabf-4ef3-9864-42aed7a2099e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all -n4 --graph         &#x2F;&#x2F; 查看简略ID</span><br><span class="line">git log --pretty&#x3D;oneline --all -n4 --graph  &#x2F;&#x2F; 查看详细ID</span><br></pre></td></tr></table></figure><p><strong>使用网页方式查看相关命令帮助</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help --web  log            &#x2F;&#x2F; 以网页方式查看log命令用法</span><br><span class="line">git help --web  commit         &#x2F;&#x2F; 以网页方式查看commit命令用法</span><br></pre></td></tr></table></figure><h3 id="6-gitk-通过图形界面工具查看版本演变历史"><a href="#6-gitk-通过图形界面工具查看版本演变历史" class="headerlink" title="6.gitk   通过图形界面工具查看版本演变历史"></a>6.gitk   通过图形界面工具查看版本演变历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br><span class="line"></span><br><span class="line">gitk --all</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ddf34b16-0714-4641-8483-02fffa3fcc0c.png" alt></p><h3 id="7-探索-git目录"><a href="#7-探索-git目录" class="headerlink" title="7.  探索.git目录"></a>7.  探索.git目录</h3><h5 id="HEAD文件"><a href="#HEAD文件" class="headerlink" title="HEAD文件"></a>HEAD文件</h5><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28fe4315-38cf-495f-8da8-0731f13553d7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat HEAD        &#x2F;&#x2F;查看HEAD文本内容 HEAD是一个引用，指向当前工作分支，指向的是refs文件夹下的heads文件夹下的某个分支的ID号</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/d99a688c-7472-48a0-a725-d089915e1249.png" alt></p><p><font color="red">切换回master分支后，HEAD内容发生变化</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/03ef6a79-099b-4929-be05-36bb21a766f4.png" alt></p><h5 id="config配置文件"><a href="#config配置文件" class="headerlink" title="config配置文件"></a>config配置文件</h5><p>对config作用域的user信息的修改直接保存到该文件中。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/98e5bb44-5de4-4ee8-8226-019330ad2950.png" alt></p><p>将user.name 由 local1 改为local2后，再次查看该文件发现已经更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list      &#x2F;&#x2F;列出本地所有可以看得信息</span><br><span class="line">git config --local user.nane   &#x2F;&#x2F;列出指定信息（如user.name）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c595b00-c8c0-47d9-a8aa-793465e69f43.png" alt></p><p><strong>再次修改回去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &#39;local1&#39;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6c514813-a599-410d-98f0-144f247436ab.png" alt></p><h5 id="refs文件夹"><a href="#refs文件夹" class="headerlink" title="refs文件夹"></a>refs文件夹</h5><p>heads: 分支，一个独立的开发空间，前后端各1个分支，互不影响，需要集成时，合并到一个共同的分支上。<br>tags: 标签/里程碑 标明一个版本等。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28046633-46c0-4af5-8ad1-36344f509e92.png" alt></p><p><strong>heads文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t ID号前几位        &#x2F;&#x2F;查看存放的对象是一个什么类型 （commit类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/e0e52020-8d55-44b6-8a0a-392604927f6c.png" alt></p><p><strong>tags文件夹</strong></p><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c392142-567a-466e-b72a-f7bff540600f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p ID号前几位         &#x2F;&#x2F; 查看内容（tag类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/76815d92-3063-4ae0-8e1e-9d260cf93fac.png" alt></p><h5 id="objects文件夹"><a href="#objects文件夹" class="headerlink" title="objects文件夹"></a>objects文件夹</h5><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6659db73-a48b-4935-b5fe-33b9af5f6978.png" alt></p><p><strong>查看98文件夹下存放的类型与内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看类型（tree类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/09cba8a4-0998-4c2b-a306-a57336988f2b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看内容</span><br><span class="line"></span><br><span class="line">blob 文本类型   再次查看blob ID号对应的内容是文本信息</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a2cd87bf-3284-4f0f-ad62-b512505b0199.png" alt></p><p>内容是文本里的内容信息</p><p><font color="red">核心类型：</font><br><strong>TREE  / COMMIT  /  BLOB</strong></p><h3 id="8-commit、tree、blob-三者关系"><a href="#8-commit、tree、blob-三者关系" class="headerlink" title="8.  commit、tree、blob 三者关系"></a>8.  commit、tree、blob 三者关系</h3><p>Git眼中，文件内容完全相同，就被认为是同一个对象。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c6b17719-a3a1-4b69-9edb-76ed250c6cef.jpg" alt><br>**<br>一个commit 对应一个 tree<br>blob 对应文本文件<br>tree 对应文件夹，文件夹下可能有tree或者blob<br>**<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ae5fb42a-36b4-4df1-bf33-9c3f29353970.png" alt></p><h3 id="8-tree的个数"><a href="#8-tree的个数" class="headerlink" title="8.  tree的个数"></a>8.  tree的个数</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c44300e9-0b7b-462a-b9d4-bc00140c4c3a.jpg" alt></p><p>查看某个目录下类型是文件的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .git&#x2F;objects -type f</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/96621697-d0f6-4774-8282-e08b68043fb7.png" alt></p><p>2个tree，1个commit，1个blob</p><h3 id="9-分离头指针时的注意事项（detached-HEAD）"><a href="#9-分离头指针时的注意事项（detached-HEAD）" class="headerlink" title="9.  分离头指针时的注意事项（detached HEAD）"></a>9.  分离头指针时的注意事项（detached HEAD）</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2ed04c46-8f7f-4bf7-b619-2df3653fb36b.png" alt></p><p>如果此时对某些文件做了修改，并提交到仓库后，切换分支时，会提示是否给当前没有依赖的变更创建新的分支，如果不创建，会丢失这次修改。<br>在Git看来，如果没有将某个commit与分支或者tag绑定，都会被清除<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5dc33929-8d2e-418e-96a5-1aea442dfbd6.png" alt></p><p>按照提示 git branch branch_name ID号 进行分支的挂钩，即可保留修改。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1b1a7c5a-850a-4d0f-bc42-b388bf34e891.png" alt></p><p><strong>因此，分离头指针指的是 某个变更没有基于branch进行，在切换分支时，分离头指针下的commit会被Git当做垃圾清理掉。如果这些变更是重要的，要与某个分支绑定在一起。</strong></p><h3 id="9-HEAD-与-branch"><a href="#9-HEAD-与-branch" class="headerlink" title="9.  HEAD 与 branch"></a>9.  HEAD 与 branch</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/dcec9acc-64e3-4422-8b45-58ac5b9e8b40.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch_name      &#x2F;&#x2F;基于当前分支创建新分支</span><br><span class="line">git checkout -b new_branch_name old_branch_name   &#x2F;&#x2F;基于指定分支创建新分支</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/587b9e50-28f3-40ec-bd1c-8ae109102004.png" alt></p><p>此时 .git/HEAD 的引用也指向了新的分支<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e96d652-d2b3-45c8-84b0-a6e6aec3a29f.png" alt></p><p><strong>HEAD 既可以指向最后一次提交的分支，也可以不与任何分支挂钩（即处于分离头指针状态下），整个HEAD指向了某个 commit上。当做分支切换时，HEAD指向新分支</strong></p><p><font color="red">HEAD 指向分支，分支指向commit，或者HEAD直接指向commit</font>.</p><p><strong>比较两次commit的差异性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff 待比较ID1  待比较ID2     &#x2F;&#x2F; ID1与ID2的提交比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD^1             &#x2F;&#x2F; 当前HEAD所指向的commit与他的父亲（上一次）比较</span><br><span class="line">git diff HEAD HEAD^1^1           &#x2F;&#x2F; 当前HEAD所指向的commit与他的爷爷（上两次）比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD~n             &#x2F;&#x2F; 当前HEAD所指向的commit与 上n次 比较</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextRank基本了解</title>
      <link href="/2018/09/01/TextRank/"/>
      <url>/2018/09/01/TextRank/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一-TextRank算法介绍"><a href="#一-TextRank算法介绍" class="headerlink" title="一. TextRank算法介绍"></a>一. TextRank算法介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法相对来说，是一种很简单的算法。算法的流程类似于Kleinberg的HITS算法，<font color="red">Google</font>的PageRank算法，不得不说GooglePageRank算法的出现引发了搜索引擎的一次变革。PageRank算法成功运用到互联网上来评估网页的重要性，当用户搜索时，返回与搜索问题相关又有质量的网页。TextRank算法可以说借鉴了PageRank算法的思想，也非常成功的运用到文章的引文提取，关键词提取上。当然一个单纯的算法来提取关键词，可能效果并不如意，可以结合其他算法，比如TF-IDF来筛选有力表达主题/文章中心思想的词语。</p><a id="more"></a><h1 id="二-TextRank算法解析"><a href="#二-TextRank算法解析" class="headerlink" title="二. TextRank算法解析"></a>二. TextRank算法解析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法对文章关键词进行提取的过程，实际就是迭代计算一个由文章中的词语构建的有向有权图G=(V,E) 。其中集合V(图中的节点)有文章中的词语构成，中文我们可以利用ansj_seg进行分词筛选特定词性的词。集合E(图中的边)由文章中的词在特定的滑动窗口下组成。E是一个VxV的子集。图中任意两节点Vi,Vj之间的权重为Wij，而对于一个节点Vi，In(Vi)表示图中指向该节点的其他节点集合，入度。而Out(Vi)为节点Vi指向的其他节点的集合。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于TextRank算法每次迭代是Vi节点的得分的计算公式为：<img src="/2018/09/01/TextRank/6d3a90f9-54f5-411b-bf3d-5e119062f76e.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;其中d是一个阻尼系数，其值在0到1之间。代表从图中一节点指向其他任意一节点的概率, 一般取值为 0.85。上述的公式，表示当前节点Vi的值为所有指向Vi的节点Vj给予的值的和。就相当于，我现在手上有1个苹果，如果我收集了我朋友给我的苹果，我将有多少个苹果的问题。假如我有两个朋友，他们会给我一些苹果，而我现在拥有的苹果数量就是他们给我的苹果数量的和。朋友A有3个苹果，但是同样他有3个朋友，而且需要给苹果给他的朋友，所以只能给我3/3＝1个苹果。朋友B有6个苹果，他有3个朋友，那么他给我6/3=2个苹果。那我现在手头将有1+1+3=5个苹果。实际中还要乘阻尼系数。TextRank算法就是这样迭代计算每个节点的值，而算法停止可以采用指定的迭代次数或者图中节点的值跟上次结果值的误差是否小于一个制定的极限值，一般取值为：0.0001。</p><h1 id="三-TextRank算法文本关键词提取"><a href="#三-TextRank算法文本关键词提取" class="headerlink" title="三. TextRank算法文本关键词提取"></a>三. TextRank算法文本关键词提取</h1><p>主要步骤：</p><ol><li>利用分词工具对文本进行分词</li><li>指定滑动窗口大小</li><li>滑动窗口经过文本词组，构建有向有权图。</li><li>迭代计算有向有权图，直到收敛。</li></ol><p>注意：在构建有向有权图时候，只筛选特定词性的词作为节点，比如名词，动词，形容词等，同时删除停用词。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol><li><p>一个文本，对其进行分词后，词组组成一个集合：<br>T = [S1,S2,S3,S1,S5,S6,S7,S8,S9]</p></li><li><p>指定滑动窗口大小为3</p></li><li><p>窗口里面的词组构建图，每次都是以窗口头结点为主节点。如下图所示：</p></li></ol><p>A：窗口第一次经过的词组，那么组成的边有:(S1,S2),(S2,S1),(S1,S3),(S3,S1)<br><img src="/2018/09/01/TextRank/e78a6e11-0507-4e6e-a289-a6bd1d4365b2.jpg" alt><br>B：窗口第二次经过的词组,组成的边有：(S2,S3),(S3,S1),(S2,S1),(S1,S2)。遇到重叠的边，则权重加1.<br><img src="/2018/09/01/TextRank/59840975-e639-4ab7-970b-171816be466e.jpg" alt><br>C：构建图完成之后，按照textRank算法的执行步骤，迭代计算，直到收敛。</p><p>D：最后对节点的权重排序输出。</p><h1 id="四-TextRank算法Scala代码实现"><a href="#四-TextRank算法Scala代码实现" class="headerlink" title="四. TextRank算法Scala代码实现"></a>四. TextRank算法Scala代码实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法的实现，这里采用scala，分词工具采用ansj_seg，这里scala代码实现的TextRank算法，只实现关键词的提取，没有实现句子提取，后续再补充。代码略。<br>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">object TextRankTest&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val tr &#x3D; new TextRank</span><br><span class="line">    tr.setStopword(Config.STOP_WORDS_FILE)&#x2F;&#x2F;停用词</span><br><span class="line">    val text &#x3D; &quot;机器学习是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。&quot;</span><br><span class="line">    val tags &#x3D; tr.textrank(sentence &#x3D; text,topK &#x3D; 10, allowPOS &#x3D; List(&quot;ns&quot;, &quot;vn&quot;, &quot;n&quot;, &quot;nr&quot;, &quot;nt&quot;, &quot;mama&quot;))</span><br><span class="line">    tags.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(算法,n,1.0)</span><br><span class="line">(学科,n,0.963356)</span><br><span class="line">(理论,n,0.934734)</span><br><span class="line">(分析,vn,0.85816)</span><br><span class="line">(机器学习,n,0.723762)</span><br><span class="line">(数据,n,0.615997)</span><br><span class="line">(规律,n,0.537537)</span><br><span class="line">(设计,vn,0.474728)</span><br><span class="line">(概率论,n,0.466409)</span><br><span class="line">(复杂度,n,0.442039)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(5)Hexo踩坑_主题优化</title>
      <link href="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="0-字体乱码问题"><a href="#0-字体乱码问题" class="headerlink" title="0 字体乱码问题"></a>0 字体乱码问题</h2><p>Windows 上新建的文件一般都是 <strong>gb2312或iso-8859-1</strong>，这样windows下的文件传递到Linux可能会出乱码问题</p><p>用 Git进去文件使用命令查看文件是否是<strong>utf-8</strong> 格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i word.ejs</span><br><span class="line">word.ejs: text&#x2F;html; charset&#x3D;iso-8859-1(或是其他)</span><br></pre></td></tr></table></figure><p><strong>第一种</strong><br>最简单的办法就是  vim  word.ejs</p><a id="more"></a><p>设置 set fileencoding=utf-8，强制保存，此时中文会乱码，再次输入即可</p><p><strong>第二种</strong></p><p>找一个 是 utf-8文件的 直接粘贴到需要位置，改名删除内容，写上自己的内容即可。</p><h2 id="1-图片无法加载"><a href="#1-图片无法加载" class="headerlink" title="1 图片无法加载"></a>1 图片无法加载</h2><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><p>效果如下图：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/83b0faba-efa5-477e-b4bf-be002402fb8b.jpg" alt></p><h2 id="2-点击所有文章-缺失模块"><a href="#2-点击所有文章-缺失模块" class="headerlink" title="2 点击所有文章 缺失模块"></a>2 点击所有文章 缺失模块</h2><p>缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br>npm i hexo-generator-json-content –save</p><p>3、在根目录_config.yml里添加配置：直接粘贴复制即可。（自己手打可能出错）</p><pre q-show="jsonFail" style="box-sizing: border-box; overflow: auto; white-space: pre-wrap; overflow-wrap: break-word; font-family: monospace, monospace; font-size: 12px;">  jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</pre><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9266a57c-8ba0-4ea9-831d-5d868b6de1de.jpg" alt></p><h2 id="3-个人头像及网站图标"><a href="#3-个人头像及网站图标" class="headerlink" title="3 个人头像及网站图标"></a>3 个人头像及网站图标</h2><h3 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h3><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。</p><h2 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h2><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/avatar.png</code>，设置则为<code>avatar: /assets/avatar.png</code>。（图标同理）</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f3f4cf22-244b-4dc6-9ec6-80772d70eeb5.jpg" alt></p><h2 id="4-文章摘要"><a href="#4-文章摘要" class="headerlink" title="4 文章摘要"></a>4 文章摘要</h2><p>目前主要是两种方式在首页显示文章摘要而不是全文</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1 "></a>方法1 <!--more--></h3><p>ps: 之前最好不要有空格</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/EBX_29_24AY7O_5DK_7EUZCSA2LR1BN.png" alt></p><h3 id="方法2-description-in-Front-matter"><a href="#方法2-description-in-Front-matter" class="headerlink" title="方法2 description in Front-matter"></a>方法2 description in Front-matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2015-12-03 00:00:00</span><br><span class="line">description: &quot;Welcome to Hexo! This is your very first post.&quot;</span><br><span class="line">---</span><br><span class="line">&lt;Contents&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>description</code> 添加的摘要只能为纯文本</p><p><code>description</code> 中的内容加引号，可以避免一些程序错误，例如当内容里包含英文冒号时。</p><h2 id="5-主菜单"><a href="#5-主菜单" class="headerlink" title="5 主菜单"></a>5 主菜单</h2><p>按下面格式添加侧边栏，菜单前的<font color="red">#</font>表示隐藏该条目<font color="red">themes/yilia/_config.yml</font>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按需求更改</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  所有文章: &#x2F;archives&#x2F;</span><br><span class="line">  #随笔: &#x2F;tags&#x2F;随笔</span><br><span class="line">  标签云: &#x2F;tags&#x2F;</span><br><span class="line">  关于我: &#x2F;about&#x2F;</span><br></pre></td></tr></table></figure><h2 id="6-标签云"><a href="#6-标签云" class="headerlink" title="6 标签云"></a>6 标签云</h2><p>使用 Hexo 命令新建一个tags的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/60e3c4cd-8d7d-43ab-8d6d-70d12b414979.png" alt></p><p>该页面标题可以在 /hexo/source/tags/index.md 中修改</p><p>同一片文章设置多个分类后的问题 <a href="https://github.com/MOxFIVE/hexo-theme-yelee/issues/4" target="_blank" rel="noopener">issue#4</a></p><h2 id="7-关于我"><a href="#7-关于我" class="headerlink" title="7 关于我"></a>7 关于我</h2><p>使用 Hexo 命令新建一个名为 <code>about</code> 的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>该页面内容在文件 <code>\hexo\source\about\index.md</code> 中修改</p><h2 id="8-本地搜索"><a href="#8-本地搜索" class="headerlink" title="8 本地搜索"></a>8 本地搜索</h2><p>使用搜索需先安装对应插件，用于生成索引数据</p><p>插件主页: <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置插件启用为true 到根目录下的_config.yml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line"> on: true</span><br><span class="line"> onload: false</span><br></pre></td></tr></table></figure><p><strong>onload: true：</strong> 索引数据<strong>search.xml</strong>随页面一起加载（效率优先）<br><strong>onload：false：</strong> 当激活搜索框时在下载索引数据（按需加载）</p><h2 id="9-社交图标"><a href="#9-社交图标" class="headerlink" title="9 社交图标"></a>9 社交图标</h2><p>去掉前面的 # 再填写链接即可</p><p><font color="red">themes/yilia/_config.yml</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line"> Email: &quot;haoransunlin@163.com&quot;</span><br><span class="line"> #新浪微博: &quot;sina weibo&quot;</span><br><span class="line"> GitHub: ...</span><br><span class="line"> #RSS: &quot;&#x2F;aotm.xml&quot;</span><br></pre></td></tr></table></figure><p>设置 Email 时保留 <code>mailto:</code> 可考虑加密邮件地址 <a href="http://ctrlq.org/encode/" target="_blank" rel="noopener">http://ctrlq.org/encode/</a></p><p>使用 RSS 需先安装对应插件 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><h2 id="10-网站运行时间-暂时没有配置"><a href="#10-网站运行时间-暂时没有配置" class="headerlink" title="10 网站运行时间(暂时没有配置)"></a>10 网站运行时间(暂时没有配置)</h2><h3 id="1-修改-themes-yilia-config-yml-添加如下内容"><a href="#1-修改-themes-yilia-config-yml-添加如下内容" class="headerlink" title="1 修改 \themes\yilia_config.yml 添加如下内容"></a>1 修改 \themes\yilia_config.yml 添加如下内容</h3><p>网站运行时间，格式形如：“本站已安全运行 50 天 12 小时 13 分 41 秒”<br>Runing Time<br>running_time:<br> enable: true<br> create_time: ‘07/25/2019 12:00:00’ #此处修改你的建站时间或者网站上线时间</p><h3 id="2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容："><a href="#2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容：" class="headerlink" title="2 修改\themes\yilia\layout\_partial\footer.ejs，在&lt;/footer&gt;上面添加如下内容："></a>2 修改<code>\themes\yilia\layout\_partial\footer.ejs</code>，在<code>&lt;/footer&gt;</code>上面添加如下内容：</h3><!--《添加网站运行时间  <br/>--><p>&lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time){ %&gt;<br>    <span id="timeDate">载入天数…</span><span id="times">载入时分秒…</span><br>    <script><br>    var now = new Date();<br>    function createtime() {<br>        //此处修改你的建站时间或者网站上线时间<br>        var create_time = '<%- theme.running_time.create_time %>';<br>        now.setTime(now.getTime() + 250);<br>        days = (now - grt) / 1000 / 60 / 60 / 24;<br>        dnum = Math.floor(days);<br>        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);<br>        hnum = Math.floor(hours);<br>        if (String(hnum).length == 1) {<br>            hnum = "0" + hnum;<br>        }<br>        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);<br>        mnum = Math.floor(minutes);<br>        if (String(mnum).length == 1) {<br>            mnum = "0" + mnum;<br>        }<br>        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);<br>        snum = Math.round(seconds);<br>        if (String(snum).length == 1) {<br>            snum = "0" + snum;<br>        }<br>        document.getElementById("timeDate").innerHTML = " | 本站已安全运行 " + dnum + " 天 ";<br>        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";<br>    }<br>    setInterval("createtime()", 250);<br>    </script><br>&lt;% } %&gt;</p><!-- 添加网站运行时间》--><h2 id="11-背景图片"><a href="#11-背景图片" class="headerlink" title="11 背景图片"></a>11 背景图片</h2><p>*<em>推荐大小：700 x 1200 *</em></p><h3 id="1-找到-themes-lilia-目录下的-config-yml-修改配置如下："><a href="#1-找到-themes-lilia-目录下的-config-yml-修改配置如下：" class="headerlink" title="1 找到 themes\lilia\目录下的 _config.yml,修改配置如下："></a>1 找到 themes\lilia\目录下的 _config.yml,修改配置如下：</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/2488f7cb-b9a9-4f5e-b191-8b9fd0200767.png" alt></p><h3 id="2-将选好的背景图片放入-themes-yilia-source-assets-目录下"><a href="#2-将选好的背景图片放入-themes-yilia-source-assets-目录下" class="headerlink" title="2 将选好的背景图片放入 themes\yilia\source\assets 目录下"></a>2 将选好的背景图片放入 themes\yilia\source\assets 目录下</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/a9d8f38d-868e-48ba-8299-1f2dd027adaa.jpg" alt></p><h3 id="3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）"><a href="#3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）" class="headerlink" title="3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）"></a>3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）</h3><p><strong>ctrl + f 搜索：.left-col{ 、.left-col .overlay{ 、#mobile-nav .overlay</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/aeda14f1-204f-4735-a71a-b5df19eb9bc4.png" alt></p><p>里面添加 <strong>background-image:url(“图片地址”)即可</strong></p><p>字体颜色需要自己根据背景图片来调配</p><p>搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.left-col #header a&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header a:hover&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header .header-subtitle&#123;</span><br></pre></td></tr></table></figure><h3 id="4-打开-yilia-layout-partial-left-col-ejs"><a href="#4-打开-yilia-layout-partial-left-col-ejs" class="headerlink" title="4 打开 yilia\layout_partial\left-col,ejs"></a>4 打开 yilia\layout_partial\left-col,ejs</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9c9a363b-d5e2-4785-b13d-5b4e4945b8ce.png" alt></p><p>重新部署即可看到效果</p><h2 id="12-文章目录"><a href="#12-文章目录" class="headerlink" title="12 文章目录"></a>12 文章目录</h2><h3 id="1-添加-CSS-样式"><a href="#1-添加-CSS-样式" class="headerlink" title="1 添加 CSS 样式"></a>1 添加 CSS 样式</h3><p>打开 <code>themes\yilia\source</code> 下的 <code>main.234bc0.css</code> 文件，直接在后面添加如下代码：</p><p>/<em>新添加的</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#container .show-toc-btn,#container .toc-article&#123;display:block&#125;</span><br><span class="line">.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http:&#x2F;&#x2F;7xtawy.com1.z0.glb.clouddn.com&#x2F;show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;</span><br><span class="line">.toc-article li ol, .toc-article li ul &#123;</span><br><span class="line">    margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.toc-article ol, .toc-article ul &#123;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-修改-article-ejs-文件"><a href="#2-修改-article-ejs-文件" class="headerlink" title="2 修改 article.ejs 文件"></a>2 修改 article.ejs 文件</h3><p>打开 <code>themes\yilia\layout\_partial</code> 文件夹下的 <code>article.ejs</code> 文件, 在 <code>&lt;/header&gt; &lt;% } %&gt;</code> 下面加入如下内容（注意位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目录内容 --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;show-toc-btn&quot; id&#x3D;&quot;show-toc-btn&quot; onclick&#x3D;&quot;showToc();&quot; style&#x3D;&quot;display:none&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-bg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-text&quot;&gt;文章导航&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;toc-article&quot; class&#x3D;&quot;toc-article&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;toc-close&quot; class&#x3D;&quot;toc-close&quot; title&#x3D;&quot;隐藏导航&quot; onclick&#x3D;&quot;showBtn();&quot;&gt;×&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;toc-title&quot;&gt;文章目录&lt;&#x2F;strong&gt;</span><br><span class="line">           &lt;%- toc(post.content) %&gt;</span><br><span class="line">         &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function showToc()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    function showBtn()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">&lt;!-- 目录内容结束 --&gt;</span><br></pre></td></tr></table></figure><p>想要温江显示目录，在每篇文章开头加入：toc: true 即可。</p><h2 id="13-版权"><a href="#13-版权" class="headerlink" title="13 版权"></a>13 版权</h2><p>待定</p><h2 id="14-友情链接"><a href="#14-友情链接" class="headerlink" title="14 友情链接"></a>14 友情链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 编辑友链</span><br><span class="line">friends:</span><br><span class="line">  Hexo: https:&#x2F;&#x2F;hexo.io</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;pages.github.com&#x2F;</span><br><span class="line">  MOxFIVE: http:&#x2F;&#x2F;moxfive.xyz&#x2F;</span><br><span class="line"></span><br><span class="line">## 关闭友链</span><br><span class="line">friends: false</span><br></pre></td></tr></table></figure><h2 id="15-关于我"><a href="#15-关于我" class="headerlink" title="15 关于我"></a>15 关于我</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启“关于我”。</span><br><span class="line">aboutme: 专注于前端</span><br><span class="line"></span><br><span class="line"># 关闭“关于我”</span><br><span class="line">aboutme: false</span><br></pre></td></tr></table></figure><h2 id="16-评论"><a href="#16-评论" class="headerlink" title="16 评论"></a>16 评论</h2><p><strong>GitHub OAuth授权：Settings/Developer settings/OAuth Apps</strong></p><p><a href="https://github.com/settings/applications/1265561" target="_blank" rel="noopener">https://github.com/settings/applications/1265561</a></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0_3_C@_7EZ_609_5DF_4_7E1_240_24S0L5.png" alt></p><h3 id="在layout-partial-post目录下新增gitalk-ejs文件"><a href="#在layout-partial-post目录下新增gitalk-ejs文件" class="headerlink" title="在layout/_partial/post目录下新增gitalk.ejs文件"></a>在<code>layout/_partial/post</code>目录下新增<code>gitalk.ejs</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot; style&#x3D;&quot;padding: 0px 30px 0px 30px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">if(&lt;%&#x3D;theme.gitalk.enable%&gt;)&#123;</span><br><span class="line"> var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line"> clientID: &#39;&lt;%&#x3D;theme.gitalk.ClientID%&gt;&#39;,</span><br><span class="line"> clientSecret: &#39;&lt;%&#x3D;theme.gitalk.ClientSecret%&gt;&#39;,</span><br><span class="line"> repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line"> owner: &#39;&lt;%&#x3D;theme.gitalk.githubID%&gt;&#39;,</span><br><span class="line"> admin: [&#39;&lt;%&#x3D;theme.gitalk.adminUser%&gt;&#39;],</span><br><span class="line"> id: &#39;&lt;%&#x3D; page.date %&gt;&#39;,</span><br><span class="line"> distractionFreeMode: &#39;&lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="修改source-src-css-目录下comment-scss文件"><a href="#修改source-src-css-目录下comment-scss文件" class="headerlink" title="修改source-src/css/目录下comment.scss文件"></a>修改<code>source-src/css</code>/目录下<code>comment.scss</code>文件</h3><p>注意第一行最后添加了 #gitalk-container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container &#123;</span><br><span class="line"> padding: 0 30px !important;</span><br><span class="line"> min-height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#SOHUCS &#123;</span><br><span class="line"> #SOHU_MAIN .module-cmt-list .block-cont-gw &#123;</span><br><span class="line"> border-bottom: 1px dashed #c8c8c8 !important;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码："><a href="#在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码：" class="headerlink" title="在layout/_partial目录下的article.ejs文件内新增gitalk相关的配置代码："></a>在<code>layout/_partial</code>目录下的<code>article.ejs</code>文件内新增<code>gitalk</code>相关的配置代码：</h3><p>在最后一行 &lt;% } %&gt; 前加入，如下图所示<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9f43f555-78c6-44fa-a465-3b55891297fd.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable)&#123; %&gt;</span><br><span class="line"> &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line"> key: post.slug,</span><br><span class="line"> title: post.title,</span><br><span class="line"> url: config.url+url_for(post.path)</span><br><span class="line"> &#125;) %&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="最后在yilia主题配置文件中新增gitalk相关的配置："><a href="#最后在yilia主题配置文件中新增gitalk相关的配置：" class="headerlink" title="最后在yilia主题配置文件中新增gitalk相关的配置："></a>最后在<code>yilia</code>主题配置文件中新增<code>gitalk</code>相关的配置：</h3><p>属性名要与 配置文件中保持一致 ,如：<br>theme.gitalk.client_id  要与配置文件中 client_id 这几个字母一致<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/63179418-0e08-4864-bc85-b444e6067360.png" alt></p><p><strong>githubID：是自己的GitHub账户名称，如我的是JavaSsun</strong><br><strong>repo：是新建的评论仓库名称</strong><br><strong>adminuser:是自己的账户名称JavaSsun</strong></p><h3 id="更新一下即可。"><a href="#更新一下即可。" class="headerlink" title="更新一下即可。"></a>更新一下即可。</h3><p>基本完成，现在解决常见问题：</p><h2 id="17-文章字数及统计阅读时长-注意乱码"><a href="#17-文章字数及统计阅读时长-注意乱码" class="headerlink" title="17 文章字数及统计阅读时长(注意乱码)"></a>17 文章字数及统计阅读时长(注意乱码)</h2><h3 id="1-安装-hexo-wordcount"><a href="#1-安装-hexo-wordcount" class="headerlink" title="1 安装 hexo-wordcount"></a>1 安装 hexo-wordcount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h3 id="2-文件配置"><a href="#2-文件配置" class="headerlink" title="2 文件配置"></a>2 文件配置</h3><p>在theme\yilia\layout_partial\post下创建word.ejs文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top:10px;&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &amp;nbsp; | &amp;nbsp;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后在 themes/yilia/layout/_partial/article.ejs中添加(在 /header 之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;article-inner&quot;&gt;</span><br><span class="line">    &lt;% if (post.link || post.title)&#123; %&gt;</span><br><span class="line">      &lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class="line">        &lt;% if (!post.noDate)&#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">        &lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">        &lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">        &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">          &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">        &lt;!-- 添加完成 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      &lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure><h3 id="3-开启功能"><a href="#3-开启功能" class="headerlink" title="3 开启功能"></a>3 开启功能</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e0da8fad-4be8-436b-9491-b943d26853f1.png" alt></p><p>效果如图所示：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0c5c293d-95ac-47c3-a2cc-b3a589682a23.png" alt></p><h2 id="18-添加背景音乐"><a href="#18-添加背景音乐" class="headerlink" title="18 添加背景音乐"></a>18 添加背景音乐</h2><h3 id="1-打开网易云音乐首页，然后搜索要添加的背景音乐"><a href="#1-打开网易云音乐首页，然后搜索要添加的背景音乐" class="headerlink" title="1 打开网易云音乐首页，然后搜索要添加的背景音乐"></a>1 打开网易云音乐首页，然后搜索要添加的背景音乐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/65d6c7e8-80bf-45c9-8092-a46d177d5dfa.jpg" alt></p><h3 id="2-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#2-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="2 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>2 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/19e4d9b9-e95b-4313-947f-5f0fc33bea71.png" alt></p><h3 id="3-复制外链播放器的代码"><a href="#3-复制外链播放器的代码" class="headerlink" title="3 复制外链播放器的代码"></a>3 复制外链播放器的代码</h3><p>打开 /yilia/layout/_partia/left-col.ejs 文件 <strong>nav标签中添加代码</strong><br>注：放在<code>&lt;nav&gt;</code>和<code>&lt;/nav&gt;</code>之内</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9dd56bf0-40f8-46ae-acb7-764d7074be59.png" alt><br>[========]</p><h2 id="19-鼠标点击桃心效果"><a href="#19-鼠标点击桃心效果" class="headerlink" title="19 鼠标点击桃心效果"></a>19 鼠标点击桃心效果</h2><p>在 themes/yilia/source文件夹下，建立resources文件夹，再新建click.js文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">! function(e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e &#x3D; 0; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick &#x3D; function(e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText &#x3D; e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d &#x3D; [];</span><br><span class="line">    e.requestAnimationFrame &#x3D; function() &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure><p>然后在themes/yilia/layout/_partial文件夹下的after-footer.ejs中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&lt;%&#x3D;config.root%&gt;.&#x2F;resources&#x2F;click.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/68ee37c3-7cb5-49b0-9d82-d670cf2bf98c.png" alt></p><p>重新部署即可</p><h2 id="20-添加网站运行时间"><a href="#20-添加网站运行时间" class="headerlink" title="20 添加网站运行时间"></a>20 添加网站运行时间</h2><h2 id="21-Hexo博客添加-helper-live2d动态模型插件"><a href="#21-Hexo博客添加-helper-live2d动态模型插件" class="headerlink" title="21 Hexo博客添加 helper-live2d动态模型插件"></a>21 Hexo博客添加 helper-live2d动态模型插件</h2><h3 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h3><ul><li>yilia主题</li><li>插件地址 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener" title="hexo-helper-live2d">hexo-helper-live2d</a></li><li><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></li></ul><h3 id="1-安装模块"><a href="#1-安装模块" class="headerlink" title="1 安装模块"></a>1 安装模块</h3><p>在hexo根目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h3 id="2-下载模型"><a href="#2-下载模型" class="headerlink" title="2 下载模型"></a>2 下载模型</h3><p>作者各种模型包展示 ➡️ <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener" title=" hexo live2d插件 2.0 !">hexo live2d插件 2.0 !</a></p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haru/02</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code> 黑猫</li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code> 白猫</li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>使用<code>npm install {packagename}</code>安装模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install live2d-widget-model-hibiki</span><br></pre></td></tr></table></figure><h3 id="3-详细配置"><a href="#3-详细配置" class="headerlink" title="3 详细配置"></a>3 详细配置</h3><p>在Hexo的 <code>_config.yml</code> 文件中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  #enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hibiki</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure><p>hexo g | hexo s即可</p><h2 id="22-Hexo添加访问量统计"><a href="#22-Hexo添加访问量统计" class="headerlink" title="22 Hexo添加访问量统计"></a>22 Hexo添加访问量统计</h2><ul><li>主题 yilia</li><li>访问统计量使用 <strong><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener" title="不蒜子">不蒜子</a></strong></li></ul><h3 id="1-配置是否开启不蒜子访问量统计功能"><a href="#1-配置是否开启不蒜子访问量统计功能" class="headerlink" title="1 配置是否开启不蒜子访问量统计功能"></a>1 配置是否开启不蒜子访问量统计功能</h3><p>在 <strong>themes/yilia/_config.yml</strong> 添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启访问量统计功能（不蒜子）</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="2-引入不蒜子并添加站点访问量"><a href="#2-引入不蒜子并添加站点访问量" class="headerlink" title="2 引入不蒜子并添加站点访问量"></a>2 引入不蒜子并添加站点访问量</h3><p>在<code>themes/yilia/layout/_partial/footer.ejs</code>末尾添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/760ffbaf-8a71-415e-8869-74c555cddcf8.png" alt></p><h3 id="3-添加文章访问量"><a href="#3-添加文章访问量" class="headerlink" title="3 添加文章访问量"></a>3 添加文章访问量</h3><p>在<code>themes/yilia/layout/_partial/post/date.ejs</code>开头添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/daf13bfc-f651-4963-99bd-3cec83a0b71a.png" alt></p><meta charset="utf-8"><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><p>两种方法选择一种使用即可，都使用可能会出现无法显示的问题</p></li><li><p>使用<code>hexo s</code>部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用<code>localhost:4000</code>进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p></li></ul><h2 id="23-RSS"><a href="#23-RSS" class="headerlink" title="23 RSS"></a>23 RSS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/fafa6df3-68ca-4b15-aaa9-b8ebb2ea0dec.png" alt></p><h2 id="24-Hexo设置-标签-分类-归档"><a href="#24-Hexo设置-标签-分类-归档" class="headerlink" title="24 Hexo设置 标签 分类 归档"></a>24 Hexo设置 标签 分类 归档</h2><p>举例：</p><h3 id="1添加-分类页面"><a href="#1添加-分类页面" class="headerlink" title="1添加 分类页面"></a>1添加 分类页面</h3><p>使用：<code>hexo new page categories</code> 新建一个 分类 页面。</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/50a49785-9652-4252-af8d-f67fbc85784c.png" alt></p><p>添加 type: “categories”<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/ac3196b3-f7f0-4483-8f0b-581b673c3e04.png" alt></p><p>tags类似：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/db61e102-242e-404a-8f6e-9026770bcf82.png" alt></p><p>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/24627704-f7a0-4686-9c87-bd3ecc9d433e.png" alt></p><h2 id="25-Hexo博客优化之文章置顶-置顶标签"><a href="#25-Hexo博客优化之文章置顶-置顶标签" class="headerlink" title="25 Hexo博客优化之文章置顶+置顶标签"></a>25 Hexo博客优化之文章置顶+置顶标签</h2><h3 id="1-博文置顶"><a href="#1-博文置顶" class="headerlink" title="1 博文置顶"></a>1 博文置顶</h3><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index  --save </span><br><span class="line">$ npm install hexo-generator-index-pin-top  --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：<br>注意有 <strong>空格</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/062b9442-ca03-4376-b1c2-52287944889b.png" alt></p><h3 id="2-配置置顶标准"><a href="#2-配置置顶标准" class="headerlink" title="2 配置置顶标准"></a>2 配置置顶标准</h3><p>打开：/themes/*/layout（/_macro）/post.ejs<br>直接在最前面加入以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.top) &#123; %&gt;</span><br><span class="line"> &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line"> &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line"> &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="3-配置文章"><a href="#3-配置文章" class="headerlink" title="3 配置文章"></a>3 配置文章</h3><p>然后在需要置顶的文章的Front-matter中加上top选项即可<br>top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> title: (5)Hexo踩坑_主题优化</span><br><span class="line"> date: 2018-08-21 17:15:09</span><br><span class="line"> tags: Hexo-yilia</span><br><span class="line"> categories: Hexo</span><br><span class="line"> top: 5</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><h3 id="4-优先级配置"><a href="#4-优先级配置" class="headerlink" title="4 优先级配置"></a>4 优先级配置</h3><p>修改根目录配置文件/_config.yml,top值-1标示根据top值倒序（正序设置为1即可），同样date也是根据创建日期倒序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line"> path: &#39;&#39;</span><br><span class="line"> per_page: 10</span><br><span class="line"> order_by:</span><br><span class="line"> top: -1</span><br><span class="line"> date: -1</span><br></pre></td></tr></table></figure><h3 id="5-设置置顶标志"><a href="#5-设置置顶标志" class="headerlink" title="5 设置置顶标志"></a>5 设置置顶标志</h3><p>暂时用默认的</p><h2 id="26-去掉配置文件中的-more"><a href="#26-去掉配置文件中的-more" class="headerlink" title="26 去掉配置文件中的 more"></a>26 去掉配置文件中的 more</h2><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/957764e6-d0ac-4b0c-8cc2-4b05f6327872.png" alt></p><h2 id="27-在左侧显示总文章数"><a href="#27-在左侧显示总文章数" class="headerlink" title="27 在左侧显示总文章数"></a>27 在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class&#x3D;&quot;header-menu&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line"> &lt;% for (var i in theme.menu)&#123; %&gt;</span><br><span class="line"> &lt;li&gt;&lt;a href&#x3D;&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%&#x3D; i %&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;%&#125;%&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav style&#x3D;&quot;color: #7FFFD4;&quot;&gt;总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(4)Hexo撰写文章</title>
      <link href="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
      <url>/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><img src="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/60bbee39-dccc-48d2-9fb5-149a40253315.png" alt></p><a id="more"></a><h3 id="一、创建文章"><a href="#一、创建文章" class="headerlink" title="一、创建文章"></a>一、创建文章</h3><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 <code>title</code> 为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <strong>source/_post</strong> 文件夹下创建一个文件，命名为：<strong>title.md</strong></p><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h3 id="二、编写文章（基于Markdown）"><a href="#二、编写文章（基于Markdown）" class="headerlink" title="二、编写文章（基于Markdown）"></a>二、编写文章（基于Markdown）</h3><h4 id="1-Markdown基本语法略"><a href="#1-Markdown基本语法略" class="headerlink" title="1 Markdown基本语法略"></a>1 <strong>Markdown基本语法略</strong></h4><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2 说明："></a>2 <strong>说明：</strong></h4><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><h4 id="3-高级设置"><a href="#3-高级设置" class="headerlink" title="3 高级设置"></a>3 高级设置</h4><p><strong>1 模板设置</strong></p><p>当我们使用命令 <strong>hexo new “title”</strong> 创建文章时，Hexo 会根据 <strong>/scaffolds/post.md</strong> 对新文章进行初始化</p><p>换言之，<strong>/scaffolds/post.md</strong> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories</span><br></pre></td></tr></table></figure><p><strong>2 头部设置</strong></p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置<strong>文章标题</strong>、<strong>发布日期</strong>等基础信息外，还可以为文章<strong>添加标签</strong>、<strong>分类</strong>等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><font color="red"><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</font></p><p><strong>3 首页显示</strong></p><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，<strong>表示只会显示标志前面的内容</strong></p><h3 id="三、部署发布"><a href="#三、部署发布" class="headerlink" title="三、部署发布"></a>三、部署发布</h3><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h3 id="四、Hexo一篇文章多个categories"><a href="#四、Hexo一篇文章多个categories" class="headerlink" title="四、Hexo一篇文章多个categories"></a>四、Hexo一篇文章多个categories</h3><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写一篇 《Servlet笔记》，我既想将它放在 <strong>Java</strong> 这个分类中，又想将它放入 <strong>Servlet</strong> 这个分类。</p><p>  按照官方的解释，<code>categories</code> 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h4 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h4><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Java</span><br><span class="line">  - Servlet</span><br></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [Java, Servlet]</span><br></pre></td></tr></table></figure><h4 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h4><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java]</span><br><span class="line">  -[Servlet]</span><br></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。</p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java, Servlet]</span><br><span class="line">  -[Programming]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(3)Hexo常用命令详解</title>
      <link href="/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><strong>Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</strong><br><strong>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</strong><br><strong>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</strong><br><strong>不同的主题会有不同的主题配置文件，由主题作者所提供</strong>.</p><a id="more"></a><h3 id="1、hexo-init"><a href="#1、hexo-init" class="headerlink" title="1、hexo init"></a>1、hexo init</h3><p><strong>hexo init</strong> 命令用于初始化本地文件夹为网站的根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><ul><li><strong>folder</strong> 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录</li></ul><h3 id="2、hexo-new"><a href="#2、hexo-new" class="headerlink" title="2、hexo new"></a>2、hexo new</h3><p><strong>hexo new</strong> 命令用于新建文章，一般可以简写为<strong>hexo n</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>layout</strong> 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</p></li><li><p><strong>title</strong> 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</p></li></ul><h3 id="3、hexo-generate"><a href="#3、hexo-generate" class="headerlink" title="3、hexo generate"></a>3、hexo generate</h3><p><strong>hexo generate</strong> 命令用于生成静态文件，一般可以简写为 hexo g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong> 选项，指定生成后部署，与 <strong>hexo d -g</strong> 等价</li></ul><p>详细信息请参考：<a href="https://hexo.io/docs/generating" target="_blank" rel="noopener">https://hexo.io/docs/generating</a></p><h3 id="4、hexo-server"><a href="#4、hexo-server" class="headerlink" title="4、hexo server"></a>4、hexo server</h3><p><strong>hexo server</strong> 命令用于启动本地服务器，一般可以简写为 <strong>hexo s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><ul><li><p>-p 选项，指定服务器端口，默认为 4000</p></li><li><p>-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</p></li><li><p>-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p></li></ul><p>说明 ：运行服务器前需要安装 hexo-server 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">https://hexo.io/docs/server.html</a></p><h3 id="5、hexo-deploy"><a href="#5、hexo-deploy" class="headerlink" title="5、hexo deploy"></a>5、hexo deploy</h3><p><strong>hexo deploy</strong> 命令用于部署网站，一般可以简写为 hexo d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><ul><li><strong>-g</strong> 选项，指定生成后部署，与 hexo g -d 等价</li></ul><p>说明 ：部署前需要修改 _config.yml 配置文件，下面以 git 为例进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: &lt;repository url&gt;</span><br><span class="line">    branch:    master</span><br><span class="line">    message: 自定义提交消息，默认为Site updated: &#123;&#123; now(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><h3 id="6、hexo-clean"><a href="#6、hexo-clean" class="headerlink" title="6、hexo clean"></a>6、hexo clean</h3><p><strong>hexo clean</strong> 命令用于清理缓存文件，是一个比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>网站显示异常时可尝试此操作</p><h3 id="7、Option"><a href="#7、Option" class="headerlink" title="7、Option"></a>7、Option</h3><p><strong>（1）hexo –safe</strong></p><p><strong>hexo –safe</strong> 表示安全模式，用于禁用加载插件和脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>安装新插件时遇到问题可尝试此操作</p><p><strong>（2）hexo –debug</strong></p><p><strong>hexo –debug</strong> 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p><strong>（3）hexo –silent</strong></p><p><strong>hexo –silent</strong> 表示静默模式，用于静默输出到终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Hexo配置文件详解</title>
      <link href="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p>Hexo 是一款极为优秀的博客框架，使用 Hexo 搭建一个个人博客后，还需要编写位于站点根目录下的 <code>_config.yml</code> 文件来满足定制化的需求。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:&#x2F;&#x2F;elfwalk.github.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line">#发布设置</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;elfwalk&#x2F;elfwalk.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1d62242a-d3b1-417a-bf11-e69e000b36f1.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/c95a5140-a299-4492-9006-3827168ab8e9.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/6ef267ec-cfd0-411b-891a-15de0966c39b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/92065ad3-a506-4066-8ccf-0dc4f6804458.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/97fd8861-b2b9-48a8-8c6a-545d0f31b2d0.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/7fdb3429-0dd3-4363-bf04-c03636d1702b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/d3ea4182-f75f-4576-904c-71883facc176.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/cb23844c-160e-47e9-97d3-753d06414ab8.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/801539a4-704b-4a63-b4f3-b824a474f7cd.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Firewalld二三事</title>
      <link href="/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>文章来源：<br><a href="http://www.excelib.com/article/287/show/#u0pW4f" target="_blank" rel="noopener">http://www.excelib.com/article/287/show/#u0pW4f</a></p><h2 id="Firewalld简介"><a href="#Firewalld简介" class="headerlink" title="Firewalld简介"></a>Firewalld简介</h2><p>Centos7中默认将原来的防火墙iptables升级为了firewalld，firewalld跟iptables比起来至少有两大好处：</p><ol><li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效；</li><li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。<a id="more"></a><h3 id="iptables-五表"><a href="#iptables-五表" class="headerlink" title="iptables 五表"></a>iptables 五表</h3>大部分iptables的资料都介绍说iptables包含四张表、五条链，不过实际上iptables还有第五张表——security表，但是这张表需要和selinux结合使用，而selinux虽然已经发布了十多年了但是直到现在还有很多人对他的理解不够透彻，甚至有很多人会将其关闭！</li></ol><p>其实selinux的设计理念在安全上来说是非常优秀的，而且理解了其设计理念之后再去使用也没那么复杂，只不过其内置的规则是非常复杂的，有机会再说。现在还回到iptables的五张表，他们分别是<strong>filter、nat、mangle、raw和security</strong>。</p><p>filter表就是我们最常使用的过滤表；nat表主要用于数据包转发，比如局域网的电脑如果想连接互联网，那么就可以使用nat给转发一下；mangle表的规则可以对数据包进行修改，比如修改ttl值等；raw表主要是为了提高效率使用的，raw本身的含义是指“原生的”、“未经过加工的”，符合raw表所对应规则的数据包将会跳过一些检查，这样就可以提高效率，当然，raw表的优先级也是最高的；security是跟selinux相关的MAC模式的安全过滤。</p><h3 id="firewalld和iptables的关系"><a href="#firewalld和iptables的关系" class="headerlink" title="firewalld和iptables的关系"></a>firewalld和iptables的关系</h3><p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样罢了。</p><h3 id="firewalld的配置文件结构"><a href="#firewalld的配置文件结构" class="headerlink" title="firewalld的配置文件结构"></a>firewalld的配置文件结构</h3><p>在具体介绍firewalld配置文件结构之前先介绍一下firewalld的配置模式，firewalld的配置模式设计的非常巧妙，而且这种设计思路也非常值得我们借鉴和学习。</p><h4 id="firewalld的配置模式"><a href="#firewalld的配置模式" class="headerlink" title="firewalld的配置模式"></a>firewalld的配置模式</h4><p>firewalld的配置文件以xml格式为主（主配置文件firewalld.conf例外），他们有两个存储位置</p><p>1.<code>/etc/firewalld/</code></p><p>2.<code>/usr/lib/firewalld/</code></p><p>使用时的规则是这样的：当需要一个文件时firewalld会首先到第一个目录中去查找，如果可以找到，那么就直接使用，否则会继续到第二个目录中查找。</p><p>firewalld的这种配置文件结构的主要作用是这样的：在第二个目录中存放的是firewalld给提供的通用配置文件，如果我们想修改配置，那么可以copy一份到第一个目录中，然后再进行修改。这么做有两个好处：首先我们日后可以非常清晰地看到都有哪些文件是我们自己创建或者修改过的，其次，如果想恢复firewalld给提供的默认配置，只需要将自己在第一个目录中的配置文件删除即可，非常简单，而不需要像其他很多软件那样在修改之前还得先备份一下，而且时间长了还有可能忘掉之前备份的是什么版本。</p><p>当然，这种配置模式也并不是firewalld的首创，在其他很多地方也都有用到，比如java中用于记录日志的logback也是这种模式，他在查找配置文件时会首先在根目录下找logback-test.xml文件，如果可以找到就直接使用，如果找不到就会接着找logback.xml文件，如果还找不到就会使用自己包里边自带的配置文件，这样使用起来就非常方便了，比如我们可以把logback-test.xml和logback.xml两个文件都创建出来，在开发机上使用logback-test.xml文件，然后在往服务器部署的时候直接将其删掉就可以了！</p><h4 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h4><p>firewalld的配置文件结构非常简单，主要有两个文件和三个目录：<br>文件：firewalld.conf、lockdown-whitelist.xml<br>目录：zones、services、icmptypes</p><p>另外，如果使用到direct，还会有一个direct.xml文件。我们要注意，在保存默认配置的目录 <code>/usr/lib/firewalld/</code> 中只有我们这里所说的目录，而没有firewalld.conf、lockdown-whitelist.xml和direct.xml这三个文件，也就是说这三个文件只存在于 <code>/etc/firewalld/</code> 目录中。</p><h4 id="文件和目录的作用"><a href="#文件和目录的作用" class="headerlink" title="文件和目录的作用"></a>文件和目录的作用</h4><ul><li><p>irewalld.conf：firewalld的主配置文件，是键值对的格式，不过非常简单，只有五个配置项</p></li><li><p>DefaultZone：默认使用的zone，关于zone学生稍后给大家详细介绍，默认值为public；</p></li><li><p>MinimalMark： 标记的最小值，linux内核会对每个进入的数据包都进行标记，目的当然是为了对他们进行区分，前面给大家补充iptables五张表相关的内容时候介绍说符合raw表规则的数据包可以跳过一些检查，那么是怎么跳过的呢？这里其实就是使用的标记，当然对数据包的标记还有很多作用。这里所设置的 MinimalMark值就是标记的最小值，默认值为100，一般情况下我们不需要对其进行修改，但是如果我们有特殊需要的时候就可以通过对其进行修改来告诉linux所使用标记的最小值了，比如我们需要给符合某条件的数据包标记为123，这时候为了防止混淆就需要将MinimalMark设置为一个大于123的值了；</p></li><li><p>CleanupOnExit：这个配置项非常容易理解，他表示当退出firewalld后是否清除防火墙规则，默认值为yes；</p></li><li><p>Lockdown： 这个选项跟D-BUS接口操作firewalld有关，firewalld可以让别的程序通过D-BUS接口直接操作，当Lockdown设置为yes的 时候就可以通过lockdown-whitelist.xml文件来限制都有哪些程序可以对其进行操作，而当设置为no的时候就没有限制了，默认值为 no；</p></li><li><p>IPv6_rpfilter：其功能类似于rp_filter，只不过是针对ipv6版的，其作用是判断所接受到的包是否是伪造的，检查方式主要是通过路由表中的路由条目实现的，更多详细的信息大家可以搜索uRPF相关的资料，这里的默认值为yes。</p></li><li><p>lockdown-whitelist.xml：当Lockdown为yes的时候用来限制可以通过D-BUS接口操作firewalld的程序</p></li><li><p>direct.xml：通过这个文件可以直接使用防火墙的过滤规则，这对于熟悉iptables的用户来说会非常顺手，另外也对从原来的iptables到firewalld的迁移提供了一条绿色通道</p></li><li><p>zones：保存zone配置文件</p></li><li><p>services：保存service配置文件</p></li><li><p>icmptypes：保存和icmp类型相关的配置文件</p></li></ul><h3 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h3><p>firewalld默认提供了九个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、home.xml、internal.xml、public.xml、trusted.xml、work.xml，他们都保存在 <code>/usr/lib/firewalld/zones/</code> 目录下。这些zone之间是什么关系？他们分别适用用哪些场景呢？</p><p>防火墙就相当于一个门卫，门卫对具体某个来访的人判断是否应该放行是依靠规则来判断的，而我们这里的zone其实就是一套规则集，或者说是一套判断的方案</p><p>理解了这层含义firewalld就容易了，比如上面的九个zone其实就是九种方案，而且起决定作用的其实是每个xml文件所包含的内容，而不是文件名，所以大家不需要对每种zone（每个文件名）的含义花费过多的精力，比如trusted这个zone会信任所有的数据包，也就是说所有数据包都会放行，但是public这个zone只会放行其中所配置的服务，其他的一律不予放行，其实我们如果将这两个文件中的内容互换一下他们的规则就换过来了，也就是public这个zone会放行所有的数据包，下面我们来看一下这两个文件的内容</p><p>public.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">  &lt;short&gt;Public&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;ssh&quot;&#x2F;&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;dhcpv6-client&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>trusted.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone target&#x3D;&quot;ACCEPT&quot;&gt;</span><br><span class="line">  &lt;short&gt;Trusted&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;All network connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>我们要特别注意trusted.xml中zone的target，就是因为他设置为了ACCEPT，所以才会放行所有的数据包，而public.xml中的zone没有target属性，这样就会默认拒绝通过，所以public这个zone（这种方案）只有其中配置过的服务才可以通过。</p><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>service是firewalld中另外一个非常重要的概念，不过其含义是非常简单的。还是拿门卫的例子来给大家做解释，在iptables的时代我们给门卫下达规则时需要告诉他“所有到22号楼的人全部予以放行”、“所有到80号楼的人全部予以放行”等等，不过到了firewalld的时代就不需要这样了，而是可以直接下达像“到销售部的全部予以放行”这样的命令，然后门卫再一查发现销售部在80号楼，那么所有到80号楼的人门卫就都会放行了。我们这里的楼牌号和端口号相对应，部门名和服务名相对应，这样大家应该就可以理解service的作用了。</p><p>从端口号改为服务名主要有两个好处：首先是使用服务名配置的语义清晰，不容易出错；其次在对某个服务的端口号进行修改的时候只需要修改相应的service文件就可以了，而不需要再修改防火墙方案——zone。这其实跟DNS将ip地址和域名关联了起来是一样的道理。下面学生再来给大家介绍一下service的配置文件。</p><p>service配置文件的命名规则是&lt;服务名&gt;.xml，比如ssh的配置文件是ssh.xml，http的配置文件是http.xml等，他们默认保存在<code>/usr/lib/firewalld/services/</code>目录下，常见的服务其中都可以找到，如果我们想修改某个服务的配置，那么可以复制一份到<code>/etc/firewalld/services/</code>目录下然后进行修改就可以了，要想恢复默认配置直接将我们自己的配置文件删除就可以了。我们来看一下ssh服务的ssh.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;short&gt;SSH&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;22&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure><p>可以看到这里配置了tcp的22号端口，所以将ssh服务配置到所使用的zone（默认public）中后tcp的22号端口就开放了。如果我们想将ssh的端口修改为222，那么只需要将ssh.xml复制一份到“<code>/firewalld/</code>services/”中，然后将端口号修改为222就可以了。当然直接修改“/usr/lib/firewalld/services/”中的配置文件也可以实现，但是强烈建议不要那么做，原因相信大家都明白。</p><p>明白原理之后使用起来就可以非常灵活了，比如我们将“<code>/etc/firewalld/</code>services/ssh.xml”文件复制一份到“<code>/etc/firewalld/</code>services/”中，然后将名字改为abc.xml，并且将abc这个服务配置到所使用的zone中，这时22端口就会开放。也就是说在zone中所配置的服务其实跟实际的服务并不存在直接联系，而是和相应配置文件中配置的内容有关系。</p><h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>firewalld的配置方法主要有三种：firewall-config、firewall-cmd和直接编辑xml文件，其中firewall-config是图形化工具，firewall-cmd是命令行工具，而对于linux来说大家应该更习惯使用命令行方式的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)Hexo博客搭建</title>
      <link href="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一-搭建GitHub-Pages"><a href="#一-搭建GitHub-Pages" class="headerlink" title="一 搭建GitHub Pages"></a>一 搭建GitHub Pages</h2><h3 id="1-注册一个GitHub账号，且登录"><a href="#1-注册一个GitHub账号，且登录" class="headerlink" title="1 注册一个GitHub账号，且登录"></a>1 注册一个GitHub账号，且登录</h3><h3 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2 创建仓库"></a>2 创建仓库</h3><p>1、点击 “NEW”</p><a id="more"></a><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_24_5DH_7B_5DR_7DU5PLM_602_7BV_29_24GMOCB.png" alt></p><p>2、填写的仓库名为”用户名.github.io”，用户名要与左边用户名一致，否则后面会报错</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7CKL_252_5DIX_25UYRE7_6K_5D16VK.png" alt></p><h3 id="3-启用Github-Pages"><a href="#3-启用Github-Pages" class="headerlink" title="3 启用Github Pages"></a>3 启用Github Pages</h3><p>1、点击”Settings”进入设置</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4FW_60V5O_7EEU_5D_DXF_7BD_7DQ_5B__G.png" alt></p><p>2、往下拉找到”GitHub Pages”,显示如图所示，即表明已经开启（一般创建完成后会默认自动开启）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_298GL_28RD@J3TIU5_5DN_24YGQUZC.png" alt></p><h3 id="4-选择主题"><a href="#4-选择主题" class="headerlink" title="4 选择主题"></a>4 选择主题</h3><p>1、点击 “Choose a theme”选择主题</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/AXQ5_5DWYAVR_5B2U3_X4KV6_5B3M.png" alt></p><p>2、任意选择一个主题，然后点击”select theme”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/DCVLHREVPA_7EZDM_V86_60C_WI.png" alt></p><h3 id="5-下载安装Node-js和Git"><a href="#5-下载安装Node-js和Git" class="headerlink" title="5 下载安装Node.js和Git"></a>5 下载安装Node.js和Git</h3><p>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/G_7B_29SB4U_5B2JZTZ_28OVV_243YXKQ.png" alt></p><p>2、安装Git和配置好Git环境</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3_28_24R8E_24Y_25D_29GX_7BCCX_24W002D.png" alt></p><h2 id="二-Hexo"><a href="#二-Hexo" class="headerlink" title="二 Hexo"></a>二 Hexo</h2><h3 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1 安装Hexo"></a>1 安装Hexo</h3><p>1、在自己认为合适的地方创建文件夹，然后在此文件夹中打开 Git命令行，即右击鼠标，选择”Git Bash here”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/R59B_29DJVG8CWW8R295GJ9_252.png" alt></p><p>2、输入 npm install -g hexo 进行安装</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/T@JPUVO_5BMOEO3E8IOLQX_29CK.png" alt></p><p>然后使用 hexo -v，出现下面界面说明安装成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/CK1_28_29ELV_5DWSZMIE1QLVOW_7EQ.png" alt></p><p>3、输入 hexo init  初始化文件夹（漫长等待<del>~</del> ）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9L_7E7EU_7E_7E2YODCLXO_250_7DTS_25K.png" alt></p><p>看到最后的”Start blogging with Hexo! “，表示成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/JN9YT_7BBQNQ5_60E_60BA89EX_T41586526832595.png" alt></p><p>4、输入 npm install，安装所需组件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SLIJWA4ITMT_25NDREFVWOITN.png" alt></p><p>5、输入 hexo g, 生成源文件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/TXXGDI6ZN_25HZM_5BQM7K@_24Z_7DI.png" alt></p><p>6、输入 hexo s,启动本地服务器，通过访问 <strong><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></strong>,正式体验 Hexo</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5D_7BH_24LAXS3ZCI_29F_7DJ1DM_7BL_28E.png" alt>\</p><p>成功界面如下所示</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/C_5BB075IG7XK_5DT0VNFR_60L1WR.png" alt></p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h3><p>1、安装主题（yilia）</p><p>使用命令</p><p>hexo clean</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>clone后面跟着的是主题的git repo地址，而themes/yilia则表示要将该主题克隆到blob/themes/yilia目录中</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/8OMPT6DL_7DD5RSCMCDNTR_5B_5DL.png" alt></p><p>2、启动主题</p><p>找到目录下的_config.yml文件，打开找到 theme:属性，并设置为 yilia</p><p>3、更新主题</p><p>好像没有用到下面这两个命令<br>cd themes/yilia<br>git pull</p><p>hexo g</p><p>hexo s</p><p>使用 localhost:4000 查新新主题</p><h2 id="三-部署到GitHub"><a href="#三-部署到GitHub" class="headerlink" title="三 部署到GitHub"></a>三 部署到GitHub</h2><h3 id="1-使用Hexo-deploy-部署到GitHub"><a href="#1-使用Hexo-deploy-部署到GitHub" class="headerlink" title="1 使用Hexo deploy 部署到GitHub"></a>1 使用Hexo deploy 部署到GitHub</h3><p>1、编辑根目录下_config.yml文件，添加如下代码（JavaSsun换成自己的用户名），并进行保存</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5_Z78JY_60M0M1KL21UV_24OH_H.png" alt></p><p>2、安装一个扩展</p><p>npm install hexo-deployer-git –save</p><h3 id="2-检查SSH-Keys设置"><a href="#2-检查SSH-Keys设置" class="headerlink" title="2 检查SSH Keys设置"></a>2 检查SSH Keys设置</h3><p>1、输入 cd ~/.ssh</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5BWC_7D_28_5BOXTZI_X_28U_5B10BQPU0.png" alt></p><p>如果没有rsa文件，输入 ssh-keygen -t rsa -C “<a href="mailto:xxxxxxx@qq.com">xxxxxxx@qq.com</a>“(自己邮箱)</p><p>2、输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/NRKM5_7EPRMR9B6TTSF2Z_28SAF.png" alt></p><p>3、再输入 ssh-add ~/.ssh/id_rsa ,添加生成的SSH Key到 ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_28_28K6H4_29IJE0N9XO716_7DXTJQ.png" alt></p><p>4 添加 SSH Key 到GitHub</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SN_1UT78G_250HN_5DJ_293T_5B6_7BLG.png" alt></p><p>5 输入 ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明添加成功了（有一个会让输入yes）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_25YT4_7D_601_601_283MW__7D_7B3_29_28_60I@A.png" alt></p><p>6 设置个人账号信息</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QV1PTZ_25XP966E3RO_7E0_7DZ_246H.png" alt></p><h3 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h3><p>hexo d -g</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7e9d1463-32aa-42f1-b3de-f627a98136fa.png" alt></p><h2 id="四-日常维护"><a href="#四-日常维护" class="headerlink" title="四 日常维护"></a>四 日常维护</h2><p>当部署成功后，日常只需</p><ol><li>新建文章(new)</li><li>找到生成的.md然后编辑并保存</li><li>生成博客（generate）</li><li>部署（deploy）</li></ol><p>即可完成新文章的发布</p><p>日常使用命令如下：</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/71900d3f-350a-4750-8a47-4bff361282d3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Vim_tab为4个空格</title>
      <link href="/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/"/>
      <url>/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>为了 vim 更好的支持 python写代码，修改tab默认4个空格的两种设置方法：</strong></p><ul><li><p><strong>vim /etc/vimrc</strong><br>set ts=4<br>set sw=4</p></li><li><p><strong>vim/etc/vimrc</strong><br>set ts=4<br>set expandtab<br>set autoindent</p></li></ul><p>推荐第二种，按 tab 键时产生4个空格，兼容性更好。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOs7防火墙开端口测试</title>
      <link href="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>CentOS7之后，无法使用 iptables控制 Linux的端口，而是换成了<strong>firewalld</strong>。</p><ul><li><strong>查看防火墙状态</strong><br>systemctl status firewalld</li></ul><a id="more"></a><ul><li><p><strong>开启防火墙</strong><br>systemctl start firewalld</p></li><li><p><strong>关闭防火墙</strong><br>systemctl stop firewalld</p></li><li><p><strong>开机启用防火墙</strong><br>systemctl enable firewalld</p></li><li><p><strong>禁止开机启动防火墙</strong><br>systemctl disable firewalld</p></li><li><p><strong>查看当前firewall状态</strong><br>firewall-cmd –state</p></li><li><p><strong>重启防火墙</strong><br>firewall-cmd –reload</p></li></ul><h2 id="开启端口"><a href="#开启端口" class="headerlink" title="开启端口"></a>开启端口</h2><ul><li><p><strong>查看那已经开放的端口</strong><br>firewall-cmd –list-ports</p></li><li><p><strong>删除指定端口</strong><br>firewall-cmd –zone=public –remove-port=80/tcp –permanent</p></li><li><p>*<em>查看已启动的服务列表 *</em><br>systemctl list-unit-files|grep enabled</p></li><li><p><strong>查看启动失败的服务列表</strong><br>systemctl –failed</p></li><li><p><strong>查看内核版本</strong><br>uname -r</p></li><li><p><strong>查看版本</strong><br>firewall-cmd –version</p></li><li><p><strong>查看所有打开的端口</strong><br>firewall-cmd –zone=public –list-ports</p></li><li><p><strong>查看区域信息</strong><br>firewall-cmd –get-active-zones</p></li><li><p><strong>查看指定接口所属区域</strong><br>firewall-cmd –get-zone-of-interface=eth0</p></li><li><p><strong>开启端口</strong><br>firewall-cmd –zone=public –add-port=80/tcp –permanent<br>命令含义：</p></li></ul><p>–zone 作用域<br>–add-port=80/tcp 添加端口 ，格式为：端口/通讯协议<br>–permanent 永久生效，没有此参数重启后失效</p><p><strong>开启端口后，需要重启防火墙</strong><br>firewall-cmd –reload</p><h2 id="测试端口"><a href="#测试端口" class="headerlink" title="测试端口"></a>测试端口</h2><p>在开启的端口中启动一个服务，如 nginx 或者 可运行 jar包.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd reload</span><br><span class="line">nohup java jar -Dserver.port&#x3D;80 xxx.jar &gt; console.log 2&gt;&amp;1 &amp;</span><br><span class="line">tail -f console.log</span><br></pre></td></tr></table></figure><p><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/ac8de13d-3c1c-4959-8a85-c89d3288175f.png" alt></p><p>在 windows下 打开 cmd telnet 服务器ip 80（刚开的端口），如下界面表示端口开启成功。<br><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/d785cee1-1fc9-4afa-8358-a3ddc085eae0.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK三剑客</title>
      <link href="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/"/>
      <url>/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h1><p><a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">转载出处</a></p><h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><p>awk 是一种很棒的语言，它适合<strong>文本处理和报表生成</strong>，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。</p><a id="more"></a><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125;</span><br></pre></td></tr></table></figure><p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p><p>awk语言的最基本功能是<strong>在文件或者字符串中基于指定规则浏览和抽取信息</strong>，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p><p>通常，<strong>awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本</strong>。</p><h2 id="awk-的原理"><a href="#awk-的原理" class="headerlink" title="awk 的原理"></a>awk 的原理</h2><p>通过一个简短的命令，我们来了解其工作原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin</span><br><span class="line">.....................................................</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo hhh|awk &#39;&#123;print &quot;hello,world&quot;&#125;&#39;</span><br><span class="line">hello,world</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# awk &#39;&#123;print &quot;hiya&quot;&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">...............................................</span><br></pre></td></tr></table></figure><p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p><p>所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。</p><p>解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p><p><strong><font color="red">再次说明， awk 对输入文件中的每一行都执行这个脚本。</font></strong></p><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126222420597-662074402.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &quot; &quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print &quot;username: &quot; $1 &quot;\t\tuid:&quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>-F 参数：指定分隔符，可指定一个或多个</p><p>print 后面做字符串的拼接</p><h2 id="实战了解awk工作原理"><a href="#实战了解awk工作原理" class="headerlink" title="实战了解awk工作原理"></a>实战了解awk工作原理</h2><h4 id="实例一：只查看test-txt文件（100行）内第20到第30行的内容"><a href="#实例一：只查看test-txt文件（100行）内第20到第30行的内容" class="headerlink" title="实例一：只查看test.txt文件（100行）内第20到第30行的内容"></a>实例一：只查看test.txt文件（100行）内第20到第30行的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;if (NR&gt;&#x3D;20 &amp;&amp; NR&lt;&#x3D;30) print $1&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/3c5bee5c-ab0c-4985-ac20-b4a6c0dcc752.png" alt></p><h4 id="实例二：已知test-txt文件内容为："><a href="#实例二：已知test-txt文件内容为：" class="headerlink" title="实例二：已知test.txt文件内容为："></a>实例二：已知test.txt文件内容为：</h4><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ae59ac8d-9292-48e9-b271-8f715ae6f106.png" alt></p><p>请从该文件中过滤出’Poe’字符串与xxxx，最后输出的结果为：Poe xxxx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F &#39;[ ,]+&#39; &#39;&#123;print $3 &quot; &quot; $7&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/27ee340d-594c-4956-8d2b-e68b4fdae633.png" alt></p><h2 id="BEGIN-和-END-模块"><a href="#BEGIN-和-END-模块" class="headerlink" title="BEGIN 和 END 模块"></a>BEGIN 和 END 模块</h2><p>通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许定义一个 BEGIN 块。</p><p>因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p><p>awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p><h4 id="实例一：统计-etc-passwd的账户人数"><a href="#实例一：统计-etc-passwd的账户人数" class="headerlink" title="实例一：统计/etc/passwd的账户人数"></a>实例一：统计/etc/passwd的账户人数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/41d660b8-756b-45f5-bd17-fba6f535aa99.png" alt></p><p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;count&#x3D;0;print &quot;[start] user count is &quot;,count&#125; &#123;count&#x3D;count+1;print $0&#125; END&#123;print &quot;[end] user count is&quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a5855665-c30a-42a4-9d90-75c1eae79a7c.png" alt></p><h4 id="实例二：统计某个文件夹下的文件占用的字节数"><a href="#实例二：统计某个文件夹下的文件占用的字节数" class="headerlink" title="实例二：统计某个文件夹下的文件占用的字节数"></a>实例二：统计某个文件夹下的文件占用的字节数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/b3fd5eaa-5af4-4a4e-82c4-1456c99aec5e.png" alt></p><p>如果以M为单位显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#x2F;1024&#x2F;1024,&quot;M&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/5ece48af-16b1-491a-b0e3-fc2e698a7242.png" alt></p><h2 id="awk运算符"><a href="#awk运算符" class="headerlink" title="awk运算符"></a>awk运算符</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126224150269-207487187.jpg" alt></p><h4 id="awk-赋值运算符：a-5-等价于：-a-a-5-其他同类"><a href="#awk-赋值运算符：a-5-等价于：-a-a-5-其他同类" class="headerlink" title="awk 赋值运算符：a+=5;等价于： a=a+5;其他同类"></a>awk 赋值运算符：a+=5;等价于： a=a+5;其他同类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;5;a+&#x3D;5;print a&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/9e725b31-125a-4837-9e11-8d8d4806566f.png" alt></p><h4 id="awk逻辑运算符："><a href="#awk逻辑运算符：" class="headerlink" title="awk逻辑运算符："></a>awk逻辑运算符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;1;b&#x3D;2;print(a&gt;2 &amp;&amp; b&gt;1,a&#x3D;1||b&gt;1)&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ff0172a3-07e4-4b77-bcb6-23bb947fa0b6.png" alt></p><h4 id="awk正则运算符："><a href="#awk正则运算符：" class="headerlink" title="awk正则运算符："></a>awk正则运算符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;;if(a~&#x2F;100&#x2F;)&#123;print &quot;ok&quot;&#125;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo | awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;&#125; a~&#x2F;test&#x2F;&#123;print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8c085f3b-6749-4097-a370-3c4a43cae515.png" alt></p><h4 id="关系运算符："><a href="#关系运算符：" class="headerlink" title="关系运算符："></a>关系运算符：</h4><p>如： &gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;11&quot;;if(a&gt;&#x3D;9)&#123;print &quot;ok&quot;&#125;&#125;&#39; #无输出</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;11;if(a&gt;&#x3D;9)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a;if(a&gt;&#x3D;b)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/11e24ac8-1bde-4456-9c4c-4453b2688bd4.png" alt></p><h4 id="awk-算术运算符："><a href="#awk-算术运算符：" class="headerlink" title="awk 算术运算符："></a>awk 算术运算符：</h4><p>所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a++,++a&#125;&#39;</span><br><span class="line">0 2</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++;++a&#125;&#39;</span><br><span class="line">20</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++,++a&#125;&#39;</span><br><span class="line">20 22</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8afa7f71-52cb-4fbf-a979-08e0e007d195.png" alt></p><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符 ?:"></a>三目运算符 ?:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;c&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">err</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e6da1f28-ff78-4933-8914-5c0b6fec6fd1.png" alt></p><h2 id="常用-awk-内置变量"><a href="#常用-awk-内置变量" class="headerlink" title="常用 awk 内置变量"></a>常用 awk 内置变量</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126225731300-1873454323.jpg" alt><br>注：内置变量很多，参阅相关资料</p><h4 id="字段分隔符-FS"><a href="#字段分隔符-FS" class="headerlink" title="字段分隔符 FS"></a>字段分隔符 FS</h4><p>FS=”\t+” 一个或多个 Tab 分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">ww CC IDD</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;\t+&quot;&#125;&#123;print $1,$2,$3&#125;&#39; test.txt </span><br><span class="line">ww CC IDD</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c865da77-e766-40ea-a7f4-6f2d8093013f.png" alt></p><p>FS=[[:space:]+] 一个或多个空白空格，默认的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [[:space:]+] &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1cec6d3e-d39a-4173-bb21-4b54f51e73fe.png" alt></p><p>FS=[“ “:]+ 以一个或多个空格或：分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [&quot; &quot;:]+ &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/d833df93-0259-4fa9-9069-dcc9f9393bd7.png" alt></p><p>字段数量 NF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk -F &quot;:&quot; &#39;NF&#x3D;&#x3D;8&#123;print $0&#125;&#39; test.txt </span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/393eb9b6-011c-475e-b90a-97ee7bbb7256.png" alt></p><p>记录数量 NR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk -F [&quot; &quot;:]+ &#39;NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br><span class="line"></span><br><span class="line">## NR&#x3D;&#x3D;2即是取第二行数据</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/32a25c64-0e99-40f1-a668-3f8c77937b5d.png" alt></p><p>RS 记录分隔符变量</p><p>将 FS 设置成”\n”告诉 awk 每个字段都占据一行。通过将 RS 设置成””，还会告诉 awk每个地址记录都由空白行分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p>ps:** 凡是被#!注释的，统统是加载器(解释器)的路径。#!/bin/awk :指定使用此程序来运行本文件。**</p><p>OFS 输出字段分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat hello.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125;&#123;print $1&quot;,&quot;$2&quot;,&quot;$3&#125;&#39; hello.txt </span><br><span class="line">root,x,0</span><br><span class="line">bin,x,1</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;;OFS&#x3D;&quot;#&quot;&#125;&#123;print $1,$2,$3&#125;&#39; hello.txt </span><br><span class="line">root#x#0</span><br><span class="line">bin#x#1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c1f049a7-edea-4bb8-b786-356de8bbd561.png" alt></p><p>ORS 输出记录分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">    ORS&#x3D;&quot;\n\n&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c4e9909e-c851-448d-affe-8d5acfd9ad66.png" alt></p><h2 id="awk正则"><a href="#awk正则" class="headerlink" title="awk正则"></a>awk正则</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126232437800-1355193233.jpg" alt></p><h4 id="正则应用"><a href="#正则应用" class="headerlink" title="正则应用"></a>正则应用</h4><p>规则表达式<br>awk ‘/REG/{action} ‘ file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd  ##匹配所有包含root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">operator:x:11:0:operator:&#x2F;root:&#x2F;sbin&#x2F;nologin</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# awk -F: &#39;$5~&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd ## 以冒号作为分隔符，匹配第5个字段是root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk &#39;BEGIN&#123;FS&#x3D;&quot;[[:space:]:]+&quot;&#125; NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/460ee8cf-76ae-41ce-8448-c212c858c5a9.png" alt></p><p>布尔表达式<br>awk ‘布尔表达式{action}’ file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F : &#39;$1&#x3D;&#x3D;&quot;root&quot; &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">[root@haoransun demo]#</span><br><span class="line">[root@haoransun demo]# awk -F : &#39;($1&#x3D;&#x3D;&quot;root&quot;)&amp;&amp;($5&#x3D;&#x3D;&quot;root&quot;) &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/53f21771-aef3-4683-a415-1839a4939df3.png" alt></p><h2 id="awk-的-if、循环和数组"><a href="#awk-的-if、循环和数组" class="headerlink" title="awk 的 if、循环和数组"></a>awk 的 if、循环和数组</h2><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>awk 提供了非常好的类似于 C 语言的 if 语句。<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/cb35a7a2-c225-4d92-ad58-5f7d7dc977a0.png" alt></p><p>使用 if 语句还可以将代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! &#x2F;matchme&#x2F; &#123;print $1 $3 $4&#125;</span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if($0 !~ &#x2F;matchme&#x2F; )&#123;</span><br><span class="line">        print $1 $3 $4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有”do…while”循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。</p><p>它类似于其它语言中的”repeat…until”循环。以下是一个示例：<br>do…while 示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    count &#x3D; do&#123;</span><br><span class="line">        print &quot;xxxxx&quot;</span><br><span class="line">    &#125;while(count !&#x3D;1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (initial assignment; comparation; increment)&#123;</span><br><span class="line">    code block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(x&#x3D;1;x&lt;&#x3D;4;x++)&#123;</span><br><span class="line">    print &quot;iteration&quot;,x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iteration1</span><br><span class="line">iteration2</span><br><span class="line">iteration3</span><br><span class="line">iteration4</span><br></pre></td></tr></table></figure><h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h4><p>此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a425efad-8bdf-4bf8-8379-cfd3cb2f6930.png" alt></p><p>以下只执行10次<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e1f4652e-1c8c-4031-8fa5-19a84853429c.png" alt></p><p>这里， break 语句用于“逃出”最深层的循环。 “break”使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e5cd9ad0-3212-4d52-8c60-ad07febf338b.png" alt></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>AWK 中的数组都是关联数组,数字索引也会转变为字符串索引<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/06c347db-0e28-45cc-a3f6-a51ce62523bd.png" alt><br>for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</p><h4 id="数组的典型应用"><a href="#数组的典型应用" class="headerlink" title="数组的典型应用"></a>数组的典型应用</h4><p>用 awk 中查看服务器连接状态并汇总</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# netstat -an|awk &#39;&#x2F;^tcp&#x2F;&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;&#39;</span><br><span class="line">LISTEN 4</span><br><span class="line">ESTABLISHED 1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/2c9f17b2-4bf8-4fcc-8ff8-49b6a160c7c0.png" alt></p><p>统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/065c3870-c2e8-4acc-9596-35d91ae183d1.png" alt></p><h2 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126235509019-257728577.jpg" alt></p><h4 id="字符串函数的应用"><a href="#字符串函数的应用" class="headerlink" title="字符串函数的应用"></a>字符串函数的应用</h4><p>替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;gsub(&#x2F;[0-9]+&#x2F;,&quot;!&quot;,info);print info&#125;&#39;</span><br><span class="line">this is a test!test!</span><br><span class="line"></span><br><span class="line">在info中查找满足正则表达式， &#x2F;[0-9]+&#x2F; 用 “！”替换，并且赋值给 info值，默认是$0</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>匹配查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print match(info,&#x2F;[0-9]+&#x2F;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">如果查找到数字匹配成功返回 ok</span><br></pre></td></tr></table></figure><p>截取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#39;</span><br><span class="line">s is a tes</span><br><span class="line">从第4个字符开始，截取10个长度字符串。</span><br></pre></td></tr></table></figure><p>分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#39;</span><br><span class="line">4</span><br><span class="line">4 test</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">分割 info,动态创建数组tA,awk for ...循环 是一个无序的循环，并不是从数组下表1...n开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>Practice makes perfect</strong></p><h1 id="Vim-的前生今世"><a href="#Vim-的前生今世" class="headerlink" title="Vim 的前生今世"></a>Vim 的前生今世</h1><p>Vi 最初是由 Bill Joy 在 1976 年编码实现的。而 Vim (Vi IMproved) 则是改进的 Vi，由 Bram Moolenaar 在 1991 年开发并发布。Vi/Vim 是所有 Unix/Linux 操作系统默认配备的编辑器。因其强大的功能和高效的操作，Vi/Vim 也成为众多 Unix/Linux 用户、管理员必须掌握并熟练使用的编辑工具之一。尤其是在没有图形界面的情况下，更是离不开 Vi/Vim。Vi/Vim 命令非常多、用法极为灵活，掌握起来有一定的难度。本文为入门教程，关于 Vi/Vim 各种定制后的功能不在本文讨论范围之列。</p><a id="more"></a><h1 id="Vi和Vim"><a href="#Vi和Vim" class="headerlink" title="Vi和Vim"></a>Vi和Vim</h1><p>在 Linux 的世界中，绝大部分的配置文件都是以 ASCII 的<strong>纯文本</strong>形态存在，因此利用简单的文字编辑软件就能够修改！ 与微软 Windows 系统不同的是，如果你用惯了 Microsoft Word 的话，在 Linux 的文本模式下，会觉得文书编辑程序都没有窗口接口来的直观与方便，那么问题来了，干嘛还要学这个不是很友善和方便的vi编辑器呢？因为：</p><ul><li>跨平台无所不在。所有的 Unix 和 Linux 系统都会内建 vi 文本编辑器，其他的编辑器则不一定会有而且你无需担心到了其他平台需要学习新编辑器，除了Linux/Mac OS X外Windows系统也都可用。</li><li>很多个别软件的编辑接口都会主动调用 vi ；</li><li>可扩展性。你可以只用它来编辑配置文件，也可以将它当做你的开发平台。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；</li><li>程序简单、功能强大、运行飞快</li></ul><h1 id="什么是Vim呢？"><a href="#什么是Vim呢？" class="headerlink" title="什么是Vim呢？"></a>什么是Vim呢？</h1><p>其实你可以将 vim 视作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。 举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是shell script程序时，vim 会依据档案的扩展名或者是档案内的开头信息， 判断该档案的内容而自动调用该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说， 这个 vim 已经是个『程序编辑器』了！甚至一些 Linux 基础配置文件内的语法，都能用 vim 来检查！<br> 简单来说， vi 是老式的文本处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim 则可以说是程序开发者的『程序编辑器』了，就连 vim 的<a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">官网</a>也说 vim 是一个『程序开发工具』而不是文本处理软件。 因为 vim 里面加入了很多额外的功能，例如支持正规表示法的搜寻架构、多档案编辑、区块复制等等。</p><p><strong>学习 <a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">vim</a> 并且它可能会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用</strong>。</p><p><strong>提示</strong>：在 Linux 下，如果以 root 用户登录系统的话，通过 vi 命令打开的 Vim 编辑器往往只加载最基本的功能，像语法加亮着色的功能基本上没有。在 root 用户下使用 Vim 所有功能的技巧是用 vim 命令打开 Vim 编辑器。</p><h1 id="如何进入Vim"><a href="#如何进入Vim" class="headerlink" title="如何进入Vim?"></a>如何进入Vim?</h1><p>可以在终端（不明白什么是终端的，请自行谷歌命令行、终端、shell、bash了解）输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim [filename]</span><br></pre></td></tr></table></figure><p>其中<code>filename</code>是文件的路径。如果文件不存在，它将为你建立一个新文件。</p><h1 id="Vim的三种操作模式"><a href="#Vim的三种操作模式" class="headerlink" title="Vim的三种操作模式"></a>Vim的三种操作模式</h1><p>Vim编辑程序有三种操作模式，分别称为<strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>。</p><p><strong>编辑模式</strong>：用以执行命令，也称为Normal正常模式，也是进入Vim的缺省模式。进入Vim后会直接进入编辑模式(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来操作文本， 也可以使用『复制、剪切、粘贴』来处理文本数据，删除正文和插入新的正文。但是却是无法编辑文本内容的！</p><p><strong>插入模式</strong>：即 Insert 模式，用来输入文本，就像你用“记事本”一样。进入Vim后会直接进入编辑模式，要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进行编辑，可以输入字符。而如果要回到一般模式时， 则必须要按下『Esc』这个按键才可退出编辑模式。</p><p><strong>命令模式</strong>：用来执行冒号命令。在编辑模式下输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中，可以进行保存、查找、替换、显示行号、退出、配置Vim操作等等的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i → Insert 模式，按 ESC 回到 Normal 模式。</span><br><span class="line">x → 删当前光标所在的一个字符。</span><br><span class="line">dd → 删除当前行，并把删除的行存到剪贴板里。</span><br><span class="line">p → 粘贴剪贴板。</span><br><span class="line">:wq → 存盘 + 退出 (:w 存盘后可以跟文件名，:q 退出，:q!强制退出)</span><br><span class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。</span><br></pre></td></tr></table></figure><p><strong>推荐</strong>：<br>强例推荐使用hjkl键盘移动光标，但不必需，你也可以使用光标键 (←↓↑→)移动。<br>以 : 开始的命令你需要输入 <enter> 回车结束，例如我写成 :q 也就是说你要输入 :q然后回车。</enter></p><h1 id="编辑模式下命令"><a href="#编辑模式下命令" class="headerlink" title="编辑模式下命令"></a>编辑模式下命令</h1><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k或↑              上移</span><br><span class="line">j或↓               下移</span><br><span class="line">h或←            左移</span><br><span class="line">l或→             右移</span><br></pre></td></tr></table></figure><p>上面这４个键将光标位置每次移动一行或一个字符 。Vim还提供稍大范围移动光标的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f         在文件中前移一页（相当于 page down）</span><br><span class="line">ctrl+b        在文件中后移一页（相当于 page up）</span><br><span class="line">ctrl+d        屏幕向下移动半页</span><br><span class="line">ctrl+u        屏幕向上移动一页</span><br></pre></td></tr></table></figure><p>更大范围的移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*          当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</span><br><span class="line">#          当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</span><br><span class="line">(&#x2F;)        移动到 前&#x2F;后 句 的开始；</span><br><span class="line">&#123;&#x2F;&#125;        跳转到 当前&#x2F;下一个 段落 的开始。</span><br><span class="line">g_         到本行最后一个不是 blank 字符的位置。</span><br><span class="line">fa         到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</span><br><span class="line">t,         到逗号前的第一个字符。逗号可以变成其它字符。</span><br><span class="line">3fa        在当前行查找第三个出现的 a。</span><br><span class="line">F&#x2F;T        和 f 和 t 一样，只不过是相反方向;</span><br></pre></td></tr></table></figure><p>在屏幕中找到需要的 一页 时，可以用下面的命令快速移动光标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H                  将光标移到屏幕上的起始行（或最上行）</span><br><span class="line">M                  将光标移到屏幕中间</span><br><span class="line">L                  将光标移到屏幕最后一行</span><br><span class="line">G                  将光标定位到文件最后一行起始位置</span><br><span class="line">NG或Ngg            将光标定位到第 N 行的起始位置</span><br><span class="line">gg                 将光标定位到文件第一行起始位置</span><br><span class="line">N(ENTER)           光标下移N行</span><br></pre></td></tr></table></figure><p>同样需要注意字母的大小写。H 和 L 命令还可以加数字。如 2H 表示将光标移到屏幕的第２行，3L 表示将光标移到屏幕的倒数第3行。<br>当将光标移到所要的行是，行内移动 光标可以用下面的命令来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w                右移光标到下一个字的开头；</span><br><span class="line">e                右移光标到一个字的末尾；</span><br><span class="line">b                左移光标到前一个字的开头；</span><br><span class="line">0                数字０，左移光标到本行的开始；</span><br><span class="line">$                右移光标，到本行的末尾；</span><br><span class="line">^                移动光标，到本行的第一个非空字符。</span><br><span class="line">+                光标移动到非空格符的下一行；</span><br><span class="line">-                光标移动到非空格符的上一行n；</span><br><span class="line">n                n表示数字，按下数字后按空格键，光标右移n个字符，会跨行移动。</span><br></pre></td></tr></table></figure><h2 id="查找。搜索匹配"><a href="#查找。搜索匹配" class="headerlink" title="查找。搜索匹配"></a>查找。搜索匹配</h2><p>和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 / ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 ? 取代 / ，可以实现反向搜索（朝文件开头方向）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;str1                正向搜索字符串 str1；</span><br><span class="line">n                    继续搜索，重复之前的查找，但是向上重复查找；</span><br><span class="line">N                    继续搜索，重复之前的查找，但是向下重复查找；</span><br><span class="line">?str2                反向搜索字符串 str2 。</span><br><span class="line">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g   这个操作代表在n1与n2行之间查找word1并用word2来代替它</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;g     这个操作是从第一行到最后一行进行查找替换</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;gc    与上面一样只不过多了个确认confirm</span><br></pre></td></tr></table></figure><p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。<br>Vim中执行搜索匹配最强大的地方是结合 正则表达式 来搜索，</p><h2 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h2><p>Vim常规的删除命令是 d、 x (前者删除 行 ，后者删除 字符 ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rc                 用 c 替换光标所指向的当前字符；</span><br><span class="line">nrc                用 c 替换光标所指向的前 n 个字符；</span><br><span class="line">5rA                用 A 替换光标所指向的前 5 个字符；</span><br><span class="line">x                  删除光标所指向的当前字符；</span><br><span class="line">nx                 删除光标所指向的前 n 个字符；</span><br><span class="line">3x                 删除光标所指向的前 3 个字符；</span><br><span class="line">dw                 删除光标右侧的字；</span><br><span class="line">ndw                删除光标右侧的 n 个字；</span><br><span class="line">3dw                删除光标右侧的 3 个字；</span><br><span class="line">db                 删除光标左侧的字；</span><br><span class="line">ndb                删除光标左侧的 n 个字；</span><br><span class="line">5db                删除光标左侧的 5 个字；</span><br><span class="line">dd                 删除光标所在行，并去除空隙；</span><br><span class="line">ndd                删除（剪切） n 行内容，并去除空隙；</span><br><span class="line">3dd                删除（剪切） 3 行内容，并去除空隙；</span><br></pre></td></tr></table></figure><p>其他常用的删除命令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d$                从当前光标起删除字符直到行的结束；</span><br><span class="line">d0                从当前光标起删除字符直到行的开始；</span><br><span class="line">J                 删除本行的回车符（CR），并和下一行合并。</span><br></pre></td></tr></table></figure><p>Vim常规的替换命令有 c 和 s ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由<strong>编辑模式</strong>进入<strong>插入模式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s                用输入的正文替换光标所指向的字符；</span><br><span class="line">S                删除当前行，并进入编辑模式；</span><br><span class="line">ns               用输入的正文替换光标右侧 n 个字符；</span><br><span class="line">nS               删除当前行在内的 n 行，并进入编辑模式；</span><br><span class="line">cw               用输入的正文替换光标右侧的字；</span><br><span class="line">cW               用输入的正文替换从光标到行尾的所有字符（同 c$ )；</span><br><span class="line">ncw              用输入的正文替换光标右侧的 n 个字；</span><br><span class="line">cb               用输入的正文替换光标左侧的字；</span><br><span class="line">ncb              用输入的正文替换光标左侧的 n 个字；</span><br><span class="line">cd               用输入的正文替换光标的所在行；</span><br><span class="line">ncd              用输入的正文替换光标下面的 n 行；</span><br><span class="line">c$               用输入的正文替换从光标开始到本行末尾的所有字符；</span><br><span class="line">c0               用输入的正文替换从本行开头到光标的所有字符。</span><br></pre></td></tr></table></figure><p><a href="https://link.jianshu.com/?t=http://blog.jobbole.com/86132/" target="_blank" rel="noopener">Vim 入门教程</a><br><a href="https://link.jianshu.com/?t=http://cn.linux.vbird.org/linux_basic/0310vi.php" target="_blank" rel="noopener">vim 程序编辑器</a><br><a href="https://www.jianshu.com/p/7678a7e6973e" target="_blank" rel="noopener">http://www.jianshu.com/p/7678a7e6973e</a><br><a href="https://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="noopener">http://www.jianshu.com/p/bcbe916f97e1</a><br><a href="https://link.jianshu.com/?t=http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时任务Crontab详解</title>
      <link href="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="noopener">文章出处</a></p><p>Linux系统是由cron（crond）这个系统服务来控制的。Linux系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。</p><a id="more"></a><h1 id="一、crond简介"><a href="#一、crond简介" class="headerlink" title="一、crond简介"></a>一、crond简介</h1><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>/etc/crontab文件包括下面几行：<br><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/e8696488-4891-4358-a0ed-22f305460374.png" alt></p><p>前 四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行 命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p><p>使用者权限文件：</p><p>/etc/cron.deny<br>说明：<br>该文件中所列用户不允许使用crontab命令</p><p>/etc/cron.allow<br>说明：<br>该文件中所列用户允许使用crontab命令</p><p>/var/spool/cron/<br>说明：<br>所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><p>minute hour day month week command<br>其中：</p><p>minute： 表示分钟，可以是从0到59之间的任何整数。</p><p>hour：表示小时，可以是从0到23之间的任何整数。</p><p>day：表示日期，可以是从1到31之间的任何整数。</p><p>month：表示月份，可以是从1到12之间的任何整数。</p><p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p><p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p><p><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/513841-20160812102124078-171184924.png" alt></p><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h1 id="二、crontab命令详解"><a href="#二、crontab命令详解" class="headerlink" title="二、crontab命令详解"></a>二、crontab命令详解</h1><p>1．命令格式：</p><p>crontab [-u user] file</p><p>crontab [-u user] [ -e | -l | -r ]</p><p>2．命令功能：</p><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><p>3．命令参数：</p><p>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</p><p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</p><p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</p><p>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</p><p>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</p><p>-i：在删除用户的crontab文件时给确认提示。</p><p>4．常用方法：</p><p>1). 创建一个新的crontab文件</p><p>在 考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其 中加入这样一行：</p><p>EDITOR=vi; export EDITOR</p><p>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</user></user></p><h1 id="put-your-own-initials-here-echo-the-date-to-the-console-every"><a href="#put-your-own-initials-here-echo-the-date-to-the-console-every" class="headerlink" title="(put your own initials here)echo the date to the console every"></a>(put your own initials here)echo the date to the console every</h1><h1 id="15minutes-between-6pm-and-6am"><a href="#15minutes-between-6pm-and-6am" class="headerlink" title="15minutes between 6pm and 6am"></a>15minutes between 6pm and 6am</h1><p>0,15,30,45 18-06 * * * /bin/echo ‘date’ &gt; /dev/console</p><p>保存并退出。确信前面5个域用空格分隔。</p><p>在 上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：</p><p>$ crontab davecron</p><p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。</p><p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p><p>2). 列出crontab文件</p><p>为了列出crontab文件，可以用：</p><p>$ crontab -l</p><p>0,15,30,45,18-06 * * * /bin/echo <code>date</code> &gt; dev/tty1</p><p>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：</p><p>$ crontab -l &gt; $HOME/mycron</p><p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><p>3). 编辑crontab文件</p><p>如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为：</p><p>$ crontab -e</p><p>可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p><p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p><h1 id="DT-delete-core-files-at-3-30am-on-1-7-14-21-26-26-days-of-each-month"><a href="#DT-delete-core-files-at-3-30am-on-1-7-14-21-26-26-days-of-each-month" class="headerlink" title="DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month"></a>DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</h1><p>30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm {} ;</p><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p><p>$ crontab -l</p><h1 id="crondave-installed-on-Tue-May-4-13-07-43-1999"><a href="#crondave-installed-on-Tue-May-4-13-07-43-1999" class="headerlink" title="(crondave installed on Tue May 4 13:07:43 1999)"></a>(crondave installed on Tue May 4 13:07:43 1999)</h1><h1 id="DT-ech-the-date-to-the-console-every-30-minites"><a href="#DT-ech-the-date-to-the-console-every-30-minites" class="headerlink" title="DT:ech the date to the console every 30 minites"></a>DT:ech the date to the console every 30 minites</h1><p>0,15,30,45 18-06 * * * /bin/echo <code>date</code> &gt; /dev/tty1</p><h1 id="DT-delete-core-files-at-3-30am-on-1-7-14-21-26-26-days-of-each-month-1"><a href="#DT-delete-core-files-at-3-30am-on-1-7-14-21-26-26-days-of-each-month-1" class="headerlink" title="DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month"></a>DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</h1><p>30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm {} ;</p><p>4). 删除crontab文件</p><p>要删除crontab文件，可以用：</p><p>$ crontab -r</p><p>5). 恢复丢失的crontab文件</p><p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：</username></username></p><p>$ crontab <filename></filename></p><p>其中，<filename>是你在$ H O M E目录中副本的文件名。</filename></p><p>我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。</Ctrl-D></p><p>5．使用实例</p><p>实例1：每1分钟执行一次command<br>命令：</p><ul><li><ul><li><ul><li><ul><li><ul><li>command</li></ul></li></ul></li></ul></li></ul></li></ul><p>实例2：每小时的第3和第15分钟执行<br>命令：<br>3,15 * * * * command</p><p>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * * command</p><p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 */2 * * command</p><p>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * 1 command</p><p>实例6：每晚的21:30重启smb<br>命令：<br>30 21 * * * /etc/init.d/smb restart</p><p>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<br>45 4 1,10,22 * * /etc/init.d/smb restart</p><p>实例8：每周六、周日的1 : 10重启smb<br>命令：<br>10 1 * * 6,0 /etc/init.d/smb restart</p><p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<br>0,30 18-23 * * * /etc/init.d/smb restart</p><p>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<br>0 23 * * 6 /etc/init.d/smb restart</p><p>实例11：每一小时重启smb<br>命令：</p><ul><li>*/1 * * * /etc/init.d/smb restart</li></ul><p>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：</p><ul><li>23-7/1 * * * /etc/init.d/smb restart</li></ul><p>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<br>0 11 4 * mon-wed /etc/init.d/smb restart</p><p>实例14：一月一号的4点重启smb<br>命令：<br>0 4 1 jan * /etc/init.d/smb restart</p><p>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<br>01 * * * * root run-parts /etc/cron.hourly<br>说明：<br>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p><p>四、使用注意事项</p><p>注意环境变量问题<br>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p><p>在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。</p><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><p>1）脚本中涉及文件路径时写全局路径；</p><p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p><p>cat start_cbp.sh</p><p>#!/bin/sh</p><p>source /etc/profile</p><p>export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</p><p>/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</p><p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><p>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p><p>注意清理系统用户的邮件日志<br>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p><p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p><p>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p><p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p><p>系统级任务调度与用户级任务调度<br>系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。</p><p>其他注意事项<br>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p><p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用插件及乱码</title>
      <link href="/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="清空文件-gt-filename-或者-gt-filename"><a href="#清空文件-gt-filename-或者-gt-filename" class="headerlink" title="清空文件   &gt; filename 或者 : &gt; filename"></a>清空文件   &gt; filename 或者 : &gt; filename</h1><h1 id="configure-make-make-install"><a href="#configure-make-make-install" class="headerlink" title="./configure make make install"></a>./configure make make install</h1><ul><li><p>./configure 检测安装平台的目标特征的。如会检测是不是有CC或者GCC，并不是需要CC或者GCC，它是个shell脚本，生成Makefile,为下一步的编译做准备。</p><a id="more"></a></li><li><p>make 用来编译的，它从 Makefile读取指令，然后编译。</p></li><li><p>make install 用来安装。他也从 Makefile中读取指令，安装到指定的位置。</p></li></ul><h2 id="configure"><a href="#configure" class="headerlink" title="./configure"></a>./configure</h2><p>一般用来生成 Makefile，为下一步的编译做准备。</p><p>你可以通过在 configure 后加上参数来对安装进行控制，比如代码:</p><p>./configure –prefix=/usr<br>意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin)，资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。<br>同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><p>make 的作用是开始进行源代码编译，</p><p>以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。</p><p>如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行）。</p><p>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。</p><p>一般情况下，他所使用的 Makefile ，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><h2 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h2><p>安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（sudo make install</p><h1 id="搜索安装包路径"><a href="#搜索安装包路径" class="headerlink" title="搜索安装包路径"></a>搜索安装包路径</h1><p>whereis 安装包<br>如：whereis vim<br>    whereis tree</p><h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><p>yum instsall vim</p><h1 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h1><p>yun install tree</p><h1 id="通用下载方式"><a href="#通用下载方式" class="headerlink" title="通用下载方式"></a>通用下载方式</h1><p>yum install wget</p><h1 id="上传下载下工具"><a href="#上传下载下工具" class="headerlink" title="上传下载下工具"></a>上传下载下工具</h1><p>yum install lrzsz</p><h1 id="CentOS6-中文乱码解决"><a href="#CentOS6-中文乱码解决" class="headerlink" title="CentOS6 中文乱码解决"></a>CentOS6 中文乱码解决</h1><h2 id="1-安装语言包"><a href="#1-安装语言包" class="headerlink" title="1 安装语言包"></a>1 安装语言包</h2><p>yum groupinstall chinese-support</p><h2 id="2-设置字符集"><a href="#2-设置字符集" class="headerlink" title="2 设置字符集"></a>2 设置字符集</h2><h3 id="临时生效-好像不管用"><a href="#临时生效-好像不管用" class="headerlink" title="临时生效(好像不管用)"></a>临时生效(好像不管用)</h3><p>export LANG=”zh_CN.UTF-8” ## 设置为中文<br>export LANG=”en-US.UTF-8” ## 设置为英文，</p><h3 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h3><p>vi /etc/sysconfig/i18n(最好reboot下)<br>LANG =”zh_CN.UTF-8”</p><p>或者<br>vi /etc/profile配置文件，添加一行<br>export LANG=”zh_CN.UTF-8”<br>重新载入<br>./etc/profile</p><p>查看当前字符集<br>echo $LANG</p><h1 id="CentOS7中英文乱码解决"><a href="#CentOS7中英文乱码解决" class="headerlink" title="CentOS7中英文乱码解决"></a>CentOS7中英文乱码解决</h1><h2 id="1-安装中文库"><a href="#1-安装中文库" class="headerlink" title="1 安装中文库"></a>1 安装中文库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure><h2 id="2-检查是否有中文语言包"><a href="#2-检查是否有中文语言包" class="headerlink" title="2 检查是否有中文语言包"></a>2 检查是否有中文语言包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure><h2 id="3-查看当前系统语言环境"><a href="#3-查看当前系统语言环境" class="headerlink" title="3 查看当前系统语言环境"></a>3 查看当前系统语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale</span><br></pre></td></tr></table></figure><h2 id="4-修改本机语言环境"><a href="#4-修改本机语言环境" class="headerlink" title="4 修改本机语言环境"></a>4 修改本机语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locale -a | grep &quot;zh_CN&quot;</span><br><span class="line"></span><br><span class="line">一个一个试。目前是 zh_CN有效果</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;locale.conf</span><br><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">source &#x2F;etc&#x2F;locale.conf</span><br></pre></td></tr></table></figure><h2 id="5-重启系统"><a href="#5-重启系统" class="headerlink" title="5 重启系统"></a>5 重启系统</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装常用软件</title>
      <link href="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="mysql国内镜像下载网址"><a href="#mysql国内镜像下载网址" class="headerlink" title="mysql国内镜像下载网址"></a>mysql国内镜像下载网址</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><h1 id="开源镜像站点汇总"><a href="#开源镜像站点汇总" class="headerlink" title="开源镜像站点汇总"></a>开源镜像站点汇总</h1><p><a href="http://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000375848</a></p><p><a href="https://opsx.alibaba.com/mirror/search?q=mysq5.7&lang=zh-CN" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror/search?q=mysq5.7&amp;lang=zh-CN</a></p><p><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p><a id="more"></a><h1 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h1><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">java包</a></p><h2 id="手动解压"><a href="#手动解压" class="headerlink" title="手动解压"></a>手动解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;</span><br><span class="line">make java</span><br><span class="line">[root@haoransun java]# wget https:&#x2F;&#x2F;download.oracle.com&#x2F;otn&#x2F;java&#x2F;jdk&#x2F;8u211-b12&#x2F;478a62b7d4e34b78b671c754eaaf38ab&#x2F;jdk-8u211-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">或者直接将jar由 winSCP包传导至Linux指定目录</span><br><span class="line"></span><br><span class="line">配置环境变量</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">将下列配置文件添加，保存退出(一定要去掉等号两边的空格)</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">export CLASSPATH&#x3D;.$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line">:wq</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">java -version 或者 jps 验证即可</span><br></pre></td></tr></table></figure><hr><h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum search java | grep jdk</span><br><span class="line">yum install java-1.8.0-openjdk</span><br><span class="line">默认安装在 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;</span><br><span class="line">配置环境变量及验证安装</span><br></pre></td></tr></table></figure><hr><h2 id="rpm-安装"><a href="#rpm-安装" class="headerlink" title="rpm 安装"></a>rpm 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh  指定安装包</span><br><span class="line">配置环境变量。验证安装</span><br></pre></td></tr></table></figure><h1 id="CentOS7-安装-MySQL5-7"><a href="#CentOS7-安装-MySQL5-7" class="headerlink" title="CentOS7 安装 MySQL5.7"></a>CentOS7 安装 MySQL5.7</h1><p>安装环境：CentOS7 64位 mini版，安装MySQL5.7</p><p>mysql-client和server的区别：<br><strong>本质上的区别是：server是执行一个crud操作，client是发送一个crud操作</strong></p><p>server是把sql语句翻译成对内存和文件的操作，也就是说，server是直接操作文件的。</p><p>而client是对数据库/表进行操作，不是直接对文件进行操作。</p><p>举个例子：<br>①client：我用一个Navicat去链接一个数据库，这个Navicat就是client。</p><p>②server：我有多个mysql服务实例，他们可以位于不同的端口（这句不重要），但是他们是挂载在了宿主机同一个目录下的（这句重要，对内存/文件进行操作了），而且数据共享（这句也不重要）。</p><p>小知识点：</p><p>①sql只是去知道server如何去操作数据。</p><p>②即使C/S在同一台机器上，他们也是通过网络通讯的。</p><h2 id="1-配置-YUM源"><a href="#1-配置-YUM源" class="headerlink" title="1. 配置 YUM源"></a>1. 配置 YUM源</h2><p>在<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">MySQL</a>官网中下载YUM源rpm安装包：<a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/repo/yum/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载mysql源安装包</span><br><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">安装mysql源</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong><font color="red">由于某些原因，下载过慢，可以参考最上方的国内网址进行下载，</font>如下所示：</strong><br><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/060fa4bb-b320-4095-bd6c-aab5b5f1f232.png" alt></p><ul><li><strong>1</strong> 右键选择，复制链接地址，到Linux中  wget 链接地址，下载 xxx.rpm安装包<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/a7aa735c-9414-4e83-beae-d17b54ce252e.png" alt></li><li><strong>2</strong> sudo rpm -ivh 上述mysql安装包</li><li><strong>3</strong> 安装MySql sudo yum install mysql-server<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/adb53ba1-80e5-413e-8cf0-16cd3b40b621.png" alt></li></ul><p>看到上图所示，则表示安装成功。</p><h2 id="2-启动MySQL服务"><a href="#2-启动MySQL服务" class="headerlink" title="2. 启动MySQL服务"></a>2. 启动MySQL服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL的启动状态<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/c8cbc2ec-f7aa-4adb-8729-3abbb7b9396b.png" alt></p><h2 id="3-开机启动"><a href="#3-开机启动" class="headerlink" title="3. 开机启动"></a>3. 开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="4-修改root默认密码"><a href="#4-修改root默认密码" class="headerlink" title="4. 修改root默认密码"></a>4. 修改root默认密码</h2><p>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/5bbf95fd-6e34-40ef-a1c7-ad57bea532e0.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">mysql &gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Sun@123456!&#39;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;MyNewPass4!&#39;);</span><br></pre></td></tr></table></figure><p>注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示：</p><p>通过msyql环境变量可以查看密码策略的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%password%&#39;;</span><br></pre></td></tr></table></figure><p> validate_password_policy：密码策略，默认为MEDIUM策略  validate_password_dictionary_file：密码策略文件，策略为STRONG才需要  validate_password_length：密码最少长度  validate_password_mixed_case_count：大小写字符长度，至少1个  validate_password_number_count ：数字至少1个  validate_password_special_char_count：特殊字符至少1个  _上述参数是默认策略MEDIUM的密码检查规则。</p><p>共有以下几种密码策略：</p><table><thead><tr><th>策略</th><th>检查规则</th></tr></thead><tbody><tr><td>0 or LOW</td><td>Length</td></tr><tr><td>1 or MEDIUM</td><td>Length; numeric, lowercase/uppercase, and special characters</td></tr><tr><td>2 or STRONG</td><td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td></tr><tr><td>MySQL官网密码策略详细说明：<a href="http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy</a></td><td></td></tr></tbody></table><h4 id="修改密码策略"><a href="#修改密码策略" class="headerlink" title="修改密码策略"></a>修改密码策略</h4><p>在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</span><br><span class="line">validate_password_policy&#x3D;0</span><br></pre></td></tr></table></figure><p>如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate_password &#x3D; off</span><br></pre></td></tr></table></figure><p>重新启动mysql服务使配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h2 id="5-添加远程登录用户"><a href="#5-添加远程登录用户" class="headerlink" title="5. 添加远程登录用户"></a>5. 添加远程登录用户</h2><p>默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sunhaoran&#39;@&#39;%&#39; IDENTIFIED BY &#39;Sun@123456&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h2 id="6-配置默认编码为-utf8"><a href="#6-配置默认编码为-utf8" class="headerlink" title="6. 配置默认编码为 utf8"></a>6. 配置默认编码为 utf8</h2><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure><p>重新启动mysql服务，查看<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">数据库</a>默认编码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;character%&#39;;</span><br></pre></td></tr></table></figure><p><strong>默认配置文件路径：</strong>  配置文件：/etc/my.cnf  日志文件：/var/log//var/log/mysqld.log  服务启动脚本：/usr/lib/systemd/system/mysqld.service  socket文件：/var/run/mysqld/mysqld.pid</p><h3 id="mysql-基本操作"><a href="#mysql-基本操作" class="headerlink" title="mysql 基本操作"></a>mysql 基本操作</h3><h4 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 回车</span><br><span class="line">输入密码回车即可</span><br><span class="line">数据库查看：show databases;</span><br><span class="line">数据库选择：use xx;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Host-Vm相互ping不同到的解决办法</title>
      <link href="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天总结一下前段时间出现的一些虚拟机问题，之前配置的宿主机ping虚拟机以及虚拟机ping外网没有什么问题，但是后来不知道什么原因突然就ping不通了，经过网上各种找资料，研究了下VM0,1,8的区别，为了防止遗忘在此记录。</p><a id="more"></a><h2 id="两机互ping的问题"><a href="#两机互ping的问题" class="headerlink" title="两机互ping的问题"></a>两机互ping的问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VMnet0使用的是桥接模式，安装VM后默认的就是这种模式，这种模式一般是只需要一台虚拟机与宿主机可以互通，并且虚拟机可以访问外网。VMnet1是使用host-only模式，即虚拟机只能与主机构成内部通信，无法对外网进行通信。<font color="red">VMnet8使用的是NAT网络模式，这种模式一般是一台宿主机以及多台虚拟机，在构建hadoop分布式集群的时候就是采用这种模式的。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了上面三个的区别，下面就可以亲手实验一番了。首先看下自己创建的虚拟机的网关地址，看下面2张图，选择创建的虚拟机，在编辑中选择<font color="red">虚拟网络编辑器，选择VMnet8,点击NAT设置，可以看到虚拟机的网关地址是192.168.80.2</font><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/d1702534-20f1-4b7c-a261-e485335b1c32.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/51b2659f-8316-46d5-b5d2-2f4f519da6fe.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是找到宿主机的网关地址，看下面两个图，在控制面板的网络连接中找到VMnet8，右键选择属性，在网络中找到IPv4选项再次点击属性，<font color="red">这里出现的问题时我这里不知道为什么手动选择IP地址下面的全成空了，</font>这就是我为什么出现ping不同的原因了，这里配置IP地址为192.168.80.1，子网掩码与虚拟机的子网掩码保持一致即可，保存。<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a5aeda05-11b2-4236-96e1-878a0e475db2.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/bd88b882-dec1-412b-85c5-c141dee5eba1.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后修改虚拟机的网络适配器模式为NAT模式，选择创建好的虚拟机，在网络适配器中选中即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来进入虚拟机，修改配置文件，</p><ol><li>CentOS6.5 vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/91c717c7-f0a5-45fb-ae74-58cbaba603e7.png" alt></li><li>修改ifcfg-ens33配置文件，这里用的是CentOS7，按具体情况来，根据之前查到的虚拟机网关及子网掩码配置如下：<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a375362f-3899-4f21-b131-daf5fecc9009.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存之后，通过 service network restart重启即可，在宿主机与虚拟机分别用ping命令测试发现可以ping通，OK。<h2 id="虚拟机上网问题"><a href="#虚拟机上网问题" class="headerlink" title="虚拟机上网问题"></a>虚拟机上网问题</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以在宿主机使用xshell进行虚拟机连接了，方便操作，还有一个问题是之前虚拟机可以ping通外网的，现在突然连不上了，这样如果在虚拟机中下载一些软件安装包就会出现问题，查找了一下资料，发现:<font color="red">是因为没有设置dns服务器导致的，修改/etc/resolv.conf配置文件即可</font>，向里面加入dns服务器地址，它是DNS客户机配置文件，用于设置DNS服务器的IP地址地址及DNS域名，添加如下两个地址即可ping通外网了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 168.95.1.1</span><br><span class="line">nameserver 168.95.192.1</span><br></pre></td></tr></table></figure>测试一下，ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 发现ping通，OK</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
