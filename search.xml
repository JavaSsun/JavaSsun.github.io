<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ详解</title>
      <link href="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载<a href="http://www.ityouknow.com/springboot/2016/11/30/spring-boot-rabbitMQ.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。消息中间件在互联网公司的使用中越来越多，消息中间件最主要的作用是解耦，中间件最标准的用法是生产者生产消息传送到队列，消费者从队列中拿取消息并处理，生产者不用关心是谁来消费，消费者不用关心谁在生产消息，从而达到解耦的目的。在分布式的系统中，消息队列也会被用在很多其它的方面，比如：分布式事务的支持，RPC 的调用等等。</p><h2 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h2><p>RabbitMQ 是实现 AMQP（高级消息队列协议）的消息中间件的一种，最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbitMQ 主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。</p><p>AMQP，即 Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p><p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><a id="more"></a><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>通常我们谈到队列服务, 会有三个概念： 发消息者、队列、收消息者，RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在发消息者和 队列之间, 加入了交换器 (Exchange). 这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/RabbitMQ01.png" alt></p><ul><li>左侧 P 代表 生产者，也就是往 RabbitMQ 发消息的程序。</li><li>中间即是 RabbitMQ，其中包括了 交换机 和 队列。</li><li>右侧 C 代表 消费者，也就是从 RabbitMQ 拿消息的程序。</li></ul><p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机，交换机，队列，和绑定。</p><ul><li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单， RabbitMQ 当中，<em>用户只能在虚拟主机的粒度进行权限控制。</em> 因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机“/”。</li><li>交换机：<em>Exchange 用于转发消息，但是它不会做存储</em> ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。 这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</li><li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系</li></ul><h3 id="交换机-Exchange"><a href="#交换机-Exchange" class="headerlink" title="交换机(Exchange)"></a>交换机(Exchange)</h3><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。交换机有四种类型：Direct, topic, Headers and Fanout</p><ul><li>Direct：direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 <strong>routing_key</strong>, 消息的<strong>routing_key</strong> 匹配时, 才会被交换器投送到绑定的队列中去.</li><li>Topic：按规则转发消息（最灵活）</li><li>Headers：设置 header attribute 参数类型的交换机</li><li>Fanout：转发消息到所有绑定队列</li></ul><p><strong>Direct Exchange</strong></p><p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。</p><p><img src="/2020/02/25/RabbitMQ%E8%AF%A6%E8%A7%A3/rabbitMq_direct.png" alt></p><p>第一个 X - Q1 就有一个 binding key，名字为 orange； X - Q2 就有 2 个 binding key，名字为 black 和 green。<em>当消息中的 路由键 和 这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</em></p><p>Ps：为什么 X 到 Q2 要有 black，green，2个 binding key呢，一个不就行了吗？ - 这个主要是因为可能又有 Q3，而Q3只接受 black 的信息，而Q2不仅接受black 的信息，还接受 green 的信息。</p><p><strong>Topic Exchange</strong></p><p>Topic Exchange 转发消息主要是根据通配符。_ 在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p><p>在这种交换机模式下：</p><ul><li>路由键必须是一串字符，用句号（<code>.</code>） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。</li><li>路由模式必须包含一个 星号（<code>*</code>），主要用于匹配路由键指定位置的一个单词，比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：第一个单词是 agreements，第四个单词是 b。 井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以agreements.eu.berlin 开头的路由键都是可以的。</li></ul><p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br></pre></td></tr></table></figure><p>topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:</p><ul><li><code>*</code>表示一个词.</li><li><code>#</code>表示零个或多个词.</li></ul><p><strong>Headers Exchange</strong></p><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><p><strong>Fanout Exchange</strong></p><p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，_会把消息发给绑定给它的全部队列_，如果配置了 routing_key 会被忽略。</p><h2 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h2><p>Spring Boot 集成 RabbitMQ 非常简单，如果只是简单的使用配置非常少，Spring Boot 提供了<code>spring-boot-starter-amqp</code> 项目对消息各种支持。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>1、配置 Pom 包，主要是添加 <code>spring-boot-starter-amqp</code> 的支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置文件</p><p>配置 RabbitMQ 的安装地址、端口以及账户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name&#x3D;Spring-boot-rabbitmq</span><br><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;192.168.0.86</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line">spring.rabbitmq.username&#x3D;admin</span><br><span class="line">spring.rabbitmq.password&#x3D;123456</span><br></pre></td></tr></table></figure><p>3、队列配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue Queue() &#123;</span><br><span class="line">        return new Queue(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、发送者</p><p>rabbitTemplate 是 Spring Boot 提供的默认实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@component</span><br><span class="line">public class HelloSender &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    public void send() &#123;</span><br><span class="line">        String context &#x3D; &quot;hello &quot; + new Date();</span><br><span class="line">        System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@RabbitListener(queues &#x3D; &quot;hello&quot;)</span><br><span class="line">public class HelloReceiver &#123;</span><br><span class="line"></span><br><span class="line">    @RabbitHandler</span><br><span class="line">    public void process(String hello) &#123;</span><br><span class="line">        System.out.println(&quot;Receiver  : &quot; + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class RabbitMqHelloTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void hello() throws Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，发送者和接收者的 queue name 必须一致，不然不能接收</p></blockquote><h3 id="多对多使用"><a href="#多对多使用" class="headerlink" title="多对多使用"></a>多对多使用</h3><p>一个发送者，N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p><p><strong>一对多发送</strong></p><p>对上面的代码进行了小改造，接收端注册了两个 Receiver,Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void oneToMany() throws Exception &#123;</span><br><span class="line">    for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 12</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 14</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 13</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 15</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 16</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 18</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 17</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 19</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br></pre></td></tr></table></figure><p>根据返回结果得到以下结论</p><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><p><strong>多对多发送</strong></p><p>复制了一份发送者，加入标记，在一百个循环中相互交替发送</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void manyToMany() throws Exception &#123;</span><br><span class="line">        for (int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">            neoSender.send(i);</span><br><span class="line">            neoSender2.send(i);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Receiver 1: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 20</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 21</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 22</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 23</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 24</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 25</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 25</span><br></pre></td></tr></table></figure><blockquote><p>结论：和一对多一样，接收端仍然会均匀接收到消息</p></blockquote><h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><p><strong>对象的支持</strong></p><p>Spring Boot 以及完美的支持对象的发送和接收，不需要格外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发送者</span><br><span class="line">public void send(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Sender object: &quot; + user.toString());</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;object&quot;, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收者</span><br><span class="line">@RabbitHandler</span><br><span class="line">public void process(User user) &#123;</span><br><span class="line">    System.out.println(&quot;Receiver object : &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sender object: User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br><span class="line">Receiver object : User&#123;name&#x3D;&#39;neo&#39;, pass&#x3D;&#39;123456&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>Topic Exchange</strong></p><p>topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列</p><p>首先对 topic 规则配置，这里使用两个队列来测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class TopicRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    final static String message &#x3D; &quot;topic.message&quot;;</span><br><span class="line">    final static String messages &#x3D; &quot;topic.messages&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessage() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue queueMessages() &#123;</span><br><span class="line">        return new Queue(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    TopicExchange exchange() &#123;</span><br><span class="line">        return new TopicExchange(&quot;exchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessage(Queue queueMessage, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessage).to(exchange).with(&quot;topic.message&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeMessages(Queue queueMessages, TopicExchange exchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(queueMessages).to(exchange).with(&quot;topic.#&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 queueMessages 同时匹配两个队列，queueMessage 只匹配 “topic.message” 队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send1() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am message 1&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.message&quot;, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void send2() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, i am messages 2&quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;exchange&quot;, &quot;topic.messages&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送send1会匹配到topic.#和topic.message 两个Receiver都可以收到消息，发送send2只有topic.#可以匹配所有只有Receiver2监听到消息</p><p><strong>Fanout Exchange</strong></p><p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p><p>Fanout 相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FanoutRabbitConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue AMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue BMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Queue CMessage() &#123;</span><br><span class="line">        return new Queue(&quot;fanout.C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    FanoutExchange fanoutExchange() &#123;</span><br><span class="line">        return new FanoutExchange(&quot;fanoutExchange&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeA(Queue AMessage,FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeB(Queue BMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    Binding bindingExchangeC(Queue CMessage, FanoutExchange fanoutExchange) &#123;</span><br><span class="line">        return BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    String context &#x3D; &quot;hi, fanout msg &quot;;</span><br><span class="line">    System.out.println(&quot;Sender : &quot; + context);</span><br><span class="line">    this.rabbitTemplate.convertAndSend(&quot;fanoutExchange&quot;,&quot;&quot;, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">...</span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver A  : hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg</span><br></pre></td></tr></table></figure><p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zouyesheng.com/rabbitmq.html" target="_blank" rel="noopener">RabbitMQ 使用参考</a></p><p><a href="https://github.com/401Studio/WeekLearn/issues/2" target="_blank" rel="noopener">RabbitMQ：Spring 集成 RabbitMQ 与其概念，消息持久化，ACK机制</a></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot面试</title>
      <link href="/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/02/19/SpringBoot%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着 Spring Boot 使用越来越广泛，Spring Boot 已经成为 Java 程序员面试的知识点，比如下面这一段的 Spring Boot 问答：</p><p>问：你觉得 Spring Boot 最大的优势是什么呢？</p><p>答：Spring Boot 的最大的优势是“约定优于配置“。“约定优于配置“是一种软件设计范式，开发人员按照约定的方式来进行编程，可以减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p><p>问：Spring Boot 中 “约定优于配置“的具体产品体现在哪里。</p><p>答：Spring Boot Starter、Spring Boot Jpa 都是“约定优于配置“的一种体现。都是通过“约定优于配置“的设计思路来设计的，Spring Boot Starter 在启动的过程中会根据约定的信息对资源进行初始化；Spring Boot Jpa 通过约定的方式来自动生成 Sql ，避免大量无效代码编写。具体详细可以参考：Spring Boot 为什么这么火？</p><p>问：Spring Boot Starter 的工作原理是什么？</p><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li><p>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources/META-INF/spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</p></li><li><p>② 根据 spring.factories 配置加载 AutoConfigure 类</p></li><li><p>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</p></li></ul><p>总结一下，其实就是 Spring Boot 在启动的时候，按照约定去读取 Spring Boot Starter 的配置信息，再根据配置信息对资源进行初始化，并注入到 Spring 容器中。这样 Spring Boot 启动完毕后，就已经准备好了一切资源，使用过程中直接注入对应 Bean 资源即可。</p><a id="more"></a><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li><p>@Configuration</p></li><li><p>@ComponentScan</p></li><li><p>@EnableAutoConfiguration</p></li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF/spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢"><a href="#2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢" class="headerlink" title="2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?"></a>2、什么是嵌入式服务器？我们为什么要使用嵌入式服务器呢?</h2><p>思考一下在你的虚拟机上部署应用程序需要些什么。</p><p>第一步：安装 Java</p><p>第二部：安装 Web 或者是应用程序的服务器（Tomat/Wbesphere/Weblogic 等等）</p><p>第三部：部署应用程序 war 包</p><p>如果我们想简化这些步骤，应该如何做呢？</p><p>让我们来思考如何使服务器成为应用程序的一部分？</p><p>你只需要一个安装了 Java 的虚拟机，就可以直接在上面部署应用程序了，</p><p>是不是很爽？</p><p>这个想法是嵌入式服务器的起源。</p><p>当我们创建一个可以部署的应用程序的时候，我们将会把服务器（例如，tomcat）嵌入到可部署的服务器中。</p><p>例如，对于一个 Spring Boot 应用程序来说，你可以生成一个包含 Embedded Tomcat 的应用程序 jar。你就可以像运行正常 Java 应用程序一样来运行 web 应用程序了。</p><p>嵌入式服务器就是我们的可执行单元包含服务器的二进制文件（例如，tomcat.jar）。</p><h2 id="3、微服务同时调用多个接口，怎么支持事务的啊？"><a href="#3、微服务同时调用多个接口，怎么支持事务的啊？" class="headerlink" title="3、微服务同时调用多个接口，怎么支持事务的啊？"></a>3、微服务同时调用多个接口，怎么支持事务的啊？</h2><p>支持分布式事务，可以使用Spring Boot集成 Aatomikos来解决，但是我一般不建议这样使用，因为使用分布式事务会增加请求的响应时间，影响系统的TPS。一般在实际工作中，会利用消息的补偿机制来处理分布式的事务。</p><h2 id="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"><a href="#4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。" class="headerlink" title="4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。"></a>4、shiro和oauth还有cas他们之间的关系是什么？问下您公司权限是如何设计，还有就是这几个概念的区别。</h2><p>cas和oauth是一个解决单点登录的组件，shiro主要是负责权限安全方面的工作，所以功能点不一致。但往往需要单点登陆和权限控制一起来使用，所以就有 cas+shiro或者oauth+shiro这样的组合。</p><p>token一般是客户端登录后服务端生成的令牌，每次访问服务端会进行校验，一般保存到内存即可，也可以放到其他介质；redis可以做Session共享，如果前端web服务器有几台负载，但是需要保持用户登录的状态，这场景使用比较常见。</p><p>我们公司使用oauth+shiro这样的方式来做后台权限的管理，oauth负责多后台统一登录认证，shiro负责给登录用户赋予不同的访问权限。</p><h2 id="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"><a href="#5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？" class="headerlink" title="5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？"></a>5、各服务之间通信，对Restful和Rpc这2种方式如何做选择？</h2><p>在传统的SOA治理中，使用rpc的居多；Spring Cloud默认使用restful进行服务之间的通讯。rpc通讯效率会比restful要高一些，但是对于大多数公司来讲，这点效率影响甚微。我建议使用restful这种方式，易于在不同语言实现的服务之间通讯。</p><h2 id="6、怎么设计无状态服务？"><a href="#6、怎么设计无状态服务？" class="headerlink" title="6、怎么设计无状态服务？"></a>6、怎么设计无状态服务？</h2><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h2 id="7、Spring-Cache-三种常用的缓存注解和意义？"><a href="#7、Spring-Cache-三种常用的缓存注解和意义？" class="headerlink" title="7、Spring Cache 三种常用的缓存注解和意义？"></a>7、Spring Cache 三种常用的缓存注解和意义？</h2><p>@Cacheable ，用来声明方法是可缓存，将结果存储到缓存中以便后续使用相同参数调用时不需执行实际的方法，直接从缓存中取值。</p><p>@CachePut，使用 @CachePut 标注的方法在执行前，不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</p><p>@CacheEvict，是用来标注在需要清除缓存元素的方法或类上的，当标记在一个类上时表示其中所有的方法的执行都会触发缓存的清除操作。</p><h2 id="8、Spring-Boot-如何设置支持跨域请求？"><a href="#8、Spring-Boot-如何设置支持跨域请求？" class="headerlink" title="8、Spring Boot 如何设置支持跨域请求？"></a>8、Spring Boot 如何设置支持跨域请求？</h2><p>现代浏览器出于安全的考虑， HTTP 请求时必须遵守同源策略，否则就是跨域的 HTTP 请求，默认情况下是被禁止的，IP（域名）不同、或者端口不同、协议不同（比如 HTTP、HTTPS）都会造成跨域问题。</p><p>一般前端的解决方案有：</p><ul><li><p>① 使用 JSONP 来支持跨域的请求，JSONP 实现跨域请求的原理简单的说，就是动态创建<code>&lt;script&gt;</code>标签，然后利用<code>&lt;script&gt;</code>的 SRC 不受同源策略约束来跨域获取数据。缺点是需要后端配合输出特定的返回信息。</p></li><li><p>② 利用反应代理的机制来解决跨域的问题，前端请求的时候先将请求发送到同源地址的后端，通过后端请求转发来避免跨域的访问。</p></li></ul><p>后来 HTML5 支持了 CORS 协议。CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin]来告诉客户端跨域的限制，如果浏览器支持 CORS、并且判断 Origin 通过的话，就会允许 XMLHttpRequest 发起跨域请求。</p><p>前端使用了 CORS 协议，就需要后端设置支持非同源的请求，Spring Boot 设置支持非同源的请求有两种方式。</p><p>第一，配置 CorsFilter。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class GlobalCorsConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line">          config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line">          config.setAllowCredentials(true);</span><br><span class="line">          config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line">          config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">          config.addExposedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        return new CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要配置上述的一段代码。第二种方式稍微简单一些。</p><p>第二，在启动类上添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Application extends WebMvcConfigurerAdapter &#123;  </span><br><span class="line"></span><br><span class="line">    @Override  </span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;  </span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)  </span><br><span class="line">                .allowCredentials(true)  </span><br><span class="line">                .allowedHeaders(&quot;*&quot;)  </span><br><span class="line">                .allowedOrigins(&quot;*&quot;)  </span><br><span class="line">                .allowedMethods(&quot;*&quot;);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？"><a href="#9、JPA-和-Hibernate-有哪些区别？JPA-可以支持动态-SQL-吗？" class="headerlink" title="9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？"></a>9、JPA 和 Hibernate 有哪些区别？JPA 可以支持动态 SQL 吗？</h2><p>JPA本身是一种规范，它的本质是一种ORM规范（不是ORM框架，因为JPA并未提供ORM实现，只是制定了规范）因为JPA是一种规范，所以，只是提供了一些相关的接口，但是接口并不能直接使用，JPA底层需要某种JPA实现，Hibernate 是 JPA 的一个实现集。</p><p>JPA 是根据实体类的注解来创建对应的表和字段，如果需要动态创建表或者字段，需要动态构建对应的实体类，再重新调用Jpa刷新整个Entity。动态SQL，mybatis支持的最好，jpa也可以支持，但是没有Mybatis那么灵活。</p><h2 id="10、Spring-、Spring-Boot-和-Spring-Cloud-的关系"><a href="#10、Spring-、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="10、Spring 、Spring Boot 和 Spring Cloud 的关系?"></a>10、Spring 、Spring Boot 和 Spring Cloud 的关系?</h2><p>Spring 最初最核心的两大核心功能 Spring Ioc 和 Spring Aop 成就了 Spring，Spring 在这两大核心的功能上不断的发展，才有了 Spring 事务、Spring Mvc 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring ,是为了让人们更容易的使用 Spring 。</p><p>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>用一组不太合理的包含关系来表达它们之间的关系。</p><p>Spring ioc/aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2014年，Oracle发布了Java8新版本后，愈来愈多的公司开始尝试使用Java8新特性来摆脱繁琐的语法，在使用Java8代码编写公司项目后，尝到了“语法糖”的妙处，由此开始了系统学习Java8的一些新特性。<br>疫情在家，闲来无事，收集整理网上各种Java8学习笔记后，汇成一篇，以便诸君参考，亦是个人Java8学习的小结。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>速度更块</li><li>代码更少（Lambda表达式）</li><li>强大的Stream API</li><li>便于并行</li><li>最大化减少空指针异常 Optional</li></ul><p><font color="red">核心为：Lambda表达式与Stream API</font></p><a id="more"></a><h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h2><h3 id="1-为什么使用Lambda表达式"><a href="#1-为什么使用Lambda表达式" class="headerlink" title="1. 为什么使用Lambda表达式"></a>1. 为什么使用Lambda表达式</h3><p><strong>Lambda</strong>是一个<font color="red">匿名函数</font>，我们可以把Lambda表达式理解为是<font color="red">一段可以传递的代码</font>（将代码像数据一样传递）。可以写出更简洁、更灵活的代码。作为一种紧凑的代码风格，使Java语言的表达更加凝练。</p><ul><li>从匿名类到 Lambda 的转换</li></ul><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;匿名内部类</span><br><span class="line">Runnable r1 &#x3D; new Runnable()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run()&#123;</span><br><span class="line">         System.out.println(&quot;Hello World!&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式</span><br><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello World!&quot;);</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;原来使用匿名内部类作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts &#x3D; new TreeSet&lt;&gt;(new Comparator&lt;String&gt;()&#123;</span><br><span class="line">     @Override</span><br><span class="line">     public int compare(String o1,String o2)&#123;</span><br><span class="line">        return Integer.compare(o1.length,o2.length());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lambda 表达式作为参数传递</span><br><span class="line">TreeSet&lt;String&gt; ts2 &#x3D; new TreeSet&lt;&gt;(</span><br><span class="line">     (o1,o2) -&gt; Integer.compare(o1.length(),o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p> <font color="red"><strong>匿名内部类</strong></font>：冗余的语法。导致了“Height Problem”（只有一行在工作）</p><h3 id="2-Lambda表达式语法"><a href="#2-Lambda表达式语法" class="headerlink" title="2. Lambda表达式语法"></a>2. Lambda表达式语法</h3><p>Lambda 表达式在Java语言中引入了一个新的语法元素和操作符。这个操作符为 “<font color="red"> -&gt; </font>“，该操作符被称为 Lambda操作符 或 箭头操作符。它将Lambda分为两个部分：</p><p><strong>左侧：</strong>指定了 Lambda 表达式需要的所有参数<br><strong>右侧：</strong>指定了 Lambda 体，即 Lambda 表达式要执行的功能。</p><p><strong>语法格式一：无参，无返回值，Lambda只需一条语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 &#x3D; () -&gt; System.out.println(&quot;Hello Lambda&quot;);</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lambda需要一个参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; fun &#x3D; (args) -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式三：Lambda只需要一个参数时，参数的小括号可省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consummer&lt;String&gt; fun &#x3D; args -&gt; System.out.println(args);</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lambda需要两个参数，并且有返回值</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt;&#123;</span><br><span class="line">      System.out.println(&quot;实现函数接口方法&quot;);</span><br><span class="line">      return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：当Lambda体只有一条语句时，return与大括号可以省略</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (x,y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：Long数据类型可以省略，可由编译器推断，即“类型推断”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; bo &#x3D; (Long x,Long y) -&gt; &#123;</span><br><span class="line">         System.out.println(&quot;实现函数接口方法&quot;)；</span><br><span class="line">         x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong>是<font color="red"><strong>匿名内函数</strong></font>：提供了轻量级的语法。解决了匿名内部类带来的“高度”问题。</p><p>语法：<strong>参数列表</strong> <strong>-&gt;</strong> <strong>函数体</strong>三部分组成。<br>函数体：表达式、语句块。<br><font color="red"><strong>表达式</strong></font>：表达式会被执行然后返回执行结果。<br><font color="red"><strong>语句块</strong></font>：语句块中的语句会被依次执行，就像方法中的语句一样</p><ol><li>return语句会把控制权交给匿名函数的调用者</li><li>break和continue只能在循环中使用。</li><li>如果函数体有返回值。那么函数体内部的每一条路径都要有。</li></ol><p>表达式函数体适合小型<strong>Lambda</strong>表达式。消除了return关键字。简洁。</p><p><font color="red">新包</font>：<strong>java.util.function:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收 T对象 返回boolean</span><br><span class="line">Predicate&lt;T&gt; boolean test(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 接收 T对象 不返回任何值</span><br><span class="line">Consumer&lt;T&gt; void accept(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收 T对象 返回R对象</span><br><span class="line">Function(T,R) R apply(T t)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供 T对象（工厂T）</span><br><span class="line">Supplier&lt;T&gt; T get()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 一元：接收T 返回T</span><br><span class="line">UnaryOperator&lt;T&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 二元：接收两个T 返回T</span><br><span class="line">BinaryOperator&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些 Lambda表达式简单例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(int x,int y)-&gt;x+y; &#x2F;&#x2F;接收 x y 返回 x与y的和</span><br><span class="line">()-&gt;45;       &#x2F;&#x2F; 不接受参数 返回45</span><br><span class="line">(String s)-&gt;&#123;System.out.println(s);&#125; &#x2F;&#x2F;接收一个字符串，并把它打印在控制台</span><br></pre></td></tr></table></figure><h3 id="3-类型推断"><a href="#3-类型推断" class="headerlink" title="3. 类型推断"></a>3. 类型推断</h3><p>Lambda表达式无需指定类型，程序依然可以编译，因为 javac 根据程序上下文，在后台推断出了参数类型。Lambda表达式的类型依赖于上下文环境，是由编译器推断出来的。即所谓的“类型推断”。</p><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><h3 id="1-什么是函数式接口"><a href="#1-什么是函数式接口" class="headerlink" title="1. 什么是函数式接口"></a>1. 什么是函数式接口</h3><ul><li><p>只包含了一个抽象方法的接口，称为<strong>函数式接口</strong></p></li><li><p>你可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>我们可以在任意函数式接口上使用 <strong>@FunctionalInterface</strong> 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p></li></ul><h3 id="2-自定义函数式接口"><a href="#2-自定义函数式接口" class="headerlink" title="2. 自定义函数式接口"></a>2. 自定义函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyNumber&#123;</span><br><span class="line">   public double getValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数式接口中使用泛型：</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">   public T getValue(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;作为参数传递 Lambda 表达式</span><br><span class="line">public String toUpperString(MyFunc&lt;String&gt; mf, String str)&#123;</span><br><span class="line">        return mf.getValue(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       String newStr &#x3D; toUpperString(</span><br><span class="line">       (str) -&gt; str.toUpperCase(), &quot;abcdef&quot;);</span><br><span class="line">       System.out.println(newStr);</span><br></pre></td></tr></table></figure><p><font color="red">作为参数传递 Lambda 表达式：为了将 Lambda 表达式作为参数传递，接收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口的类型。<br></font></p><h3 id="3-Java内治四大核心函数式接口"><a href="#3-Java内治四大核心函数式接口" class="headerlink" title="3. Java内治四大核心函数式接口"></a>3. Java内治四大核心函数式接口</h3><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/97801292-5716-4519-9bff-9f8f08aed48b.png" alt></p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/743ea2bc-aeda-44e0-b691-31c354b94f47.png" alt></p><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><p>当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用！<br>（实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致！）<br>方法引用：使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况：</p><ul><li><p><strong>对象::实例方法</strong></p></li><li><p><strong>类::静态方法</strong></p></li><li><p><strong>类::实例方法</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(x);</span><br><span class="line">等同于</span><br><span class="line">System.out::println;</span><br><span class="line"></span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D; (x,y) -&gt; Math.pow(x,y);</span><br><span class="line">等同于</span><br><span class="line">BinaryOperator&lt;Double&gt; bo &#x3D;Math::pow;</span><br><span class="line"></span><br><span class="line">compare((x,y) -&gt;x.equals(y), &quot;abcdef&quot; , &quot;abcdef&quot;);</span><br><span class="line">等同于</span><br><span class="line">compare(String::equals,&quot;abc&quot;,&quot;abc&quot;);</span><br></pre></td></tr></table></figure><p><strong>注意：当需要引用方法的第一个参数是调用对象，并且第二个参数是需要引<br>用方法的第二个参数(或无参数)时：ClassName::methodName</strong></p><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><p><strong>格式： ClassName::new</strong><br>与函数式接口相结合，自动与函数式接口中方法兼容。 可以把构造器引用赋值给定义的方法，与构造器参数 列表要与接口中抽象方法的参数列表一致！</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; (n) -&gt; new MyClass(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; MyClass::new;</span><br></pre></td></tr></table></figure><h3 id="3-数字引用"><a href="#3-数字引用" class="headerlink" title="3. 数字引用"></a>3. 数字引用</h3><p><strong>格式： type[] :: new</strong></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer,Integer[]&gt; fun &#x3D; (n) -&gt; new Integer(n);</span><br><span class="line">等同于</span><br><span class="line">Function&lt;Integer,MyClass&gt; fun &#x3D; Integer[]::new;</span><br></pre></td></tr></table></figure><h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4. Stream API"></a>4. Stream API</h2><h3 id="1-了解Stream"><a href="#1-了解Stream" class="headerlink" title="1. 了解Stream"></a>1. 了解Stream</h3><p>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一 个则是 <strong>Stream API(java.util.stream.*)</strong>。 Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p><p>*<em>流(Stream)是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>*</em><br><font color="red">“集合讲的是数据，流讲的是计算！”</font></p><ol><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ol><h3 id="2-Stream三步骤"><a href="#2-Stream三步骤" class="headerlink" title="2. Stream三步骤"></a>2. Stream三步骤</h3><ul><li><p><strong>创建 Stream</strong><br>一个数据源（如：集合、数组），获取一个流</p></li><li><p><strong>中间操作</strong><br>一个中间操作链，对数据源的数据进行处理 </p></li><li><p><strong>终端操作</strong><br>一个终止操作，执行中间操作链，并产生结果<br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/37346492-7531-44b8-a2bf-681c14b381ec.jpg" alt></p></li></ul><h3 id="3-创建Stream"><a href="#3-创建Stream" class="headerlink" title="3. 创建Stream"></a>3. 创建Stream</h3><h4 id="1-Collection-创建流"><a href="#1-Collection-创建流" class="headerlink" title="1. Collection 创建流"></a>1. Collection 创建流</h4><ul><li><p>default Stream<E> stream() : 返回一个顺序流</E></p></li><li><p>default Stream<E> parallelStream() : 返回一个并行流</E></p></li></ul><h4 id="2-数组-创建流（Arrays的静态方法stream-创建）"><a href="#2-数组-创建流（Arrays的静态方法stream-创建）" class="headerlink" title="2. 数组 创建流（Arrays的静态方法stream()创建）"></a>2. 数组 创建流（Arrays的静态方法stream()创建）</h4><ul><li>static <T> Stream<T> stream(T[] array): 返回一个流</T></T></li></ul><p><strong>重载形式，能够处理对应基本类型的数组</strong></p><ul><li><p>public static IntStream stream(int[] array)</p></li><li><p>public static LongStream stream(long[] array)</p></li><li><p>public static DoubleStream stream(double[] array)</p></li></ul><h4 id="3-由值创建流"><a href="#3-由值创建流" class="headerlink" title="3. 由值创建流"></a>3. 由值创建流</h4><p>可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数。</p><ul><li>public static<T> Stream<T> of(T… values) : 返回一个流</T></T></li></ul><h4 id="4-由函数创建流：创建无限流"><a href="#4-由函数创建流：创建无限流" class="headerlink" title="4. 由函数创建流：创建无限流"></a>4. 由函数创建流：创建无限流</h4><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><ul><li>迭代</li></ul><p>public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)</T></T></T></p><ul><li>生成</li></ul><p>public static<T> Stream<T> generate(Supplier<T> s)</T></T></T></p><h3 id="4-Stream-的中间操作"><a href="#4-Stream-的中间操作" class="headerlink" title="4. Stream 的中间操作"></a>4. Stream 的中间操作</h3><p>多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理！ 而在终止操作时一次性全部处理，称为“惰性求值”。</p><p><strong>筛选与切片</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/853fb496-9885-4191-b20d-1d5c8508def5.png" alt></p><p><strong>映射</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/feb89458-0a81-42a9-9aa4-33b20b5991bf.png" alt></p><p><strong>排序</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/3a69b800-08f9-4bca-ab2d-51e3f3446635.png" alt></p><h3 id="5-Stream-的终止操作"><a href="#5-Stream-的终止操作" class="headerlink" title="5. Stream 的终止操作"></a>5. Stream 的终止操作</h3><p>终端操作会从流的流水线生成结果。其结果可以是任何不是流的 值，例如：List、Integer，甚至是 void 。</p><p><strong>查找与匹配</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1cd0233f-598b-4537-8998-5e5fa24aada0.png" alt><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/bae6b149-cc4f-4f84-aec0-e27bf8afe015.png" alt></p><p><strong>归约</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/037bfd49-78ed-468b-aa65-4ad0242e490b.png" alt></p><p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它 来进行网络搜索而出名。</p><p><strong>收集</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/2cccbffb-7df8-4a65-8153-537071e75bd7.png" alt></p><p>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p><h3 id="6-并行流与串行流"><a href="#6-并行流与串行流" class="headerlink" title="6. 并行流与串行流"></a>6. 并行流与串行流</h3><p><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。</p><p>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</p><h3 id="7-了解-Fork-Join-框架"><a href="#7-了解-Fork-Join-框架" class="headerlink" title="7. 了解 Fork/Join 框架"></a>7. 了解 Fork/Join 框架</h3><p><strong>Fork/Join 框架</strong>:就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/84eaed9b-717b-47f9-9f0a-f5fde05f7472.jpg" alt></p><h3 id="8-Fork-Join-框架与传统线程池的区别"><a href="#8-Fork-Join-框架与传统线程池的区别" class="headerlink" title="8. Fork/Join 框架与传统线程池的区别"></a>8. Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p><p>相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的<br>处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因<br>无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果<br>某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子<br>问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程<br>的等待时间,提高了性能.</p><h2 id="5-新时间日期API"><a href="#5-新时间日期API" class="headerlink" title="5. 新时间日期API"></a>5. 新时间日期API</h2><ul><li>LocalDate、LocalTime、LocalDateTime 类的实 例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日 历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</li></ul><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/1d49dcda-eb3d-4eb7-aa3c-889e5607867f.png" alt></p><p><strong>Instant 时间戳</strong></p><ul><li>用于“时间戳”的运算。它是以Unix元年(传统 的设定为UTC时区1970年1月1日午夜时分)开始 所经历的描述进行运算</li></ul><p><strong>Duration 和 Period</strong></p><ul><li><p>Duration:用于计算两个“时间”间隔</p></li><li><p>Period:用于计算两个“日期”间隔</p></li><li><p>日期的操纵</p></li><li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获 取例如：将日期调整到“下个周日”等操作。</p></li><li><p>TemporalAdjusters : 该类通过静态方法提供了大量的常 用 TemporalAdjuster 的实现。</p></li></ul><p>例如获取下个周日：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextSunday &#x3D; LocalDate.now().with(</span><br><span class="line">   TemporalAdjusters.next(DayOfWeek.SUNDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>解析与格式化</strong></p><p>java.time.format.DateTimeFormatter 类：该类提供了三种 格式化方法：</p><ul><li><p>预定义的标准格式</p></li><li><p>语言环境相关的格式</p></li><li><p>自定义的格式</p></li></ul><p><strong>时区的处理</strong></p><ul><li>Java8 中加入了对时区的支持，带时区的时间为分别为：</li></ul><p>ZonedDate、ZonedTime、ZonedDateTime<br>其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式<br>例如 ：Asia/Shanghai 等</p><p>ZoneId：该类中包含了所有的时区信息</p><p>getAvailableZoneIds() : 可以获取所有时区时区信息<br>of(id) : 用指定的时区信息获取 ZoneId 对象</p><p><strong>与传统日期处理的转换</strong><br><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/0b30f162-415f-4a9c-a650-ba13116ff20b.png" alt></p><h2 id="6-接口中的默认方法与静态方法"><a href="#6-接口中的默认方法与静态方法" class="headerlink" title="6. 接口中的默认方法与静态方法"></a>6. 接口中的默认方法与静态方法</h2><h3 id="1-接口中的默认方法"><a href="#1-接口中的默认方法" class="headerlink" title="1. 接口中的默认方法"></a>1. 接口中的默认方法</h3><p>Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">interface MyFunc&lt;T&gt;&#123;</span><br><span class="line">  T func(int a);</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello Java&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>*<em>接口默认方法的”类优先”原则 *</em></p><p>若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时</p><ul><li><p>选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。</p></li><li><p>接口冲突。如果一个父接口提供一个默认方法，而另一个接 口也提供了一个具有相同名称和参数列表的方法（不管方法 是否是默认方法），那么必须覆盖该方法来解决冲突</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface MyFunc&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello World&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Named&#123;</span><br><span class="line">   default String getName()&#123;</span><br><span class="line">        return &quot;Hello java8&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyClass implements MyFunc,Named&#123;</span><br><span class="line">   public String getName()&#123;</span><br><span class="line">        return Named.super.getName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-接口中的静态方法"><a href="#2-接口中的静态方法" class="headerlink" title="2. 接口中的静态方法"></a>2. 接口中的静态方法</h3><p>Java8 中，接口中允许添加静态方法</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Named&#123;</span><br><span class="line">  public Integer myFun();</span><br><span class="line"></span><br><span class="line">  default String getName()&#123;</span><br><span class="line">     return &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static void show()&#123;</span><br><span class="line">     System.out.println(&quot;Hello Lambda&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-其他新特性"><a href="#7-其他新特性" class="headerlink" title="7. 其他新特性"></a>7. 其他新特性</h2><p><strong>Optional 类</strong></p><p>Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p><p><strong>常用方法：</strong><br>Optional.of(T t) : 创建一个 Optional 实例<br>Optional.empty() : 创建一个空的 Optional 实例<br>Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例<br>isPresent() : 判断是否包含值<br>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t<br>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值<br>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()<br>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</p><p><strong>重复注解与类型注解</strong></p><p>Java 8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotations&#123;</span><br><span class="line">   MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repeatable(MyAnnotations.class)</span><br><span class="line">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE,ElementType.TYPE_PARAMETER&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface MyAnnotation&#123;</span><br><span class="line">   String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@MyAnnotation(&quot;Hello&quot;)</span><br><span class="line">@MyAnnotation(&quot;World&quot;)</span><br><span class="line">public void show(@MyAnnotation(&quot;abc&quot;) String str)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1 交易员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">public class Trader &#123;</span><br><span class="line">     private String name;</span><br><span class="line">     private String city;</span><br><span class="line">     public Trader(String name, String city) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.city &#x3D; city;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; getter setter方法省略</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line">     private Trader trader;</span><br><span class="line">     private int year;</span><br><span class="line">     private int value;</span><br><span class="line">     public Transaction(Trader trader, int year, int value) &#123;</span><br><span class="line">        this.trader &#x3D; trader;</span><br><span class="line">        this.year &#x3D; year;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PuttingIntoPractice &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Trader raoul &#x3D; new Trader(&quot;Raoul&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader mario &#x3D; new Trader(&quot;mario&quot;,&quot;Milan&quot;);</span><br><span class="line">        Trader alen &#x3D; new Trader(&quot;alen&quot;,&quot;Cambridge&quot;);</span><br><span class="line">        Trader brian &#x3D; new Trader(&quot;brian&quot;,&quot;Cambridge&quot;);</span><br><span class="line"></span><br><span class="line">  List&lt;Transaction&gt; transactions &#x3D; Arrays.asList(</span><br><span class="line">          new Transaction(brian,2011,300),</span><br><span class="line">          new Transaction(raoul,2012,1000),</span><br><span class="line">          new Transaction(raoul,2011,400),</span><br><span class="line">          new Transaction(mario,2012,710),</span><br><span class="line">          new Transaction(mario,2012,700),</span><br><span class="line">          new Transaction(alen,2012,950)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (1) 找出2011年发生的所有交易，并按交易额排序（从低到高）。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getYear() &#x3D;&#x3D; 2011)</span><br><span class="line">.sorted(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (2) 交易员都在哪些不同的城市工作过？</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getCity())</span><br><span class="line">                .distinct()</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (3) 查找所有来自于剑桥的交易员，并按姓名排序。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getTrader)</span><br><span class="line">                .filter(trader -&gt; trader.getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted(Comparator.comparing(Trader::getName))</span><br><span class="line">                .collect(Collectors.toList())</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (4) 返回所有交易员的姓名字符串，按字母顺序排序。</span><br><span class="line">  String traderStr &#x3D; transactions.stream()</span><br><span class="line">                .map(transaction -&gt; transaction.getTrader().getName())</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .reduce(&quot;&quot;, (n1, n2) -&gt; n1 + n2);</span><br><span class="line">  System.out.println(traderStr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (5) 有没有交易员是在米兰工作的？</span><br><span class="line">  boolean miLanBased &#x3D; transactions.stream()</span><br><span class="line">                .anyMatch(transaction -&gt; transaction.getTrader()</span><br><span class="line">                        .getCity().equals(&quot;MiLan&quot;));</span><br><span class="line">  System.out.println(miLanBased);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (6) 打印生活在剑桥的交易员的所有交易额。</span><br><span class="line">         transactions.stream()</span><br><span class="line">                .filter(transaction -&gt; transaction.getTrader().getCity().equals(&quot;Cambridge&quot;))</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (7) 所有交易中，最高的交易额是多少？</span><br><span class="line">  int highestValue &#x3D; transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(0,Integer::max);</span><br><span class="line">  System.out.println(highestValue);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">  .sorted(Comparator.comparing(Transaction::getValue).reversed())</span><br><span class="line">                .findFirst()</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (8) 找到交易额最小的交易。</span><br><span class="line">  transactions.stream()</span><br><span class="line">                .map(Transaction::getValue)</span><br><span class="line">                .reduce(Integer::min)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">             .min(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">  transactions.stream()</span><br><span class="line">                .min(Comparator.comparing((Transaction t1)-&gt; t1.getValue()))</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (9) 统计每个交易员的记录</span><br><span class="line">  transactions.stream()</span><br><span class="line">       .collect(Collectors.groupingBy(Transaction::getTrader))</span><br><span class="line">                .entrySet().stream()</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;        (10) 找到单笔交易最高的交易员</span><br><span class="line">  transactions.stream()</span><br><span class="line">             .max(Comparator.comparing(Transaction::getValue))</span><br><span class="line">                .ifPresent(tran -&gt;&#123;</span><br><span class="line">                    System.out.println(tran.getTrader());</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多练习参考网络</p><h2 id="8-java8红黑树"><a href="#8-java8红黑树" class="headerlink" title="8. java8红黑树"></a>8. java8红黑树</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>回顾：HashSet是基于HashCode实现元素不重复的。当插入元素的哈希码相同时，会调用equals方法进行二次比较，如果相同，则新值替旧值。如果不同，则以链表的形式挂在当前元素所在的位置。</p><p>扩容因子：0.75</p><p>如果是1 ，则可能永远是只插入到两个位置，形成部分元素的长链表。每次都要在哈希码相同时进行equals比较（哈希碰撞）。降低性能。</p><p>如果是&lt;0.75,则可能浪费空间。</p><h3 id="数组-链表-红黑树-二叉树的一种"><a href="#数组-链表-红黑树-二叉树的一种" class="headerlink" title="数组-链表-红黑树(二叉树的一种)"></a>数组-链表-红黑树(二叉树的一种)</h3><p><strong>条件：当碰撞袁术个数&gt;8 &amp;&amp; 总容量&gt;64 将其转换为红黑树</strong></p><p><font color="red">碰撞元素个数</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK7是数组-&gt;链表</font>：一个数组元素上所挂载的（链表）元素个数。</p><p><font color="red">JDK8是数组-链表</font>： 当转变为红黑树时，添加的效率变低。其他效率都高了。平衡二叉树（比当前值与节点值的大小）</p><p>扩容是：原来表会计算hashcode值进行元素的再次填充。</p><p>现在只需要找原来表的总长度+当前所在的位置，就是当前扩容后的位置。（不需要再次进行哈希计算）。</p><p><strong>ConcurrentHashMap：效率提高</strong></p><p>JDK7: ConcurrentLevel = 16<br>JDK8：CAS算法</p><p><img src="/2020/02/08/Java8%E6%96%B0%E7%89%B9%E6%80%A7/7d750713-3d72-48e3-b512-d11dc1900f92.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot+Docker简单配置</title>
      <link href="/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/15/SpringBoot-Docker%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="http://www.ityouknow.com/springboot/2018/03/19/spring-boot-docker.html" target="_blank" rel="noopener">纯洁的微笑</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 技术发展为微服务落地提供了更加便利的环境，使用 Docker 部署 Spring Boot其实非常简单。</p><p>首先构建一个简单的 Spring Boot 项目，然后给项目添加 Docker 支持，最后对项目进行部署。</p><a id="more"></a><h2 id="一个简单-Spring-Boot-项目"><a href="#一个简单-Spring-Boot-项目" class="headerlink" title="一个简单 Spring Boot 项目"></a>一个简单 Spring Boot 项目</h2><p>在 <code>pom.xml</code> 中 ，使用 Spring Boot 2.0 相关依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure><p>添加 web 和测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>创建一个 DockerController，在其中有一个<code>index()</code>方法，访问时返回：<code>Hello Docker!</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DockerController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello Docker!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class DockerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DockerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加完毕后启动项目，启动成功后浏览器访问：<code>http://localhost:8080/</code>，页面返回：<code>Hello Docker!</code>，说明 Spring Boot 项目配置正常。</p><h2 id="Spring-Boot-项目添加-Docker-支持"><a href="#Spring-Boot-项目添加-Docker-支持" class="headerlink" title="Spring Boot 项目添加 Docker 支持"></a>Spring Boot 项目添加 Docker 支持</h2><p>在 <code>pom.xml-properties</code>中添加 Docker 镜像名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;docker.image.prefix&gt;springboot&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure><p>plugins 中添加 Docker 构建插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;!-- Docker maven plugin --&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><p>在目录<code>src/main/docker</code>下创建 Dockerfile 文件，Dockerfile 文件用来说明如何来构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 文件很简单，构建 Jdk 基础环境，添加 Spring Boot Jar 到镜像中，简单解释一下:</p><ul><li>FROM ，表示使用 Jdk8 环境 为基础镜像，如果镜像不是本地的会从 DockerHub 进行下载</li><li>VOLUME ，VOLUME 指向了一个<code>/tmp</code>的目录，由于 Spring Boot 使用内置的Tomcat容器，Tomcat 默认使用<code>/tmp</code>作为工作目录。这个命令的效果是：在宿主机的<code>/var/lib/docker</code>目录下创建一个临时文件并把它链接到容器中的<code>/tmp</code>目录</li><li>ADD ，拷贝文件并且重命名</li><li>ENTRYPOINT ，为了缩短 Tomcat 的启动时间，添加<code>java.security.egd</code>的系统属性指向<code>/dev/urandom</code>作为 ENTRYPOINT</li></ul><blockquote><p>这样 Spring Boot 项目添加 Docker 依赖就完成了。</p></blockquote><h2 id="构建打包环境"><a href="#构建打包环境" class="headerlink" title="构建打包环境"></a>构建打包环境</h2><p>需要有一个 Docker 环境来打包 Spring Boot 项目，在 Windows 搭建 Docker 环境很麻烦，这里以 Centos 7 为例。</p><h3 id="安装-Docker-环境"><a href="#安装-Docker-环境" class="headerlink" title="安装 Docker 环境"></a>安装 Docker 环境</h3><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令来启动 docker 服务，并将其设置为开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">chkconfig docker on</span><br><span class="line"></span><br><span class="line">#LCTT 译注：此处采用了旧式的 sysv 语法，如采用CentOS 7中支持的新式 systemd 语法，如下：</span><br><span class="line">systemctl  start docker.service</span><br><span class="line">systemctl  enable docker.service</span><br></pre></td></tr></table></figure><p>使用Docker 中国加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line">#添加后：</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;],</span><br><span class="line">    &quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>输入<code>docker version</code> 返回版本信息则安装正常。</p><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure><p>配置环境变量 打开 <code>vim /etc/profile</code> 添加一下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-1.8.0.161-0.b14.el7_4.x86_64 </span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br></pre></td></tr></table></figure><p>修改完成之后，使其生效</p><p>输入<code>java -version</code> 返回版本信息则安装正常。</p><h3 id="安装MAVEN"><a href="#安装MAVEN" class="headerlink" title="安装MAVEN"></a>安装MAVEN</h3><p>下载：<code>http://mirrors.shu.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 解压</span><br><span class="line">tar vxf apache-maven-3.5.2-bin.tar.gz</span><br><span class="line">## 移动</span><br><span class="line">mv apache-maven-3.5.2 &#x2F;usr&#x2F;local&#x2F;maven3</span><br></pre></td></tr></table></figure><p>修改环境变量， 在<code>/etc/profile</code>中添加以下几行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;maven3</span><br><span class="line">export MAVEN_HOME</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure><p>记得执行<code>source /etc/profile</code>使环境变量生效。</p><p>输入<code>mvn -version</code> 返回版本信息则安装正常。</p><blockquote><p>这样整个构建环境就配置完成了。</p></blockquote><h2 id="使用-Docker-部署-Spring-Boot-项目"><a href="#使用-Docker-部署-Spring-Boot-项目" class="headerlink" title="使用 Docker 部署 Spring Boot 项目"></a>使用 Docker 部署 Spring Boot 项目</h2><p>将项目 <code>spring-boot-docker</code> 拷贝服务器中，进入项目路径下进行打包测试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#打包</span><br><span class="line">mvn package</span><br><span class="line">#启动</span><br><span class="line">java -jar target&#x2F;spring-boot-docker-1.0.jar</span><br></pre></td></tr></table></figure><p>看到 Spring Boot 的启动日志后表明环境配置没有问题，接下来我们使用 DockerFile 构建镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package docker:build</span><br></pre></td></tr></table></figure><p>第一次构建可能有点慢，当看到以下内容的时候表明构建成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Step 1 : FROM openjdk:8-jdk-alpine</span><br><span class="line"> ---&gt; 224765a6bdbe</span><br><span class="line">Step 2 : VOLUME &#x2F;tmp</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; b4e86cc8654e</span><br><span class="line">Step 3 : ADD spring-boot-docker-1.0.jar app.jar</span><br><span class="line"> ---&gt; a20fe75963ab</span><br><span class="line">Removing intermediate container 593ee5e1ea51</span><br><span class="line">Step 4 : ENTRYPOINT java -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar</span><br><span class="line"> ---&gt; Running in 85d558a10cd4</span><br><span class="line"> ---&gt; 7102f08b5e95</span><br><span class="line">Removing intermediate container 85d558a10cd4</span><br><span class="line">Successfully built 7102f08b5e95</span><br><span class="line">[INFO] Built springboot&#x2F;spring-boot-docker</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 54.346 s</span><br><span class="line">[INFO] Finished at: 2018-03-13T16:20:15+08:00</span><br><span class="line">[INFO] Final Memory: 42M&#x2F;182M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>使用<code>docker images</code>命令查看构建好的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">springboot&#x2F;spring-boot-docker   latest              99ce9468da74        6 seconds ago       117.5 MB</span><br></pre></td></tr></table></figure><p><code>springboot/spring-boot-docker</code> 就是我们构建好的镜像，下一步就是运行该镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 -t springboot&#x2F;spring-boot-docker</span><br></pre></td></tr></table></figure><p>启动完成之后我们使用<code>docker ps</code>查看正在运行的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">049570da86a9        springboot&#x2F;spring-boot-docker   &quot;java -Djava.security&quot;   30 seconds ago      Up 27 seconds       0.0.0.0:8080-&gt;8080&#x2F;tcp   determined_mahavira</span><br></pre></td></tr></table></figure><p>可以看到我们构建的容器正在在运行，访问浏览器：<code>http://192.168.0.x:8080/</code>,返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Docker!</span><br></pre></td></tr></table></figure><p>说明使用 Docker 部署 Spring Boot 项目成功！</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-Nginx变量原理-应用</title>
      <link href="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/"/>
      <url>/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx中变量是一个非常强大的工具，可以在nginx.conf配置文件中，通过变量去修改各个模块处理请求的方式。因此，<strong>变量是一个解耦工具</strong>。它同样可以在 openresty 中 lua 语言中大有用处。</p><a id="more"></a><h2 id="变量原理"><a href="#变量原理" class="headerlink" title="变量原理"></a>变量原理</h2><h3 id="变量的提供模块与使用模块"><a href="#变量的提供模块与使用模块" class="headerlink" title="变量的提供模块与使用模块"></a>变量的提供模块与使用模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d4564092-81ea-4d1e-a6e6-55b113cd6724.jpg" alt></p><p><strong>流程：</strong></p><p><font color="red">提供变量名的模块</font></p><p>Nginx启动后，发现当前是一个HTTP模块。它其中有一个 <strong>preconfiguration回调方法</strong>，如 realip模块的 realip变量等等。它定义的是一对值，即<strong>变量名</strong>和<strong>解析出当前变量名的方法</strong>。如给出输入（如http请求头部中的名称），输出就是对应的值。此处<strong>定义规则</strong>。</p><p><font color="red">使用变量名的模块</font></p><p>通过变量名完成解耦。</p><p><strong>两个模块各自专注于自己的职责</strong></p><h3 id="变量的特性"><a href="#变量的特性" class="headerlink" title="变量的特性"></a>变量的特性</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/16c0d0ee-eea1-4e84-b72f-0d99716a1a82.jpg" alt></p><h3 id="存放变量的哈希表"><a href="#存放变量的哈希表" class="headerlink" title="存放变量的哈希表"></a>存放变量的哈希表</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a51c5b96-8f90-4db7-8a3c-5be8fc35c05b.jpg" alt></p><h2 id="HTTP框架提供的请求有关变量"><a href="#HTTP框架提供的请求有关变量" class="headerlink" title="HTTP框架提供的请求有关变量"></a>HTTP框架提供的请求有关变量</h2><p>除许多HTTP模块会提供变量外，Nginx的HTTP框架也提供了大量的变量，这些变量不需要编译、引入新的HTTP模块，而且框架提供的变量往往反映了用户发来的请求时被Nginx处理的流程与细节。因此，熟悉Nginx框架提供的每一个变量的用法是非常有必要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf配置文件中</span><br><span class="line"></span><br><span class="line">vim var.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/780053e8-ebbd-4515-a257-109fdd50ba0f.jpg" alt><br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8dd34c5-839c-4201-a384-06a439b4a88f.jpg" alt></p><p>为了演示有些变量在不同的阶段时不同的，添加了日志文件。return中，将相关联的变量以一行显示，以逗号分隔。冒号前是变量名，冒号后是变量值。</p><p>做一次访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B7.PNG" alt></p><h3 id="HTTP框架提供的变量"><a href="#HTTP框架提供的变量" class="headerlink" title="HTTP框架提供的变量"></a>HTTP框架提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/535214ab-1e4a-40d3-a006-333711c9259c.jpg" alt></p><h3 id="HTTP请求有关变量"><a href="#HTTP请求有关变量" class="headerlink" title="HTTP请求有关变量"></a>HTTP请求有关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7b486912-8cd7-47a3-89c7-48843fd52723.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c9fdf904-3f7d-416a-b4be-e49b2f4a33c4.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e2070844-a852-4cf3-978b-4b27ba67365b.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a8abd28c-0ef9-4070-98f4-914b88414852.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a43e65e2-6f41-47f0-8f3e-a62e9dc13303.jpg" alt></p><h2 id="HTTP框架提供的其他变量"><a href="#HTTP框架提供的其他变量" class="headerlink" title="HTTP框架提供的其他变量"></a>HTTP框架提供的其他变量</h2><h3 id="TCP连接有关的变量"><a href="#TCP连接有关的变量" class="headerlink" title="TCP连接有关的变量"></a>TCP连接有关的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d920d0da-2705-45e4-92d3-7591b589a20f.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/962047ba-83c2-416d-87a1-8a5b26102403.jpg" alt></p><h3 id="Nginx处理请求过程中产生的变量"><a href="#Nginx处理请求过程中产生的变量" class="headerlink" title="Nginx处理请求过程中产生的变量"></a>Nginx处理请求过程中产生的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e25f6442-1682-4d3e-acf1-8fe712fc7601.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/b7821b26-bd21-4930-b315-96c7b4f4a582.jpg" alt></p><h3 id="发送HTTP响应时相关变量"><a href="#发送HTTP响应时相关变量" class="headerlink" title="发送HTTP响应时相关变量"></a>发送HTTP响应时相关变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589440450988.PNG" alt></p><h3 id="Nginx系统变量"><a href="#Nginx系统变量" class="headerlink" title="Nginx系统变量"></a>Nginx系统变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/14088861-0f90-4cba-ba31-ee728fc9ea81.jpg" alt></p><h2 id="变量防盗链"><a href="#变量防盗链" class="headerlink" title="变量防盗链"></a>变量防盗链</h2><h3 id="简单有效的防盗链手段：referer模块"><a href="#简单有效的防盗链手段：referer模块" class="headerlink" title="简单有效的防盗链手段：referer模块"></a>简单有效的防盗链手段：referer模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52fc1d8f-49eb-4f0a-9260-cde0e218ccd5.jpg" alt></p><h3 id="referer模块的指令"><a href="#referer模块的指令" class="headerlink" title="referer模块的指令"></a>referer模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a01e89ed-9426-420a-98b8-c9255c31d197.jpg" alt></p><h3 id="valid-referers-指令"><a href="#valid-referers-指令" class="headerlink" title="valid_referers 指令"></a>valid_referers 指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e54ac723-8063-4e30-92fc-ae1e90441ddd.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6deb74a6-c5ac-4d39-b36c-32af38a57191.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim referer.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/746f4c69-3700-40f1-b5c1-b2ed3c4b9c5c.jpg" alt></p><p>将带测验8个请求放入 testurl中</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8449207d-4d7c-4da3-b7a8-e161e01c19b2.jpg" alt></p><p><strong>第一个：403 没有匹配上</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d12d9d27-044e-4f2a-9bd1-ca85d432b590.jpg" alt></p><p><strong>第二个：valid,匹配上了 *.taohui.pub</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5d42d29d-4018-41ac-84e6-1005638b2f3e.jpg" alt></p><p><strong>第三个：valid，以内没有referer，匹配上了blocked</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/af7b6ab0-34a0-4a1d-a4f5-df816de7855f.jpg" alt></p><p><strong>第四个：valid，匹配上了 none</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/c1f5564a-ef69-45d9-af0e-7a0c27306f77.jpg" alt></p><p><strong>第五个：403 没有匹配上<a href="http://www.taohui.tech" target="_blank" rel="noopener">www.taohui.tech</a></strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a7a7df59-3678-49ca-a876-6c2f54f8d166.jpg" alt></p><p><strong>第六个：valid，匹配上了 server_name</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7f671a43-86f3-47e5-99b2-8ec29753c44b.jpg" alt></p><p><strong>第七个：403 没有配置与baidu有关的</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/f3f2d117-77c7-4e6e-b9dd-7664cdcd4f80.jpg" alt></p><p><strong>第八个：匹配上了正则表达式</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a15fd9ff-cf2e-4ce8-ac7f-94b6d6db4886.jpg" alt></p><h2 id="为复杂业务生成新的变量：map模块"><a href="#为复杂业务生成新的变量：map模块" class="headerlink" title="为复杂业务生成新的变量：map模块"></a>为复杂业务生成新的变量：map模块</h2><p>很多时候，直接使用某些变量的值做逻辑判断是比较困难的，而Map模块提供了可根据1个或多个变量组合成的值结果做判断，进而生成新的变量。再判断新的变量值做逻辑判断。</p><h3 id="通过映射新变量提供更多的可能性：map模块"><a href="#通过映射新变量提供更多的可能性：map模块" class="headerlink" title="通过映射新变量提供更多的可能性：map模块"></a>通过映射新变量提供更多的可能性：map模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/85a00cd6-ef9c-4b74-9843-d3add7d242c5.jpg" alt></p><h3 id="map模块的指令"><a href="#map模块的指令" class="headerlink" title="map模块的指令"></a>map模块的指令</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/dd78cd48-64fa-4fad-ac21-41d2f7184f58.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/65abe6b5-434d-4b47-bc9f-ac482844cf51.jpg" alt></p><p><strong>问题：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/028fd1ec-f458-4ec8-a901-cc4ce08d150a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589442692006.PNG" alt></p><p>将待检测url放入 testurl，方便拷贝访问</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/50eed808-e466-43c3-af8f-b744b4f33625.jpg" alt></p><p>访问 map.taohui.org.cn ，匹配上了 泛域名正则、前缀、后缀。而前缀最优先，所以返回 2:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6e049513-0650-42b2-a1e7-ccca35715a47.jpg" alt></p><p>访问 map.tao123.org.cn，只有正则表达式匹配上 1:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/8f07ad7f-d832-45bd-b698-5fa0567236e4.jpg" alt></p><p>访问 map.taohui.tech， 完全匹配 与  后缀匹配 都行，但是完全匹配优先级最高，所以 3:0</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/bf57c2ab-44d3-4e0c-a1c6-af7883535d12.jpg" alt></p><h2 id="通过变量指定少量用户实现AB测试：split-clients模块"><a href="#通过变量指定少量用户实现AB测试：split-clients模块" class="headerlink" title="通过变量指定少量用户实现AB测试：split_clients模块"></a>通过变量指定少量用户实现AB测试：split_clients模块</h2><p>该模块可以根据变量的值按照百分比方式生成新的变量。</p><h3 id="AB测试：split-clients模块"><a href="#AB测试：split-clients模块" class="headerlink" title="AB测试：split_clients模块"></a>AB测试：split_clients模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443194182.PNG" alt></p><h3 id="split-clients-模块指令"><a href="#split-clients-模块指令" class="headerlink" title="split_clients 模块指令"></a>split_clients 模块指令</h3><p><strong>AB测试：产品推出的功能不太确定用户是否接受，所以推出多个类似功能，让某一个百分比用户去尝试某一类功能，看大家的反馈来决定最终使用哪一个功能的版本。关键：确保按照某一定的百分比决定用户的行为。</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/3b3fc65c-30fd-47b3-82cd-83d467f82da1.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/5f8c251c-a7e5-4e44-a908-c1bfe51b26b9.jpg" alt></p><p>上述问题是已经超过100%了。此时重启会发现，重启失败。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/485b6f96-2886-43a2-a5bf-4f413c9856d4.jpg" alt></p><p>将 40% 注释掉。再次访问，server-location中额 $variant 取自 split_clients 中的配置项。而他又取决于$(http_testcli)经算法改造后的值，看这个值落在那个区域，就返回后面对应的值。</p><p><strong>testcli: xxx</strong>，xxx值随便填写，<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589443935577.PNG" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589444022423.PNG" alt></p><h2 id="根据IP地址范围的匹配生成新变量：geo模块"><a href="#根据IP地址范围的匹配生成新变量：geo模块" class="headerlink" title="根据IP地址范围的匹配生成新变量：geo模块"></a>根据IP地址范围的匹配生成新变量：geo模块</h2><p>可根据子网掩码来生成新变量。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/208fe8ff-79ac-4ae0-9568-9b650664ea54.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/a751238f-27ba-4fae-b8ae-a7b5c5e6980e.jpg" alt></p><p><strong>geo模块示例</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9b9883bc-c88a-48d8-9017-54b3afbb84bd.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/9a632337-6e6d-48c1-b019-c3f9b08daf6a.jpg" alt></p><p>访问<br><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589449028238.PNG" alt></p><h2 id="使用变量获得用户的地理位置：geoip模块"><a href="#使用变量获得用户的地理位置：geoip模块" class="headerlink" title="使用变量获得用户的地理位置：geoip模块"></a>使用变量获得用户的地理位置：geoip模块</h2><p>可以根据IP地址库自动的计算出IP地址找到相应的地理位置。</p><h3 id="基于MaxMind数据库从客户端地址获取变量：geoip模块"><a href="#基于MaxMind数据库从客户端地址获取变量：geoip模块" class="headerlink" title="基于MaxMind数据库从客户端地址获取变量：geoip模块"></a>基于MaxMind数据库从客户端地址获取变量：geoip模块</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589450542232.PNG" alt></p><h3 id="geoip-country指令提供的变量"><a href="#geoip-country指令提供的变量" class="headerlink" title="geoip_country指令提供的变量"></a>geoip_country指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/557efae0-fbc2-4a0f-be6f-cf302b8ba368.jpg" alt></p><h3 id="geoip-city指令提供的变量"><a href="#geoip-city指令提供的变量" class="headerlink" title="geoip_city指令提供的变量"></a>geoip_city指令提供的变量</h3><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/52203507-2fba-4aa3-9a1c-f52fbf4903ff.jpg" alt></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/212dbcb2-ddaa-4b31-b1a6-3e78e9f4f2ad.jpg" alt></p><p><a href="https://dev.maxmind.com/geoip/legacy/downloadable/" target="_blank" rel="noopener">MaxMind</a>网址，因为Nginx使用C语言，所以选中C语言的GitHub，进行下载。</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/7930ddd0-47f0-4e0e-b982-c81bca70c522.png" alt></p><p><a href="https://github.com/maxmind/geoip-api-c" target="_blank" rel="noopener">Github下载zip文件</a></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/6793d729-e928-47a5-b427-3920b0c71f28.png" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/d07ee523-b404-4c4b-ab54-24c96cbb361f.jpg" alt></p><p>编译进nginx后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf中</span><br><span class="line"></span><br><span class="line">vim map.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/e6863285-196c-4e7d-af76-e8df4f44fb06.jpg" alt></p><p>在 <a href="http://www.goubanjia.com/" target="_blank" rel="noopener">http://www.goubanjia.com/</a>选择一些IP来做测试。</p><p>广东IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453163330.PNG" alt></p><p>纽约IP</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/_u6355_u83B71589453218372.PNG" alt></p><h2 id="对客户端使用keepalive提升连接效率"><a href="#对客户端使用keepalive提升连接效率" class="headerlink" title="对客户端使用keepalive提升连接效率"></a>对客户端使用keepalive提升连接效率</h2><p>此处是 HTTP协议中的Keepalive，不是TCP协议中的Keepalive</p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/86c74fbd-439f-434f-b50c-8e9f25123974.jpg" alt></p><p><strong>语法：</strong></p><p><img src="/2019/12/13/25-Nginx%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8/2205cb77-407c-4672-8c3d-682654a9a5a4.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-详解HTTP过滤模块</title>
      <link href="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上文介绍了HTTP模块的11个阶段，在<strong>content</strong>阶段会生成返回给用户的响应内容，这部分响应内容还需要再做加工处理的，这就需要用到<strong>HTTP过滤模块</strong>，因此，它是处于 <strong>Log</strong>阶段之前，<strong>content</strong>阶段之后去介入请求的处理。</p><a id="more"></a><h2 id="HTTP过滤模块的调用流程"><a href="#HTTP过滤模块的调用流程" class="headerlink" title="HTTP过滤模块的调用流程"></a>HTTP过滤模块的调用流程</h2><h3 id="HTTP过滤模块位置"><a href="#HTTP过滤模块位置" class="headerlink" title="HTTP过滤模块位置"></a>HTTP过滤模块位置</h3><p>image_filter resize 长 宽；（此处图片略有问题）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B7.PNG" alt></p><p><strong>content阶段的 static模块生成响应内容后，到达 header过滤模块的 image_filter，再到 gzip压缩，二者不可翻转。</strong></p><h3 id="返回响应-加工响应内容"><a href="#返回响应-加工响应内容" class="headerlink" title="返回响应-加工响应内容"></a>返回响应-加工响应内容</h3><p>查看 Nginx_module.c数组中内容，也是如下图一样，由下往上看，先被下面的过滤模块处理，在推送到上方的过滤模块。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/_u6355_u83B71589376248179.PNG" alt></p><h2 id="用过滤模块更改响应中的字符串-sub模块"><a href="#用过滤模块更改响应中的字符串-sub模块" class="headerlink" title="用过滤模块更改响应中的字符串-sub模块"></a>用过滤模块更改响应中的字符串-sub模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/b3d6ce9b-3543-4171-8024-f6a6365fe8e0.jpg" alt></p><h3 id="sub模块指令"><a href="#sub模块指令" class="headerlink" title="sub模块指令"></a>sub模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/f13609e6-c454-4416-a81f-fd26a6238b3b.jpg" alt></p><ul><li><p><strong>sub_filter string replacement，将响应中的string换成replacement</strong></p></li><li><p><strong>sub_filter_last_modified：off,是否同时返回上次未修改过的旧内容（默认是不返回旧内容）</strong></p></li><li><p><strong>sub_filter_once：on  只修改 1次，如果改为off，则是扫描整个body内容，全文修改</strong></p></li><li><p><strong>sub_filter_types mimie-type，只针对 mimie-type类型的响应进行替换，默认是 text/html</strong></p></li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim sub.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/be46d0e3-7da9-4c95-be47-dd161c2736a9.jpg" alt></p><p>首先，将配置全部注释，访问域名：端口，得到的是一个index.html欢迎页面。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/312e41fc-b9f1-4657-b13f-2874fbeee811.jpg" alt></p><p>看到 nginx.org 这个超链接中，显示的是<strong>nginx.org</strong>文字，将其替换掉。<strong>替换时忽略大小写</strong>。</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/36a19f55-6752-4a68-8bd3-0440f6e09b1d.jpg" alt></p><p>再次访问，发现文字没有变，但是超链接已经变了。（因为开启了只替换一次的功能，所以只替换了超链接，没有替换文字）</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/7770d995-813c-4a6c-a224-6c00a5517ff7.jpg" alt></p><p>同时响应头中没有返回<strong>last-modified</strong>有关的内容</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/76b8d1d8-ef27-4e57-b0a3-f1d3c16a70e0.jpg" alt></p><p>再次修改配置项，将 once 改为 off , last_modified 改为 on</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e45f5291-7c8c-4116-9ae0-1a107a67333a.jpg" alt></p><p>访问时会发现被替换掉，且有last-modified</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/e5feba71-f287-4ba6-bf46-5dba4f3927c0.jpg" alt></p><h2 id="用过滤模块在http响应前后添加内容-addition模块"><a href="#用过滤模块在http响应前后添加内容-addition模块" class="headerlink" title="用过滤模块在http响应前后添加内容-addition模块"></a>用过滤模块在http响应前后添加内容-addition模块</h2><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/6f8bae7e-41c0-474a-93d1-a1804c570499.jpg" alt></p><h3 id="addition模块指令"><a href="#addition模块指令" class="headerlink" title="addition模块指令"></a>addition模块指令</h3><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/20fa76fe-2f13-4024-a514-4061c47c44b2.jpg" alt></p><p>add_before|after_body uri：添加的URI是<strong>子请求</strong>，让Nginx去访问这个URI，将响应内容添加到body前后。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，include到 nginx.conf中</span><br><span class="line">vim addition.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/2cced630-36cc-417e-a563-40c1d92ebb95.jpg" alt></p><p>先访问一个存在的文件 a.txt</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/85d9e2c2-7f2d-4919-baf2-59a045663850.jpg" alt></p><p>修改 addition.conf ，将3个注释解开，再次访问</p><p><img src="/2019/12/12/24-%E8%AF%A6%E8%A7%A3HTTP%E8%BF%87%E6%BB%A4%E6%A8%A1%E5%9D%97/41aacb64-baf1-4429-a122-0cae9ba421c1.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-详解HTTP请求的11个阶段</title>
      <link href="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
      <url>/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>除<strong>HTTP过滤模块</strong> 和 <strong>只提供变量的Nginx模块</strong>之外，所有的HTTP模块必须从Nginx定义好的<strong>11</strong>个阶段进行请求处理。每一个HTTP模块何时生效，有没有机会生效，都要看一个请求究竟处理到哪一个阶段。Nginx是如何定义这11个处理阶段的呢？</p><h2 id="HTTP请求处理时的11个阶段"><a href="#HTTP请求处理时的11个阶段" class="headerlink" title="HTTP请求处理时的11个阶段"></a>HTTP请求处理时的11个阶段</h2><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B7.PNG" alt></p><a id="more"></a><ul><li><p><strong>post_read</strong>：read到Header内容，刚读完HTTP头部，没有做任何加工之前的原始数据。涉及到 <font color="red"><strong>realip模块</strong></font>。</p></li><li><p><strong>server_rewrite、rewrite</strong>：涉及到<strong>rewrite模块</strong>.</p></li><li><p><strong>find_config</strong>：Nginx框架会做，其实是在做location的匹配。</p></li><li><p><strong>post_rewrite</strong>：即 rewrite之后，需要做的一些工作</p></li></ul><p><strong>Access有关的三个模块</strong>：确认访问权限的。（能不能访问）</p><ul><li><p><strong>preaccess</strong>：在access之前做一些处理。</p></li><li><p><strong>access</strong>：auth_basic（用户名密码），access（访问IP），auth_request(第三方授权等)</p></li><li><p><strong>post_access</strong>：在access之后做一些处理。</p></li></ul><p><strong>content有关的</strong></p><ul><li><p><strong>precontent</strong>：在处理content之前做一些处理。</p></li><li><p><strong>content</strong>：诸如一些方向代理等都是在这个阶段生效的。</p></li><li><p><strong>log</strong>：打印access日志的</p></li></ul><p><strong>所有的请求都是由上到下一个阶段一个阶段按序执行。</strong>在debug时可以清楚地看到。</p><h2 id="11个阶段的顺序处理"><a href="#11个阶段的顺序处理" class="headerlink" title="11个阶段的顺序处理"></a>11个阶段的顺序处理</h2><p>当一个HTTP请求进入到Nginx这11个阶段时，由于每一个阶段都可能有0-n个HTTP模块，如果某一个模块不再把HTTP请求向下传递，那么后面的模块是不会执行的。同一阶段中的多个模块，也不是每个模块都有机会执行到的，可能会有前面的模块把请求直接传递给下一个阶段的模块去处理。下面看一看HTTP模块顺序以及他们的处理流程。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2009d91-a832-44c0-bb11-cdb5ac1dd40c.jpg" alt></p><p><strong>每一个蓝色的模块都属于某一个阶段，这些模块是有序的</strong>。</p><p><strong>char *ngx_module_name[]</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe4091aa-9ac8-4596-895b-ed7041e5b2f5.jpg" alt></p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>顺序如何确定呢？可以去看 ngx_modules.c，即configure执行时，会用 with添加模块，这些都会出现在 ngx_module_name[]数组中，这些模块出现的顺序非常关键。</p><p>如 <strong>limit_req</strong> 与 <strong>limit_conn</strong>，二者同属于<strong>preaccess阶段</strong>，在数组中则是 limit_conn 先出现，limit_req后出现，但是对应于请求的处理时它们是相反的。<strong>一个HTTP请求，会先被 limit_req处理，再被limit_conn处理</strong>，假设这两个同时生效去阻止一个请求时，假设这两个返回值也不同，limit_req返回值是没有机会得到执行的，他已经先于limit_conn将请求结果返回给用户。</p><p><strong>灰色的是Nginx框架执行的，其他的第三方HTTP模块没有机会在此运行。</strong></p><h3 id="非顺序处理"><a href="#非顺序处理" class="headerlink" title="非顺序处理"></a>非顺序处理</h3><p>有些则是不会顺序执行的。如 access阶段，当某一个access模块满足，可以直接跳到 try_files模块。当content阶段index模块执行时有时会直接跳到log模块执行。</p><h2 id="postread阶段：获取真实客户端地址的realip模块"><a href="#postread阶段：获取真实客户端地址的realip模块" class="headerlink" title="postread阶段：获取真实客户端地址的realip模块"></a>postread阶段：获取真实客户端地址的realip模块</h2><p>它可以发现用户的真实IP地址，为后续模块的限速、限流等等功能提供了前提。</p><h3 id="如何拿到真实的用户IP地址？"><a href="#如何拿到真实的用户IP地址？" class="headerlink" title="如何拿到真实的用户IP地址？"></a>如何拿到真实的用户IP地址？</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/17157206-ab2d-457a-8e29-331609170ff3.jpg" alt></p><p>TCP连接有一个四元组，根据一条连接的Source_IP就能够判断出用户的IP地址了，但是网络中存在许多反向代理，这又导致反向代理后与上游服务器又建立了一个新的TCP连接。因此上游服务器想通过TCP中的Source_IP获取用户原始IP地址，是不可能的。</p><p><strong>举例：</strong></p><p>在家里上网时，家里的路由器可能分配了一个<strong>内网IP 192.168.0.x</strong>，当通过运营商（电信可能给分配了一个<strong>公网的IP：115.204.33.1</strong>）去访问某一个网站时，先命中到它的<strong>CDN</strong>，这个网站使用CDN加速（如图片等），这个CDN如果还没有把我所访问的资源缓存时，它可能要去<strong>回源</strong>，又建立了一条新的连接，回源过程中可能进入到一个<strong>反向代理</strong>中（如服务器买在阿里云，可能会用<strong>阿里云的SLB</strong>），这个SLB又会去建立一个新的连接，到我购买的服务器的<strong>Nginx</strong>，因此，Nginx如果仅通过拿地址的话，只能拿到<strong>反向代理的IP地址（2.2.2.2）</strong>，反向代理之前的<strong>CDN的地址是1.1.1.1</strong>，其实我们要拿到的是用户的<strong>公网地址115.204.33.1.</strong>， 如果要做限速、并发连接控制，肯定是基于这个公网IP进行的。</p><p><strong>现在拿到的remote_addr是2.2.2.2，想要的是115.204.33.1，如何做到呢？</strong></p><p>通过 <strong>2</strong>、<strong>3</strong>即可做到。</p><ul><li><p><strong>HTTP头部中有 X-Forwarded-For用来传递IP，如CDN的IP地址是1.1.1.1，他又建立了一个新的到反向代理的连接，这个方向代理服务器收到的Header中，可能会存在 X-Forwarded-for 与 X-Real-IP，这个是CDN添加的。</strong></p></li><li><p><strong>X-Forwarded-For 与 X-Real-IP不同，X-Real-IP永远都是一个用户真实IP地址，而X-Forwarded-For则是累加的。如上图中反向代理到Nginx的连接中，加上了CDN的IP地址</strong></p></li></ul><h3 id="拿到用户真实IP地址如何使用？"><a href="#拿到用户真实IP地址如何使用？" class="headerlink" title="拿到用户真实IP地址如何使用？"></a>拿到用户真实IP地址如何使用？</h3><p>基于变量来解耦使用。根据我们在realip模块中配置的指令，<strong>realip模块</strong>会把从 <strong>X-Forwarded-For、X-Real-IP</strong>中获取到的用户真实IP地址去覆盖 binary_remote_addr、remote_addr这两个变量的值。而这两个变量原来指向的是直接与Nginx连接的客户端地址。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1be2a418-5fc1-4400-9f52-4351644d8728.jpg" alt></p><h3 id="realip模块"><a href="#realip模块" class="headerlink" title="realip模块"></a>realip模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/45c34dc4-a550-45ac-90bb-451c4f10798e.jpg" alt></p><h3 id="realip模块的指令"><a href="#realip模块的指令" class="headerlink" title="realip模块的指令"></a>realip模块的指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/41eb8af6-6c20-4df5-a634-a0034257f583.jpg" alt></p><p>real_ip_recursive：环回地址，默认是关闭的，当它打开时，他会将X-Forwarded-For中，最后的那个地址如果是和客户端地址相同，就会赔pass掉，去取上一个地址。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要自己添加realip.con配置，并且include到nginx.conf中</span><br><span class="line">vim realip.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589215977643.PNG" alt></p><p>此处的server_name 用的是 realip_.taohui.tech;<br>因为当前所在的机器是 116.62.160.193，所以这个测试是不会跨服务器的，本机访问，所以将本机设置为可信地址（set_real_ip_from 116.62.160.193;）没有用它的默认配置（ real_ip_header X-Real-IP;），而是重新作了配置（real_ip_header X-Forwarded-For;）环回地址用了默认 off ，对于这样的请求，返回 remote_addr 的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#39;X-Forwarded-For: 1.1.1.1,116.62.160.193&#39; realip taohui.tech</span><br><span class="line"></span><br><span class="line">-H 可以对我的请求中添加一个Header，Header中放了两个IP，一个是1.1.1.1（模拟上一个对端地址），另一个是116.62.160.193；</span><br></pre></td></tr></table></figure><p>返回的 116.62.160.193</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e52cfd9f-d514-40f6-9aca-2f0226969883.jpg" alt></p><p>如果开启了环回地址 即为 on，Nginx做一次 realod，再次访问，因为我们最后一个地址是本机地址，出发了环回地址被pass掉，发现变为上一个对端地址 1.1.1.1</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/789f10ab-1a2c-4646-b6c1-0d7d5f73f356.jpg" alt></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 post_read阶段中的realip模块，因为它处于的阶段，可以拿到没有加工过的X-Forwarded-For或X-Real-IP中的用户地址，因为后续的很多模块会去修改 X-Forwarded-For中头部的值。</p><h2 id="rewrite阶段：rewrite模块"><a href="#rewrite阶段：rewrite模块" class="headerlink" title="rewrite阶段：rewrite模块"></a>rewrite阶段：rewrite模块</h2><p><strong>rewrite模块</strong>中的<strong>return指令</strong>会在 server_rewrite 与 rewrite阶段都会生效，生效后，后续的HTTP模块的其他阶段是没有机会得到执行的。</p><h3 id="rewrite模块：return指令"><a href="#rewrite模块：return指令" class="headerlink" title="rewrite模块：return指令"></a>rewrite模块：return指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/62d86676-c710-43e4-b52a-bdd1f59ee2c9.jpg" alt></p><p>444 表示Nginx立即关闭连接，不再向客户端返回任何内容。</p><h3 id="rewrite模块：return指令与error-page指令"><a href="#rewrite模块：return指令与error-page指令" class="headerlink" title="rewrite模块：return指令与error_page指令"></a>rewrite模块：return指令与error_page指令</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ffdd9a3d-294a-4148-9b6b-4b51b00f7f55.jpg" alt></p><h3 id="return示例"><a href="#return示例" class="headerlink" title="return示例"></a>return示例</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5c75f1a9-fe7a-4e37-9720-d5bafda5d1cd.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建return.conf，并include进nginx.conf</span><br><span class="line">vim return.conf</span><br></pre></td></tr></table></figure><p>root html/  即我们访问 location 下的某个资源时，会去html下去找资源是否存在。如果文件没有找到，会生成一个404错误码，正常会这样返回，但这里注释掉，并且定义了一个 error_page 404 /403.html；即当看到404时给他重新定向到 403.html页面。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589217726606.PNG" alt></p><p>访问时故意找一个不存在的资源</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02ea6d8e-a71b-460e-a4a5-c67390fd926f.jpg" alt></p><p>此时，解开 return 404 的注释，再次访问， error_page是没有机会得到执行的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/36b9a97b-5f89-4733-8205-b6c0f14fdd27.jpg" alt></p><p>再如：在server中加入了一个 return 405;</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/09fad081-c6bd-4e98-b361-d231b97374d4.jpg" alt></p><p>此时会执行谁呢？ 在11个阶段中不难发现， server配置项中的return 是在 server_rewrite中的，location中的return是在 rewrite中的，肯定是 server_rewrite中的return先执行，而 location中的return是没有机会执行的。<strong>即肯定返回405</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/482f0981-162a-44e1-b2a6-7c71e67a86d7.jpg" alt></p><h3 id="rewrite模块：rewrite指令重写URL"><a href="#rewrite模块：rewrite指令重写URL" class="headerlink" title="rewrite模块：rewrite指令重写URL"></a>rewrite模块：rewrite指令重写URL</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/42d90672-258b-43f1-bfca-758460fbbaa2.jpg" alt></p><h4 id="rewrite指令示例（一）"><a href="#rewrite指令示例（一）" class="headerlink" title="rewrite指令示例（一）"></a>rewrite指令示例（一）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/118bb95d-6343-4197-a1f1-3e588ba5d3b4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/40344274-ece7-4745-8cbc-1495bbe764f5.jpg" alt></p><p>首先访问 first/3.txt</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6b709829-c696-4633-a415-a1f23c883a66.jpg" alt></p><p>在second中间 break注释放开，会有什么不一样呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d8c0525e-65d8-4b72-b88c-2699d513bf92.jpg" alt></p><h4 id="rewrite指令示例（二）"><a href="#rewrite指令示例（二）" class="headerlink" title="rewrite指令示例（二）"></a>rewrite指令示例（二）</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0d88d297-907e-452a-9348-28f6bb1db4a8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim rewrite.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd30f763-825d-4e63-a7d6-bc80aba824e9.jpg" alt></p><p>访问第一个，因为指定了 permanent（永久重定向），返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3717eeea-bc58-4d62-96f1-4c7c6e2c0b4a.jpg" alt></p><p>访问第二个，因为指令了 redirect（临时重定向），返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d719b0-ea6b-4891-93cb-32dcea315dfb.jpg" alt></p><p>访问第三个，因为什么都没有指定，但前面又有一个 http、https等，会返回302</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f37d3915-6a05-4f68-af33-1c418890ad66.jpg" alt></p><p>访问第四个，虽然前面有 http、https，但最后指定了 permanent，会返回301</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d55a475a-8a3f-43b6-b002-60a63daee590.jpg" alt></p><p><strong>rewrite_log指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8e0d3f73-8412-402c-b627-4a4c47dae229.jpg" alt></p><p>默认是不会开启的，需要显示开启，打开后，刚刚访问过的所有重定向的URL都会在指定的 <strong>logs/rewrite_error.log</strong>中出现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim rewrite_error.log</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8216df9e-65f7-40d8-b14d-81f473e58d38.jpg" alt></p><h3 id="rewrite模块：if指令-条件判断"><a href="#rewrite模块：if指令-条件判断" class="headerlink" title="rewrite模块：if指令-条件判断"></a>rewrite模块：if指令-条件判断</h3><p><strong>if指令</strong>可以让我们判断请求中的变量的值是否满足某个条件，再去决定由哪一个配置块执行，再根据这些配置块调用相应的模块去解析请求。（逻辑判断）</p><h4 id="rewrite模块的if指令"><a href="#rewrite模块的if指令" class="headerlink" title="rewrite模块的if指令"></a>rewrite模块的if指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/437f5e32-4633-43cd-a275-e96edcd4a1fc.jpg" alt></p><h4 id="if指令的条件表达式"><a href="#if指令的条件表达式" class="headerlink" title="if指令的条件表达式"></a>if指令的条件表达式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fdb72d21-a525-4781-b8aa-671d915b59f6.jpg" alt></p><p><strong>简单示例</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/25e97781-e9a3-4b33-af77-19c7189b6aa5.jpg" alt></p><h2 id="find-config阶段"><a href="#find-config阶段" class="headerlink" title="find_config阶段"></a>find_config阶段</h2><p>当我们在server块下的rewrite系列指令执行完毕后，开始根据用户请求中的URL去location中对应的URL正则表达式进行匹配。这一步【匹配完成后，就确定了由哪一个location对这个请求进行处理。</p><h3 id="处理请求的-location-指令块"><a href="#处理请求的-location-指令块" class="headerlink" title="处理请求的 location 指令块"></a>处理请求的 location 指令块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/96b8444c-2c2d-44f7-a224-24b101a157ca.jpg" alt></p><p><strong>merge_slashes</strong>可以去合并URL里的斜杠，两个斜杠在一起时，默认打开该配置项，会合并成一个。只有当URL中用到<strong>base64编码</strong>等等规则时，才需要关闭。</p><h4 id="location匹配规则：仅匹配URI，忽略参数"><a href="#location匹配规则：仅匹配URI，忽略参数" class="headerlink" title="location匹配规则：仅匹配URI，忽略参数"></a>location匹配规则：仅匹配URI，忽略参数</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bc97e48a-b6da-45b3-9a94-ccdb4dfdeb4d.jpg" alt></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/46154d9b-cde7-44aa-8011-b571869ddf18.jpg" alt></p><h4 id="location匹配顺序"><a href="#location匹配顺序" class="headerlink" title="location匹配顺序"></a>location匹配顺序</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/db8723bd-dfe2-4cca-a421-fa5e85e6eec4.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，将它 include到nginx.conf中</span><br><span class="line">vim locations.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/afea573c-c8c2-46f9-9964-81a5dfe637a0.jpg" alt></p><p>访问Test1,精确匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f8816478-51ce-4992-bf10-57198fc681c7.jpg" alt></p><p>访问Test1/,虽然有多个匹配，但是前缀字符串中遵循<strong>最长匹配</strong>的规则，所以匹配到了 Test1/，并且匹配上后，禁止后续正则表达式的匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fe863375-e5e2-45b7-9d29-5c59ddc3b0d2.jpg" alt></p><p>访问/Test1/Test2 ，/Test1/Test2 与 <del>* /Test1/(\w+)$ 都匹配上了，但由于没有使用 ^</del>禁止正则表达式匹配，所以匹配的是带有正则表达式的最长匹配。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c4e6b72-6e3a-4789-beec-aad6474d0f44.jpg" alt></p><p>访问/Test1/Test2/ ，因为正则没有匹配上，所以使用最长字符串匹配</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/937460a9-1add-4e3d-a739-ef415bb617c0.jpg" alt></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>以上介绍了 location的匹配规则，对于URI的请求，到底是由哪一个location下的指令去执行，就十分了然了，同时也知道了当location数量非常多时，怎样通过 <strong>禁止正则表达式匹配</strong>、<strong>使用=精确匹配</strong>等等方式对非常频繁发起的请求来减少它们做location匹配的次数。</p><h2 id="preaccess阶段"><a href="#preaccess阶段" class="headerlink" title="preaccess阶段"></a>preaccess阶段</h2><h3 id="对连接做限制的limit-conn模块"><a href="#对连接做限制的limit-conn模块" class="headerlink" title="对连接做限制的limit_conn模块"></a>对连接做限制的limit_conn模块</h3><p><strong>问题：如何限制每个客户端的并发连接数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/c2bbb690-8f6f-4a6b-a5e9-ef85c44d74b9.jpg" alt></p><h4 id="limit-conn指令"><a href="#limit-conn指令" class="headerlink" title="limit_conn指令"></a>limit_conn指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7fcdbe6a-773f-4720-9636-475b1fa1f457.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0126152a-bb75-4b70-bac7-0030bdb75d55.jpg" alt></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;3r&#x2F;s</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        limit_rate 50;</span><br><span class="line">        limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;1 nodelay;</span><br><span class="line">        #limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/636ff2ff-a1c4-408a-9b79-9dfa88be33f8.jpg" alt></p><p>上述配置文件定义了一个 <strong>10M</strong> 的共享内存，共享内存中使用 binary_remote_addr，这是一个二进制格式的IP地址（IPV4协议下只有4个字节,效率较高）。</p><p>定义了向用户返回的错误码是500（默认是503）</p><p>将 log_level调成了 warn（默认是error）</p><p>limit_conn_addr 1; 即限制了并发连接数为1（只为演示效果，当有两个客户端同时访问时，就会返回500）</p><p>limit_rate 50; 为了更好的演示，又加上了该配置项，即限制向用户返回的速度，每秒钟只返回50个字节，比较容易出现限制并发连接的场景。</p><p>在一个shell中访问，回复速度非常慢</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b53e8635-ea6e-477f-baf7-d7e9a41130ae.jpg" alt></p><p>在另一个shell中也访问，会回复500错误码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8032adb7-ee5f-4213-b7e5-6d37ba578735.jpg" alt></p><p>在 myerror.log中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d9f8cbfc-d250-42a1-b59a-542a21ee2700.jpg" alt></p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>当Nginx作为资源服务器为用户提供服务时，限制用户能够同时发起的并发连接数，是一个很常用的功能。Nginx默认编辑进去的 ngx_http_limit_conn_module模块提供了这样的功能。<strong>设计好Key是关键</strong>。</p><h3 id="对请求做限制的limit-req模块"><a href="#对请求做限制的limit-req模块" class="headerlink" title="对请求做限制的limit_req模块"></a>对请求做限制的limit_req模块</h3><p><strong>问题：如何限制每个客户端的每秒处理请求数？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f310270f-af32-456f-a8bc-10f9d88052ea.jpg" alt></p><h4 id="leaky-bucket算法"><a href="#leaky-bucket算法" class="headerlink" title="leaky bucket算法"></a>leaky bucket算法</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a55435d0-d50f-48e1-92e6-48e569f84fe6.jpg" alt></p><p>对于突发性流量，前两秒12Mbps，总共24M，2-7s没有流量，7-10为2Mbps，共6M，前10秒总共30M。</p><p>使用了该算法后，可以限制为3Mbps,前10秒总共 30M。</p><p>可以比喻为一个水龙头，向盆里流动的是突发性流量，而盆向下流的则是恒速流量。</p><ul><li><p><strong>当盆burst满的时候，立刻向用户返回503错误码</strong>。</p></li><li><p><strong>当盆burst没有满的时候，但向下速率已经达到最大化的时，水滴就会存在盆里，即用户的响应会变慢，请求并不会被拒绝</strong>。</p></li></ul><h4 id="limit-req指令"><a href="#limit-req指令" class="headerlink" title="limit_req指令"></a>limit_req指令</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/39b5d9e6-fc0a-486b-9ba3-417d57dc2ae0.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bafe56ec-ff77-4371-b9de-7bf7dbb7a0f8.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab666467-5387-42cf-b454-0b3ddf8c26b4.jpg" alt></p><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">创建文件并且include到 nginx.conf中</span><br><span class="line">vim limit_conn.conf</span><br><span class="line"></span><br><span class="line">limit_conn_zone $binary_remote_addr zone&#x3D;addr:10m;</span><br><span class="line">#limit_req_zone $binary_remote_addr zone&#x3D;one:10m rate&#x3D;2r&#x2F;m</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    server_name limit.haoran.tech;</span><br><span class="line">    root html&#x2F;;</span><br><span class="line">    error_log logs&#x2F;myerror.log info;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        limit_conn_status 500;</span><br><span class="line">        limit_conn_log_level warn;</span><br><span class="line">        #limit_rate 50;</span><br><span class="line">        #limit_conn addr 1;</span><br><span class="line">        #limit_req zone&#x3D;one burst&#x3D;3 nodelay;</span><br><span class="line">        limit_req zone&#x3D;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有加 burst 与 nodelay时，结果会是怎样？同时注释掉 limit_rate 这样可以快速返回内容。<strong>每分钟两条</strong></p><p><strong>curl limit.haoran.tech</strong> ，看到结果</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7db81b53-d952-41df-aa52-23651ef9a701.jpg" alt></p><p>再次访问</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/034093e0-7e6e-4aa0-8022-e4d36bbb5818.jpg" alt></p><p>将  burst的注释解开会是什么样的呢？</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f129ccd-e03c-45ef-a3de-27ab1087cea7.jpg" alt></p><p>访问3次都可以看到结果，访问第4次时，会有503错误码。</p><p>现在将限制连接与限制请求同时打开。看下效果。返回500（限制连接生效），返回503（限制请求生效），</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/80d4681d-1e8d-410e-9491-4dc792b7e05d.jpg" alt></p><p>每分钟只能处理2个请求，所以第3次访问时，<strong>limit_req生效</strong>，但其实 第二次访问时 <strong>limit_conn</strong>同样生效了。返回的还是503，而不是500，这是因为 limit_req模块是在limit_conn模块之前生效的，limit_req已经向用户拒绝了，limit_conn就没有机会得到执行了。<br><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/1eba94b3-b698-40f9-9d67-3243174af439.jpg" alt></p><h2 id="access阶段"><a href="#access阶段" class="headerlink" title="access阶段"></a>access阶段</h2><h3 id="对IP做限制的-access-模块"><a href="#对IP做限制的-access-模块" class="headerlink" title="对IP做限制的 access 模块"></a>对IP做限制的 access 模块</h3><p><strong>access模块</strong> 可以控制那些IP可以访问某些URL，那些不可以访问。</p><p><strong>问题：如何限制那些IP地址的访问权限？</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/832769b6-fcc5-4fa5-9da7-4c17ec221d47.jpg" alt></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/066c8482-4e64-46a6-b6a6-4ff35b0056e2.jpg" alt></p><h3 id="对用户名-密码做限制的-auth-basic-模块"><a href="#对用户名-密码做限制的-auth-basic-模块" class="headerlink" title="对用户名-密码做限制的 auth_ basic 模块"></a>对用户名-密码做限制的 auth_ basic 模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/609f0ee1-f934-4a18-be91-114657084c86.jpg" alt></p><p><strong>auth_basic模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/98ca71bc-ed6b-4332-910d-a6d02f593c64.jpg" alt></p><p><strong>生成密码文件</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d1d3a69a-f867-448b-a035-8a86dfc57870.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install -y httpd-tools</span><br><span class="line"></span><br><span class="line">htpasswd -c file -b user pass</span><br><span class="line"></span><br><span class="line">-c 指定生成的文件，-b 指定用户名密码</span><br><span class="line"></span><br><span class="line">假设现在已经生成了 auth.pass文件</span><br><span class="line"></span><br><span class="line">vim auth.pass</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4f016d91-a721-4522-a1fb-80cd531197ce.jpg" alt></p><p>上述密码文件中的密码做了一个简单的base64编码。</p><p>在 nginx.conf配置文件中指定有关配置</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/895f11ef-d463-4cd3-ac87-55a76b65174e.jpg" alt></p><p>浏览器访问 access.taohui.tech；会发现需要输入用户名-密码</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d41f3894-95a1-4f95-b711-327495299542.jpg" alt></p><p>当我们提供一个非常简单的页面时，如go-access，想对他做一个安全保护，auth_basic是一个不错的做法。</p><h3 id="使用第三方做权限控制的-auth-request-模块"><a href="#使用第三方做权限控制的-auth-request-模块" class="headerlink" title="使用第三方做权限控制的 auth_request 模块"></a>使用第三方做权限控制的 auth_request 模块</h3><p>在生产环境中，往往会有一个动态Web服务器或者相应的一些应用服务器，它们提供更复杂的用户名-密码权限验证，这个时候可以通过访问Nginx的资源池先将这个请求传递给应用服务器上，根据应用服务器返回的结果再判断这个请求资源能不能继续执行，那么Nginx的access阶段有一个模块为 auth_request模块，他就可以完成这样的功能。</p><p><strong>统一的用户权限验证系统</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7af33897-413a-4e91-ace2-ec13a7099185.jpg" alt></p><p><strong>演示</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6a69a3f-c156-4852-9303-e6f37b8e8210.jpg" alt></p><p>当访问 / 时 通过 auth_request 生成子请求,会去访问这个URL test_auth，而这个URL通过 proxy_pass反向代理到本机的另一个Nginx服务器（监听端口为8090），他提供的URL为 auth_upstream。成功后，因为有一个默认的配置 root html/(即使注释了也会正常显示html下的 index页面)，如果被拒绝，就会返回 8090 这台机器的错误码。</p><p>8090这台nginx的内容如下（成功的时候）：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/7ec46de9-417b-4c2e-9538-92900bc23395.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/cacc2da6-43af-49a1-a0c2-5c875a1c29eb.jpg" alt></p><p>将上游的返回值改为403：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b3662788-1074-492f-9d3c-5c370f409aec.jpg" alt></p><p>禁用缓存后，再次访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e887c996-2eb0-47f2-a0e6-d7c049bc7c2b.jpg" alt></p><h3 id="access阶段的-satisfy-指令"><a href="#access阶段的-satisfy-指令" class="headerlink" title="access阶段的 satisfy 指令"></a>access阶段的 satisfy 指令</h3><p>前面提到了 access 阶段的3个模块，那这三个模块任意一个模块拒绝了用户的请求，用户请求就无法执行了呢？其实并不是这样的，那他们是否严格的按照顺序往下执行呢？同样不是这样的。</p><p>因为 Nginx的HTTP框架中提供了一个 <strong>satisfy指令</strong>，允许我们改变模块的执行顺序。</p><p><strong>限制所有access阶段模块的 satisfy指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9e0e322a-b59c-477b-8787-131df574d6ca.jpg" alt></p><p>即一个 access模块，有三种处理结果：</p><ul><li><p><strong>忽略，即没有任何配置，直接跳到下一个access模块</strong></p></li><li><p><strong>放行（allow），先判断satisfy开关，如果配置为 all（表示必须所有的access模块都同意放行这个请求才可以通过），所以继续执行下一个access模块；如果配置为 any（即不用再去考虑后续的access模块是否同意，直接跳到下一个 post_access阶段执行）</strong></p></li><li><p><strong>拒绝（deny），同样判断satisfy开关，如果配置为 all（直接拒绝请求），不再向下执行。如果是 any，虽然当前这个模块拒绝了，但也会后续模块会同意放行，所以继续执行下一个access模块</strong></p></li></ul><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/11fb6c5d-da39-4d6e-afeb-47fc345a904e.jpg" alt></p><ul><li><p><strong>1：肯定不会生效，因为return指令的生效期是 server_rewrite 与 rewrite阶段，二者都领先于 access，access是没有机会得到执行的。</strong></p></li><li><p><strong>2：肯定有影响，即如果 access阶段已经拒绝了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li><li><p><strong>3：可以访问到，配置了 satisfy any</strong></p></li><li><p><strong>4：提到之前，仍然可以访问，因为模块间的顺序ok就行了，配置指令间的顺序无关紧要</strong></p></li><li><p><strong>5：将 deny all 改为 allow all，没有机会输入，因为配置的 satisfy all，任意的模块同意就可以了，allow all是 access模块的，它先于auth_basic模块执行的，它已经同意了，则auth_basic是没有机会输入用户名-密码的。</strong></p></li></ul><h2 id="precontent阶段"><a href="#precontent阶段" class="headerlink" title="precontent阶段"></a>precontent阶段</h2><h3 id="按序访问资源的-try-files-模块"><a href="#按序访问资源的-try-files-模块" class="headerlink" title="按序访问资源的 try_files 模块"></a>按序访问资源的 try_files 模块</h3><p><strong>对于反向代理的场景十分有用，Nginx先尝试去获取磁盘上的文件内容，如果没有再反向代理到上游服务。</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/728821e7-c28a-470a-8c79-2cc85b353fd3.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim tryfiles.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3eb1c77a-1125-49b9-ac41-bb1c00ee2057.jpg" alt></p><p>访问 /first，如果系统在维护的话可能会有一个 /system/maintenance.html文件，如果这个文件找不到的话，我们就去找 uri（即 html下first有没有），同样没有，$uri/index.html、$uri.html同样都没有，这时使用了 @lasturl 符号 去访问 另一个 location @lasturl。在这个location中返回 200的状态码。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/93bb2a64-19b6-4c1c-9e5a-ae4127d27779.jpg" alt></p><p>访问 /second，一样与一个去尝试，所有文件都找不到时，返回404.</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e14e4c54-713c-4f5d-afe3-826434d572c8.jpg" alt></p><h3 id="实时拷贝流量-mirror-模块"><a href="#实时拷贝流量-mirror-模块" class="headerlink" title="实时拷贝流量 mirror 模块"></a>实时拷贝流量 mirror 模块</h3><p>mirror模块可以帮我们创造一份镜像流量，如生产环境中处理一些请求，这些请求可能需要把他们同步的拷贝一份到我的测试、开发环境中做处理。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8611ad8c-6413-4e49-8c81-14d5dcc9d7bb.jpg" alt></p><p>即当请求到了Nginx后，可以生成一个子请求，这个子请求可以通过反向代理去访问我们的其他环境（测试环境等），对其他环境返回值不作处理。</p><p><strong>举例</strong></p><p>需要一个上游服务器</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8262d188-51e4-42cf-9020-9d191d34a19a.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim mirror.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/dfe18329-89d0-4458-b28a-2415d5d86bde.jpg" alt></p><p>收到一个请求时，会拷贝一份流量到 mirror 中去，/mirror收到后，会指定 internal（内部），将其方向代理到本机的10020端口上去。</p><p>访问8001</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5602b6ce-74a5-4899-895c-8a0996c08303.jpg" alt></p><p>实时查看日志</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bd01d90d-8679-434b-90d7-76bcdd1da763.jpg" alt></p><p>再去看上游Nginx(10020)的日志，是否收到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8fb49605-4b51-43a3-93b5-482835b2f6f5.jpg" alt></p><h2 id="content阶段"><a href="#content阶段" class="headerlink" title="content阶段"></a>content阶段</h2><h3 id="static模块-root-和-alias-指令"><a href="#static模块-root-和-alias-指令" class="headerlink" title="static模块 root 和 alias 指令"></a>static模块 root 和 alias 指令</h3><p>content阶段中 static模块  默认是在Nginx框架中的，是没有办法做移除的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b281027a-aae7-4dfe-88bc-ac86be3b0a78.jpg" alt></p><p><strong>问题</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/85228787-c832-42d3-abcc-d1c9a88e6bf8.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/8ecfd588-3241-470e-87bb-05787d28f3c5.jpg" alt></p><p><font color="red">直接访问 root/，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0c140f6a-cbcd-47c6-9d3b-709a76fee58e.jpg" alt></p><p>查看日志，在 html后又加上了刚刚 location中的root，因为有个 反斜杠，所有有添加了 index.html，这个文件其实是不存在的。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b653fc8e-67c4-41b4-8a47-8ab73f3bb163.jpg" alt></p><p><font color="red">直接访问 root/1.txt，文件不存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a47c5ad2-58ce-400b-9310-0c10ef8caff9.jpg" alt></p><p>查看日志，它其实是在 html/first/1.txt 后面又添加了 /root/1.txt，即 html/first/1.txt/root/1.txt</p><p><font color="red">直接访问 curl static.taohui.tech/alias/   ,他匹配到了 location /alias  会去访问 html下的index.html，所以应该访问首页</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e81ffef0-5e33-44d9-b9fc-87cdc23a59f0.jpg" alt></p><p><font color="red">直接访问 curl static.taohui.tech/alias/1.txt  ，不会添加完整路径，文件存在</font></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2c61806a-68d3-412a-bdae-c38891d6fe4e.jpg" alt></p><h3 id="static模块-3个变量"><a href="#static模块-3个变量" class="headerlink" title="static模块 3个变量"></a>static模块 3个变量</h3><p><strong>生成待访问文件的三个相关变量</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363559193.PNG" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并include到 nginx.conf文件中</span><br><span class="line">vim static.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ef33b509-ef3c-4791-9a89-de3d330cd1f9.jpg" alt></p><p>realpath 实际上是一个软链接，他指向了 first目录下，这个目录下有一个1.txt文件</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2fc334d9-4140-4ae2-b475-c8c70453c88e.jpg" alt></p><p>在下图中可看到，返回3个路径，第一个是完整路径，后两个都是1.txt所在的目录，只不过 document_root 没有做软链接的替换，还是根据配置项拼接出来的，而 realpath_root 已经将 realpath 替换为真实 first目录。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589363849390.PNG" alt></p><h3 id="static模块提供的其他功能"><a href="#static模块提供的其他功能" class="headerlink" title="static模块提供的其他功能"></a>static模块提供的其他功能</h3><h4 id="静态文件返回时的-content-type"><a href="#静态文件返回时的-content-type" class="headerlink" title="静态文件返回时的 content-type"></a>静态文件返回时的 content-type</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/fcc5c202-7370-4c46-9781-5c3013c3ac45.jpg" alt></p><p>当我们去读磁盘上的文件时，根据文件的扩展名做一次映射。<strong>types指令</strong>就是做这个事情的，为了加速，需要将 content-type  与 扩展名 做一次映射放入 Hash 表中。</p><p><strong>default_type</strong>是在没有文件名时用来告诉用户这个content-type究竟怎样解析</p><h4 id="未找到文件时的错误日志"><a href="#未找到文件时的错误日志" class="headerlink" title="未找到文件时的错误日志"></a>未找到文件时的错误日志</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/73be5c25-2a92-49df-9fa6-4e5a2f18d0e1.jpg" alt></p><h3 id="static模块对url不以斜杠结尾却访问目录的做法"><a href="#static模块对url不以斜杠结尾却访问目录的做法" class="headerlink" title="static模块对url不以斜杠结尾却访问目录的做法"></a>static模块对url不以斜杠结尾却访问目录的做法</h3><p>很多人使用 static 模块的  root/alias 指令将Nginx当做静态资源服务器时，很可能会发现，当我们去访问一个目录，但是在url结尾没有加上斜杠时，实际上Nginx会返回一个301的重定向，那么对于重定向中的内容，Nginx提供了3种不同的指令，去控制location这样的行为。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d79721a2-30b5-45d1-bc5f-5a23376cb8f0.jpg" alt></p><p><strong>重定向跳转的域名</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/5be98a60-9879-424b-af00-20da33bd9ac6.jpg" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim dirredirect.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/0f59cecd-1d65-4878-a2fc-ed552e9a8ced.jpg" alt></p><p>在 server_name 中配置了两个域名，第一个是主域名。将 absolute_redireect off 开启（默认是on），root指向 html/ 下有一个 first文件夹。</p><p>先来访问 first文件夹，没有加反斜杠，此时应该获得一个301重定向</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/6f469702-82cb-4d21-9e94-87b8d4cbbbb2.jpg" alt></p><p>将 absolute_redirect off 注释掉。再次访问，发现 在 <strong>Location</strong>中将域名都添加了进去。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f4c52dee-e694-456e-a032-3adf3c6cb7cc.jpg" alt></p><p>如果头部有一个 <strong>Host: aaa</strong>，那么就会将它替换掉掉Location中的localhost。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/3be924e8-441e-49aa-b014-0639d6707a30.jpg" alt></p><p>将 dirredirect.conf配置文件中的 <strong>server_name_in_redirect on</strong>开启后，再去访问，会发现Location中以主域名来绑定。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ea6acb6d-f387-4f79-b80e-04aaa22ace11.jpg" alt></p><h3 id="index-与-autoindex模块"><a href="#index-与-autoindex模块" class="headerlink" title="index 与 autoindex模块"></a>index 与 autoindex模块</h3><p>在前面已经演示过，autoindex会以目录形式显示服务器上的资源。但有时在搭建的时候，会没有看到目录结构，看到的是一个文件的内容，这是因为** index 模块** 先于 <strong>autoindex 模块</strong>产生作用。</p><h4 id="对访问-时的处理：content阶段的index模块"><a href="#对访问-时的处理：content阶段的index模块" class="headerlink" title="对访问/时的处理：content阶段的index模块"></a>对访问/时的处理：content阶段的index模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/03f6d0ed-8176-4fa7-9d84-94e0b6ba03d1.jpg" alt></p><h4 id="显示目录内容：content阶段的autoindex模块"><a href="#显示目录内容：content阶段的autoindex模块" class="headerlink" title="显示目录内容：content阶段的autoindex模块"></a>显示目录内容：content阶段的autoindex模块</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/ab7fdd2b-3bc0-411f-a706-72de6fa40001.jpg" alt></p><p><strong>autoindex 模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/4a0c0058-8c44-4e61-bf74-a4a1031a99fe.jpg" alt></p><p>autoindex_exact_size on|off ：当默认打开的格式（向用户返回的是html格式时才有效）是显式相对的路径。<strong>绝对路径：</strong>以<strong>字节</strong>来显示。<strong>相对路径：</strong>以<strong>K、M</strong>显示。</p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim autoindex.conf</span><br></pre></td></tr></table></figure><p>监听了1个8080端口，以server_name指定的域名进行访问，默认没有修改index a.html（注释掉了）。当访问 / 时，会去找 index.html，在 alias指定的html下是有这个文件。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/bf6a5afc-224c-4ace-bb0d-9980a58ef6d6.jpg" alt></p><p>去访问 autoindex.taohui.tech:8080，得到的是index.html内容</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/35ca0dd5-1174-4d4c-8ab4-f29a4e95c157.jpg" alt></p><p>因为 index 模块是没有办法从  Nginx中移除的，所以可以去修改 index指向的文件，将它指向一个不存在的 a.html文件（即将 index a.html 注释解开）</p><p>再次访问autoindex.taohui.tech:8080，是JSON格式返回这个目录</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d928ea5f-1314-45f7-8c2b-2bfa98a9379b.jpg" alt></p><p>同理，将 autoindex_format json 改为 html</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2f0517d-faa7-47bd-9d91-aaa32607b218.jpg" alt></p><p>reload后，再次访问，因为是以相对路径，所以可以显示到K。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a18c6759-3aae-41de-8cdf-f7b93d5e3473.jpg" alt></p><h3 id="content阶段中有Alibaba提供的concat模块"><a href="#content阶段中有Alibaba提供的concat模块" class="headerlink" title="content阶段中有Alibaba提供的concat模块"></a>content阶段中有Alibaba提供的concat模块</h3><p>concat模块可在一次请求中返回多个文件的内容，这对在Web页面中访问多个小文件来提升性能十分有用。（需要下载并且在 .configure 时编译进Nginx）</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/68e622ae-6d7a-42c3-9890-3cb801bc37d8.jpg" alt></p><p><strong>concat模块的指令</strong></p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/9d3beaf0-7b29-4534-81e5-7649b057033b.jpg" alt></p><ul><li><p><strong>concat 开启或者关闭</strong></p></li><li><p><strong>concat_delimiter：String，如果服务器返回多个文件，通过指定的String分隔符进行分割</strong></p></li><li><p><strong>concat_types: MIME types，对那些文件的类型做合并</strong></p></li><li><p><strong>concat_unique：对某一种文件类型进行合并，还是对多个文件类型进行合并</strong></p></li><li><p><strong>concat_ignore_file_error：如果某个文件出现错误，是忽略它，返回其他文件的内容</strong></p></li><li><p><strong>concat_max_files：最多合并多少个文件，默认为10</strong></p></li></ul><p><strong>看一下淘宝网的做法</strong></p><p>可以看到他的大部分请求，都使用了 <strong>??</strong>，后面添加了多个文件，后面用逗号隔开。</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/02e8a5f0-565f-4068-92ac-01046a0008ab.jpg" alt></p><p>在响应中也可以看到</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/14b5a5c5-325f-42ae-8156-591e00c25231.png" alt></p><p><strong>演示</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">新建配置文件，并且include到 nginx.conf配置文件中</span><br><span class="line">vim concat.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/b6d44649-a349-4292-b964-44f983a5e1b3.jpg" alt></p><p>在 concat.conf配置文件中，首先打开了这个功能，最多20个文件，类型是 text/plain，以 <strong>三个分号</strong>来分隔多个文件。</p><p>现在来访问，他回去 html/concat 路径下找 1.txt 与 2.txt，这两个文件是存在的，内容如下：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/e9612a1d-ca16-462c-a9e5-eaba187d31d5.jpg" alt></p><p>访问：</p><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/d3025d36-8921-429f-81f4-f5eefb3dd611.jpg" alt></p><h2 id="Log阶段（记录请求访问日志的log模块）"><a href="#Log阶段（记录请求访问日志的log模块）" class="headerlink" title="Log阶段（记录请求访问日志的log模块）"></a>Log阶段（记录请求访问日志的log模块）</h2><h3 id="http-log模块"><a href="#http-log模块" class="headerlink" title="http_log模块"></a>http_log模块</h3><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/a7c1944c-6b8c-4a7e-9155-dd3a886d2584.jpg" alt></p><h4 id="access-日志格式"><a href="#access-日志格式" class="headerlink" title="access 日志格式"></a>access 日志格式</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/2b74ec9f-c476-4e23-8162-da5fe03379b0.jpg" alt></p><h4 id="配置日志文件路径"><a href="#配置日志文件路径" class="headerlink" title="配置日志文件路径"></a>配置日志文件路径</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/f2806838-8e42-4e9f-992b-b9357b7a2820.jpg" alt></p><h4 id="对日志文件名包含变量时的优化"><a href="#对日志文件名包含变量时的优化" class="headerlink" title="对日志文件名包含变量时的优化"></a>对日志文件名包含变量时的优化</h4><p><img src="/2019/12/11/23-%E8%AF%A6%E8%A7%A3HTTP%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5/_u6355_u83B71589375413620.PNG" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-如何找到处理请求的Server指令块</title>
      <link href="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/"/>
      <url>/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Nginx-HTTP模块处理请求之前，要确保它的指令可以被正确解析。即我们知道，为了处理这个请求，我们知道到底使用那个指令的值。因为前卫提到指令的配置是可以出现在多个配置项中的，首先确保这个请求是被哪一个<strong>server块</strong>处理，因此，要先介绍一个配置指令 <strong>server_name</strong>，server_name可以保证我们在处理11个阶段的HTTP模块处理之前，先决定哪一个Server块被使用。</p><a id="more"></a><h2 id="Server-name-指令"><a href="#Server-name-指令" class="headerlink" title="Server_name 指令"></a>Server_name 指令</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/df26bdab-3bfd-42ee-86f7-638175ac5b63.jpg" alt></p><p><strong>简单演示：</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/afcba697-6524-4d0a-b0de-26c81a9e6f51.jpg" alt><br><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/9fb82a75-fe58-4cbb-b484-6e81b8ce6784.png" alt></p><p>主域名当前不会生效，curl 域名 -I  （-I 显示头部），访问second开头的域名，返回second开头的域名</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/28d97c9d-1dff-48c5-8da5-7ffe4c7bce25.jpg" alt></p><p>如果先返回是是主域名，就要将 off 改为 on，主域名开始生效。访问second开始的域名，发挥primary开头的主域名。</p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/b8921fa4-75db-4574-a213-1614397578e8.jpg" alt></p><p><strong>server_name指令其他用法</strong></p><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/7150b181-f5f1-4210-8132-47aad432be28.jpg" alt></p><h2 id="Server匹配顺序"><a href="#Server匹配顺序" class="headerlink" title="Server匹配顺序"></a>Server匹配顺序</h2><p><img src="/2019/12/10/22-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84Server%E6%8C%87%E4%BB%A4%E5%9D%97/eb693887-6efd-474d-be89-0322bb142a96.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了当Nginx框架取到了Host头部值时，就可以用这个值与我们<strong>Server</strong>块下的<strong>Server_name</strong>指令进行匹配，然后利用其中定义的规则进行解析处理。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-Nginx中的正则表达式</title>
      <link href="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在Nginx中确定使用哪一个域名处理用户请求时，或者location中匹配哪些URL时，又或者重写URL时，都可以用到<strong>正则表达式</strong>，它可以让我们匹配到的功能更为强大。</p><a id="more"></a><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/0e4b9acc-6d13-4199-8470-93df39ce4d0b.jpg" alt></p><p><strong>举例：</strong><br><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7fb63cc5-8759-486f-8d6d-c533584d10e1.jpg" alt></p><p><strong>工具：pcretest</strong></p><p>输入模式，输入待校验数据，查看匹配结果，可验证正则书写是否正确。</p><p><img src="/2019/12/09/21-Nginx%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/7b9755d2-be5c-4b01-b2c2-1c91929f9831.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-处理HTTP请求头部流程</title>
      <link href="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在HTTP模块开始处理用户请求之前，首先要Nginx框架先对客户端建立连接，接收用户发来的 <strong>HTTP Line</strong>，如方法、URL等，再去接收到所有的<strong>Header</strong>，根据Header信息，才能决定使用哪些配置块，让HTTP模块怎样处理请求。因此，有必要看一看 Nginx框架如何建立连接、接收HTTP请求。</p><a id="more"></a><h2 id="接收请求事件模块"><a href="#接收请求事件模块" class="headerlink" title="接收请求事件模块"></a>接收请求事件模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/6db1c81d-6992-4757-bdda-4bd8ea201a0c.jpg" alt></p><p>大致分为3个层次：<strong>操作系统内核</strong>、<strong>事件模块</strong>、<strong>HTTP模块</strong>，流程大致如下：</p><ul><li><p><strong>操作系统内核：3次握手，当用户发来SYN时，内核会回复一个SYN+ACK表示已确认，当客户端再发来ACK时，标明连接已成功建立，Nginx有很多Worker进程，都监听了80、443端口，操作系统会依据它的负载均衡算法，选中某一个Worker进程</strong></p></li><li><p><strong>被选中的Worker进程会通过 epoll_wait方法去返回刚刚建立好连接的句柄，拿到句柄后，这其实是一个读事件（读到了一个ACK报文），根据读事件，找到监听的80、443端口，可以调用accept方法，分配连接内存池，默认为 connection_pool_size 512字节</strong></p></li><li><p><strong>所有的HTTP模块开始从事件模块中接入请求，HTTP模块在启动时会定义一个ngx_http_init_connection回调方法，通过 epoll_ctl将读事件加入其中，同时设置超时定时器（client_header_timeout:60s）</strong></p></li><li><p><strong>当用户真的把一个HTTP请求（get、post）发来时，其实是DATA，在TCP层（内核层），会回复一个ACK，同时事件模块的epoll_wait又拿到这个请求，回调方法是 ngx_http_wait_request_handler，需要将内核中的DATA读到Nginx的用户态中，需要分配内存，从连接内存池分配1k(client_header_buffer_size),并不是越大越好，因为只要用户有1个字节发过来，就要为他分配1k大小内存，但是如果用户发来的DATA（URL、Header）超过1K了呢？</strong></p></li></ul><h2 id="接收请求HTTP模块"><a href="#接收请求HTTP模块" class="headerlink" title="接收请求HTTP模块"></a>接收请求HTTP模块</h2><p><img src="/2019/12/09/20-%E5%A4%84%E7%90%86HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8%E6%B5%81%E7%A8%8B/301c6d75-7166-4bd4-b44f-9e1e8470fae6.jpg" alt></p><h3 id="接收URI"><a href="#接收URI" class="headerlink" title="接收URI"></a>接收URI</h3><p>刚刚分配完1K后，已经收到了 小于等于1K的请求内容。</p><ul><li><p><strong>分配请求内存池：</strong>处理请求与处理连接不同，处理连接只需要将它收到Nginx内存中就OK了，但处理请求时，去做大量的上下文分析，分析它的HTTP协议、Header，因此要分配一个<strong>请求内存池</strong>，默认 request_pool_size:4k，基本上是<strong>connection_pool_size</strong>的8倍，因为请求的上下文涉及到业务，通常4K是一个比价合适的大小（如果分配过小，请求内存池需要不断地扩充，分配内存的次数变多时，肯定会影响性能），要不要改这个4K要根据业务来决定。</p></li><li><p><strong>状态机解析请求行：</strong>解析请求的行， /r /n之前的 方法名、URL、协议。解析过程中可能会发现URL特别大，超过了刚刚分配的1K内存。</p></li><li><p><strong>分配大内存：</strong>主要是来解决大URL的问题，分多大的呢？<strong>large_client_header_buffers:4 8k</strong>，分配的并不是32K 这么大的内存，而是先分配一个8K的内存，将刚刚1K内存中内容拷贝到这个8K内存中来，还剩7K的内存，用剩下的7K再去接收URL，然后用状态机去继续解析URL，如果发现7K都没有解析完，再次分配第二个8K，即一共分配了16K，最多分配32K。</p></li><li><p><strong>解析完成时，就可以标识URI</strong>，类似于超链接，Nginx用指针指向这个URI。</p></li></ul><h3 id="接收Header"><a href="#接收Header" class="headerlink" title="接收Header"></a>接收Header</h3><p>HTTP请求中的Header可能会非常长，如有Cookie、Host等字段。</p><ul><li><p><strong>状态机解析Header</strong>,Header非常有可能超过1K,又需要分配大内存。</p></li><li><p><strong>分配大内存</strong>与左边接收URI是共用的，如左边已用了2个8K，此处最多只能在分配2个8k。</p></li><li><p><strong>标识header</strong></p></li><li><p><strong>移除超时定时器</strong>，是在收到完整的Header后，才可移除。</p></li><li><p><strong>开始11个阶段的HTTP请求处理</strong></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上都是Nginx框架处理的，11个流程是HTTP模块处理的。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19-Nginx中Listen指令用法</title>
      <link href="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/"/>
      <url>/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每一个请求进入Nginx开始处理之前，都首先需要<strong>监听端口</strong>，以使得Nginx与客户端建立起<strong>TCP连接</strong>，监听端口的指令为<strong>listen</strong>指令，它是放在<strong>server</strong>配置块下的，通过监听的端口或是地址已经可以决定由哪些可以匹配上我们TCP资源组监听的地址链接对应的server块去处理相关的请求。</p><a id="more"></a><h2 id="Listen-指令"><a href="#Listen-指令" class="headerlink" title="Listen 指令"></a>Listen 指令</h2><p><img src="/2019/12/08/19-Nginx%E4%B8%ADListen%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95/729d148b-a54e-49ff-a745-fd79853e3e8f.jpg" alt></p><ul><li><p><strong>lisent address[:port]</strong></p></li><li><p><strong>listen port</strong></p></li><li><p><strong>listen unix:path 只用于本机通讯</strong></p></li><li><p><strong>listen 127.0.0.1; 此处默认使用 80端口</strong></p></li></ul><p>详细的Listen用法在后续文章实践时再提及。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-Nginx冲突的配置指令以谁为准</title>
      <link href="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/"/>
      <url>/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正式开始学习<strong>HTTP模块</strong>之前，先要谈一谈指令的<strong>嵌套结构</strong>，每一个HTTP模块出现的指令，可能出现的<strong>Context(上下文)</strong>，既可以在<strong>location</strong>中，也可以在<strong>server</strong>中，或是<strong>http</strong>中，当一个指令出现在多个<strong>配置块</strong>中时，它们的值可能是冲突的，到底以谁为准呢？或者在某个配置块下发现没有这个指令，但是在启动时却发现生效了，这样的机制是怎么实现的呢？还有很多的<strong>第三方模块</strong>可能不是很守规矩的去遵循官方制定的规则，这个时候我们应该怎样去判断配置指令到底是怎样生效，发生冲突时如何解决冲突呢？</p><a id="more"></a><h2 id="典型的配置块嵌套"><a href="#典型的配置块嵌套" class="headerlink" title="典型的配置块嵌套"></a>典型的配置块嵌套</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/2d6e5c41-6a8b-4259-bf26-934c752a9249.jpg" alt></p><p>http–server–location 是<strong>HTTP框架来定义</strong>，处理一个请求时，先按照请求中的<strong>域名：如 host</strong>找到对应的<strong>server</strong>,再根据<strong>URL</strong>找到对应的<strong>location</strong>，根据location下具体的指令来处理请求。</p><h2 id="指令的-Context"><a href="#指令的-Context" class="headerlink" title="指令的 Context"></a>指令的 Context</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1b48fc0d-3015-4f35-b87c-6d2eb15f8be8.jpg" alt></p><ul><li><strong>log_format</strong>出现的上下文Context是在<strong>http</strong>中的，如果把它放在<strong>server</strong>、<strong>location</strong>时，启动nginx检查配置文件语法时，会失败，无法启动。</li><li><strong>access_log</strong> 同理。</li></ul><h2 id="指令的合并"><a href="#指令的合并" class="headerlink" title="指令的合并"></a>指令的合并</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/7edbb2e6-b36d-4b34-959d-7db4f481fd9b.jpg" alt></p><h2 id="存储值的指令继承规则：向上覆盖"><a href="#存储值的指令继承规则：向上覆盖" class="headerlink" title="存储值的指令继承规则：向上覆盖"></a>存储值的指令继承规则：向上覆盖</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/82868d03-da97-48c9-af03-557cf3a81ead.jpg" alt></p><ul><li><p><strong>listen指令只能出现在server上下文中</strong></p></li><li><p><strong>alias指令虽然可以出现在 http、server、location中，但是在上述图示中只在location中出现</strong></p></li><li><p><strong>server下的root /home/geek/nginx/html;而其他location中没有定义root，同样可以使用父配置块定义的root，如最下方的root。这是一个通用配置规则，只要该指令允许在子配置块中生效</strong></p></li><li><p><strong>在 location /test 下重新定义了一个 root /home/geek/nginx/test; 或者 access_log 也重新定义了，此时直接使用子配置覆盖父配置</strong></p></li></ul><h2 id="HTTP模块合并配置的实现"><a href="#HTTP模块合并配置的实现" class="headerlink" title="HTTP模块合并配置的实现"></a>HTTP模块合并配置的实现</h2><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/d052eae4-743b-4529-90ba-69e184b87f48.jpg" alt></p><p>举一个例子 <strong>ngx_http_referer_module</strong>防盗链模块，它们都有一个结构体是 <strong>ngx_module_t</strong>，相当于说明书。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/5c0f1a1b-ac60-4725-92e0-cc4f19839d32.jpg" alt></p><p>该模块提供的配置指令，都在 *<em>ngx_command_t &nbsp; &nbsp;ngx_http_referer_commands[] *</em>中提及。<br><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/658fa363-3808-499a-b04d-f78aa16ec8e1.jpg" alt></p><p>如 <strong>valid|referers</strong> 指令可以出现在 server、location下，可以携带1MORE（1个或多个）参数。</p><p>所有指令解析完要做合并，可以看 <strong>ngx_http_module_t</strong> 结构体。</p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/1afde405-4fb7-4e72-963f-45ce63bfe249.jpg" alt></p><p>它定义了 8个回调方法，重点看 <strong>ngx_http_referer_merge_conf</strong>，以上指令都是在location下生效的，所以需要 http、server向location合并。</p><p><strong>合并规则</strong></p><p><img src="/2019/12/08/18-Nginx%E5%86%B2%E7%AA%81%E7%9A%84%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E4%BB%A5%E8%B0%81%E4%B8%BA%E5%87%86/aa4e4b16-319b-434f-9a0b-dc098312b979.jpg" alt></p><p>parent：父指令<br>child： 子指令</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上介绍了HTTP模块指令合并规则，为下面正式学习HTTP每一个模块提供了技术帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-Nginx动态模块</title>
      <link href="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>动态模块</strong>可以在使用Nginx中升级Nginx时减少编译环节。本文主要讲的是动态模块编译及使用的流程，再用一个例子来演示。</p><h2 id="动态模块-减少编译环节"><a href="#动态模块-减少编译环节" class="headerlink" title="动态模块-减少编译环节"></a>动态模块-减少编译环节</h2><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/cdfe3da9-95c0-4ebf-91da-bbe142dd4f6e.jpg" alt></p><a id="more"></a><p>左上图 是没有使用动态模块的编译方式及结果。</p><p>左下图 是使用了动态模块的编译及结果（生成了<strong>指定模块的动态库</strong>）。</p><p><font color="red">动态库</font>与<font color="red">静态库</font>区别：静态库会将所有的源代码编译进最终的二进制可执行文件中；动态库在Nginx二进制可执行文件中只保留了<strong>调用它的地址</strong>，在需要用到动态库的功能时，由<strong>Nginx的二进制可执行文件（Nginx Executable）</strong>去调用这个动态库，再去完成对应的功能。好处：当我们仅仅需要修改某一个模块、升级某个模块的功能时（特别是当Nginx编译了大量的第三方模块），重新编译这个动态库，而不用替换二进制可执行文件，编译出新的动态库后，只需要替换出旧的动态库，让 Nginx reload即可使用新的模块功能。</p><p><strong>具体步骤：上右图6步骤</strong></p><p>工作流程：</p><ul><li><p><strong>Configure加入动态模块</strong>：只有<strong>部分模块</strong>可以以动态模块的身份编译</p></li><li><p><strong>执行make，编译出 binary</strong></p></li><li><p><strong>启动时会去读 ngx_modules[] 数组，在模块数组中会发现使用了某个动态模块</strong></p></li><li><p><strong>在nginx.conf中需要加入一个配置项 load_modules，这个配置项指明了这个动态模块所在的路径</strong></p></li><li><p><strong>接下来就可以在Nginx进程中打开动态库并上面的模块加入模块数组中</strong>。</p></li><li><p><strong>基于模块数组再进行初始化过程</strong>。</p></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>查看可以增加哪些动态模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br><span class="line"></span><br><span class="line">后面带有 dynamic 关键字的即为可以动态模块身份编译的</span><br><span class="line">--with-xx-xx-module&#x3D;dynamic</span><br></pre></td></tr></table></figure><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/13afd584-3542-46c9-ad01-e852d8644ff3.png" alt></p><p>以<strong>–with-http-image_filter_module=dynamic</strong> 为例来进行演示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">如果出现 下列信息</span><br><span class="line">.&#x2F;configure: error: the HTTP image filter module requires the GD library.</span><br><span class="line">You can either do not enable the module or install the libraries.</span><br><span class="line"></span><br><span class="line">按照下面这个命令安装依赖库</span><br><span class="line">yum install gd-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再次运行编译</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx_tmp&#x2F; --with http_image_filter_module&#x3D;dynamic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>我们打开了 8080端口，把一些文件放在了test文件下</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/03066fd1-e17b-4cda-b8fe-90713600cc0d.png" alt></p><p>在test文件夹下，我们存放了一张图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/1786e7f3-3033-4e31-9792-d402fec8b880.png" alt></p><p>用浏览器访问该图片</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e63ab0bf-c704-4dc9-bc3a-583f3f3f7126.jpg" alt></p><p><strong>而上述动态模块的功能则是可以实时的把图片压缩成更小的图片</strong></p><p>安装好的目录中多了一个 <strong>modules</strong>目录，在这个目录中多出了一个动态库，Linux中所有的动态库是以 .so结尾，静态库是以 .a 结尾的。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/5f9d8e7e-ed30-48db-9bf1-8800ecef0f50.png" alt></p><p>打开nginx配置文件，调用 load_module 这个配置项，将相对路径放在此处。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/e1e82aa5-e27d-4576-b1b6-adf007925733.png" alt></p><p>同时将图片放缩</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/328f5eca-3b8c-4fe5-8995-a16cc8f6c49a.png" alt></p><p>图片没有放缩，是因为浏览器缓存了这张图片，按F12，禁用缓存，再次刷新就可以了。</p><p><img src="/2019/12/07/17-Nginx%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97/a836cbf8-ddc3-412e-bc6a-43ef0000240a.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16-Nginx容器</title>
      <link href="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx容器是许多Nginx高级功能的基础，即使我们不需要去编写第三方模块或是去查看Nginx的源代码，但需要变更Nginx配置文件，已达到最大化的性能，也需要理解Nginx容器。</p><h2 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h2><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/292d9b9f-1801-49d5-b829-d0cf04868461.jpg" alt></p><a id="more"></a><h3 id="Nginx哈希表"><a href="#Nginx哈希表" class="headerlink" title="Nginx哈希表"></a>Nginx哈希表</h3><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/deb747db-853d-49bc-98b9-34edffd68808.jpg" alt></p><h4 id="哈希表配置"><a href="#哈希表配置" class="headerlink" title="哈希表配置"></a>哈希表配置</h4><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/42459f32-e90c-4688-a0b9-aad76a907fd1.jpg" alt></p><p>与常见的哈希表不同的是：</p><ul><li><strong>应用场景不同</strong>。用于<strong>静态不变的内容</strong>，即在运行过程中，哈希表通常不会出现插入、删除等操作，Nginx刚启动时就基本确定这个Hash表中一共有多少个元素。因此使用Hash表这种数据结构的模块通常会暴露出 <strong>max_size</strong> 与 <strong>bucket size</strong>。max size仅仅控制了最大的哈希表 bucket的个数，而不是实际上 bucket的个数，它的意义在于限制最大化使用内存。</li></ul><p>如上图所示，所有使用哈希表的模块有一些特点。stream/http中所有的变量使用了哈希表，因为变量在模块编译进去的时候就已经定义清楚了。还有 map、反向代理等。反向代理中需要对在配置文件中定义好的Header做哈希来提升它的访问性能。哈希表在访问的时候是一个O(1)的复杂度。</p><p>哈希表中有一个称之为 <strong>Bucket size</strong>，在这个里面会有一些默认值，这些默认值在Nginx的配置文档中说会使CPU Cache len 对齐到这样一个值。这实际上影响了怎样去配置 Bucket size，现在的主流CPU会有 L1、L2、L3缓存，它在取主存（内存）上的数据时，并不是按照所想像的那样，按照64位、32位去取。现在主流CPU去主存，一次取得的字节数是就是 CPU Cache len 。如现在是 64 字节。</p><p>为什么Hash表要向64字节对齐呢？</p><p>假设每一个Hash表的 Bucket是59字节，如果紧密排列在一起，取第一个Hash表元素，仅需要访问一次，还多取了一个自己。取第二个时，要访问主存两次，包括第一个64字节中的最后一个字节以及第二个单元中的58个字节。为了避免取两次的问题，Nginx在它的代码中自动向上对齐。在配置Bucket size时，要注意两个问题。</p><ul><li><p><strong>1 如果配置的不是CPU Cache Len，如配置了70字节，他就会向上分配，每个元素分配128字节。</strong></p></li><li><p><strong>2 如果有可能，尽量不要超过64字节，以减少CPU访问每个Hash表的次数。</strong></p></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>哈希表专注于为<strong>静态不变</strong>的内容服务。</li><li>Hash表的 Bucket size 需要考虑CPU Cache Len 对齐问题。</li></ol><h3 id="Nginx红黑树"><a href="#Nginx红黑树" class="headerlink" title="Nginx红黑树"></a>Nginx红黑树</h3><p>Nginx多个Worker进程间做进程间通讯时，经常在共享内存上使用红黑树来管理对象，实际上，在Nginx内存中也会大量使用红黑树。</p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/fc01b91e-4a3c-42a7-b2e8-37b11db20474.jpg" alt></p><p><strong>特点：n为节点数</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/88f836f9-ea9e-4adf-9bae-fe33c6d0d709.jpg" alt></p><p><strong>红黑树的使用模块</strong></p><p><img src="/2019/12/06/16-Nginx%E5%AE%B9%E5%99%A8/9388a073-697f-4253-b903-2d36628116b2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-Worker集成协同工作的关键</title>
      <link href="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/"/>
      <url>/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个多进程程序，不同的Worker进程间如果想要共享数据，只能通过共享内存来通讯。那么Nginx中的共享内存如何使用的呢？这个问题值得研究。</p><h2 id="Nginx进程间通讯方式"><a href="#Nginx进程间通讯方式" class="headerlink" title="Nginx进程间通讯方式"></a>Nginx进程间通讯方式</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0af09836-ba26-4f41-96af-e3fb0d421a2b.jpg" alt></p><a id="more"></a><ul><li><p><strong>信号</strong>：前文也提及过。</p></li><li><p><strong>共享内存</strong>：数据同步。所谓的共享内存也就是我们打开了一个内存空间，如10M，那么一整块0-10M内存，多个Worker之间可以同时访问它，包括读取、写入等操作。为了使用好这样一块共享内存，就会引出另外两个问题。</p></li></ul><blockquote><p><strong>第一个就是锁</strong>，多个Worker进程同时操作一块内存，一定会出现竞争关系，不得不加锁。早期是基于<strong>信号量</strong>的锁，信号量是Linux中比较久远的一种进程同步方式，会导致进程进入休眠状态，即发生了主动切换。而现在大都使用的是<strong>自旋锁</strong>，当锁的条件没有满足，会一直请求。如：这块内存被Worker1使用，Worker2需要去获取锁时，只要Worker1没有释放锁，Worker2会一直在不停地去请求这把锁。<strong>自旋锁</strong>要求所有的Nginx模块必须快速的使用共享内存，即快速取锁，快速释放锁。一旦出现有的第三方模块不遵守这样的规则，就可能导致死锁。</p></blockquote><blockquote><p>一整块共享内存通常是给许多对象同时使用的，如果在模块中手动的去编写、分配内存给到不同的对象，是非常繁琐的，此时引入了<strong>Slab内存管理器</strong>。</p></blockquote><h2 id="共享内存：跨worker进程通讯"><a href="#共享内存：跨worker进程通讯" class="headerlink" title="共享内存：跨worker进程通讯"></a>共享内存：跨worker进程通讯</h2><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/456d7c90-48ea-4f21-9f96-6563bb043d8d.jpg" alt></p><p><strong>红黑树</strong> ：限速、流控场景。（插入、删除快）。</p><p><strong>单链表</strong>：将共享元素串起来。</p><p><strong>Ngx_http_lua_api</strong>：Openresty核心模块</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/685b875f-0c66-4a51-96b0-b1b4dd0626d0.jpg" alt></p><h2 id="共享内存工具-Slab管理器"><a href="#共享内存工具-Slab管理器" class="headerlink" title="共享内存工具-Slab管理器"></a>共享内存工具-Slab管理器</h2><p>上文谈到Nginx不同的Worker进程间需要共享信息时，只能通过共享内存。共享内存上可以使用链表、红黑树这样的数据结构，但每一个红黑树上有许多节点，每一个节点都需要分配内存去存放。怎样把一整块共享内存切割成小块给红黑树上的每个节点使用呢？</p><h3 id="Slab内存管理"><a href="#Slab内存管理" class="headerlink" title="Slab内存管理"></a>Slab内存管理</h3><p>详见 <strong>408 操作系统、计算机组成原理-内存管理与分配</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/edd2057b-fbb7-4724-a215-48c2d898ed15.jpg" alt></p><p><a href="http://tengine.taobao.org/document/ngx_slab_stat.html" target="_blank" rel="noopener">Tengine-Slab</a></p><p><strong>Tengine上 ngx_sla_stat:统计Slab使用状态</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/28245628-4a49-4dd0-a117-a51e6a8568ba.jpg" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/601995b6-b99a-4324-b88e-14106a22871c.png" alt></p><p>会发现没有Github地址，即没有作为一个独立模块发布出来，所以只能点击<strong>Download</strong>下载整个Tengine项目。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0f3a65a0-3276-4dd7-b396-7ea3c5338bdb.png" alt></p><p>解压后，发现tengine中多出一个modules目录，进去查看</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/eed3a379-a7f8-4379-9982-16f2b6dcc0f5.png" alt></p><p>在最后发现 <strong>ngx_slab_stat</strong>模块。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/79bcae21-d7f4-4314-ae50-33d8b9762854.png" alt></p><p>这是一个标准的第三方模块。.c文件是它的说明书。config帮助他编译进目标nginx中。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>现在回到<strong>Openresty</strong>中，让Openresty编译时将<strong>Tengine的Slab_Stat模块</strong>编译进去，然后使用Openrety下的 <strong>share_dict</strong>去分配共享内存，再用<strong>slab_state</strong>查看共享内存的使用情况。</p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/262f2390-9a34-4537-bf05-74dad3bb3775.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --add-module&#x3D;..&#x2F;tengine-2.3.2&#x2F;modules&#x2F;ngx_slab_stat&#x2F;</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/0cf928f7-a528-4746-8894-5c1d923feab3.png" alt></p><p><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/5b4305a1-3c01-4a02-a48b-2253016dc8de.png" alt></p><p><strong>set、get、slab_stat 得到信息</strong><br><img src="/2019/12/06/15-Worker%E9%9B%86%E6%88%90%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%85%B3%E9%94%AE/a8f4040f-2d4e-4b38-8d11-d882abc30425.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-Nginx连接池处理网络请求-内存池对性能的影响</title>
      <link href="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前谈到的Nginx中的读写事件，这些网络读写事件究竟是怎样的应用到Nginx上的呢？</p><p>Nginx使用了<strong>连接池</strong>来增加它对资源的利用率。</p><h2 id="Nginx通过连接池处理网络请求"><a href="#Nginx通过连接池处理网络请求" class="headerlink" title="Nginx通过连接池处理网络请求"></a>Nginx通过连接池处理网络请求</h2><p><strong>连接池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/8b0e0f0d-eddf-4830-9dfa-ac9f3c6acf40.jpg" alt></p><a id="more"></a><p>右边图中每一个Worker进程中都有一个独立的数据结构：<strong>ngx_cycle_t</strong>。其中有三个中重要的数据。</p><ul><li><strong>connection数组</strong>：即连接池，他指向的数组有多大呢？其实是有一个配置项可以查看的。512大小的数组。</li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/85000415-fd2a-4026-a7c7-58328179c6f3.jpg" alt></p><ul><li><strong>read_event数组</strong>：数组大小与上述配置一致。</li><li><strong>write_event数组</strong>：同上。</li></ul><p>三者通过序号对应，5号连接自然对应5号读写事件。</p><p><strong>核心数据结构</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c5ba5443-c176-4ef7-b010-486eebe81312.jpg" alt></p><p>一般是 235 + 96*2   （乘2是因为读写两个分配）。</p><p>rb_tree_node_t 红黑树中每个节点指向的 timer，标志读写事件是否超时。</p><p>定时器也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/59848113-bab2-42fa-ae47-d22a8a33595e.jpg" alt></p><p>ngx_queue_t 事件进队列。</p><p>右边的 <strong>off_t</strong> 可以理解为一个无符号的变量，即已经向客户端发送了多少字节。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/9c81e155-3996-4a06-9890-5d00a60de797.jpg" alt></p><p>这个也是可配置的。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/b0b1dcdf-5169-45e1-a438-1c24df64e78c.jpg" alt></p><p>在access.log中可以看到上述配置生效。<br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/c86ece93-3a3a-444d-bcb7-ae03da2b5c3d.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是 ngx_connection_t 与 ngx_event的配置。即连接与事件是怎样对应在一起的。当我们需要配置高并发的nginx时，需要将connection的数目配置的足够大。每一个connection对应的两个event（读写）都会消耗一定的内存。Nginx结构体中的许多成员与内置变量是可以对应做配置的。</p><h2 id="Nginx内存池对性能的影响"><a href="#Nginx内存池对性能的影响" class="headerlink" title="Nginx内存池对性能的影响"></a>Nginx内存池对性能的影响</h2><p>如果开发过第三方模块，会发现虽然在写C语言代码，但我们不需要关心内存的释放。如果在配置一些比较罕见的Nginx使用场景，可能需要去修改Nginx在请求和连接上初始分配的内存池大小。Nginx官方通常推荐不需要修改有关配置。究竟要不要改呢？</p><p><strong>内存池运转方式</strong><br>在上面的 <font color="red">核心数据结构</font>中，发现ngx_connection_s结构体中有一个<strong>ngx_pool_t</strong> 结构。它对应着当前连接所使用的内存池，可以通过 connection_pool_size去定义。</p><p><strong>内存池</strong><br><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/3e50c6d2-f117-49df-bc57-79dc8df8c829.jpg" alt></p><ul><li><p><strong>连接内存池</strong>上只分配一次，只要连接不关闭，分配的内存永远不需要释放，只有当关闭连接时才会释放。</p></li><li><p><strong>请求内存池</strong>：每一个HTTP请求开始分配时并不知道分配多少合适，但对于HTTP1.1 通常分配 4k大小（URL、Header往往需要这么多）。如果没有内存池，可能需要频繁而小块的分配，可能会造成内存碎片过多这样的代价。</p></li></ul><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/759a1245-2d83-43a9-b133-553b16c11061.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/1e0b5619-0a02-44af-8fda-989c9671877e.jpg" alt></p><p>当分配的内存超过 256|521 这种预分配大小时，还是可以继续分配的，这里只是提前分配空间，为了减少分配次数。</p><p>请求内存池大小</p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/93e8541a-d8a5-4616-a1ab-2a9f576d8855.jpg" alt></p><p><img src="/2019/12/05/14-Nginx%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/304ff837-d46a-4e4a-86c3-68d0c54dde1e.jpg" alt></p><p>对于连接而言，他所需要的空间很小，只需要帮助后面的请求读取最初的一部分字节就ok了，而对于请求而言，要保存大量的上下文信息（URL、Header）等。如果URL过大，可以考虑修改这个配置项。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-Nginx模块</title>
      <link href="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx之所以有如此多的特性，是因为有大量的第三方开发者在为它开发模块。Nginx之所以有这么丰富的生态圈，是因为它的模块设计十分优良。如TCP协议一样，从上个世纪70年代设计至今，没有做过大的变动。Nginx同样如此，从2004年发布后，没有发生过大的变化。</p><a id="more"></a><h2 id="Nginx模块就是什么？"><a href="#Nginx模块就是什么？" class="headerlink" title="Nginx模块就是什么？"></a>Nginx模块就是什么？</h2><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/4e23e191-595e-4e1c-a473-b1d92c0732e8.jpg" alt></p><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx开源文档</a>，如 gzip模块文档中，会有它的用法以及内置变量等。<a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html" target="_blank" rel="noopener">Nginx-gzip</a></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f286212a-ebdb-4f32-899d-7d0c6b2173e2.png" alt></p><p>有的第三方模块没有详细说明，可到 安装模块中查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;nginx&#x2F;nginx-1.16.0</span><br><span class="line"></span><br><span class="line">.&#x2F;configure</span><br><span class="line"></span><br><span class="line">之后会生成 objs文件夹</span><br><span class="line"></span><br><span class="line">cd objs</span><br><span class="line">vim ngx_module.c</span><br><span class="line"></span><br><span class="line">其中是ngx_modules数组，都是被加载进ngx中的模块</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/cf1f0e17-1b30-4c69-9839-ee34e6908b47.png" alt></p><p>如 gzip模块已经被加载进来，每一个模块在 *<em>/usr/local/geek/nginx/nginx-1.16.0/src/http/modules<br>*</em>中都会有对应的 .c文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http_gzip_filter_module.c</span><br></pre></td></tr></table></figure><p>在每一个源文件中，都会由 ngx_command_t 这样一个唯一的结构体。</p><p>该结构体是一个数组，其中的元素是它所支持的指令名，参数名、参数类型等等参考文档。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/8925c799-45a5-4fc5-a28c-4d947eaf2c5a.png" alt></p><p><strong>Nginx模块</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/92a824bb-768f-4e0a-94d0-127e5091f5e4.jpg" alt></p><h2 id="Nginx模块的分类"><a href="#Nginx模块的分类" class="headerlink" title="Nginx模块的分类"></a>Nginx模块的分类</h2><p>针对不同的应用场景，Nginx会细分为不同的子模块。在特定的复杂的应用场景下，这些子模块会增加许多新的特性和功能。</p><p><strong>Nginx模块分类</strong><br><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/10ed37f5-43f0-43dd-a089-416575abc55b.jpg" alt></p><p><strong>/usr/local/geek/nginx/nginx-1.16.0/src目录下</strong></p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/fcfe9d98-d06e-44e7-a821-85cfc3d17eef.png" alt></p><p><strong>core目录</strong>：仅仅是Nginx的核心框架代码，并不是Nginx的 Core Module。</p><p><strong>event、http、mail、stream</strong>则是对应的子类型模块。</p><p>以最复杂的<strong>http</strong>为例</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/6003a348-cd71-423c-b7e7-ed9cf983e0f1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ngx_http.c</span><br><span class="line"></span><br><span class="line">&#x2F;ngx_module_t </span><br><span class="line">可以看到类型type是 ngx_core_module</span><br></pre></td></tr></table></figure><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/f23c4bbb-17b5-470e-b0ab-e81187cd3ee0.png" alt></p><p>官方提供的都是在上述目录下，非官方提供的在 modules目录下。</p><p><img src="/2019/12/04/13-Nginx%E6%A8%A1%E5%9D%97/7f92c21d-6a1b-4770-874e-672773ea4d9b.png" alt></p><p>上述模块大概分为 3 类：</p><p>处理请求、生成响应 + 响应过滤 + 与上游服务器交互（负载均衡等工作）</p><p>响应过滤的名称有<strong>filter</strong>关键字。</p><p>与上游服务器交互的有<strong>upstream</strong>关键字。</p><p>其它模块都是生成响应或为生成响应而工作的。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-网络收发与Nginx事件模型</title>
      <link href="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是一个<strong>事件驱动</strong>的框架。事件主要指的是<strong>网络事件</strong>。Nginx每个连接会自然对应两个网络事件，<strong>读事件</strong> 与 <strong>写事件</strong>。因此，我们在深入了解Nginx的各种原理以及它在极端场景下的各种错误处理时，必须首先理解什么是网络事件。</p><a id="more"></a><h2 id="网络收发"><a href="#网络收发" class="headerlink" title="网络收发"></a>网络收发</h2><p><strong>网络传输</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/bd0ed4ad-9ab4-4f02-b787-cd11c0157c85.jpg" alt></p><p><strong>TCP流与报文</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/7f4caf3e-3802-450c-958a-7cce48864829.jpg" alt></p><p><strong>TCP协议与非阻塞接口</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/04d4fa8e-bcb4-42d2-bd74-5901fab6af91.jpg" alt></p><h2 id="Nginx网络事件实例演示"><a href="#Nginx网络事件实例演示" class="headerlink" title="Nginx网络事件实例演示"></a>Nginx网络事件实例演示</h2><p>访问 116.62.160.193:8080 这是一个之前搭建的Nginx-Web静态资源服务器.</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/e446f920-ae60-4cc9-9698-02daad34ba0f.jpg" alt></p><p>同时要安装 Wireshark网络抓包器。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/ba356c5e-97af-4987-9957-452919556294.jpg" alt></p><p>TCP三次握手时会发送 <strong>SYN、SYN+ACK、ACK包</strong></p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/1442eeeb-7de3-4a6e-a140-b30a86df688d.jpg" alt></p><p><strong>TCP</strong>层主要是做进程与进程间的通讯，本地打开1875端口，远程是8080端口</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/597d3231-48b6-4424-8a89-a25bfad8fbe2.jpg" alt></p><p><strong>IP层</strong>主要解决机器之间互相找到的问题。本地IP是 192.168.74.142，远端Nginx所在IP是 116.62.160.193</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/78f77e0d-0a29-479f-b894-5d946f30d640.jpg" alt></p><h2 id="Nginx事件驱动模型"><a href="#Nginx事件驱动模型" class="headerlink" title="Nginx事件驱动模型"></a>Nginx事件驱动模型</h2><p>在了解了网络事件以及事件分发、收集器后，再来学习Nginx是如何处理事件的。</p><p><strong>Nginx事件循环</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/875ec507-3b0b-462b-891e-6045caf65664.jpg" alt></p><p>流程：<br>当Nginx刚刚启动时，处于 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态，即我们打开了80、443端口后，等待新的事件进来（如新的客户端连上了Nginx,向我们发起了连接）。这一步对应着 epoll中的 epoll_wait方法。Nginx是处于<strong>Sleep</strong>进程状态。</p><p>当操作系统收到了一个建立连接的TCP握手报文并处理完成后，操作系统就会通知epoll_wait阻塞方法，告之可以往下走了（找操作系统要事件），并且唤醒我们的Nginx-Worker进程。</p><p>Kernel 即操作系统内核会将事件放入到事件队列中。从事件队列中，Nginx可以获取到要处理事件，如 建立连接、TCP请求报文等。取出来后就会处理对应的事件，进入 <strong>PROCESS THE EVENTS QUEUE CIRCLE</strong>，即右边的图。</p><p>队列不为空，就将事件取出来进行处理。在处理事件的过程中可能会生成一些新的事件（如：新连接建立，要设置一个超时时间，超时时间后，浏览器不向我发送新的请求，我就关闭它。又比如：当收完完整的HTTP请求后，可以进行HTTP响应了，这个响应是需要我可以向操作系统的写缓存区中把响应写进来的，要求操作系统尽快把这样一段写的内容发回给浏览器，即期待一个写事件等等）。</p><p>所有的事件处理完成后，又会返回到 <strong>WAIT FOR EVENTS ON CONNECTIONS</strong>状态。</p><p><strong>知道上述流程的好处：</strong><br>一些第三方模块可能会做大量的CPU运算，此类计算任务会导致我处理一个事件的时间非常长，在上述流程图中会导致后续队列中的大量事件长时间得不到处理。从而引发恶性循环，他们的超时时间可能到了，CPU都消耗到处理连接不正常的断开。</p><p>有些第三方模块长时间的消耗大量CPU进行计算任务，这是Nginx不能容忍的。gzip等模块不会一次使用大量的CPU，而是分段使用。</p><h2 id="epoll的优势及原理"><a href="#epoll的优势及原理" class="headerlink" title="epoll的优势及原理"></a>epoll的优势及原理</h2><p>上面讨论到了Nginx事件分发机制，最关键的就是Nginx怎样快速的从操作系统的Kernel中获取到等待处理的事件。这一步经历了很长时间的解决。当下Nginx主要是使用epoll网络事件收集器模型。</p><p><strong>各个模型性能对比</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/b1948077-bc41-410e-ad9a-78281102880f.jpg" alt></p><p><strong>epoll</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/9ee0a593-037f-4c48-b96a-6e1583f5bd92.jpg" alt></p><h2 id="Nginx请求切换场景使用epoll带来的争议"><a href="#Nginx请求切换场景使用epoll带来的争议" class="headerlink" title="Nginx请求切换场景使用epoll带来的争议"></a>Nginx请求切换场景使用epoll带来的争议</h2><p><strong>请求切换</strong></p><p>传统服务依赖OS，处理大量连接时很困难。<br>Nginx用户态即可完成切换。除非Nginx-Worker时间片到了（5ms-800ms），才会依赖OS切换，因此往往将Nginx-Worker优先级加到最高（-19），操作系统分配的时间片往往是最大的。这样能比较好的在用户态完成进程切换，使得CPU少做无用功。</p><p><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/f88e575b-fd29-4890-90ad-9a1e9a33f41c.jpg" alt></p><h2 id="同步-amp-异步-阻塞-amp-非阻塞之间的区别"><a href="#同步-amp-异步-阻塞-amp-非阻塞之间的区别" class="headerlink" title="同步&amp;异步 阻塞&amp;非阻塞之间的区别"></a>同步&amp;异步 阻塞&amp;非阻塞之间的区别</h2><p>同步是两个对象之间的关系，而阻塞是一个对象的状态。</p><p>阻塞可以是实现同步的一种手段！例如两个东西需要同步，一旦出现不同步情况，我就阻塞快的一方，使双方达到同步。</p><p><strong>阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/52aa1fc5-cf86-4aff-9cb5-aa70a6c11518.jpg" alt></p><p><strong>非阻塞调用</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/4f1b1ce6-f00d-4303-83f4-c54520ef08e2.jpg" alt></p><p><strong>非阻塞调用下的同步与异步</strong><br><img src="/2019/12/03/12-%E7%BD%91%E7%BB%9C%E6%94%B6%E5%8F%91%E4%B8%8ENginx%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/03334dfa-1e2a-4510-955a-08cd8528e1c8.jpg" alt></p><p><strong>四种组合方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步阻塞方式： </span><br><span class="line">发送方发送请求之后一直等待响应。 </span><br><span class="line">接收方处理请求时进行的IO操作如果不能马上等到返回结果，就一直等到返回结果后，才响应发送方，期间不能进行其他工作。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步非阻塞方式： </span><br><span class="line">发送方发送请求之后，一直等待响应。</span><br><span class="line">接受方处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，取做其他事情。 </span><br><span class="line">但是由于没有得到请求处理结果，不响应发送方，发送方一直等待。</span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方，发送方才进入下一次请求过程。（实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">异步阻塞方式：</span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。</span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应发送方，期间不能进行其他操作。 （实际不应用）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步非阻塞方式： </span><br><span class="line">发送方向接收方请求后，不等待响应，可以继续其他工作。 </span><br><span class="line">接收方处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 </span><br><span class="line">当IO操作完成以后，将完成状态和结果通知接收方，接收方再响应发送方。（效率最高）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-Nginx架构_相关流程</title>
      <link href="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>为什么要讨论Nginx的架构技术呢？</strong></p><p>因为Nginx运行在企业内网的最外层-边缘节点，它处理的流量是其他应用服务器的几个数量级。任何一种问题在不同的场景下解决方式不尽相同。因此，Nginx处理问题时的难度会被放大，我们有必要熟知:</p><p><font color="red">为什么Nginx采用<strong>Master-Worker</strong>这样一种架构模型</font><br><font color="red">为什么Worker进程的数量要与CPU的核数相匹配</font><br><font color="red">在多个Worker之间共享数据时，为什么在TLS或者限流、限速场景下的共享方式是有所不同的。</font></p><p>这些都需要我们对Nginx架构有一个清晰的了解。</p><a id="more"></a><h2 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h2><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/bd9bd159-e718-4206-9d7e-1e9a460c9bcb.jpg" alt></p><p>网络大致有三种流量 Web、Email、TCP 。</p><p>三种状态机：处理Tcp/Ip的第四层状态机、HTTP应用层状态机、mail邮件状态机。为什么需要状态机呢？因为Nginx中是使用 <strong>非阻塞的事件驱动处理引擎</strong>来工作的，即<strong>Epoll</strong>，当使用异步时，通常需要用状态机将请求正确的识别处理。</p><h2 id="Nginx进程结构"><a href="#Nginx进程结构" class="headerlink" title="Nginx进程结构"></a>Nginx进程结构</h2><h3 id="1-单进程结构"><a href="#1-单进程结构" class="headerlink" title="1 单进程结构"></a>1 单进程结构</h3><p>不适用于生产环境，只适合做开发、调试。<br>生产环境要保持Nginx足够健壮，同时发挥Nginx可利用多核的特性。</p><p><font color="red">默认配置都是打开多进程Nginx</font></p><h3 id="2-多进程结构"><a href="#2-多进程结构" class="headerlink" title="2 多进程结构"></a>2 多进程结构</h3><p><strong>为什么是多进程而不是多线程呢？</strong></p><p>Nginx要保证它的高可用性、高可靠性。当Nginx使用多线程结构时，因为线程间是共享同一个地址空间的，当某一个第三方模块引发了地址空间的越界时，会导致整个nginx进程挂掉。多进程结构则不会出现上述问题。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/d2ec02bd-fac8-40f1-9343-b1f7a8d4aa25.jpg" alt></p><p>Nginx在做进程设计时，同样遵循了高可用、高可靠原则。</p><p><strong>在Master进程中</strong>，通常第三方模块是不会在这里加入自己的功能代码的。<br>虽然Nginx在设计时，允许第三方模块在Master进程中，添加自己独有的自定义的一些方法，但是第三方模块通常不会这么做。</p><p><strong>Master进程</strong>是被设计用来做 <strong>Worker进程</strong>的管理的。</p><p><strong>Worker进程</strong>是真正处理请求的，而Master进程是负责监控每个Worker进程是否正常工作、需不需要重新载入配置文件、热部署等。</p><p><strong>缓存</strong>是在多个Worker进程间共享，而且还要被 <strong>Cache Manager/loader进程</strong>使用。</p><p><strong>Cache Manager/loader进程</strong>是为反向代理时后端发过来的动态请求做缓存负责的。Manager负责缓存的管理。 Loader负责缓存的载入。</p><p>实际上每一个请求处理时用到的缓存还是由Worker进程响应的。</p><p>进程间的通讯都是使用共享内存解决。</p><p><strong>为什么worker进程很多呢？</strong></p><p>Nginx采用事件驱动模型后，希望每一个Worker进程从头到尾占有一颗CPU，因此，通常不仅要把Worker进程数量与服务器上的CPU核数一致，还要把每一个Worker进程与它对应的CPU绑定在一起。可以更好地使用每颗CPU核上对应的CPU缓存来减少缓存失效的命中率。</p><h3 id="3-多进程结构实例演示"><a href="#3-多进程结构实例演示" class="headerlink" title="3 多进程结构实例演示"></a>3 多进程结构实例演示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">进入 openstry的安装目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx</span><br><span class="line"></span><br><span class="line">vim config&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">修改 从1 到2（此处只为演示）</span><br><span class="line">worker_process 2</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line">sbin&#x2F;nginx -c config&#x2F;nginx.conf</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><h4 id="1-首次查看"><a href="#1-首次查看" class="headerlink" title="1 首次查看"></a>1 首次查看</h4><p>第一次：1个master(12906) + 2个worker(父进程是12906，即master进程)</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9ccf4f35-8fe8-4f1d-b7a7-fa4181171712.png" alt></p><p>现在使用 -s reload 会将之前的 worker + cache进程 优雅的退出，重载新的配置项，新起新的 worker 与  cache进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sbin&#x2F;nginx -s reload</span><br><span class="line"></span><br><span class="line">worker 进程号与上述已经不同，证明是新起的worker进程，同时他们的父进程ID 依然是 12906</span><br></pre></td></tr></table></figure><h4 id="2-reload后查看"><a href="#2-reload后查看" class="headerlink" title="2 reload后查看"></a>2 reload后查看</h4><p>第二次：master不变，worker 新起<br><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/7bc1fe02-d57d-4ea4-87b5-476b8721fd82.png" alt></p><h4 id="3-发送hup信号查看"><a href="#3-发送hup信号查看" class="headerlink" title="3 发送hup信号查看"></a>3 发送hup信号查看</h4><p>第三次： reload 与 hup的作用相同,现在向 12906的 master进程发送 hup信号，结果依然相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGHUP 12906</span><br></pre></td></tr></table></figure><p>master进程依然没有变，worker进程是新起的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/fe405a29-14c4-4e24-acd4-27bd1e762a4b.png" alt></p><h4 id="4-quit、stop信号查看"><a href="#4-quit、stop信号查看" class="headerlink" title="4 quit、stop信号查看"></a>4 quit、stop信号查看</h4><p>第四次：向一个 worker进程发送 quit信号，该worker进程再退出的同时，会自动的向他的父进程 12906 发送一个CHLD退出信号，master进程收到信号后，会新起一个worker进程，维持worker进程的进程结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigterm 退出信号</span><br><span class="line"></span><br><span class="line">kill -SIGTERM 13041</span><br></pre></td></tr></table></figure><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/0d2af2bd-d80e-4343-a21e-fba21550e359.png" alt></p><p>因此，<strong>命令行中的需多子命令，就是向Master进程发送信号而已。</strong></p><h3 id="4-进程模型"><a href="#4-进程模型" class="headerlink" title="4 进程模型"></a>4 进程模型</h3><p><strong>进程</strong></p><p>master、worker、cache manager、cache loader</p><p><strong>通讯方式</strong></p><p>信号：TERM、INT、QUIT、HUP、USR1、USR2、WINCH</p><p>共享内存：slab内存管理、互斥锁</p><h3 id="5-信号管理Nginx父子进程"><a href="#5-信号管理Nginx父子进程" class="headerlink" title="5 信号管理Nginx父子进程"></a>5 信号管理Nginx父子进程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/442e24b0-cc0b-48df-ab6a-169534de3cfd.jpg" alt></p><p><strong>Master进程</strong></p><ul><li><p><strong>CHLD</strong>：当worker进程因为某些bug而停止工作时，它在退出时会向Master进程发送 CHLD信号，Master进程可以立刻通过 CHLD信号发现问题，重新拉起一个Worker进程。</p></li><li><p><strong>TERM，INT</strong>：立刻停止Nginx进程</p></li><li><p><strong>QUIT</strong>：优雅的停止Nginx进程</p></li><li><p><strong>HUP</strong>：重载配置文件</p></li><li><p><strong>USR1</strong>：重新打开日志文件，做日志文件的切割</p></li></ul><p>以上可以直接在 Nginx命令行 + 特定命令 向Master进程发送。</p><p>下面两个 只能通过 Linux中的  kill + 命令发送给Master进程，即先找到 Master的 PID，对 PID 发送信号。</p><ul><li><p><strong>USR2</strong>：热部署时使用</p></li><li><p><strong>WINCH</strong>：热部署时使用</p></li></ul><p><strong>Worker进程</strong></p><p>通常是不会直接对Worker进程发送相应的信号的，应该将信号发送给Master进程，由Master进程管控Worker进程。</p><p><strong>Nginx命令行</strong></p><p>当启动Nginx后，Nginx会将它的 PID 记录到 Nginx安装目录的 logs文件夹下的 Nginx.pid文件中，记录了 Master进程的PID，再次执行 nginx -s 时，Nginx命令行会读取 Nginx.pid，向Master进程所在的PID同样的去发送对应的信号。</p><p><font color="red">综上，命令行与发送信号本质是一致的</font></p><h2 id="reload重载配置文件流程"><a href="#reload重载配置文件流程" class="headerlink" title="reload重载配置文件流程"></a>reload重载配置文件流程</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当我们更改了 <strong>nginx.conf</strong> 配置文件后，再次启动时都会执行 <strong>-s reload</strong> 命令。</p><p><strong>好处：</strong>Nginx不停止服务，始终在处理新的请求，同时把Nginx的配置文件平滑的从旧的 nginx.conf 更新为新的 nginx.conf。</p><p>有时在执行完后，发现Nginx的 <strong>Worker进程</strong>变多了，这是因为老的 配置所运行的 Nginx-Worker进程长时间没有退出，当使用 stream做4层反向代理时可能会更多。</p><h3 id="reload流程"><a href="#reload流程" class="headerlink" title="reload流程"></a>reload流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b0a2b9a6-281b-4474-b39b-b7ca834ffa2f.jpg" alt></p><p>第3步：因为所有的子进程会继承父进程已经打开的端口。</p><p>第4-5步：是为了平滑过渡，先创建新的，在慢慢关闭老的。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/9b6e6e8a-d5f8-46ef-a03c-48344fe5c7ad.jpg" alt></p><p>当有些绿色的 老 worker进程因为一些bug，长时间不退出时，也只会影响已存在的连接，不会影响新的连接。如何处理这些异常存活的worker进程呢</p><p>Nginx新的版本中，提供了一个配置项，称为 worker shutdown timeout<br>，即超时时间；Master进程在启动 黄色的 新的 Worker进程时，会为老的绿色的Worker进程加上一个 定时器，超时后，将依然存在的老的Worker进程强制退出掉。</p><h2 id="热升级完整过程"><a href="#热升级完整过程" class="headerlink" title="热升级完整过程"></a>热升级完整过程</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><p>在Nginx不停止服务的情况下，做版本的更新。但也会遇到新的问题，如：</p><ul><li><p>老的Worker进程一直退不掉。</p></li><li><p>新的Worker进程起来后出现了问题，考虑回滚等。</p></li><li><p>使用了新的Nginx.conf配置文件后，发现好多功能出现了错误，只能回滚等。</p></li></ul><h3 id="热升级流程"><a href="#热升级流程" class="headerlink" title="热升级流程"></a>热升级流程</h3><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/43851d55-23fc-4e2e-876d-4d13226725f8.jpg" alt></p><p><strong>第一步</strong>：<br>将旧的 binary文件替换为新的 binary文件。之所以只替换binary文件，是因为在大部分场景下，我们新编译的Nginx文件所指定的配置选项（配置文件的目录在哪里，logs文件所在的目录在哪里），必须保持和老的Nginx是一致的，否则无法使用 nginx.conf文件。替换时要注意备份，同时，新版本的Linux中，要求覆盖一个正在使用的文件时，需要这样写命令<strong>cp -f</strong></p><p><strong>第二步</strong>：<br>向老的Master进程发送 USR2信号。此时我们是没有办法通过Nginx命令行直接用 <strong>nginx -s</strong>这个信号来处理，这是因为Nginx到目前为止还没有持这样的信号。</p><p><strong>第三步</strong>：<br>老的Master进程为了给新的Master让路，修改自己的pid文件名，以方便新的Master进程创建自己的PID文件。</p><p><strong>第四步</strong>：<br>新的Master进程起来后，会出现新老Master、老的Worker同时存在的情况。新的Master会去拉起新的Worker进程。</p><p><strong>第五步</strong>：</p><p>通过查看 .oldbin 或者 ps -ef|grep nginx 查看老的Master进程号，以便向他发送WINCH信号。老的Master会优雅关闭老Worker进程。热升级已经完成。<strong>但是老的Master进程会一直存在，方便回滚</strong>。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/b1685e4b-8e80-4a2a-baa2-b9f977363671.jpg" alt></p><p>新的Master进程是 老的Master进程的子进程。新的使用了新的binary来载入的。新老并存时，老的会在处理完请求后，关闭自己监听的端口，优雅的退出。完成后，就只剩下新的Master+Worker进程。</p><h2 id="优雅关闭Worker进程"><a href="#优雅关闭Worker进程" class="headerlink" title="优雅关闭Worker进程"></a>优雅关闭Worker进程</h2><p><strong>nginx - stop</strong> : 立即停止Nginx。<br><strong>nginx - quit</strong> : 优雅关闭Nginx。<br>在上面的热部署、reload时都是优雅的停止Nginx，那他的过程如何呢？</p><p>优雅的关闭：即Nginx的worker进程可以识别出当前的连接没有正在处理请求，此时再次关闭它。能不能做到这一点呢？</p><p>对于有些请求，Nginx是做不到的。如：</p><ul><li><p>Nginx代理 <strong>Web Socket</strong>协议时，在Web Socket通讯的 Frame帧中，Nginx是不解析这个帧的是没有办法识别的。</p></li><li><p>Nginx做TCP、UDP层的反向代理时，是没有办法识别一个请求需要经历多少报文才算是结束。</p></li></ul><p>对于<font color="red"> <strong>HTTP</strong></font>请求是可以识别的。因此，优雅的关闭，主要针对HTTP请求。</p><p><img src="/2019/12/02/11-Nginx%E6%9E%B6%E6%9E%84-%E7%9B%B8%E5%85%B3%E6%B5%81%E7%A8%8B/f4bde9ab-dc0d-4741-baa5-25d0fffe95c9.jpg" alt></p><p><strong>第一步</strong>：<br>设置完定时器后，会加一个标志位，表示现在进入优雅的关闭流程了。</p><p><strong>第二步</strong>：<br>保证所在的Worker进程不会再去处理新的连接。</p><p><strong>第三步</strong>：<br>查看Nginx的连接池，Nginx为了保证对资源的充分利用，经常会保持一些空闲连接不断开。此时会关闭所有的空闲连接。</p><p><strong>第四步</strong>：<br>用时可能会超过第一步 worker_shutdonw_timeout设置的时间。一旦超时，即使请求还没有处理完，依然会强制关闭连接。优雅的关闭只完成一半，有一部分是立即停止。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkedHashMap实现原理_探险</title>
      <link href="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.)</p><p>从注释中，我们可以先了解到 LinkedHashMap 是通过哈希表和链表实现的，它通过 维护一个链表来保证对哈希表迭代时的有序性，而这个有序是指键值对插入的顺序。 <a id="more"></a>另外，当向哈希表中重复插入某个键的时候，不会影响到原来的有序性。也就是说， 假设你插入的键的顺序为 1、2、3、4，后来再次插入 2，迭代时的顺序还是 1、2、 3、4，而不会因为后来插入的 2 变成 1、3、4、2。（但其实我们可以改变它的规则， 使它变成 1、3、4、2）</p><p>LinkedHashMap 的实现主要分两部分，一部分是哈希表，另外一部分是链表。哈希 表部分继承了 HashMap，拥有了 HashMap 那一套高效的操作，所以我们要看的就是 LinkedHashMap 中链表的部分，了解它是如何来维护有序性的。</p><p>LinkedHashMap 的大致实现如下图所示，当然链表和哈希表中相同的键值对都是指 向同一个对象，这里把它们分开来画只是为了呈现出比较清晰的结构。</p><p><img src="/2019/11/28/LinkedHashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/123e5c16-da83-4e2b-99ca-ac014847a73a.jpg" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>在看属性之前，我们先来看一下 LinkedHashMap 的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; imple ments Map&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>从上面的声明中，我们可以看见 LinkedHashMap 是继承自 HashMap 的，所以它已 经从 HashMap 那里继承了与哈希表相关的操作了，那么在 LinkedHashMap 中，它 可以专注于链表实现的那部分，所以与链表实现相关的属性如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;LinkedHashMap 的链表节点继承了 HashMap 的节点，而且每个节点都包含</span><br><span class="line">了前指针和后指针，所以这里可以看出它是一个双向链表</span><br><span class="line">static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;头指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尾指针</span><br><span class="line">transient LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认为 false。当为 true 时，表示链表中键值对的顺序与每个键的插入顺</span><br><span class="line">序一致，也就是说重复插入键，也会更新顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;简单来说，为 false 时，就是上面所指的 1、2、3、4 的情况；为 true 时，</span><br><span class="line">就是 1、3、4、2 的情况</span><br><span class="line"></span><br><span class="line">final boolean accessOrder;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><p>如果仔细看过 HashMap 源码的话，会发现 HashMap 中有如下三个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions</span><br><span class="line"></span><br><span class="line">void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line"></span><br><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果没有注意到注释的解释的话，可能会很奇怪为什么会有三个空方法，而且 有不少地方还调用过它们。其实这三个方法表示的是在访问、插入、删除某个节点 之后，进行一些处理，它们在 LinkedHashMap 都有各自的实现。LinkedHashMap 正 是通过重写这三个方法来保证链表的插入、删除的有序性。</p><h2 id="1-afterNodeAccess方法"><a href="#1-afterNodeAccess方法" class="headerlink" title="1 afterNodeAccess方法"></a>1 afterNodeAccess方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    &#x2F;&#x2F;当 accessOrder 的值为 true，且 e 不是尾节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的意思简洁明了，就是把当前节点 e 移至链表的尾部。因为使用的是双向 链表，所以在尾部插入可以以 O（1）的时间复杂度来完成。并且只有当accessOrder<br>设置为 true 时，才会执行这个操作。在 HashMap 的 putVal 方法中，就调用了这个 方法。</p><h2 id="2-afterNodeInsertion方法"><a href="#2-afterNodeInsertion方法" class="headerlink" title="2 afterNodeInsertion方法"></a>2 afterNodeInsertion方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remov e eldest</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntr y(first)) &#123;</span><br><span class="line">        K key &#x3D; first.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>afterNodeInsertion 方法是在哈希表中插入了一个新节点时调用的，它会把链表的头 节点删除掉，删除的方式是通过调用 HashMap 的 removeNode 方法。想一想，通过 afterNodeInsertion 方法和 afterNodeAccess 方法，是不是就可以简单的实现一个基于 最近最少使用（LRU）的淘汰策略了？当然，我们还要重写 removeEldestEntry 方法， 因为它默认返回的是 false。</p><h2 id="3-afterNodeRemoval方法"><a href="#3-afterNodeRemoval方法" class="headerlink" title="3 afterNodeRemoval方法"></a>3 afterNodeRemoval方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.aft er;</span><br><span class="line">    p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">    if (b &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; a;</span><br><span class="line">    else</span><br><span class="line">        b.after &#x3D; a;</span><br><span class="line">    if (a &#x3D;&#x3D; null)</span><br><span class="line">        tail &#x3D; b;</span><br><span class="line">    else</span><br><span class="line">        a.before &#x3D; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是当 HashMap 删除一个键值对时调用的，它会把在 HashMap 中删除的那 个键值对一并从链表中删除，保证了哈希表和链表的一致性。 </p><h2 id="4-get方法"><a href="#4-get方法" class="headerlink" title="4 get方法"></a>4 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    if ((e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null)</span><br><span class="line">        return null;</span><br><span class="line">    if (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    return e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>，LinkedHashMap 的 get 方法就是这么简单，因为它调用的是 HashMap 的 getNode 方法来获取结果的。并且，如果你把 accessOrder 设置为 true，那么在获取到值之后，还会调用 afterNodeAccess 方法。这样是不是就能保证一个 LRU 的算法了.</p><h2 id="5-put和remove方法"><a href="#5-put和remove方法" class="headerlink" title="5 put和remove方法"></a>5 put和remove方法</h2><p>在 LinkedHashMap 的源码中没有找到 put 方法，这就说明了它并没有重写 put 方 法，所以我们调用的 put 方法其实是 HashMap 的 put 方法。因为 HashMap 的 put 方 法中调用了 afterNodeAccess 方法和 afterNodeInsertion 方法，已经足够保证链表的有 序性了，所以它也就没有重写 put 方法了。remove 方法也是如此。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashTable实现原理_探险</title>
      <link href="/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/22/HashTable%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>Hashtable 可以说已经具有一定的历史了，现在也很少使用到 Hashtable 了，更多的是使 用 HashMap 或 ConcurrentHashMap。HashTable 是一个线程安全的哈希表，它通过使用 synchronized 关键字来对方法进行加锁，从而保证了线程安全。但这也导致了在单线程 环境中效率低下等问题。Hashtable 与 HashMap 不同，它不允许插入 null 值和 null 键。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><p>Hashtable 并没有像 HashMap 那样定义了很多的常量，而是直接写死在了方法里（看下 去就知道了），所以它的属性相比 HashMap 来说，可以获取的信息还是比较少的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">private transient Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记录哈希表中键值对的个数</span><br><span class="line">private transient int count;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;扩容的阈值</span><br><span class="line">private int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">private float loadFactor;</span><br></pre></td></tr></table></figure><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+l oadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity&#x3D;&#x3D;0)</span><br><span class="line">        initialCapacity &#x3D; 1;</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    table &#x3D; new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    threshold &#x3D; (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0.75f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Hashtable() &#123;</span><br><span class="line">    this(11, 0.75f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二话不说，上来先丢了三个构造函数。从构造函数中，我们可以获取到这些信息： Hashtable默认的初始化容量为11（与HashMap不同），负载因子默认为0.75（与HashMap 相同）。而正因为默认初始化容量的不同，同时也没有对容量做调整的策略，所以可以 先推断出，Hashtable 使用的哈希函数跟 HashMap 是不一样的（事实也确实如此）。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V get(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;通过哈希函数，计算出 key 对应的桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#x2F;&#x2F;遍历该桶的所有元素，寻找该 key</span><br><span class="line">    for (Entry&lt;?,?&gt; e &#x3D; tab[index] ; e !&#x3D; null ; e &#x3D; e.next) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            return (V)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟 HashMap 相比，Hashtable 的 get 方法非常简单。我们首先可以看见 get 方法使用了 synchronized 来修饰，所以它能保证线程安全。并且它是通过链表的方式来处理冲突的。 另外，我们还可以看见 HashTable 并没有像 HashMap 那样封装一个哈希函数，而是直接 把哈希函数写在了方法中。而哈希函数也是比较简单的，它仅对哈希表的长度进行了取模。</p><h2 id="3-put方法"><a href="#3-put方法" class="headerlink" title="3 put方法"></a>3 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; Make sure the value is not null</span><br><span class="line">    if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    &#x2F;&#x2F;计算桶的位置</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    &#x2F;&#x2F;遍历桶中的元素，判断是否存在相同的 key</span><br><span class="line">    for(; entry !&#x3D; null ; entry &#x3D; entry.next) &#123;</span><br><span class="line">        if ((entry.hash &#x3D;&#x3D; hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old &#x3D; entry.value;</span><br><span class="line">            entry.value &#x3D; value;</span><br><span class="line">            return old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;不存在相同的 key，则把该 key 插入到桶中</span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    &#x2F;&#x2F;哈希表的键值对个数达到了阈值，则进行扩容</span><br><span class="line">    if (count &gt;&#x3D; threshold) &#123;</span><br><span class="line">        &#x2F;&#x2F; Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab &#x3D; table;</span><br><span class="line">        hash &#x3D; key.hashCode();</span><br><span class="line">        index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    &#x2F;&#x2F;把新节点插入桶中（头插法）</span><br><span class="line">    tab[index] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>put 方法一开始就表明了不能有 null 值，否则就会向你抛出一个空指针异常。Hashtable 的 put 方法也是使用 synchronized 来修饰。你可以发现，在 Hashtable 中，几乎所有的方 法都使用了 synchronized 来保证线程安全。</p><h2 id="4-remove方法"><a href="#4-remove方法" class="headerlink" title="4 remove方法"></a>4 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V remove(Object key) &#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] &#x3D; table;</span><br><span class="line">    int hash &#x3D; key.hashCode();</span><br><span class="line">    int index &#x3D; (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    for(Entry&lt;K,V&gt; prev &#x3D; null ; e !&#x3D; null ; prev &#x3D; e, e &#x3D; e.nex t) &#123;</span><br><span class="line">        if ((e.hash &#x3D;&#x3D; hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            if (prev !&#x3D; null) &#123;</span><br><span class="line">                prev.next &#x3D; e.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                tab[index] &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; null;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rehash方法"><a href="#rehash方法" class="headerlink" title="rehash方法"></a>rehash方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity &#x3D; table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap &#x3D; table;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;扩容扩为原来的两倍+1</span><br><span class="line">    int newCapacity &#x3D; (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    &#x2F;&#x2F;判断是否超过最大容量</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        if (oldCapacity &#x3D;&#x3D; MAX_ARRAY_SIZE)</span><br><span class="line">            &#x2F;&#x2F; Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">            return;</span><br><span class="line">        newCapacity &#x3D; MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap &#x3D; new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F;计算下一次 rehash 的阈值</span><br><span class="line">    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAX_ARRA Y_SIZE + 1);</span><br><span class="line">    table &#x3D; newMap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;把旧哈希表的键值对重新哈希到新哈希表中去</span><br><span class="line">    for (int i &#x3D; oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old &#x3D; (Entry&lt;K,V&gt;)oldMap[i] ; old !&#x3D; null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e &#x3D; old;</span><br><span class="line">            old &#x3D; old.next;</span><br><span class="line"></span><br><span class="line">            int index &#x3D; (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next &#x3D; (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] &#x3D; e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hashtable 的 rehash 方法相当于 HashMap 的 resize 方法。跟 HashMap 那种巧妙的 rehash 方式相比，Hashtable 的 rehash 过程需要对每个键值对都重新计算哈希值，而比起异或 和与操作，取模是一个非常耗时的操作，所以这也是导致效率较低的原因之一。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap实现原理_探险</title>
      <link href="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息<br>Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p><p>大致意思是：这个哈希表是基于 Map 接口的实现的，它允许 null 值和 null 键，它不是线程同步的，同时也不保证有序。</p><a id="more"></a><p>This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the “capacity” of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it’s very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.  An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p><p>大意：讲的是 Map 的这种实现方式为 get （取）和 put（存）带来了比较好的性能。但是如果涉及到大量的遍历操作的话，就 尽量不要把 capacity 设置得太高（或 load factor 设置得太低），否则会严重降低遍历的效率。</p><p>影响 HashMap 性能的两个重要参数：“initial capacity”（初始化容量）和”load factor“（负载因子）。简单来说，容量就是哈希表桶的个数，负载因子就是键值对 个数与哈希表长度的一个比值，当比值超过负载因子之后，HashMap 就会进行 rehash 操作来进行扩容。</p><p>HashMap 的大致结构如下图所示，其中哈希表是一个数组，我们经常把数组中的每 一个节点称为一个桶，哈希表中的每个节点都用来存储一个键值对。在插入元素时， 如果发生冲突（即多个键值对映射到同一个桶上）的话，就会通过链表的形式来解 决冲突。因为一个桶上可能存在多个键值对，所以在查找的时候，会先通过 key 的<br>哈希值先定位到桶，再遍历桶上的所有键值对，找出 key 相等的键值对，从而来获 取 value。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0f32057b-e876-449b-99ec-fbcf3b3bbcce.png" alt></p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认的初始容量为 16</span><br><span class="line">static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最大的容量上限为 2^30</span><br><span class="line">static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的负载因子为 0.75 </span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变成树型结构的临界值为 8</span><br><span class="line">static final int TREEIFY_THRESHOLD &#x3D; 8;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;恢复链式结构的临界值为 6</span><br><span class="line">static final int UNTREEIFY_THRESHOLD &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表中键值对的个数</span><br><span class="line">transient int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;哈希表被修改的次数</span><br><span class="line">transient int modCount;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;它是通过 capacity*load factor 计算出来的，当 size 到达这个值时，</span><br><span class="line">就会进行扩容操作</span><br><span class="line">int threshold;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;负载因子</span><br><span class="line">final float loadFactor;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当哈希表的大小超过这个阈值，才会把链式结构转化成树型结构，否则仅采</span><br><span class="line">取扩容来尝试减少冲突</span><br><span class="line">static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</span><br></pre></td></tr></table></figure><p>Node 类的定义，它是 HashMap 中的一个静态内部类，哈希表中的每一个 节点都是 Node 类型。我们可以看到，Node 类中有 4 个属性，其中除了 key 和 value 之外，还有 hash 和 next 两个属性。hash 是用来存储 key 的哈希值的，next 是在构建链表时用来指向后继节点的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash &#x3D; hash;</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final K getKey()        &#123; return key; &#125;</span><br><span class="line">    public final V getValue()      &#123; return value; &#125;</span><br><span class="line">    public final String toString() &#123; return key + &quot;&#x3D;&quot; + valu e; &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public final int hashCode() &#123;</span><br><span class="line">        return Objects.hashCode(key) ^ Objects.hashCode(val ue); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final V setValue(V newValue) &#123;</span><br><span class="line">        V oldValue &#x3D; value;</span><br><span class="line">        value &#x3D; newValue;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean equals(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; this)</span><br><span class="line">            return true;</span><br><span class="line">        if (o instanceof Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三方法"><a href="#三方法" class="headerlink" title="三方法"></a>三方法</h1><h2 id="1-get方法"><a href="#1-get方法" class="headerlink" title="1 get方法"></a>1 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;get 方法主要调用的是 getNode 方法，所以重点要看 getNode 方法的</span><br><span class="line">实现</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        &#x2F;&#x2F;如果哈希表不为空 &amp;&amp; key 对应的桶上不为空</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;是否直接命中</span><br><span class="line">            if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first n ode </span><br><span class="line">                ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; ke y.equals(k))))</span><br><span class="line">                return first;</span><br><span class="line">            &#x2F;&#x2F;判断是否有后续节点 </span><br><span class="line">            if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果当前的桶是采用红黑树处理冲突，则调用红黑树的 get 方法去获取节点</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode (hash, key);</span><br><span class="line">                &#x2F;&#x2F;不是红黑树的话，那就是传统的链式结构了，通过循环的方法判断链中是否存在该 key</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                        ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现步骤大致如下： </p><ol><li>通过 hash 值获取该 key 映射到的桶。</li><li>桶上的 key 就是要查找的 key，则直接命中。</li><li>桶上的 key 不是要查找的 key，则查看后续节点：<br>（1）如果后续节点是树节点，通过调用树的方法查找该 key。<br>（2）如果后续节点是链式节点，则通过循环遍历链查找该 key。</li></ol><h2 id="2-put方法"><a href="#2-put方法" class="headerlink" title="2 put方法"></a>2 put方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;put 方法的具体实现也是在 putVal 方法中，所以我们重点看下面的 putVal 方法</span><br><span class="line">   public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(hash(key), key, value, false, true);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final V putVal(int hash, K key, V value, boolean onlyIf Absent,boolean evict) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">       &#x2F;&#x2F;如果哈希表为空，则先创建一个哈希表</span><br><span class="line">       if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">           n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">       &#x2F;&#x2F;如果当前桶没有碰撞冲突，则直接把键值对插入，完事</span><br><span class="line">       if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">           tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">       else &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           &#x2F;&#x2F;如果桶上节点的 key 与当前 key 重复，那你就是我要找的节点了</span><br><span class="line">           if (p.hash &#x3D;&#x3D; hash &amp;&amp;((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equ als(k))))</span><br><span class="line">               e &#x3D; p;</span><br><span class="line">           &#x2F;&#x2F;如果是采用红黑树的方式处理冲突，则通过红黑树的 putTreeVal 方法去插入这个键值对</span><br><span class="line">           else if (p instanceof TreeNode)</span><br><span class="line">               e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">           &#x2F;&#x2F;否则就是传统的链式结构</span><br><span class="line">           else &#123;</span><br><span class="line">               &#x2F;&#x2F;采用循环遍历的方式，判断链中是否有重复的 key</span><br><span class="line">               for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                   &#x2F;&#x2F;到了链尾还没找到重复的 key，则说明 HashMap 没有包含该键</span><br><span class="line">                   if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       &#x2F;&#x2F;创建一个新节点插入到尾部</span><br><span class="line">                       p.next &#x3D; newNode(hash, key, value, nul l);</span><br><span class="line"></span><br><span class="line">                       &#x2F;&#x2F;如果链的长度大于 TREEIFY_THRESHOLD 这个临界值，则把链变为红黑树</span><br><span class="line">                       if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   &#x2F;&#x2F;找到了重复的 key</span><br><span class="line">                   if (e.hash &#x3D;&#x3D; hash</span><br><span class="line">                       ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                       break;</span><br><span class="line">                   p &#x3D; e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F;这里表示在上面的操作中找到了重复的键，所以这里把该键的值替换为新值</span><br><span class="line">           if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key</span><br><span class="line">               V oldValue &#x3D; e.value;</span><br><span class="line">               if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                   e.value &#x3D; value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               return oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line">       &#x2F;&#x2F;判断是否需要进行扩容</span><br><span class="line">       if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>put 方法比较复杂，实现步骤大致如下：</p><ol><li>先通过 hash 值计算出 key 映射到哪个桶。</li><li>如果桶上没有碰撞冲突，则直接插入。</li><li>如果出现碰撞冲突了，则需要处理冲突：<br>（1）如果该桶使用红黑树处理冲突，则调用红黑树的方法插入。<br>（2）否则采用传统的链式方法插入。如果链的长度到达临界值，则把链转变为红 黑树。</li><li>如果桶中存在重复的键，则为该键替换新值。</li><li>如果 size 大于阈值，则进行扩容。</li></ol><h2 id="3-remove方法"><a href="#3-remove方法" class="headerlink" title="3  remove方法"></a>3  remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;remove 方法的具体实现在 removeNode 方法中，所以我们重点看下面的 removeNode 方法</span><br><span class="line">public V remove(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; removeNode(hash(key), key, null, false, tru e)) &#x3D;&#x3D; null ?</span><br><span class="line">        null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object va lue,</span><br><span class="line">                           boolean matchValue, boolean movabl e) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">    &#x2F;&#x2F;如果当前 key 映射到的桶不为空</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (p &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node &#x3D; null, e; K k; V v;</span><br><span class="line">        &#x2F;&#x2F;如果桶上的节点就是要找的 key，则直接命中</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            node &#x3D; p;</span><br><span class="line">        else if ((e &#x3D; p.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果是以红黑树处理冲突，则构建一个树节点</span><br><span class="line">            if (p instanceof TreeNode)</span><br><span class="line">                node &#x3D; ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#x2F;&#x2F;如果是以链式的方式处理冲突，则通过遍历链表来寻找节点</span><br><span class="line">            else &#123;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node &#x3D; e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p &#x3D; e;</span><br><span class="line">                &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;比对找到的 key 的 value 跟要删除的是否匹配</span><br><span class="line">        if (node !&#x3D; null &amp;&amp; (!matchValue || (v &#x3D; node.value) &#x3D;&#x3D; value ||</span><br><span class="line">                             (value !&#x3D; null &amp;&amp; value.equals (v)))) &#123;</span><br><span class="line">            &#x2F;&#x2F;通过调用红黑树的方法来删除节点</span><br><span class="line">            if (node instanceof TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, t ab, movable);</span><br><span class="line">            &#x2F;&#x2F;使用链表的操作来删除节点</span><br><span class="line">            else if (node &#x3D;&#x3D; p)</span><br><span class="line">                tab[index] &#x3D; node.next;</span><br><span class="line">            else</span><br><span class="line">                p.next &#x3D; node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Hash方法"><a href="#5-Hash方法" class="headerlink" title="5 Hash方法"></a>5 Hash方法</h2><p>在get方法和put方法中都需要先计算key映射到哪个桶上，然后才进行之后的操作， 计算的主要代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - 1) &amp; hash</span><br></pre></td></tr></table></figure><p>上面代码中的 n 指的是哈希表的大小，hash 指的是 key 的哈希值，hash 是通过下面 这个方法计算出来的，采用了二次哈希的方式，其中 key 的 hashCode 方法是一个 native 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>这个 hash 方法先通过 key 的 hashCode 方法获取一个哈希值，再拿这个哈希值与它 的高 16 位的哈希值做一个异或操作来得到最后的哈希值，计算过程可以参考下图。 为啥要这样做呢？注释中是这样解释的：如果当 n 很小，假设为 64 的话，那么 n-1 即为 63（0x111111），这样的值跟 hashCode()直接做与操作，实际上只使用了哈希 值的后 6 位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成冲 突了，所以这里把高低位都利用起来，从而解决了这个问题。</p><p><img src="/2019/11/20/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/0dfe17b4-be06-48e2-90e1-0383e587a440.jpg" alt></p><p>正是因为与的这个操作，决定了 HashMap 的大小只能是 2 的幂次方，想一想，如果 不是2的幂次方，会发生什么事情？即使你在创建HashMap的时候指定了初始大小， HashMap 在构建的时候也会调用下面这个方法来调整大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static final int tableSizeFor(int cap) &#123;</span><br><span class="line">    int n &#x3D; cap - 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 1;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 2;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 4;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 8;</span><br><span class="line">    n |&#x3D; n &gt;&gt;&gt; 16;</span><br><span class="line">    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_C APACITY : n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用看起来可能不是很直观，它的实际作用就是把 cap 变成第一个大于 等于 2 的幂次方的数。例如，16 还是 16，13 就会调整为 16，17 就会调整为 32。</p><h2 id="5-resize方法"><a href="#5-resize方法" class="headerlink" title="5 resize方法"></a>5 resize方法</h2><p>HashMap 在进行扩容时，使用的 rehash 方式非常巧妙，因为每次扩容都是翻倍，与 原来计算（n-1）&amp;hash 的结果相比，只是多了一个 bit 位，所以节点要么就在原来 的位置，要么就被分配到“原位置+旧容量”这个位置。</p><p>例如，原来的容量为 32，那么应该拿 hash 跟 31（0x11111）做与操作；在扩容扩到 了 64 的容量之后，应该拿 hash 跟 63（0x111111）做与操作。新容量跟原来相比只 是多了一个 bit 位，假设原来的位置在 23，那么当新增的那个 bit 位的计算结果为 0 时，那么该节点还是在 23；相反，计算结果为 1 时，则该节点会被分配到 23+31 的 桶上。</p><p>正是因为这样巧妙的 rehash 方式，保证了 rehash 之后每个桶上的节点数必定小于等 于原来桶上的节点数，即保证了 rehash 之后不会出现更严重的冲突。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F;计算扩容后的大小</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果当前容量超过最大容量，则无法进行扩容</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;没超过最大值则扩为原来的两倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp; &amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">     &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in t hreshold</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIA L_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)M AXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;新的 resize 阈值</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line">    &#x2F;&#x2F;创建新的哈希表</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab;</span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F;遍历旧哈希表的每个桶，重新计算桶里元素的新位置</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F;如果桶上只有一个键值对，则直接插入</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F;如果是通过红黑树来处理冲突的，则调用相关方法把树分</span><br><span class="line">离开</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                &#x2F;&#x2F;如果采用链式处理冲突 </span><br><span class="line">                else &#123; &#x2F;&#x2F; preserve order</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    &#x2F;&#x2F;通过上面讲的方法来计算节点的新位置</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里有一个需要注意的地方，有些文章指出当哈希表的桶占用超过阈值时就进行 扩容，这是不对的；实际上是当哈希表中的<strong>键值对个数超过阈值</strong>时，才进行扩容的.</p><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>通过红黑树的方式来处理哈希冲突是我第一次看见！学过哈希，学过红黑树，从来没有想过两个可以结合到一起这么用，或许这就是大佬吧！！！</p><p>按照原来的拉链法来解决冲突，如果一个桶上的冲突很严重的话，是会导致哈希表 的效率降低至 O（n），而通过红黑树的方式，可以把效率改进至 O（logn）。相比 链式结构的节点，树型结构的节点会占用比较多的空间，所以这是一种以空间换时间的改进方式。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis多数据源配置</title>
      <link href="/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/11/17/MyBatis%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多数据源，一般都来解决主从模式或者业务比较复杂需要连接不同的分库来支持业务。我们遇到的情况是后者，网上找了很多，大都是根据 Jpa 来做多数据源解决方案，要不就是老的 Spring 多数据源解决方案，还有的是利用 Aop 动态切换，过于复杂，当前已Mybatis Xml为例，简单配置。</p><a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Pom 包就不贴了比较简单该依赖的就依赖，主要是数据库这边的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mybatis.config-location&#x3D;classpath:mybatis&#x2F;mybatis-config.xml</span><br><span class="line"></span><br><span class="line">spring.datasource.test1.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test1?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test1.username&#x3D;root</span><br><span class="line">spring.datasource.test1.password&#x3D;root</span><br><span class="line">spring.datasource.test1.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.test2.jdbc-url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test2?serverTimezone&#x3D;UTC&amp;useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&amp;useSSL&#x3D;true</span><br><span class="line">spring.datasource.test2.username&#x3D;root</span><br><span class="line">spring.datasource.test2.password&#x3D;root</span><br><span class="line">spring.datasource.test2.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>一个 test1 库和一个 test2 库，其中 test1 位主库，在使用的过程中必须指定主库，不然会报错</p><h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">public class DataSource1Config &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1DataSource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.test1&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource testDataSource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mybatis&#x2F;mapper&#x2F;test1&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1TransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;test1DataSource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test1SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的地方就是这块了，一层一层注入,首先创建 DataSource，然后创建 SqlSessionFactory 再创建事务，最后包装到 SqlSessionTemplate 中。其中需要指定分库的 mapper 文件地址，以及分库dao层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &quot;com.neo.mapper.test1&quot;, sqlSessionTemplateRef  &#x3D; &quot;test1SqlSessionTemplate&quot;)</span><br></pre></td></tr></table></figure><p>这块的注解就是指明了扫描 dao 层，并且给 dao 层注入指定的 SqlSessionTemplate。所有<code>@Bean</code>都需要按照命名指定正确。</p><h2 id="dao-层和-xml层"><a href="#dao-层和-xml层" class="headerlink" title="dao 层和 xml层"></a>dao 层和 xml层</h2><p>dao 层和 xml 需要按照库来分在不同的目录，比如：test1 库 dao 层在 <code>com.neo.mapper.test1</code> 包下，test2 库在<code>com.neo.mapper.test2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface User1Mapper &#123;</span><br><span class="line">    List&lt;UserEntity&gt; getAll();</span><br><span class="line">    UserEntity getOne(Long id);</span><br><span class="line">    void insert(UserEntity user);</span><br><span class="line">    void update(UserEntity user);</span><br><span class="line">    void delete(Long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.neo.mapper.test1.User1Mapper&quot; &gt;</span><br><span class="line">    &lt;resultMap id&#x3D;&quot;BaseResultMap&quot; type&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;BIGINT&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;userName&quot; property&#x3D;&quot;userName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;passWord&quot; property&#x3D;&quot;passWord&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;user_sex&quot; property&#x3D;&quot;userSex&quot; javaType&#x3D;&quot;com.neo.enums.UserSexEnum&quot;&#x2F;&gt;</span><br><span class="line">        &lt;result column&#x3D;&quot;nick_name&quot; property&#x3D;&quot;nickName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;sql id&#x3D;&quot;Base_Column_List&quot; &gt;</span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    &lt;&#x2F;sql&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getAll&quot; resultMap&#x3D;&quot;BaseResultMap&quot;  &gt;</span><br><span class="line">       SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id&#x3D;&quot;getOne&quot; parameterType&#x3D;&quot;java.lang.Long&quot; resultMap&#x3D;&quot;BaseResultMap&quot; &gt;</span><br><span class="line">        SELECT </span><br><span class="line">       &lt;include refid&#x3D;&quot;Base_Column_List&quot; &#x2F;&gt;</span><br><span class="line">     FROM users</span><br><span class="line">     WHERE id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       INSERT INTO </span><br><span class="line">          users</span><br><span class="line">          (userName,passWord,user_sex) </span><br><span class="line">        VALUES</span><br><span class="line">          (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot; parameterType&#x3D;&quot;com.neo.model.User&quot; &gt;</span><br><span class="line">       UPDATE </span><br><span class="line">          users </span><br><span class="line">       SET </span><br><span class="line">        &lt;if test&#x3D;&quot;userName !&#x3D; null&quot;&gt;userName &#x3D; #&#123;userName&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        &lt;if test&#x3D;&quot;passWord !&#x3D; null&quot;&gt;passWord &#x3D; #&#123;passWord&#125;,&lt;&#x2F;if&gt;</span><br><span class="line">        nick_name &#x3D; #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">          id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;delete id&#x3D;&quot;delete&quot; parameterType&#x3D;&quot;java.lang.Long&quot; &gt;</span><br><span class="line">       DELETE FROM</span><br><span class="line">           users </span><br><span class="line">       WHERE </span><br><span class="line">           id &#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;delete&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试可以使用 SpringBootTest,也可以放到 Controller中，这里只贴 Controller 层的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User1Mapper user1Mapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private User2Mapper user2Mapper;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUsers&quot;)</span><br><span class="line">    public List&lt;UserEntity&gt; getUsers() &#123;</span><br><span class="line">        List&lt;UserEntity&gt; users&#x3D;user1Mapper.getAll();</span><br><span class="line">        return users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;getUser&quot;)</span><br><span class="line">    public UserEntity getUser(Long id) &#123;</span><br><span class="line">        UserEntity user&#x3D;user2Mapper.getOne(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">    public void save(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;update&quot;)</span><br><span class="line">    public void update(UserEntity user) &#123;</span><br><span class="line">        user2Mapper.update(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void delete(@PathVariable(&quot;id&quot;) Long id) &#123;</span><br><span class="line">        user1Mapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis多数据源配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinkList实现原理_探险</title>
      <link href="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null).</p><p>All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index.</p><p>Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list</p><p>由上述注释中可以大概得知： LinkedList 是由一个双向链表来实现的，它允许插入所有元素，包括 null，同时，它是线程不同步的。</p><a id="more"></a><p>双向链表结构示意图：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/01a8426b-2594-400f-8475-71d402cb4550.png" alt><br>双向链表每个结点除了数据域之外，还有一个前指针和后指针，分别指向前驱结点 和后继结点（如果有前驱/后继的话）。另外，双向链表还有一个 first 指针，指向头 节点，和 last 指针，指向尾节点。</p><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;链表的节点个数</span><br><span class="line">transient int size &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向头节点的指针</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指向尾节点的指针</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>LinkedList属性非常少，由上述三个属性基本可以知道他是怎么实现的。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-节点结构"><a href="#1-节点结构" class="headerlink" title="1 节点结构"></a>1 节点结构</h2><p>Node 是在 LinkedList 里定义的一个静态内部类，它表示链表每个节点的结构，包括一个数据域 item，一个后置指针 next，一个前置指针 prev。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-添加元素"><a href="#2-添加元素" class="headerlink" title="2 添加元素"></a>2 添加元素</h2><p>对于链表这种数据结构来说，添加元素的操作无非就是在表头/表尾插入元素，又或 者在指定位置插入元素。因为 LinkedList 有头指针和尾指针，所以在表头或表尾进 行插入元素只需要 O(1) 的时间，而在指定位置插入元素则需要先遍历一下链表， 所以复杂度为 O(n)。</p><p>在表头添加元素的过程如下：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/04a15498-61a8-41a2-933e-f1da8796db53.png" alt></p><p>当向表头插入一个节点时，很显然当前节点的前驱一定为 null，而后继结点是 first 指针指向的节点，当然还要修改 first 指针指向新的头节点。除此之外，原来的头节<br>点变成了第二个节点，所以还要修改原来头节点的前驱指针，使它指向表头节点， 源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向 null，后继指针原来的头节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">    &#x2F;&#x2F;头指针指向新的头节点</span><br><span class="line">    first &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有头节点，则更新原来节点的前驱指针，否则更新尾指针</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在表尾添加元素跟在表头添加元素大同小异，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/241772bf-9089-4aa3-9636-5d5e59215f01.png" alt></p><p>当向表尾插入一个节点时，很显然当前节点的后继一定为 null，而前驱结点是 last 指针指向的节点，然后还要修改 last 指针指向新的尾节点。此外，还要修改原来尾 节点的后继指针，使它指向新的尾节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱指向尾节点，后继指向 null</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    &#x2F;&#x2F;尾指针指向新的尾节点</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;如果原来有尾节点，则更新原来节点的后继指针，否则更新头指针</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在指定节点之前插入，如图所示：</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/ee88f767-33ee-4e11-ba24-bdfb1413ad86.png" alt></p><p>当向指定节点之前插入一个节点时，当前节点的后继为指定节点，而前驱结点为指 定节点的前驱节点。此外，还要修改前驱节点的后继为当前节点，以及后继节点的 前驱为当前节点，源码的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert succ !&#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;指定节点的前驱</span><br><span class="line">    final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">    &#x2F;&#x2F;当前节点的前驱为指点节点的前驱，后继为指定的节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    &#x2F;&#x2F;更新指定节点的前驱为当前节点</span><br><span class="line">    succ.prev &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F;更新前驱节点的后继</span><br><span class="line">    if (pred &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        pred.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3 删除元素"></a>3 删除元素</h2><p>删除操作与添加操作大同小异，例如删除指定节点的过程如下图所示，需要把当前 节点的前驱节点的后继修改为当前节点的后继，以及当前节点的后继结点的前驱修 改为当前节点的前驱</p><p><img src="/2019/11/17/LinkList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/571734ca-b358-465a-8bba-0c785301a2c7.png" alt></p><p>删除头节点和尾节点跟删除指定节点非常类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头节点，返回表头元素的值</span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert f &#x3D;&#x3D; first &amp;&amp; f !&#x3D; null;</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next; &#x2F;&#x2F;头指针指向后一个节点</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null; &#x2F;&#x2F;新头节点的前驱为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾节点，返回表尾元素的值</span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert l &#x3D;&#x3D; last &amp;&amp; l !&#x3D; null;</span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev; &#x2F;&#x2F;尾指针指向前一个节点</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null; &#x2F;&#x2F;新尾节点的后继为 null</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定节点，返回指定元素的值 </span><br><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert x !&#x3D; null;</span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next; &#x2F;&#x2F;当前节点的后继</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev; &#x2F;&#x2F;当前节点的前驱</span><br><span class="line"></span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next; &#x2F;&#x2F;更新前驱节点的后继为当前节点的后继</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev; &#x2F;&#x2F;更新后继节点的前驱为当前节点的前驱</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-获取元素"><a href="#4-获取元素" class="headerlink" title="4 获取元素"></a>4 获取元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取表头元素</span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取表尾元素 </span><br><span class="line">public E getLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return l.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;根据下标是否超过链表长度的一半，来选择从头部开始遍历还是从尾部</span><br><span class="line">开始遍历</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-常用方法"><a href="#5-常用方法" class="headerlink" title="5 常用方法"></a>5 常用方法</h2><p>上述方法都不是 public 的，LinkedList 是在这些基础的方法进行操作的，下面就来看看可以调用的方法有哪些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;删除表头元素 </span><br><span class="line">public E removeFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表尾元素</span><br><span class="line">public E removeLast() &#123;</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    return unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表头节点</span><br><span class="line">public void addFirst(E e) &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入新的表尾节点</span><br><span class="line">public void addLast(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;链表的大小</span><br><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表尾</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定元素</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (x.item &#x3D;&#x3D; null) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (Node&lt;E&gt; x &#x3D; first; x !&#x3D; null; x &#x3D; x.next) &#123;</span><br><span class="line">            if (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取指定下标的元素</span><br><span class="line">public E get(int index) &#123;</span><br><span class="line">    checkElementIndex(index); &#x2F;&#x2F;先检查是否越界</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;替换指定下标的值</span><br><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">    E oldVal &#x3D; x.item;</span><br><span class="line">    x.item &#x3D; element;</span><br><span class="line">    return oldVal;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;在指定位置插入节点</span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    if (index &#x3D;&#x3D; size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    else</span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除指定下标的节点</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空返回 null</span><br><span class="line">public E peek() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : f.item;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，表头为空抛出异常</span><br><span class="line">public E element() &#123;</span><br><span class="line">    return getFirst();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取表头节点的值，并删除表头节点，表头为空返回 null</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加元素到表头</span><br><span class="line">public void push(E e) &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;删除表头元素</span><br><span class="line">public E pop() &#123;</span><br><span class="line">    return removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h1><p>1、LinkedList 的底层结构是一个带头/尾指针的双向链表，可以快速的对头/尾节点 进行操作。</p><p>2、相比数组，链表的特点就是在指定位置插入和删除元素的效率较高，但是查找的 效率就不如数组那么高了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList实现原理_探险</title>
      <link href="/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/"/>
      <url>/2019/11/16/ArrayList%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-%E6%8E%A2%E9%99%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h1><p>深入理解Java集合中的源代码，可以帮助我们更好地了解大佬的意图，规避不必要的bug。</p><p>源码中的一段注释，提取关键信息</p><p>Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.)</p><p>由上文注释可以大概得知：ArrayList是一个动态数组，实现了List接口以及list相关的所有方法，它允许所有元素的插入，包括null。另外，ArrayList和Vector除了线程不同步之外，大致相等。</p><a id="more"></a><h1 id="二-属性"><a href="#二-属性" class="headerlink" title="二 属性"></a>二 属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认容量的大小</span><br><span class="line">private static final int DEFAULT_CAPACITY &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;空数组常量</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;默认的空数组常量</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;存放元素的数组，可以发现 ArrayList 的底层实现就是一个 Object数组</span><br><span class="line">transient Object[] elementData;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组中包含的元素个数</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组的最大上限 </span><br><span class="line">private static final int MAX_ARRAY_SIZE &#x3D; Integer.MAX_VALU E - 8;</span><br></pre></td></tr></table></figure><p>ArrayList 的属性非常少，就只有这些。其中最重要的莫过于 elementData 了，ArrayList 所有的方法都是建立在 elementData 之上。</p><h1 id="三-方法"><a href="#三-方法" class="headerlink" title="三 方法"></a>三 方法</h1><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1 构造方法"></a>1 构造方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; new Object[initialCapacity]; </span><br><span class="line">    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中可以看出，默认情况下，elementData 是一个大小为 0 的空数组，当我们指定了初始大小的时候，elementData 的初始大小就变成了我们所指定的初始大小了。</p><h2 id="2-get方法"><a href="#2-get方法" class="headerlink" title="2 get方法"></a>2 get方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    return elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void rangeCheck(int index) &#123;</span><br><span class="line">    if (index &gt;&#x3D; size)</span><br><span class="line">        throw new IndexOutOfBoundsException(outOfBoundsMsg (index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E elementData(int index) &#123;</span><br><span class="line">    return (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 ArrayList 是采用数组结构来存储的，所以它的 get 方法非常简单，先是判断一下有没有越界，之后就可以直接通过数组下标来获取元素了，所以 get 的时间复杂 度是 O(1)。</p><h2 id="3-add方法"><a href="#3-add方法" class="headerlink" title="3 add方法"></a>3 add方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    elementData[size++] &#x3D; e;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCou nt!!</span><br><span class="line">    &#x2F;&#x2F;调用一个 native 的复制方法，把 index 位置开始的元素都往后挪一位</span><br><span class="line">    System.arraycopy(elementData, index, elementData, inde x + 1, size - index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacit y);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 的 add 方法也很好理解，在插入元素之前，它会先检查是否需要扩容，然 后再把元素添加到数组中最后一个元素的后面。在 ensureCapacityInternal 方法中， 可以看见，如果当 elementData 为空数组时，它会使用默认的大小去扩容。所以 说，通过无参构造方法来创建 ArrayList 时，它的大小其实是为 0 的，只有在使用到 的时候，才会通过 grow 方法去创建一个大小为 10 的数组。<br>第一个 add 方法的复杂度为 O(1)，虽然有时候会涉及到扩容的操作，但是扩容的次 数是非常少的，所以这一部分的时间可以忽略不计。如果使用的是带指定下标的 add 方法，则复杂度为 O(n)，因为涉及到对数组中元素的移动，这一操作是非常耗时的。</p><h2 id="4-set方法"><a href="#4-set方法" class="headerlink" title="4 set方法"></a>4 set方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public E set(int index, E element) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue &#x3D; elementData(index);</span><br><span class="line">    elementData[index] &#x3D; element;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 方法的作用是把下标为 index 的元素替换成 element，跟 get 非常类似，时间复杂度度为 O(1)。</p><h2 id="5-remove方法"><a href="#5-remove方法" class="headerlink" title="5 remove方法"></a>5 remove方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue &#x3D; elementData(inderemove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。x);</span><br><span class="line">    int numMoved &#x3D; size - index - 1;</span><br><span class="line">    if (numMoved &gt; 0)</span><br><span class="line">        System.arraycopy(elementData, index+1, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its wo rk</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove 方法与 add 带指定下标的方法非常类似，也是调用系统的 arraycopy 方法来 移动元素，时间复杂度为 O(n)。</p><h2 id="6-grow方法"><a href="#6-grow方法" class="headerlink" title="6 grow方法"></a>6 grow方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    &#x2F;&#x2F; minCapacity is usually close to size, so this is a wi n:</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grow 方法是在数组进行扩容的时候用到的，从中可以看见，ArrayList 每次扩容 都是扩 1.5 倍，然后调用 Arrays 类的 copyOf 方法，把元素重新拷贝到一个新的数组 中去。</p><h2 id="7-ize方法"><a href="#7-ize方法" class="headerlink" title="7 ize方法"></a>7 ize方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>size 方法非常简单，它是直接返回 size 的值，也就是<strong>数组中元素的个数</strong>间 复杂度为 O(1)。这里要注意一下，返回的并不是数组的实际大小。</p><h2 id="8-indexOf-amp-lastIndexOf"><a href="#8-indexOf-amp-lastIndexOf" class="headerlink" title="8 indexOf &amp; lastIndexOf"></a>8 indexOf &amp; lastIndexOf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int indexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; size; i++)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int lastIndexOf(Object o) &#123;</span><br><span class="line">    if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (elementData[i]&#x3D;&#x3D;null)</span><br><span class="line">                return i;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        for (int i &#x3D; size-1; i &gt;&#x3D; 0; i--)</span><br><span class="line">            if (o.equals(elementData[i]))</span><br><span class="line">                return i;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>indexOf 方法的作用是返回第一个等于给定元素的值的下标。它是通过遍历比较数组 中每个元素的值来查找的，所以它的时间复杂度是 O(n)。</p><p>lastIndexOf 的原理跟 indexOf 一样，而它仅仅是从后往前找起罢了。</p><h1 id="四-Vector"><a href="#四-Vector" class="headerlink" title="四 Vector"></a>四 Vector</h1><p>很多方法都跟 ArrayList 一样，只是多加了个 synchronized 来保证线程安全,主要汇总二者不同点</p><p>Vector 比 ArrayList 多了一个属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected int capacityIncrement;</span><br></pre></td></tr></table></figure><p>这个属性是在扩容的时候用到的，它表示每次扩容只扩 capacityIncrement 个空间就 足够了。该属性可以通过构造方法给它赋值。先来看一下构造方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public Vector(int initialCapacity, int capacityIncrement) &#123;</span><br><span class="line">    super();</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacit y: &quot;+initialCapacity);</span><br><span class="line">    this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">    this.capacityIncrement &#x3D; capacityIncrement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Vector(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, 0);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public Vector() &#123;</span><br><span class="line">    this(10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中，可以看出 Vector 的默认大小也是 10，而且它在初始化的时候就 已经创建了数组了，这点跟 ArrayList 不一样。再来看一下 grow 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    &#x2F;&#x2F; overflow-conscious code</span><br><span class="line">    int oldCapacity &#x3D; elementData.length;</span><br><span class="line">    int newCapacity &#x3D; oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity &#x3D; minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 grow 方法中可以发现，newCapacity 默认情况下是两倍的 oldCapacity，而当 指定了 capacityIncrement 的值之后，newCapacity 变成了 oldCapacity+capacityIncrement。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h1><p>1、ArrayList 创建时的大小为 0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10</p><p>2、ArrayList 每次扩容都以当前数组大小的 1.5 倍去扩容。  3、Vector 创建时的默认大小为 10</p><p>4、Vector 每次扩容都以当前数组大小的 2 倍去扩容。当指定了 capacityIncrement 之 后，每次扩容仅在原先基础上增加 capacityIncrement 个单位空间。</p><p>5、ArrayList 和 Vector 的 add、get、size 方法的复杂度都为 O(1)，remove 方法的复 杂度为 O(n)。</p><p>6、ArrayList 是非线程安全的，Vector 是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-OpenResty用Lua语言实现简单服务</title>
      <link href="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/93c7612e-307f-4fe2-84c8-ac0e13a042e0.png" alt></p><a id="more"></a><p><a href="http://openresty.org/cn/" target="_blank" rel="noopener">Openresty官方站点</a></p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5f3c391e-6f44-44af-b4f9-f02244dda8b2.png" alt></p><h3 id="1-下载"><a href="#1-下载" class="headerlink" title="1 下载"></a>1 下载</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/f9783f7c-7a09-47ac-9971-b437c34d1a86.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.15.8.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf openresty-1.15.8.3.tar.gz </span><br><span class="line"></span><br><span class="line">cd openresty-1.15.8.3</span><br><span class="line"></span><br><span class="line">ll</span><br></pre></td></tr></table></figure><h3 id="2-分析目录结构"><a href="#2-分析目录结构" class="headerlink" title="2 分析目录结构"></a>2 分析目录结构</h3><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/7944541f-db36-4847-a046-9d2cea4a65e0.png" alt></p><p>看出与 nginx相比 少了很多东西，都在 bundle模块下，核心为 nginx-x模块。</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/560b6198-f80c-43f2-b7e1-a109ffcfcb95.png" alt></p><p>主要分为 两大模块<br><strong>nginx c代码模块</strong>，通常以 ngx打头。<br><strong>lua模块</strong>，使用 ngx c代码模块提供的功能。</p><p>编译时也主要是编译 <strong>C模块</strong></p><p>观看 openresty 的configure模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p>基本没有什么不同，只不过集合了更多的第三方模块。<br><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/2c32f29e-6114-4fec-beb4-1b663cdef9e3.jpg" alt></p><h3 id="3-编译"><a href="#3-编译" class="headerlink" title="3 编译"></a>3 编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">默认, &#96;--prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;openresty&#96; 程序会被安装到&#x2F;usr&#x2F;local&#x2F;openresty目录。</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="4-添加lua代码"><a href="#4-添加lua代码" class="headerlink" title="4 添加lua代码"></a>4 添加lua代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">因为被安装到了这里，所以进入这个目录</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;openresty&#x2F;nginx&#x2F;conf</span><br><span class="line"></span><br><span class="line">vim nginx.conf</span><br><span class="line"></span><br><span class="line">添加如下内容</span><br><span class="line"></span><br><span class="line">location &#x2F;lua &#123;</span><br><span class="line">        default_type text&#x2F;html;</span><br><span class="line">        content_by_lua</span><br><span class="line">           &#39;ngx.say(&quot;User-Agent: &quot;, ngx.req.get_headers()[&quot;User-Agent&quot;])&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -t</span><br><span class="line"></span><br><span class="line">sbin&#x2F;nginx -c conf&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>浏览器输入 192.168.121.100:80</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/5a886d20-993f-4a00-b51b-492b6fdbe3a7.png" alt></p><p>浏览器输入 192.168.121.100:80/lua</p><p><img src="/2019/11/12/10-OpenResty%E7%94%A8Lua%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%9C%8D%E5%8A%A1/3abd7c85-86d2-47bd-94aa-d58a42498346.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Openresty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Openresty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-SSL-Nginx</title>
      <link href="/2019/11/11/9-SSL-Nginx/"/>
      <url>/2019/11/11/9-SSL-Nginx/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络安全是当前非常受到关注的一个问题，大部分站点都是通过 <strong>HTTPS</strong> 来实现安全访问。如何将自己的站点改造成 <strong>HTTPS</strong> 站点呢？我们需要了解 <strong>SSL</strong> 协议。</p><h2 id="知识普及"><a href="#知识普及" class="headerlink" title="知识普及"></a>知识普及</h2><ul><li>TLS/SSL 发展历程<br><img src="/2019/11/11/9-SSL-Nginx/c97e2236-9c76-47a7-8101-c6a81360c5d0.jpg" alt><a id="more"></a></li><li>TLS安全密码套件解读</li></ul><p>抓包或者观察服务器端的配置时，可看到下图</p><p><img src="/2019/11/11/9-SSL-Nginx/b90659c2-af11-44dd-96c1-e06f39232949.jpg" alt></p><h3 id="概要介绍"><a href="#概要介绍" class="headerlink" title="概要介绍"></a>概要介绍</h3><p><strong>ECDHE</strong>: 密钥交换算法（此处是一个椭圆曲线加密算法），用来解决浏览器与服务器则那样独立生成相同的密钥，接下来会用此密钥加密数据。</p><p><strong>RSA</strong>: 身份验证算法。密钥交换过程中，需要验证各自身份。</p><p>数据加密、解密时要用到对称加密算法，即 <strong>AES_128_GCM</strong></p><p><strong>AES</strong>: 算法名称</p><p><strong>128</strong>：AES支持3种加密强度，此处使用 128</p><p><strong>GCM</strong>：AES有很多分组模式，GCM是较新的一种模式，可以提高多核CPU下加解密的性能。</p><p><strong>SHA256</strong>: 摘要算法，用来把不定长度的字符串生成一个固定长度的更短的摘要。</p><h4 id="对称加密-VS-非对称加密"><a href="#对称加密-VS-非对称加密" class="headerlink" title="对称加密 VS 非对称加密"></a>对称加密 VS 非对称加密</h4><h5 id="对称加密（同一把密钥）"><a href="#对称加密（同一把密钥）" class="headerlink" title="对称加密（同一把密钥）"></a>对称加密（同一把密钥）</h5><p><img src="/2019/11/11/9-SSL-Nginx/5e4ccaf3-a19e-418e-91a8-618eebf304d0.jpg" alt></p><p>使用相同的 密钥序列 进行 异或运算，第一次加密，再异或一次即解密。<br><img src="/2019/11/11/9-SSL-Nginx/4252405b-8e3e-4396-97aa-e0862c67a72f.jpg" alt></p><h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>同一份文档，用<strong>公钥</strong>加密的，只能用对应的<strong>私钥</strong>进行解密</p><p><img src="/2019/11/11/9-SSL-Nginx/3d318d9b-74f0-49b5-8ef1-53c5eb195619.jpg" alt></p><ul><li><p>文档加密</p></li><li><p>身份验证</p></li></ul><h4 id="SSL证书公信力的保证"><a href="#SSL证书公信力的保证" class="headerlink" title="SSL证书公信力的保证"></a>SSL证书公信力的保证</h4><p>爱丽丝 与 鲍勃 进行通信，但有个前提条件，爱丽丝就是爱丽丝，鲍勃就是鲍勃，这样一个新问题，在多方通讯过程中必须有一个公信机构，即 <strong>CA机构</strong></p><p><strong>CA是怎样颁发证书，使证书过期的呢?</strong></p><p><strong>PKI公钥基础设施</strong><br><img src="/2019/11/11/9-SSL-Nginx/f539cc97-f8b6-421f-80a3-47ee62687cfd.jpg" alt></p><p><font color="red">流程：</font></p><p>图中的<strong>CA</strong>即是一个公信机构，用来颁发证书的。</p><p>我们作为一个站点的维护者，就是一个 <strong>证书订阅人</strong>，首先我们要去申请一个证书，必要要登记（我是谁、我属于什么组织、我想做什么）</p><p>到了登记机构后，通过 <strong>CSR</strong> 发送给 <strong>CA</strong>，申请通过后。</p><p><strong>CA</strong>会生成一对公私钥，公钥保存在CA的证书链中，公私钥被证书订阅人拿到后。</p><p><strong>证书订阅人</strong> 会把拿到的公私钥部署到自己的 <strong>Web服务器</strong>，如 Nginx服务器等。</p><p>当 <strong>浏览器</strong>通过 第 1 步 访问我们的 HTTPS站点时，会去请求我们的证书，而Nginx这样的Web站点服务器 会将我们的 <strong>公钥证书</strong> 发给我们的浏览器。 浏览器需要去验证 我们颁发给他的证书是否 <strong>合法有效</strong></p><p>如果我们用 <strong>Let’s encrypt</strong> 会发现证书只有 90天的有效期。而用其他的SSL-CA可能会有1年的有效期。</p><p><strong>有效期如何体现</strong>： CA中心 会把过期的证书放到 <strong>CRL服务器</strong>中</p><p><strong>CRL服务器</strong>会把所有的过期证书形成一个很长很长的链条，性能极差。</p><p>所以又推出一个称为 <strong>OCSP响应程序</strong>，它可以就一个证书去查询是否过期。 因此 <strong>浏览器</strong>可以直接查询 <strong>OCSP响应程序</strong>，但 OCSP 性能依然不高。</p><p>因此，我们的 <strong>Nginx Web服务器</strong> 往往会有一个 <strong>OCSP开关</strong>，当打开时，会由 <strong>Nginx</strong> 主动地去<strong>OCSP</strong>查询, 这样，大量的客户端可以直接从 <strong>Nginx</strong> 服务器获取到证书是否有效。</p><h4 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h4><p><img src="/2019/11/11/9-SSL-Nginx/9f804386-3565-4c92-8a82-ae32e6a9afaa.jpg" alt></p><h4 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h4><p>浏览器对 DV OV EV 验证效果是一样的，唯一区别的 就是他的 证书链。</p><p><img src="/2019/11/11/9-SSL-Nginx/a6f3f984-33c9-46cc-a6e8-842e9849c9f5.jpg" alt></p><p>目前所有站点的 主证书都是有 3级结构。<strong>根证书、二级证书、主证书</strong>。</p><p>为什么形成这样的3级证书结构呢？</p><p>那是因为 根证书的 验证十分谨慎，像 Window 、 Android 等操作系统 每 1年以上才会去更新它的根证书库。所以，一个新的根证书库CA机构是很难快速加入到操作系统、浏览器认可的证书库中的。</p><p>大部分浏览器使用的是操作系统的根证书库，像Firefox可能会维护自己的根证书库。所以浏览器在验证我们的证书是否有效时，最主要是验证 根证书是否无过期，有效。</p><p>Nginx 服务器向 浏览器发送 两个证书（主证书、二级证书）即可。根证书是被操作系统、浏览器内置的，无需发送。</p><h4 id="SSL协议握手时Nginx的性能瓶颈"><a href="#SSL协议握手时Nginx的性能瓶颈" class="headerlink" title="SSL协议握手时Nginx的性能瓶颈"></a>SSL协议握手时Nginx的性能瓶颈</h4><h5 id="TLS通讯过程"><a href="#TLS通讯过程" class="headerlink" title="TLS通讯过程"></a>TLS通讯过程</h5><p><img src="/2019/11/11/9-SSL-Nginx/64515879-b4e9-46d9-85f0-49ad2d5f8b86.png" alt></p><p><font color="red">流程：</font></p><ul><li><p>1 Client Hello 浏览器发给服务器。因为我们的浏览器是非常多元化的。Chrome、IE、FireFox等。浏览器的版本也在不停的变更。不同的浏览器所支持的安全套件、加密算法是不同的。因此在第一步，主要是告诉服务器，我支持哪些算法。</p></li><li><p>2 Server Hello 如 Nginx会有一个自己知道自己可支持的加密算法列表，以及自己倾向于使用哪一个加密算法套件，Nginx会选择自己最喜欢的一个加密算法套件发送给客户端。如果想复用 Session，即 Nginx 打开了 Session Cache ，希望一天内断开了连接的客户端，不用再次协商密钥，在这一步可以直接复用之前的密钥。因此 这一步主要是发送 究竟我们选择哪一个安全套件</p></li><li><p>3 Server Certificates 会把自己的公钥证书发送给浏览器，公钥证书中是包含证书链的，所以浏览器可以找到自己的跟证书库，去验证证书是否有效。<strong>Check Certificate validity</strong></p></li><li><p>4 Server Hello Done 服务器会发送此消息，但如果之前协商的安全套件，如椭圆曲线算法，此时需要在 3 与 4 之间 将椭圆曲线的参数发送给客户端。以方便我们在 6 生成最终加密的密钥。</p></li><li><p>5 ClientKey Exchange Message 客户端也需要根据椭圆曲线的公共参数生成自己的私钥后，将公钥发送给服务器。此时，服务器也有了自己的私钥，将公钥发送给客户端。</p></li><li><p>6  Key generation 服务器可以根据自己的私钥和客户端的公钥共同生成双方加密的密钥， 客户端可以根据自己的私钥和服务器的公钥共同生成双方加密的密钥。这两个各自生成的密钥是相同的。这是由 非正式加密算法来保证的。</p></li><li><p>7 CipherSpec Exchange Finished 接下来就可以用生成的密钥进行数据加密与通讯了。</p></li></ul><p><strong>由上述过程可以看到，TLS通讯过程主要是做 交换密钥 + 加密数据</strong>，这两个最耗费性能。</p><h5 id="Nginx优化性能"><a href="#Nginx优化性能" class="headerlink" title="Nginx优化性能"></a>Nginx优化性能</h5><p>对于小文件。握手是主要影响他 QPS性能的主要指标</p><p><img src="/2019/11/11/9-SSL-Nginx/cc318a18-f172-4688-8496-aa81fbf22abc.jpg" alt></p><h5 id="Nginx数据加密性能"><a href="#Nginx数据加密性能" class="headerlink" title="Nginx数据加密性能"></a>Nginx数据加密性能</h5><p><img src="/2019/11/11/9-SSL-Nginx/b18c290e-fbd4-4cf5-8ffe-199e8b7ccdcf.jpg" alt></p><h5 id="Nginx综合性能"><a href="#Nginx综合性能" class="headerlink" title="Nginx综合性能"></a>Nginx综合性能</h5><p>当以小文件为主时，考虑优化Nginx非对称加密性能（椭圆曲线）。<br>当以大文件为主时，考虑优化Nginx非对称加密性能（AES）。<br><img src="/2019/11/11/9-SSL-Nginx/f926e156-3fa6-4969-9b6e-70b174299402.jpg" alt></p><h2 id="免费SSL实现HTTPS站点"><a href="#免费SSL实现HTTPS站点" class="headerlink" title="免费SSL实现HTTPS站点"></a>免费SSL实现HTTPS站点</h2><p><strong>前提：</strong></p><ol><li>拥有一个域名，且ICP备案。</li><li>在域名服务器创建一条A记录，指向云主机的公网IP地址。例如demo.mydomain.com指向xxx.xxx.xxx.xxx的IP地址。</li><li>要等到新创建的域名解析能在公网上被解析到。</li></ol><p><img src="/2019/11/11/9-SSL-Nginx/a12032d4-c88b-4387-aec6-9fd44a280024.jpg" alt></p><p>演示如何使用 <strong>Let’s encrypt</strong> 生成免费的DV证书，将网站改造为 https站点。</p><h3 id="1-http协议请求标识"><a href="#1-http协议请求标识" class="headerlink" title="1 http协议请求标识"></a>1 http协议请求标识</h3><p><img src="/2019/11/11/9-SSL-Nginx/df826605-29a0-4e52-a185-b581eb423338.jpg" alt><br>没有小锁，说明现在是一个 http请求。</p><h3 id="2-Nginx-conf配置"><a href="#2-Nginx-conf配置" class="headerlink" title="2 Nginx.conf配置"></a>2 Nginx.conf配置</h3><p><img src="/2019/11/11/9-SSL-Nginx/d19e0b8a-2dcf-49ed-bba7-ba4aff4eb8f6.jpg" alt></p><p>在<strong>server</strong>中，有一个 server_name，这个域名会被 <strong>Let’s encrypt</strong>脚本所使用，<strong>location</strong> 指向了一个具体的文件</p><h3 id="3-脚本安装与使用"><a href="#3-脚本安装与使用" class="headerlink" title="3 脚本安装与使用"></a>3 脚本安装与使用</h3><p><a href="https://letsencrypt.org/" target="_blank" rel="noopener">letsencrypt</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum install python2-certbot-nginx</span><br><span class="line"></span><br><span class="line">不成功的话，下面方法可以考虑，但要慎用，因为要做全面更新</span><br><span class="line"></span><br><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum update</span><br><span class="line"></span><br><span class="line">yum install python2-certbot-nginx</span><br></pre></td></tr></table></figure><p>该工具会提供一个命令  <strong>certbot</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certbot --nginx --nginx-server-root&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openrestry&#x2F;nginx&#x2F;conf&#x2F; -d geektime.taohui.pub</span><br></pre></td></tr></table></figure><p>–nginx 会为nginx的配置文件自动执行相应的修改，通常默认会去修改 /usr/local/nginx/conf/ 下的配置文件，但此处因为路径不同，所以使用</p><p>–nginx-server-port 单独指定nginx.conf所在路径。</p><p>-d 指定 申请证书的域名。</p><p><img src="/2019/11/11/9-SSL-Nginx/8e6b10a7-a712-4016-b9b9-47d352a53654.jpg" alt></p><p>首先会去获取一个证书，验证证书，投放证书到配置文件。<br>1：不做重定向。（此处选择1）<br>2：做重定向。</p><p>区别：当有了 https站点后，希望所有的http流量，明文显示的不安全流量都是用 301 、302重定向协议转到https站点。</p><p><strong>HTTPS站点标识</strong><br><img src="/2019/11/11/9-SSL-Nginx/75ac2b42-8b6c-4479-ab0c-8ca3953cd045.jpg" alt></p><p>此时查看 nginx.conf,增加了5行</p><p><img src="/2019/11/11/9-SSL-Nginx/4fa55fe8-ee24-4191-9cf2-6de0f40a54bf.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">监听443端口 使用ssl协议</span><br><span class="line"></span><br><span class="line">ssl_certificate 、 ssl_certificate_key 分别为公私钥证书部署到对应的路径中。</span><br><span class="line"></span><br><span class="line">include 通用参数加了进来</span><br><span class="line"></span><br><span class="line">ssl_dhparam:表示使用非对称加密时，使用怎样的参数，这些参数决定网络加密的强度</span><br></pre></td></tr></table></figure><p>看一下 <code>/etc/letsencrypt/options-ssl-nginx.conf</code></p><p><img src="/2019/11/11/9-SSL-Nginx/9217ebcd-3850-4766-b60a-2b12cb122f05.jpg" alt></p><p>ssl中最降低性能的就是握手，因此设置了一个 ssl_session_cache ，大小为1M。在 1440m（分钟）即1天 时间内可以复用之前的。</p><p>ssl_protocols: ssl支持哪些版本的协议。</p><p>ssl_perfer_server_ciphers on 表示nginx服务器使用那些协议与浏览器进行通讯。</p><p>ssl_ciphers 中的安全套件以 分号为分隔符。排在前面的会优先使用。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> SSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-Nginx配置文件简易解析</title>
      <link href="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/0ad1a503df198bdb026ce7e8d83f53b9.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/d1820db3ef58dac396c152bf3d460f27.png" alt>)<img src="/2019/11/10/8-Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E6%98%93%E8%A7%A3%E6%9E%90/6432890dbc992690f2068620d9ee7951.png" alt></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#运行用户</span><br><span class="line">user nobody;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"></span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"></span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # nginx作为http服务器的时候</span><br><span class="line"># max_clients &#x3D; worker_processes * worker_connections</span><br><span class="line">    # nginx作为反向代理服务器的时候：</span><br><span class="line">#max_clients &#x3D; worker_processes * worker_connections &#x2F; 4  </span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 &#x3D; 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6].&quot;;</span><br><span class="line"></span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"></span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"></span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs&#x2F;nginx.access.log  main;</span><br><span class="line"></span><br><span class="line">        #默认请求</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^&#x2F;(images|javascript|js|css|flash|media|static)&#x2F; &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ &#x2F;.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-Nginx安装详解</title>
      <link href="/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/09/7-Nginx%E5%AE%89%E8%A3%85%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx是一款轻量级高性能的Web服务器/反向代理服务器，</p><p>并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，<br>中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p><a id="more"></a><h1 id="1-新方法安装"><a href="#1-新方法安装" class="headerlink" title="1 新方法安装"></a>1 新方法安装</h1><p><strong>Nginx是C语言开发，</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. gcc安装</span><br><span class="line">yum install gcc-c++</span><br><span class="line">2. PCRE pcre-devel安装</span><br><span class="line">PCRE（Perl Compatible Regular Expressions）是一个Perl库，包括perl兼容的正则表达式。Nginx的http模块使用pcre来解析正则表达式。所以需要在linux安装pcre库。pcre-devel是pcre开发的一个二次开发库，nginx也需要此命令。</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">3. zlib安装</span><br><span class="line">zlib库提供了很多种压缩和解压额方式，Nginx使用zlib对http包的内容进行gzip，所以需要</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">4. Open-SSL安装</span><br><span class="line">OpenSSL是一个强大的安全套接字层密码库，囊括主要的密码算法，常用的密钥和证书封装管理功能以及SSL协议，并提供丰富的应用程序供测试或其他目的。</span><br><span class="line">Nginx不仅支持http协议，还支持https（在ssl协议上传输http）,所以需要安装OpenSSL库</span><br><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure><h1 id="2-老方法安装"><a href="#2-老方法安装" class="headerlink" title="2 老方法安装"></a>2 老方法安装</h1><ol><li><p>安装gcc</p><p> rpm -Uvh glibc-2.12-1.209.el6_9.2.x86_64.rpm glibc-common-2.12-1.209.el6_9.2.x86_64.rpm libgcc-4.4.7-18.el6_9.2.x86_64.rpm tzdata-2018e-3.el6.noarch.rpm </p><p> rpm -ivh cloog-ppl-0.15.7-1.2.el6.x86_64.rpm cpp-4.4.7-18.el6_9.2.x86_64.rpm glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm     kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm libgomp-4.4.7-18.el6_9.2.x86_64.rpm mpfr-2.4.1-6.el6.x86_64.rpm ppl-0.10.2-11.el6.x86_64.rpm </p><p> rpm -ivh gcc-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装gcc-c++<br> rpm -Uvh libstdc++-4.4.7-18.el6_9.2.x86_64.rpm<br> rpm -ivh libstdc++-devel-4.4.7-18.el6_9.2.x86_64.rpm  gcc-c++-4.4.7-18.el6_9.2.x86_64.rpm</p></li><li><p>安装pcre<br> tar -zxvf pcre-8.40.tar.gz<br> cd pcre-8.40<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装zlib</p><p> tar -zxvf zlib-1.2.11.tar.gz<br> cd zlib-1.2.11<br> ./configure<br> make &amp;&amp; make install</p></li><li><p>安装启动</p><p> ./configure –prefix=/usr/local/nginx  配置nginx 并且指定nginx的安装目录</p><p> make &amp;&amp; make install</p><p> cd /usr/local/nginx/sbin</p><p> netstat -ano | grep 80     //检查80端口是否占用</p><p> ./nginx -c /usr/local/nginx/conf/nginx.conf</p><p> 注意：</p><pre><code>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：ln -s /usr/local/lib/libpcre.so.1 /lib64/</code></pre></li></ol><hr><p>Nginx运行和控制<br>    /usr/local/nginx/sbin/nginx 命令</p><pre><code>nginx命令参数：不像许多其他软件系统，Nginx 仅有几个命令行参数，完全通过配置文件来配置。参数如下：-s reload | reopen | stop 进程相关（重新载入配置文件 | 重启Nginx | 停止Nginx）-c &lt;/path/to/config&gt; 为 Nginx 指定一个配置文件，来代替缺省的。-t 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。-v 显示 nginx 的版本。-V 显示 nginx 的版本，编译器版本和配置参数。</code></pre><hr><p>nginx负载均衡</p><p>1.常用的负载均衡策略<br>    a. 轮询（默认）<br>    每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>    upstream backserver {<br>        server 192.168.0.14;<br>        server 192.168.0.15;<br>    }<br>    b. 指定权重<br>    指定轮询几率（权重默认为1），weight和访问比率成正比，用于后端服务器性能不均的情况。<br>    upstream backserver {<br>        server 192.168.0.14 weight=10;<br>        server 192.168.0.15 weight=10;<br>    }<br>    c. IP绑定 ip_hash<br>    每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。<br>    upstream backserver {<br>        ip_hash;<br>        server 192.168.0.14:88;<br>        server 192.168.0.15:80;<br>    }</p><ol start="2"><li><p>完整配置</p><p> #添加tomcat列表，真实应用服务器都放在这<br> upstream tomcat_pool {</p><pre><code>#server tomcat地址:端口号 weight表示权值，权值越大，被分配的几率越大;</code></pre><p>　　    server 192.168.0.223:8080 weight=4 max_fails=2 fail_timeout=30s;<br> 　　server 192.168.0.224:8080 weight=4 max_fails=2 fail_timeout=30s;<br> }</p><p> server{</p><pre><code>......</code></pre></li></ol><pre><code>    location / {        proxy_pass    http://tomcat_pool;    #转向tomcat处理    }    ......}</code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-GoAccess实现可视化并实时监控access日志</title>
      <link href="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>access日志</strong> 记录了用户非常重要的信息，可用它来分析、定位问题，也可用它来分析用户的运营数据，但是如果想要实时分析access 日志，相对比较困难。使用 cat、awk、sed 等命令做一些简单的日志分析统计，这样分析结果不理想也不全面，方法也极不高效。</p><p><strong>GoAccess</strong> 这款工具以图形化的方式通过<strong>web socket</strong>协议，实时的将access日志的变迁反应到浏览器中。方便我们分析问题。</p><a id="more"></a><h2 id="1-Nginx配置"><a href="#1-Nginx配置" class="headerlink" title="1 Nginx配置"></a>1 Nginx配置</h2><p>为了提高 GoAccess 分析准确度，需要配置 <code>nginx.conf</code> 的 log_format 项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_body&quot;&#39;;</span><br></pre></td></tr></table></figure><h2 id="2-安装GoAccess"><a href="#2-安装GoAccess" class="headerlink" title="2 安装GoAccess"></a>2 安装GoAccess</h2><p><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess</a> 是这个工具的站点。如图所示：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/629f3358-d5c5-4889-b24f-bc4e6a87c46b.png" alt></p><p>先看一下之前静态web资源服务器所产生的access log日志格式<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/9f36080a-71ba-4c59-82e8-226d730d87a1.png" alt></p><p>现在打开 GoAccess中的 <strong>Get started</strong>快速开始页面，依据文档下载安装。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/615f6899-491f-4f74-a245-feb5f3a9c0b3.png" alt></p><p>先下载依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y GeoIP-devel</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;maxmind&#x2F;geoip-api-c&#x2F;releases&#x2F;download&#x2F;v1.6.11&#x2F;GeoIP-1.6.11.tar.gz</span><br><span class="line">tar -zxvf GeoIP-1.16.11.tar.gz</span><br><span class="line">cd GeoIP-1.16.11</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>下载安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;tar.goaccess.io&#x2F;goaccess-1.3.tar.gz</span><br><span class="line">tar -xzvf goaccess-1.3.tar.gz</span><br><span class="line">cd goaccess-1.3&#x2F;</span><br><span class="line">.&#x2F;configure --enable-utf8 --enable-geoip&#x3D;legacy --with-openssl  &#x2F;&#x2F;此处出现错误如下 安装下面依赖后回来继续安装即可</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>出现错误：<br>configure: error: *** Missing development libraries for ncursesw</p><p>解决方法：<br>要使用–enable-utf8，你需要安装ncursesw，下面是安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun goaccess]# sudo yum install ncurses-devel</span><br></pre></td></tr></table></figure><p>安装成功后：<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/dae8664f-26c8-45d9-b7ae-957833eae1fa.png" alt></p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h2><p>安装完成后，默认将配置文件<code>goaccess.conf</code>放置于<code>/usr/local/etc</code>路径，为了统一管理，使用<code>mv /usr/local/etc/goaccess.conf /etc/</code>命令将其移动到<code>/etc</code>目录下。</p><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/5a428874-2d04-42df-ad85-07cbbc719e50.png" alt></p><p>对配置文件做一些主要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;goaccess.conf</span><br><span class="line"></span><br><span class="line">time-format %H:%M:%S</span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br><span class="line">log-format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/2120efc0-f319-469d-a88e-8639b9f58a17.png" alt></p><p>其中，log-format 与 access.log 的 log_format 格式对应，每个参数以空格或者制表符分割。参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%t  匹配time-format格式的时间字段</span><br><span class="line">%d  匹配date-format格式的日期字段</span><br><span class="line">%h  host(客户端ip地址，包括ipv4和ipv6)</span><br><span class="line">%r  来自客户端的请求行</span><br><span class="line">%m  请求的方法</span><br><span class="line">%U  URL路径</span><br><span class="line">%H  请求协议</span><br><span class="line">%s  服务器响应的状态码</span><br><span class="line">%b  服务器返回的内容大小</span><br><span class="line">%R  HTTP请求头的referer字段</span><br><span class="line">%u  用户代理的HTTP请求报头</span><br><span class="line">%D  请求所花费的时间，单位微秒</span><br><span class="line">%T  请求所花费的时间，单位秒</span><br><span class="line">%^  忽略这一字段</span><br></pre></td></tr></table></figure><h2 id="4-命令"><a href="#4-命令" class="headerlink" title="4 命令"></a>4 命令</h2><p>查看 GoAccess 命令参数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -h</span><br><span class="line"># 常用参数</span><br><span class="line">-a --agent-list 启用由主机用户代理的列表。为了更快的解析，不启用该项</span><br><span class="line">-d --with-output-resolver 在HTML&#x2F;JSON输出中开启IP解析，会使用GeoIP来进行IP解析</span><br><span class="line">-f --log-file 需要分析的日志文件路径</span><br><span class="line">-p --config-file 配置文件路径</span><br><span class="line">-o --output 输出格式，支持html、json、csv</span><br><span class="line">-m --with-mouse 控制面板支持鼠标点击</span><br><span class="line">-q --no-query-string 忽略请求的参数部分</span><br><span class="line">--real-time-html 实时生成HTML报告</span><br><span class="line">--daemonize 守护进程模式，--real-time-html时使用</span><br></pre></td></tr></table></figure><h2 id="5-控制台模式"><a href="#5-控制台模式" class="headerlink" title="5 控制台模式"></a>5 控制台模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log -p &#x2F;etc&#x2F;goaccess.conf</span><br></pre></td></tr></table></figure><p><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/8378f7b8-273a-4740-8ceb-4d961484c9e7.png" alt></p><p>控制台下的操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">F1 主帮助页面</span><br><span class="line">F5 重绘主窗口</span><br><span class="line">q 退出</span><br><span class="line">1-15 跳转到对应编号的模块位置 </span><br><span class="line">o 打开当前模块的详细视图</span><br><span class="line">j 当前模块向下滚动</span><br><span class="line">k 当前模块向上滚动</span><br><span class="line">s 对模块排序</span><br><span class="line">&#x2F; 在所有模块中搜索匹配</span><br><span class="line">n 查找下一个出现的位置</span><br><span class="line">g 移动到第一个模块顶部</span><br><span class="line">G 移动到最后一个模块底部</span><br></pre></td></tr></table></figure><h2 id="6-HTML模式"><a href="#6-HTML模式" class="headerlink" title="6 HTML模式"></a>6 HTML模式</h2><p>上游服务器（14）： /home/geek/nginx  其中的 nginx.conf 配置为 127.0.0.1:8080 即仅能本机访问。</p><p>代理服务器（16）： /usr/local/geek/openstry/nginx 其中 nginx.conf 配置了 upstream 来标明上游服务器的ip地址+端口号，同时也设置了相应的缓存，具体查看前几节文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html</span><br></pre></td></tr></table></figure><p>浏览器输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.121.100:80&#x2F;go-access.html 即可看到</span><br><span class="line"></span><br><span class="line">上述配置都是在上游nginx服务器中完成的</span><br><span class="line">此处是使用了代理服务器的80端口，由代理服务器替我们到上游服务器获取go-access.log 实时日志以html页面展示</span><br></pre></td></tr></table></figure><p>由下图可看到，确实是由 代理服务器替我们拿到的数据<br><img src="/2019/11/08/6-GoAccess%E5%AE%9E%E7%8E%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B9%B6%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7access%E6%97%A5%E5%BF%97/1d80d359-8e05-421c-9637-e799599b0de8.png" alt></p><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><p>GoAccess 已经为我们考虑到这点了，它可以以 daemonize 模式运行，并提供创建实时 HTML 的功能，只需要在启动命令后追加<code>--real-time-html --daemonize</code>参数即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html --real-time-html --daemonize</span><br><span class="line"></span><br><span class="line"># 监听端口7890</span><br><span class="line">netstat -tunpl |grep &quot;goaccess&quot;</span><br><span class="line">tcp        0      0 0.0.0.0:7890            0.0.0.0:*               LISTEN      13212&#x2F;goaccess</span><br></pre></td></tr></table></figure><p>以守护进程启动 GoAccess 后，使用 Websocket 建立长连接，它默认监听 7890 端口，可以通过<code>--port</code>参数指定端口号。</p><blockquote><p>如果站点启用了 HTTPS, GoAccess 也需要使用 openssl，在配置文件<code>goaccess.conf</code>中配置<code>ssl-cert</code>和<code>ssl-key</code>项，并确保在安装过程中 configure 时已添加<code>--with-openssl</code>项来支持 openssl 。当使用 HTTPS 后 Websocket 通信时也应该使用 wss 协议，需要将<code>ws-url</code>项配置为<code>wss://www.domain.com</code>。</p></blockquote><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>在某些场景下，没有这样的实时性要求，可采用 crontab 机制实现定时更新 HTML 报表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 每天执行</span><br><span class="line"></span><br><span class="line">0 0 1 * * goaccess -a -d -f &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;haoransun.log  -p &#x2F;etc&#x2F;goaccess.conf -o &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;html&#x2F;go-access.html 2&gt; &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;go-access.log</span><br></pre></td></tr></table></figure><p>当access 日志被切割后，怎么合理使用 GoAccess 分析日志，<code>--keep-db-files</code>这个功能倒是可以尝试，这样就可以只分析新生产的日志文件了。</p><h2 id="7-不足"><a href="#7-不足" class="headerlink" title="7 不足"></a>7 不足</h2><p>尽管 GoAccess 很强大，但是它无法制定自定义监控规则，无法满足对站点更细粒度更全面的监控需求。此时就要使用到 ELK日志平台来分析站点的访问情况和流量分析。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
          <category> Tools </category>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> Tools </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Nginx搭建具备缓存功能的反向代理</title>
      <link href="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面已经展示了<strong>Nginx</strong>如何作为一个静态资源服务器进行工作，我们以此静态资源服务器作为-<strong>上游服务</strong>，再搭建一个Nginx服务，作为<strong>反向代理</strong>，演示当Nginx作为方向代理时，应该如何使用？</p><p>由于上游服务要处理非常复杂的业务逻辑，而且强调开发效率，因此它的性能并不怎么样，而使用了Nginx作为反向代理之后，可以由一台Nginx将请求用负载均衡算法代理给多台上游服务器工作，这样就实现了水平扩展，在用户无感知的情况下，我们可以添加更多的上游服务器，来提高性能。当上游服务器出现问题时，Nginx可以自动的将请求由有问题、出现灾难的服务器转交给正常的服务器，</p><a id="more"></a><p>现在这个页面仍然是我们刚才搭建的静态资源服务器所展示的页面。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/df2a42be-0e03-4eba-b963-00566fe3011b.jpg" alt></p><p>我们需要将此Nginx服务器变更为<strong>上游服务器</strong>，而上游服务器通常对公网是不进行访问的。我们可以做一个非常简单的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim conf&#x2F;nginx.conf</span><br><span class="line">   server &#123;</span><br><span class="line">        listen      127.0.0.1:8080;</span><br><span class="line">       # server_name  localhost;</span><br><span class="line"></span><br><span class="line"># 在listen上加入IP地址：127.0.0.1:8080</span><br><span class="line">这表示只能本机的进程来访问我们打开的8080端口，</span><br><span class="line"></span><br><span class="line"># 此时我们需要先将原先的Nginx进程停掉</span><br><span class="line">.&#x2F;nginx -s stop</span><br><span class="line"># 再重新打开Nginx，防止之前的端口仍然可以使用</span><br><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/ff657493-3010-44aa-8983-412cc49d08b0.png" alt></p><p>再次访问时，会发现无法访问了，因为Nginx拒绝了由浏览器发过去的请求连接。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/043e0d0a-61f5-4acc-8730-288adfb9ea29.png" alt></p><p>由此，Nginx静态资源服务器已经变成了一个上游服务器。</p><h1 id="1-开始搭建Nginx反向代理"><a href="#1-开始搭建Nginx反向代理" class="headerlink" title="1 开始搭建Nginx反向代理"></a>1 开始搭建Nginx反向代理</h1><p>之前的 <strong>Nginx</strong> 是1.14版本，而反向代理我们用openrestry的1.16版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun sbin]# .&#x2F;nginx -v</span><br><span class="line">nginx version: nginx&#x2F;1.14.2</span><br></pre></td></tr></table></figure><p>我们进入到openresty所在的nginx服务，修改其配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 在此处添加一个 upstream，即上游服务其中的一台server，它的访问地址是 127.0.0.1:8080</span><br><span class="line"># 如果我有很多上游服务，可以依次放在这里面。（命名为 local,此处可表示一批上游服务器）</span><br><span class="line">  #gzip  on;</span><br><span class="line">    upstream local&#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        # 此处设置当前代理服务器的域名，由于没有，就算了</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            # proxy_set_header：因为有了一台反向代理，所以我们再去拿一些变量或者值的时  候，可能就会出错了，</span><br><span class="line">            # 比如：一个TCP连接，是有对端地址的，而有了方向代理后，我们的              反向代理与客户端是一个TCP连接，而反向代理与上游服务器又是另外一个TCP连接，因此，如果我们取 $remote_addr 这个远端地址的时候，在上游服务那里，取到的实际上师我反向代理服务器的地址，而如果我想拿浏览器的客户端地址，作为限制浏览器访问速度功能的一个依据时，其实是拿不到的。因此，proxy_set_header可以把一些值添加为新的header发送给上游服务器，</span><br><span class="line">            # 比如说 X-Real-IP 将它的值设置为我们从TCP连接中拿到的远端IP地址，Host同样道理，因为用户直接访问的域名，是在他的浏览器中输入的，即可由上游服务器处理此域名，也可由反向代理服务器处理此域名，这些所有的配置特性，都可在官网的 http_proxy_module模块中找到。</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">            # http_proxy_module提供了非常丰富的特性+内置变量，而最重要之一特性就是 proxy_cache。</span><br><span class="line">            # 因为当我们的Nginx作为方向代理时，通常只有动态的请求，即不同的用户访问同一个URL时，看到的内容是不同的，此时才会交由上游服务处理。</span><br><span class="line">            # 但是有一些内容可能是一段时间不会发生变化的。此时，为了减轻上游服务的压力，我们就会让Nginx将上游返回来的内容缓存一段时间，如缓存一天等。在一天之内，即使上游服务器对这个内容的响应发生了变化，也不管，只会去拿已缓存的内容向浏览器发出响应。</span><br><span class="line">            # 因为 Nginx的性能远远领先于上游服务器的性能，所以使用此特性后，对我们一些小的站点，会有非常大的性能提升。</span><br><span class="line">            #proxy_cache my_cache;</span><br><span class="line">            #proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            #proxy_cache_valid 200 304 302 1d;</span><br><span class="line">            # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/2ab4b5f1-508b-47c5-af66-188ff2a9c828.png" alt></p><p>此时再去访问我们的代理服务器的IP地址，<strong>如果配置里域名，则用域名访问即可</strong>，因为监听的80端口，所以使用192.168.121.100:80/dangdang/book.html访问即可。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/14217284-3db6-4e6e-86ce-c6b7271843ef.jpg" alt></p><p>由下图可看出，我们的请求是由反向代理服务器发给我们的。其中的 <strong>server:nginx/1.16.0</strong>证明了它的身份。</p><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/06774664-cc31-4dbb-b5f5-bf44b60829d2.png" alt></p><h1 id="2-开始搭建Nginx缓存服务器"><a href="#2-开始搭建Nginx缓存服务器" class="headerlink" title="2 开始搭建Nginx缓存服务器"></a>2 开始搭建Nginx缓存服务器</h1><p>首先，我们需要<strong>proxy_cache_path</strong>来设置我们的缓存 文件写在那个目录下，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    proxy_cache_path &#x2F;tmp&#x2F;nginxcache levels&#x3D;1:2 keys_zone&#x3D;my_cache:10m max_size&#x3D;10g</span><br><span class="line">            inactive&#x3D;60m use_temp_path&#x3D;off;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            .....</span><br></pre></td></tr></table></figure><p>此处写在了 <code>/tmp/nginxcache</code>,以及这些文件的命名方式，这些文件的关键字是要放在共享内存中的，此处开了一个10m的共享内存，命名为my_cache，这些参数都在控制我们的缓存。</p><p>缓存如何使用呢？就是在我们需要做缓存的路径下添加<code>proxy_cache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       80;</span><br><span class="line">       #server_name  haoraunsun.pub;</span><br><span class="line">       server_name localhost;</span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">       location &#x2F; &#123;</span><br><span class="line">           root   html;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">           proxy_set_header Host $host;</span><br><span class="line">           proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">           # 就在此处</span><br><span class="line">           # proxy_cache 后面跟的就是我们刚才开辟的共享内存</span><br><span class="line">           proxy_cache my_cache;</span><br><span class="line">           # 共享内存中的key设置的是 同一个url 访问时 对不同的用户可能展示的内容不一样。因此，用户这样一个变量就要放在共享内存中。</span><br><span class="line">           # 此处只是简单的放置了 host+资源+参数,这些作为一个整体的Key。</span><br><span class="line">           proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">           # 对于哪些响应不返回，这里做了一些简单处理。</span><br><span class="line">           proxy_cache_valid 200 304 302 1d;</span><br><span class="line">           </span><br><span class="line">           # 所有的请求用proxy_pass代理到刚才配置的上游服务中去</span><br><span class="line">           proxy_pass http:&#x2F;&#x2F;local;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dbb3164a-c86b-45cd-97c4-4d0d228aeb3a.png" alt></p><p>加完这些参数后，需要重载配置文件，重新启用方向代理服务的配置。<br>再次直接访问站点，然后将上游服务停掉，看是否能获得同样的结果。</p><p>首先，我们再次访问，让其响应内容刷到缓存文件中。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/f116bae7-d1df-4716-9f3f-a5c461f0eb37.png" alt></p><p>查看进程<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/9733b5f7-3813-4f02-bf20-eda96a4c0ed0.png" alt></p><p>将上游服务停掉。<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/dfc0abce-1988-43f5-a4df-ae755de9af93.png" alt></p><p>再次访问，实际上读的是缓存系统中的内容作为响应返回给客户端。</p><p>此时，上游服务已经停掉了<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/a3d4faab-fcc5-4ce4-956f-7e75e52d8662.png" alt></p><p>再次访问<br><img src="/2019/11/05/5-Nginx%E6%90%AD%E5%BB%BA%E5%85%B7%E5%A4%87%E7%BC%93%E5%AD%98%E5%8A%9F%E8%83%BD%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/6f1b4d43-8144-49ac-8676-201d87902b4c.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Nginx搭建静态资源Web服务器</title>
      <link href="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font>`</p><h2 id="1-上传静态资源到Nginx目录中"><a href="#1-上传静态资源到Nginx目录中" class="headerlink" title="1 上传静态资源到Nginx目录中"></a>1 上传静态资源到Nginx目录中</h2><p>如这里新建了一个dlib目录，里面存放静态资源<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/534bed34-738b-47df-9819-997373f35987.png" alt></p><a id="more"></a><h2 id="2-修改-nginx-conf"><a href="#2-修改-nginx-conf" class="headerlink" title="2 修改 nginx.conf"></a>2 修改 nginx.conf</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;  # 监听端口</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        # 现在的请求比较简单，所有的请求都去访问我们 dlib&#x2F; 目录下面的文件，所以此处建立一个location &#x2F;  这个 “斜杠”表示所有的请求，</span><br><span class="line">        # 然后要去指定 url的后缀 要与我文件目录下的后缀一一对应（文件名），此处有两种写法：1.route，有个问题，会将URL中的一些路径，带到我们的文件目录中来。所以通常使用  2 alias：即 Nginx安装目录中的 dlib目录下，后面的路径与我们的URL路径是一一对应的。</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">做完这些后，再去启动Nginx。</span><br><span class="line">.&#x2F;nginx -c ..&#x2F;conf&#x2F;nginx.conf 会发现找不到这个文件</span><br><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf 即可</span><br><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/ec1f7e9f-05a4-41a8-9105-f636ec985a7b.jpg" alt></p><p><strong>192.168.121.100 为Nginx的服务器地址，8080是刚才配置的端口号，/dangdang/book.html是  dlib 目录下的 dangdang/book.html 。</strong></p><p><font color="red"><strong>但是此处有一个问题，打开访问页面的抓包查看</strong></font><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/324fabe1-d3b4-4f0a-aeae-5fbe99099406.jpg" alt></p><p>*<em>这里的book.html文件大小是3.0kB,与文件本身的大小是一致的。<font color="red">但是所有的文本文件是可以做 gzip 压缩的</font>，做完 gzip 压缩后，传递的字节数会大幅度减少，因此通常是 打开 gzip压缩功能。 *</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 打开 gzip开关</span><br><span class="line">gzip  on;</span><br><span class="line"></span><br><span class="line"># 小于 1字节的内容就不再行压缩了（1是可以配置的，不带单位为字节，可带单位：5K 5M 5G）</span><br><span class="line">因为对于特表小的文本内容。在TCP一个报文中就可以全部发送出来。此时再进行压缩，去消耗CPU资源，意义不大，此处是为了显示 gzip压缩效果，将其设置为1。</span><br><span class="line">gzip_min_length  1;</span><br><span class="line"></span><br><span class="line"># 表示 gzip的压缩级别</span><br><span class="line">gzip_comp_level  2;</span><br><span class="line"></span><br><span class="line"># 表示针对列举的类型才进行gzip压缩。比如 已经做过压缩的文件是没有必要再做gzip压缩的（zip文件等）</span><br><span class="line">gzip_types  text&#x2F;plain application&#x2F;x-javascript test&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php  image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line"></span><br><span class="line">加好这些配置后 reload</span><br><span class="line">sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/81b273e2-ff17-4686-b7d4-9ff0c3a0e0d8.png" alt></p><p><strong>再次访问此文件：</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/63cef855-efb9-4663-8018-804306a4f37f.jpg" alt></p><p>此时传输的字节数只有1.6KB了，从响应头中也可看出使用了  gzip压缩。<br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/d5decbbd-d47c-4472-a1ec-96b2d251f146.png" alt></p><p><strong>因此使用了 gzip 压缩后，整个静态资源 WEB服务，传输效率会提升很多。</strong></p><h2 id="3-Nginx常用功能"><a href="#3-Nginx常用功能" class="headerlink" title="3 Nginx常用功能"></a>3 Nginx常用功能</h2><h3 id="3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"><a href="#3-1-如果想要将-静态资源-服务器上的-文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？" class="headerlink" title="3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？"></a>3.1 如果想要将 静态资源 服务器上的 文件夹或文件所在的目录分享给用户，由用户去决定使用那些文件，这种常用的应用场景如何实现呢？</h3><p><strong>Nginx 提供了 官方模块 <font color="red">auto_index_module</font>在官方网站<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a> 提供了使用说明</strong>。</p><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on; # 加入此模块</span><br><span class="line">           # root   html;</span><br><span class="line">           # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">执行 reload即可。</span><br><span class="line"></span><br><span class="line">192.168.121.100:8080&#x2F;</span><br><span class="line">192.168.121.100:8080&#x2F;dangdang&#x2F;</span><br><span class="line">即可看到如下页面，则成功。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/6e4bca87-3437-42e4-bef5-df5592e3e6df.png" alt></p><hr><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/69254aad-1999-4d64-ab86-4c5cae6cacb7.png" alt></p><p>这样会显示 指定层级下 所有的目录及文件。<strong>提供了共享静态资源的功能.</strong></p><h3 id="3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"><a href="#3-2-常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。" class="headerlink" title="3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。"></a>3.2 常常公网带宽有限，当有很多并发用户使用我们的带宽时，就会形成一种争抢关系，可能会有一种策略：用户访问某些大文件的时候，限制下它的速度，以期望能够分离出足够的带宽，给用户访问要的小文件，如css、js等。</h3><p>使用 set命令+内置变量即可达到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        location &#x2F; &#123;</span><br><span class="line"></span><br><span class="line">           alias   dlib&#x2F;;</span><br><span class="line">           autoindex on;</span><br><span class="line">           set $limit_rate 1k;</span><br><span class="line">          # index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">set $limit_rate 1k; # 限制Nginx向浏览器发送响应的一个速度。</span><br></pre></td></tr></table></figure><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/396f4ca5-45fe-4926-8719-e22866f50bc2.png" alt></p><p>limit_rate：在 Nginx官网中的 <strong>ngx_http_core_module中 提供了 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="noopener">Embedded Variables</a>，在这其中有一个内置的变量，$limit_rate ,来限制我们的访问速度</strong><br><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/936fe133-af26-413a-beb9-8555e4b397ce.png" alt></p><p><strong>用法：set $limit_rate N； 是空间单位的；意义是：每秒传输 N 字节到浏览器中。<br>再去访问大页面，发现变得很慢了</strong>。</p><h3 id="3-3-记录access-log日志"><a href="#3-3-记录access-log日志" class="headerlink" title="3.3 记录access.log日志"></a>3.3 记录access.log日志</h3><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/2339d20c-675f-4197-a127-8dda272a9a06.png" alt></p><p><strong>nginx.conf 中的 log_format指令在定义日志的格式。</strong></p><p>这里的日志格式使用了许多变量，比如 $remote_addr<br>等等，具体见 00-Nginx访问日志详解。</p><p>这样的日志格式给他明明为 main , 因为我们可能对不同的域名下做不同格式的日志记录，或者对一些大文件，做反向代理等不同的用途时，记录不同日志格式。</p><p>配好 <strong>log_format</strong>之后，需要去设定 日志 记录在哪里</p><p><strong>access_log指令：决定日志记录在什么地方。access_log指令的位置决定了它所属的这样一类请求，会被记录到 当前指令所指定的路径中，采用 main这样的一种格式来记录。</strong></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name xxx;</span><br><span class="line">    acccess_log logs&#x2F;access.log main；</span><br><span class="line"># 这里access_log放在了 server下，即所有发送我这个域名或者请求端口的都会被记录到这个文件中</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx内置的所有变量都可以被记录到 日志中。</p><p>官方内置变量在上面提过了</p><p>第三方模块变量，如 ngx_http_gzip_module 中的 内置变量 $gzip_ratio：记录了压缩级别</p><p><img src="/2019/11/01/4-Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90Web%E6%9C%8D%E5%8A%A1%E5%99%A8/88b697fd-76d2-4960-8fe3-0567add181a7.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Nginx命令行演示-重载-热部署-切割</title>
      <link href="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/"/>
      <url>/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-检查80端口是否被占用"><a href="#1-检查80端口是否被占用" class="headerlink" title="1 检查80端口是否被占用"></a>1 检查80端口是否被占用</h1><p>yum install net-tools<br>netstat -ano | grep 80</p><h1 id="2-Nginx命令行"><a href="#2-Nginx命令行" class="headerlink" title="2 Nginx命令行"></a>2 Nginx命令行</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/48cac2e3-d525-4835-88aa-ce13207e19d7.jpg" alt></p><a id="more"></a><h1 id="3-重载配置文件"><a href="#3-重载配置文件" class="headerlink" title="3 重载配置文件"></a>3 重载配置文件</h1><p>此时在 nginx的安装目录下执行了 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -c &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">将Nginx启动了起来。</span><br></pre></td></tr></table></figure><p><font color="red">注意：<br>启动nginx时，服务无法启动，出现./nginx: error while loading shared libraries: libpcre.so.1: cannot open shared object file: No such file or directory的错误，解决方法如下：<br>ln -s /usr/local/lib/libpcre.so.1 /lib64/</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">再次修改了 Nginx配置文件中的一些值</span><br><span class="line">[root@haoransun nginx]# vim conf&#x2F;nginx.conf</span><br><span class="line">如需要将 #tcp_nopush这个注释去掉。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/098162e9-ca47-4da3-a22c-b0e1de51a776.png" alt></p><ul><li><p><strong><font color="red">mac</font>：当修改完成后，保存退出后，可以直接执行 <font color="red"> ./nginx -s reload </font>指令。这样是在Nginx在不停止对客户服务的情况下，使用了 tcp_nopush这个新的配置项，</strong></p></li><li><p>**<font color="red">CentOS</font>：<br>cd sbin<br>[root@haoransun sbin]# ./nginx -s reload即可</p></li><li><p><strong>ps -ef | grep nginx 可以看到正在运行的Nginx</strong></p></li></ul><h1 id="4-热部署"><a href="#4-热部署" class="headerlink" title="4 热部署"></a>4 热部署</h1><p><strong>即对Nginx在不停机的情况下做版本升级</strong>。<br><font color="red">对现有的Nginx的运行目录中的二进制可执行文件做一次备份：<strong>因为我们更换的只是二进制文件，并不会对其他文件做更换。</strong></font><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/1069c513-57b6-4f14-bf86-e72dc898eacf.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp nginx nginx.old</span><br></pre></td></tr></table></figure><p>先下载一个最新版本的Nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.16.0.tar.gz</span><br><span class="line">tar -zxvf 此版本Nginx</span><br><span class="line">编译生成二进制可执行文件</span><br><span class="line">进入新版本Nginx目录中，</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx</span><br><span class="line"></span><br><span class="line">上述命令会在Nginx最新版本目录中生成objs中间文件。</span><br><span class="line">make</span><br><span class="line">上述命令会生成Makerfile文件</span><br><span class="line">make install</span><br><span class="line">上述命令会在 &#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx目录下生成最新版本Nginx的运行目录文件，里面包含了最新版本的Nginx二进制可执行文件</span><br></pre></td></tr></table></figure><p>将我们编译好的<strong>最新版本的二进制文件</strong>拷贝到旧版本的二进制那个可执行文件目录中，替换掉当前Nginx进程正在使用的旧版本二进制文件。<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/daf5c361-5f4f-42c3-a7b0-26c0f1339f06.png" alt><br><font color="red"><strong>复制成功后，看到新版本的Nginx二进制可执行文件的size与旧版本是不一样的。</strong></font></p><p>现在，需要给<strong>正在运行的Nginx的Master进程发送一个信号，告诉它，我们要进行热部署了，做一次版本升级</strong><br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/c1c96e01-89b4-4df0-8302-d5594b0ab572.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 6655 ## master进程号</span><br><span class="line">ps -ef |grep nginx</span><br></pre></td></tr></table></figure><p>接下来会看到，<strong>Nginx Master进程会新起一个Nginx Master进程，新的Nginx Master进程使用了刚刚复制过来的最新的Nginx二级制文件，老的Worker也在运行，新的Master会生成新的Worker，它们会平滑的将所有的请求过渡到新的二进制文件所起的Nginx进程中，由此实现了平滑过度-热部署</strong>，如下所示：<br><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/086e0e3b-a68e-4e18-b5ca-2d2e14362e01.png" alt><br>我们看到，新老都存在，且新的Master进程父ID 为老的Master进程ID，由此看出新的是由老的新起的。</p><p>但是老的Master进程已经<strong>不再监听80或者443这样的Web端口</strong>，所以，新的连接，都会进入新的Nginx进程中。</p><p>这是，我们需要向老的Nginx进程发生一个信号，告诉它，优雅的关闭所有的 Worker进程.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH 6655 ## 老的Master 进程号</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/5a48e9e0-f3dc-410c-89d2-bc7de1124ecd.png" alt></p><p>老的Worker进程已经优雅的退出了，但是老的Master进程 6655 还存在，但是它手下已经没有Worker进程了，这说明了一件事情：所有的请求已经去全部切换到我们新升级好的Nginx中了。</p><p>./nginx -v :已经是最新的版本了</p><p><strong>如果升级过程完成后，没有任何问题，需要关闭老的master进程的话，使用以下命令：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill  -QUIT old_master_pid</span><br></pre></td></tr></table></figure><p><strong>但是 想要版本回退呢？只需要向老的Master进程 6655发送 reload 命令，让它重新拉起Worker进程，再把新的Master进程关掉。<font color="red"> 因此：老的Master进程是不会退出的，保留以允许我们做版本回退</font>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -v   # 此时这里是新的nginx版本号</span><br><span class="line"></span><br><span class="line">mv nginx nginx-1.16.0 # 将新的nginx文件命名为它的版本号</span><br><span class="line"></span><br><span class="line">mv nginx.old nginx # 将老的nginx命名为nginx</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">kill -USR1 6728(新的nginx的master的id)</span><br><span class="line"></span><br><span class="line">ps -ef |grep nginx</span><br><span class="line"></span><br><span class="line">.&#x2F;nginx -v # 已经是老版本的nginx了</span><br></pre></td></tr></table></figure><h1 id="5-切割日志文件"><a href="#5-切割日志文件" class="headerlink" title="5 切割日志文件"></a>5 切割日志文件</h1><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/e7955fcb-062b-424e-8db2-3f4cf82ba1ad.png" alt></p><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/ce22072b-b74f-4910-a13b-bc1a2407f577.png" alt></p><p>可以看到，haoransun_access.log日志文件已经有接近16M了，假设它此时已经很大了，想要将当前日志备份到另外一个文件中，而当前Nginx仍然正常运行，该如何做呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx -s reopen即可</span><br></pre></td></tr></table></figure><p><img src="/2019/10/20/3-Nginx%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%BC%94%E7%A4%BA-%E9%87%8D%E8%BD%BD-%E7%83%AD%E9%83%A8%E7%BD%B2-%E5%88%87%E5%89%B2/d7da2cf6-25f5-4fc5-b3bd-3618ecaea6a1.png" alt></p><p><strong>./nginx -s  reopen 命令即可做到，但是太麻烦了</strong></p><p><font color="red">具体的便捷做法参考000-Nginx访问日志配置及信息详解.。。。。</font></p><h2 id="5-1-日志切割-bash脚本demo"><a href="#5-1-日志切割-bash脚本demo" class="headerlink" title="5.1 日志切割 bash脚本demo"></a>5.1 日志切割 bash脚本demo</h2><p>往往会每一天或者每一周执行一次日志切割。</p><p>可以先写成一个<strong>bash脚本</strong>，在此脚本中，先将 haoransun.log复制一下，在执行 -s reopen命令。<br>最后将此脚本放在<strong>crontab</strong>中，比如：</p><p>在logs目录下新建 history文件夹：用于存放历史日志文件。</p><p><strong>在logs目录下新建rotate.sh脚本</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#Rotate the Nginx logs to prevent a single logfile from consuming too much disk space.</span><br><span class="line"># 此处 日志存放目录可以自定义，但一般存放在nginx相关的目录下</span><br><span class="line"># LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;history</span><br><span class="line"># CUR_LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;openstry&#x2F;nginx&#x2F;logs</span><br><span class="line">CUR_LOGS_PATH&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs</span><br><span class="line">YESTERDAY&#x3D;$(date -d &quot;yesterday&quot;+%Y-%m-%d )</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;haoransun_access.log $(LOGS_PATH)&#x2F;haoransun_access_$(YESTERDAY).log</span><br><span class="line"># 此处可以指定多个日志文件到指定目录下</span><br><span class="line">mv $(CUR_LOGS_PATH)&#x2F;error.log $(LOGS_PATH)&#x2F;error_$(YESTERDAY).log</span><br><span class="line">## 向 Nginx 主进程发送 USR1 信号 USR1 信号是重新打开日志文件</span><br><span class="line">kill -USR1 $(cat &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;nginx.pid.oldbin)</span><br></pre></td></tr></table></figure><p><strong>查看当前周期任务</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br><span class="line">crontab -e</span><br><span class="line">59 23 * * * root &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logx&#x2F;rotate.sh</span><br><span class="line">:wq</span><br><span class="line">再次 crontab -l 即可查看该脚本在每天的23点59分执行。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Nginx配置语法</title>
      <link href="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h1 id="1-Nginx-配置语法"><a href="#1-Nginx-配置语法" class="headerlink" title="1 Nginx 配置语法"></a>1 Nginx 配置语法</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/f6f8a64a-ed92-4f0c-90f7-c498e28692f0.jpg" alt></p><a id="more"></a><h1 id="2-Nginx配置参数：时间单位"><a href="#2-Nginx配置参数：时间单位" class="headerlink" title="2 Nginx配置参数：时间单位"></a>2 Nginx配置参数：时间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/4440df2c-e938-4f44-9a0e-2a9a1b44b32c.jpg" alt></p><h1 id="3-Nginx配置参数：空间单位"><a href="#3-Nginx配置参数：空间单位" class="headerlink" title="3 Nginx配置参数：空间单位"></a>3 Nginx配置参数：空间单位</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/2a8c6624-55b3-4554-b84c-8c448dc319b6.jpg" alt></p><h1 id="4-Nginx-语法示例"><a href="#4-Nginx-语法示例" class="headerlink" title="4 Nginx 语法示例"></a>4 Nginx 语法示例</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7a40655-721d-4edb-b990-9d4ef7b60470.jpg" alt></p><ul><li><p><strong>http{} 就是一个指令块</strong></p></li><li><p><strong>include            mime.types; 这是一条指令</strong></p></li><li><p><strong>指令后 可以跟多个参数</strong></p></li><li><p><strong>指令间以;为分隔符，可以将多条指令放在一行</strong></p></li><li><p><strong>指令块可以有名字，如：upstream指令块 thwp,有些指令块是没有名字的，如： http、server等。<font color="red">有名与否是由提供这个指令块的Nginx 模块来决定的</font></strong></p></li><li><p><strong>3m:表示3分钟</strong></p></li><li><p><strong>limit_req_zone 10m 开启10MB大小的共享内存空间，给不同的Worker使用</strong></p></li></ul><hr><h1 id="5-http配置的指令块"><a href="#5-http配置的指令块" class="headerlink" title="5 http配置的指令块"></a>5 http配置的指令块</h1><p><img src="/2019/10/17/2-Nginx%E9%85%8D%E7%BD%AE%E8%AF%AD%E6%B3%95/a7901424-0375-4abf-869b-7a62ddb552b8.jpg" alt></p><ul><li><p><strong>http模块有四个大的指令块：http、server、location、upstream</strong></p></li><li><p><strong>http{}：表示 大括号内的所有指令都是由<font color="red">http模块去解析、执行。一个非 http模块：stream等是没有办法被解析的</font>。</strong></p></li><li><p><strong>upstream：表示<font color="red">上游服务</font> ，当Nginx需要与Tomcat/DJango等企业内网的其他应用服务交互时，可以定义此 upstream.</strong></p></li><li><p><strong>server：对应一个组域名</strong></p></li><li><p><strong>location：一个URL表达式</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Nginx的前世今生</title>
      <link href="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
      <url>/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><p><a href="http://openresty.org/download/agentzh-nginx-tutorials-zhcn.html" target="_blank" rel="noopener">章亦春文档</a></p><h1 id="1-Nginx的三个主要应用场景"><a href="#1-Nginx的三个主要应用场景" class="headerlink" title="1 Nginx的三个主要应用场景"></a>1 Nginx的三个主要应用场景</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/2a504457-96be-4e0f-b1cf-ea6144ea59f4.jpg" alt></p><p><font color="red">流程解析：</font><br>一个<strong>Web</strong>请求从红色的线走下来后，会先经过<strong>Nginx</strong>,再到<strong>应用服务（Tomcat/Django）</strong>，再去访问<strong>Redis/MySQL</strong>这样的数据库，提供基本的数据功能，由此产生一个问题：应用服务由于要求开发效率高，所以它的运行效率很低，它的QPS/TPS/并发都是受限的，所以把这样的很多应用服务组成集群，向用户提供高可用性。当应用出现集群后，需要Nginx具有<strong>反向代理</strong>功能，将动态请求传导给应用服务，而应用服务构成集群，则又出现了两个需求，A：动态扩容。B：容灾。因此，<strong>反向代理</strong>必须具有负载均衡功能；其次，在这样的一个链路中，Nginx处于<strong>企业内网的边缘节点</strong>，随着网络链路的增长，用户体验的时延会增加，因此，如果能把一些所有用户看起来<strong>在一段时间内不变的动态内容缓存到Nginx</strong>中，由Nginx直接向用户提供访问，这样用户时延就会减少很多。反向代理引申出的另一个概念即是 <strong>缓存，加速我们的访问</strong>。（<strong>反向代理</strong>）</p><p>一些<strong>css/js/png</strong>等静态资源，是没有必要经由应用服务访问的，只需要通过本地文件 系统上放置的静态资源，直接由Nginx进行访问即可。（<strong>静态资源</strong>）</p><p>如果应用服务本身的性能有很多问题，但是数据库服务要比应用服务好的多，因为它的业务场景比较简单，并发性能/TPS都要远高于应用服务，因此可以使用Nginx直接访问数据库/Redis这样的数据库服务，利用Nginx强大的并发性能，实现Web防火墙这样复杂的业务功能（<strong>API服务</strong>）</p><a id="more"></a><h1 id="2-Nginx出现的缘由"><a href="#2-Nginx出现的缘由" class="headerlink" title="2 Nginx出现的缘由"></a>2 Nginx出现的缘由</h1><h2 id="2-1-互联网的数据量急速增长"><a href="#2-1-互联网的数据量急速增长" class="headerlink" title="2.1 互联网的数据量急速增长"></a>2.1 互联网的数据量急速增长</h2><p>互联网的快速普及<br>全球化<br>物联网</p><h2 id="2-2-摩尔定律：性能提升"><a href="#2-2-摩尔定律：性能提升" class="headerlink" title="2.2 摩尔定律：性能提升"></a>2.2 摩尔定律：性能提升</h2><h2 id="2-3-低效的Apache-：一个连接对应一个进程"><a href="#2-3-低效的Apache-：一个连接对应一个进程" class="headerlink" title="2.3 低效的Apache ：一个连接对应一个进程"></a>2.3 低效的Apache ：一个连接对应一个进程</h2><p>当有百万个连接时，Apache并不会建造出百万个进程，就算生成了，进程间的切换会损耗极大的性能。而Nginx可以轻松应对百万级的连接。</p><h1 id="3-Nginx的优点"><a href="#3-Nginx的优点" class="headerlink" title="3 Nginx的优点"></a>3 Nginx的优点</h1><p>高并发、高性能<br><strong>高并发</strong>往往需要我们对每个连接所使用的内存尽量的少即可达到，具有高并发的同时又能达到<strong>高性能</strong>，需要非常好的设计。Nginx可以达到什么样的标准呢？如现在的主流服务器（32核，64G）可以轻松地达到数千万并发连接，如果是处理简单的静态资源请求，可以达到100W的RPS(REQUEST PER SECOND)<br>可扩展性好<br>主要体现在<strong>模块化设计</strong>，非常的稳定。使其的第三方模块-生态圈非常稳定、丰富。甚至是有Tengene（淘宝修改了Nginx的源源码，做了定制化开发）/OpenResty（Lua语言开发）这样的第三方插件在他们之上，又生成了一套生态圈。<br>高可靠性<br>Nginx可以在服务器上持续不间断的运行数年。对于Nginx这样的一个高并发、高性能的反向代理服务器而言，往往运行在企业内网的边缘节点上，此时，若企业想提供<strong>5个9</strong>或更高的服务时，Nginx的宕机可能1年就1s的时间间隙。<br>热部署<br>在不停止服务的情况下，升级Nginx,此功能<strong>非常重要</strong>，因为在Nginx上可能跑了数百万的并发连接。如果是普通服务，则直接kill掉进程再重启即可。但对于Nginx而言，kill掉Nginx进程，会导致操作系统为所有的已建立连接的客户端发送<strong>TCP中的reset复位包</strong>，然而很多客户端是没有办法，很好的处理复位请求的，<strong>在大并发场景下，一些偶然事件就会导致非常恶劣的结果，因此热部署极其重要</strong><br>BSD许可证<br>开源且可商用</p><h1 id="4-Nginx的组成"><a href="#4-Nginx的组成" class="headerlink" title="4 Nginx的组成"></a>4 Nginx的组成</h1><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/e604a666-da3c-4a91-9866-53e81c4ff90f.jpg" alt></p><h2 id="4-1-Nginx二进制可执行文件"><a href="#4-1-Nginx二进制可执行文件" class="headerlink" title="4.1 Nginx二进制可执行文件"></a>4.1 Nginx二进制可执行文件</h2><p>由Nginx自身的官方模块+我们编译的第三方模块一起构建的文件，相当于汽车本身（有完整的系统，所有的功能都由它提供）</p><h2 id="4-2-Nginx-conf配置文件"><a href="#4-2-Nginx-conf配置文件" class="headerlink" title="4.2 Nginx.conf配置文件"></a>4.2 Nginx.conf配置文件</h2><p>相当于汽车的驾驶员。</p><h2 id="4-3-access-log访问日志"><a href="#4-3-access-log访问日志" class="headerlink" title="4.3 access.log访问日志"></a>4.3 access.log访问日志</h2><p>汽车经过所形成的GPS轨迹。</p><h2 id="4-4-error-log错误日志"><a href="#4-4-error-log错误日志" class="headerlink" title="4.4 error.log错误日志"></a>4.4 error.log错误日志</h2><p>黑匣子：定位问题。</p><h1 id="5-Nginx的版本（nginx-org-开源-nginx-com-商业）"><a href="#5-Nginx的版本（nginx-org-开源-nginx-com-商业）" class="headerlink" title="5 Nginx的版本（nginx.org:开源 nginx.com:商业）"></a>5 Nginx的版本（nginx.org:开源 nginx.com:商业）</h1><p>单数号：最新按本（新功能有待考验）<br>偶数号：稳定版本（一般选择此版本）<br>版本号-feature-bugfix-change<br>openresty.com openresty.org</p><h1 id="6-编译出适合自己的Nginx"><a href="#6-编译出适合自己的Nginx" class="headerlink" title="6 编译出适合自己的Nginx"></a>6 编译出适合自己的Nginx</h1><p>nginx.org网址 —–&gt; 选择download<br>在选中的版本上 —–&gt; 右键选择复制链接地址<br>在linux系统中  —–&gt; wget 下载地址即可<br><font color="red">ps:Nginx依赖一些第三方软件包，如gcc、gcc-c++、openssl、pcre、zlib,详细见0-Nginx安装过程</font></p><h1 id="7-目录解析"><a href="#7-目录解析" class="headerlink" title="7 目录解析"></a>7 目录解析</h1><p>解压压缩包： tar -zxvf nginx-xxx.tar.gz<br>进入解压源码包： cd nginx-xxx<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f08f5668-a4bd-4fe4-a790-c25c437b69e3.png" alt></p><p><strong>auto：</strong> 其中主要有四个子目录（cc:用于编译，lib库、os库对操作系统的判断，types），其他的文件是为了辅助<strong>config</strong>脚本执行时判定 当前的Nginx支持哪些模块、当前的操作系统有哪些特性供Nginx使用。</p><p><strong>CHANGES：</strong> Nginx每一个版本提供了哪些 Features、BugFix、Changes这三类特性。</p><p><strong>CHANGES.ru：</strong> 因为作者是 俄罗斯人，所以提供了一个俄罗斯语言的变更说明书。</p><p><strong>conf：</strong> 示例文件，将Nginx安装好后，为了方便运维去配置，会将此目录中的示例文件拷贝到安装目录。</p><p><strong>configure：</strong>这个脚本是用来生成中间文件、执行编译前的一个必备动作。</p><p><strong>contrib：</strong>提供了两个pl脚本和vim的工具，在没有使用vim工具时去打开nginx配置文件，会发现色彩没有什么变化（nginx语法没有在vim），此时，需要将contrib文件夹下的所有文件拷贝到我们自己的vim目录中，即：</p><p><strong>（mac:cp -r contrib/vim/* ~/.vim/ ）</strong></p><p>（ <font color="red">centos:自定义安装vim的话，使用 whereis vim查看vim的安装路径，vimfiles就在 /usr/share/vim/下<br>所以：cp -r contrib/vim/* /usr/share/vim/vimfiles/<br>此时再次打开nginx.conf文件，发现语法高亮显示</font>）<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/a11a6806-0bf0-4908-9f46-2dcb2b590271.png" alt></p><p><strong>html：</strong> 提供了两个标准的html文件。如图：<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/ae1df995-18a4-4490-97e6-93aa397516f7.png" alt><br>一个是发现500错误的时候重定向到当前指定文件。<br>一个是默认的Nginx的欢迎页面。</p><p><strong>man：</strong>Nginx的帮助文件<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/f5e50c6d-0b16-4494-9580-169a0fe8e3c3.png" alt></p><p><strong>src：</strong>Nginx的源代码。<img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/5d35e8e4-1b4c-482c-ad22-1b7af2a3d92f.png" alt>。即Nginx的框架都在这些源代码中。</p><h1 id="8开始编译"><a href="#8开始编译" class="headerlink" title="8开始编译"></a>8开始编译</h1><h2 id="8-1-编译前首先观察configure都支持哪些参数？"><a href="#8-1-编译前首先观察configure都支持哪些参数？" class="headerlink" title="8.1 编译前首先观察configure都支持哪些参数？"></a>8.1 编译前首先观察configure都支持哪些参数？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --help | more</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/b42567c1-87be-482a-86b1-b3779ec76e2c.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/727a8526-4163-4ed7-9c65-72dcaf6cf2ce.png" alt><br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/bdf16353-460a-49e4-9991-85b84e615d49.png" alt><br><strong>此处主要分为3大块参数内容</strong>：</p><ul><li><p>确定Nginx执行中会去找哪些目录下的文件作为它的辅助文件；如：使用动态模块，则 –modules-path=PATH 就会起作用；确定Nginx.log文件放在那里，则 –lock-path=PATH会起作用；然而，<font color="red">如果没有任何变动的话，只需要指定 –prefix=PATH即可,所有的其他的文件会在prefix目录下建立相应的文件夹</font>。</p></li><li><p>确定使用那些模块，而不使用那些模块。如 –with 与 –without, –with ：需要显示指定的时候，意味着Nginx默认是不会加载此模块的。 –without: 意味着默认会编译到Nginx中，如果加上了，则是显示取消编译的，移出默认的Nginx模块中。</p></li><li><p>确定Nginx编译时所需要的一些特殊参数。如 –with-cc=Path –with-cpp=Path 就是使用gcc编译时需要加一些什么样的优化参数；–with-debug 打印debug级别的日志，–with-pcre –with-zlib 这是需要加一些第三方的模块等等。</p></li></ul><h2 id="8-2-编译前的依赖包的安装"><a href="#8-2-编译前的依赖包的安装" class="headerlink" title="8.2 编译前的依赖包的安装"></a>8.2 编译前的依赖包的安装</h2><p>参看 附件 + 0篇内容，此处省略。。。。</p><h2 id="8-3-生成指定目录下的-Makefile，为下一步编译做准备"><a href="#8-3-生成指定目录下的-Makefile，为下一步编译做准备" class="headerlink" title="8.3 生成指定目录下的 Makefile，为下一步编译做准备"></a>8.3 生成指定目录下的 Makefile，为下一步编译做准备</h2><p>配置 Nginx的安装目录   /home/geek/nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标目录不存在，会自动创建</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;home&#x2F;geek&#x2F;nginx</span><br><span class="line">如果没有任何报错，则Nginx编译成功，如下图</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/30d9368f-43a9-4413-bef9-08f8311a1657.png" alt></p><p>在 ./configure 成功后，会生成一些中间文件，存储在 /objs 文件夹下。<br><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/14168daf-02ec-4203-812a-efc660721862.png" alt><br><strong>最重要的是会生成<font color="red"> ngx_modules.c：它决定了我们执行编译时有哪些模块，会被编译到Nginx中</font></strong>。</p><p><strong>所有被编译的模块都会列出来，最后形成一份 ngx_modules[] 数组</strong> <img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/20212437-7463-4e77-9fc2-de2c6a5b5700.png" alt></p><h2 id="8-4-编译"><a href="#8-4-编译" class="headerlink" title="8.4 编译"></a>8.4 编译</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make</span><br><span class="line">编译完成后，如果没有错误，就可以看到生成了大量的中间文件，如下图，他们都在 objs文件夹下。</span><br></pre></td></tr></table></figure><p><img src="/2019/10/15/1-Nginx%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/afa43e4b-c314-4481-a329-a1515a83f24b.jpg" alt></p><h2 id="8-5-为什么要知道Nginx的目标文件是放在objs下呢？"><a href="#8-5-为什么要知道Nginx的目标文件是放在objs下呢？" class="headerlink" title="8.5 为什么要知道Nginx的目标文件是放在objs下呢？"></a>8.5 为什么要知道Nginx的目标文件是放在objs下呢？</h2><p>如果是做<font color="red">Nginx版本升级</font>，此时不能执行** make install** ，而是需要从这里将目标文件 Nginx<br>拷贝到安装目录中，</p><p>C语言编译时生成的所有重要文件，都会存放在 *<em>objs/src目录 *</em>中。</p><p>如果使用了动态模块，则动态模块编译生成的<strong>so</strong>动态文件，也会放在<strong>objs 目录</strong>中。</p><h1 id="9-安装（首次安装时，可以使用此命令）"><a href="#9-安装（首次安装时，可以使用此命令）" class="headerlink" title="9 安装（首次安装时，可以使用此命令）"></a>9 安装（首次安装时，可以使用此命令）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# make install</span><br></pre></td></tr></table></figure><h1 id="10-安装目录下的目录解析"><a href="#10-安装目录下的目录解析" class="headerlink" title="10 安装目录下的目录解析"></a>10 安装目录下的目录解析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun nginx-1.14.2]# cd &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;</span><br><span class="line">ll</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 conf</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 html</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 logs</span><br><span class="line">drwxr-xr-x. 2 root root 4096 5月  30 07:43 sbin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-Nginx访问日志配置及信息详解</title>
      <link href="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-Nginx核心知识100讲，本人购买课程后依据视频讲解汇总成个人见解。</font></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过访问日志，可以知晓用户的地址，网站的哪些部分最受欢迎。用户的浏览时间，对大多数用户的浏览器做出针对性优化。</p><p>Nginx会把每个用户访问的日志信息记录到指定的日志文件里，供网站管理员分析用户浏览行为等，此功能又ngx_http_log_module 模块负责。</p><a id="more"></a><h2 id="1-访问日志参数"><a href="#1-访问日志参数" class="headerlink" title="1 访问日志参数"></a>1 访问日志参数</h2><p>Nginx访问日志主要有两个参数控制</p><ul><li><strong><font color="red">log_format</font></strong>：用来定义记录日志的格式（可以定义多种日志格式，取不同名字即可）。</li><li><strong><font color="red">access_log</font></strong>：用来指定日至文件的路径及使用的何种日志格式记录日志。</li></ul><h3 id="1-1-log-format与-access-log的默认值"><a href="#1-1-log-format与-access-log的默认值" class="headerlink" title="1.1 log_format与 access_log的默认值"></a>1.1 log_format与 access_log的默认值</h3><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/10c95625-1ad9-4c6a-b66e-30822bc362a3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log logs&#x2F;access.log main;</span><br></pre></td></tr></table></figure><p><strong>logs/access.log:这个为日志文件的存放路径，从安装目录开始，意思绝对路径为：/home/geek/nginx/logs/access.log</strong></p><p><strong>main：日志格式，通常为 combined</strong><br>若不想记录Nginx的日志：access_log off;</p><h3 id="1-2-log-format语法格式及参数语法说明"><a href="#1-2-log-format语法格式及参数语法说明" class="headerlink" title="1.2 log_format语法格式及参数语法说明"></a>1.2 log_format语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    log_format    &lt;NAME&gt;    &lt;Strin­­­g&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         格式标签   日志格式</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    格式标签：格式标签是给一套日志格式设置一个独特的名字</span><br><span class="line"></span><br><span class="line">    日志格式：给日志设置格式</span><br><span class="line"></span><br><span class="line">log_format格式变量：</span><br><span class="line"></span><br><span class="line">    $remote_addr  #记录访问网站的客户端地址</span><br><span class="line"></span><br><span class="line">    $remote_user  #远程客户端用户名</span><br><span class="line"></span><br><span class="line">    $time_local  #记录访问时间与时区</span><br><span class="line"></span><br><span class="line">    $request  #用户的http请求起始行信息</span><br><span class="line"></span><br><span class="line">    $status  #http状态码，记录请求返回的状态码，例如：200、301、404等</span><br><span class="line"></span><br><span class="line">    $body_bytes_sent  #服务器发送给客户端的响应body字节数</span><br><span class="line"></span><br><span class="line">    $http_referer  #记录此次请求是从哪个连接访问过来的，可以根据该参数进行防盗链设置。</span><br><span class="line"></span><br><span class="line">    $http_user_agent  #记录客户端访问信息，例如：浏览器、手机客户端等</span><br><span class="line"></span><br><span class="line">    $http_x_forwarded_for  #当前端有代理服务器时，设置web节点记录客户端地址的配置，此参数生效的前提是代理服务器也要进行相关的x_forwarded_for设置</span><br></pre></td></tr></table></figure><p><img src="/2019/10/11/0-Nginx%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BF%A1%E6%81%AF%E8%AF%A6%E8%A7%A3/4b4b4565ebf3424cb0c325dbd6bbcfd1.png" alt></p><h3 id="1-3-x-forwarded-for"><a href="#1-3-x-forwarded-for" class="headerlink" title="1.3 x_forwarded_for"></a>1.3 x_forwarded_for</h3><p>通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_addr拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端请求的服务器地址。</p><p>注意：<br>在定义日志目录中要注意的是，nginx进程设置的用户和组必须有对该路径创建文件的权限，<br>假设nginx的usr指令设置的用户名 和用户组都是www，而logs 目录的用户名和组是root，那么日志文件将无法被创建。</p><p>用nginx做前端代理后，我们发HTTP_X_FORWARDED_FOR 无法获取到客户端真实的IP地址了。</p><p>原因 nginx 默认并不会增加 X_FORWARDED_FOR 头信息，我们给他加上就好了。简单配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass          http:&#x2F;&#x2F;www.xxx.com;</span><br><span class="line">    proxy_set_header    Host             $host;</span><br><span class="line">    proxy_set_header    X-Real-IP        $remote_addr;</span><br><span class="line">    proxy_set_header    X-Forwarded-For  $proxy_add_x_forwarded_for;    &#x2F;&#x2F;别忘了这一句</span><br><span class="line">    proxy_set_header    HTTP_X_FORWARDED_FOR $remote_addr;              &#x2F;&#x2F;或是加上这一句</span><br><span class="line">    proxy_redirect      default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx 加载新的配置文件，就可以获取客户端真实的IP地址了。</p><p><strong>通常情况下用以上配置即可，可以将main换成combined(默认的日志格式)，其他不变即可。</strong></p><h3 id="1-4-access-log语法格式及参数语法说明"><a href="#1-4-access-log语法格式及参数语法说明" class="headerlink" title="1.4 access_log语法格式及参数语法说明"></a>1.4 access_log语法格式及参数语法说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  access_log    &lt;FILE&gt;    &lt;NAME&gt;;</span><br><span class="line"></span><br><span class="line">    关键字         日志文件   格式标签</span><br><span class="line"></span><br><span class="line">    关键字：其中关键字error_log不能改变</span><br><span class="line"></span><br><span class="line">    日志文件：可以指定任意存放日志的目录</span><br><span class="line"></span><br><span class="line">    格式标签：给日志文件套用指定的日志格式</span><br><span class="line"></span><br><span class="line">其他语法：</span><br><span class="line"></span><br><span class="line">    access_log    off;  #关闭access_log，即不记录访问日志</span><br><span class="line"></span><br><span class="line">    access_log path [format [buffer&#x3D;size [flush&#x3D;time]] [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    access_log path format gzip[&#x3D;level] [buffer&#x3D;size] [flush&#x3D;time] [if&#x3D;condition];</span><br><span class="line"></span><br><span class="line">    access_log syslog:server&#x3D;address[,parameter&#x3D;value] [format [if&#x3D;condition]];</span><br><span class="line"></span><br><span class="line">    说明：</span><br><span class="line"></span><br><span class="line">    buffer&#x3D;size  #为存放访问日志的缓冲区大小</span><br><span class="line"></span><br><span class="line">    flush&#x3D;time  #为缓冲区的日志刷到磁盘的时间</span><br><span class="line"></span><br><span class="line">    gzip[&#x3D;level]  #表示压缩级别</span><br><span class="line"></span><br><span class="line">    [if &#x3D; condition]  #表示其他条件</span><br></pre></td></tr></table></figure><p><strong>一般场景这些参数都无需配置，极端优化才有可能会<br>考虑这些参数</strong>。</p><h4 id="1-5-设置刷盘策略："><a href="#1-5-设置刷盘策略：" class="headerlink" title="1.5 设置刷盘策略："></a>1.5 设置刷盘策略：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">access_log &#x2F;home&#x2F;geek&#x2F;nginx&#x2F;logs&#x2F;access.log buffer&#x3D;32k flush&#x3D;5s;</span><br></pre></td></tr></table></figure><p><strong>buffer 满32k才刷盘；假如buffer不满5s强制刷盘。</strong></p><h3 id="1-6-其他："><a href="#1-6-其他：" class="headerlink" title="1.6 其他："></a>1.6 其他：</h3><p>error_log：配置错误日志，例如上例。</p><p>open_log_file_cache：<br>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用open_log_file_cache来设置日志文件缓存(默认是off)。语法:</p><p>open_log_file_cache max=N [inactive= time] [min_uses=N] [valid= time];</p><p>参数注释如下：</p><ul><li>max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用LRU算法将描述符关闭。</li><li>inactive:设置存活时间，默认是10s</li><li>min_uses:设置在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次</li><li>valid:设置检查频率，默认60s</li><li>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;</li></ul><h2 id="2-日志分析："><a href="#2-日志分析：" class="headerlink" title="2 日志分析："></a>2 日志分析：</h2><p>通过对日志格式的定义，就可以使用常见的 Linux 命令行工具进行分析了：</p><p>查找访问频率最高的 URL 和次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; print $10&#125;’ | sort | uniq -c</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’</span><br></pre></td></tr></table></figure><p>查找当前日志文件 500 错误的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | wc -l</span><br></pre></td></tr></table></figure><p>查找某一分钟内 500 错误访问的数量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | awk -F ‘^A’ ‘&#123; if( $5 &#x3D;&#x3D; 500) print $0&#125;’ | grep ’09:00’ | wc -l</span><br></pre></td></tr></table></figure><p>查找耗时超过 1s 的慢请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f access.log | awk -F ‘^A’ ‘&#123; if( $6&gt;1) print $0&#125;’</span><br></pre></td></tr></table></figure><h2 id="3-日志切割"><a href="#3-日志切割" class="headerlink" title="3 日志切割"></a>3 日志切割</h2><p>为了使Nginx的日志文件存储更合理、有序，我们需要将日志文件进行分开存储。</p><p>可以按时间来分开存储。今天的日志文件存储到一个文件中，明天的日志文件则存储到另一个新的文件中等等。</p><p>有两种方式：</p><ul><li><strong>1 手动切割</strong><br>（1）进入 logs目录，执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv access.log xxx(随便起个名).log</span><br></pre></td></tr></table></figure>即将以前的日志文件重命名为一个新的名字的日志文件。<br>（2）执行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR1 主进程号（需要先用 ps -ef| grep nginx命令找到master的进程号）</span><br></pre></td></tr></table></figure>kill -USR1 主进程号 ：</li></ul><p>在logs目录ls一个，会发现又自动多出了一个日志文件(这个日志文件的命名来源于nginx.conf文件里的access_log的路径)，并且里面无内容。这个文件就是切割出来的新文件，再有日志会往这里面写，而不会操作老日志文件。</p><ul><li><strong>2 自动进行切割</strong><br>（1）首先创建个sh文件（称为批处理日志文件），进入nginx的logs目录运行命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch cutlog.sh（文件名自定义，后缀.sh即可）</span><br></pre></td></tr></table></figure>（2）编辑cutlog.sh文件。输入如下内容：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim cutlog.sh</span><br><span class="line"></span><br><span class="line">D&#x3D;$(date +%Y%m%d)</span><br><span class="line">LOGS_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log &#x2F;$&#123;LOGS_PATH&#125;&#x2F;$&#123;D&#125;.log</span><br><span class="line">kill -USR1 $(cat &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid)</span><br></pre></td></tr></table></figure><p>说明：<br>D=$(date +%Y%m%d)，声明个变量，名为D（自定义）,值为date（Linux自带的，类似于函数，用于获取当前时间，并且格式为年月日）</p><p>${D}：引用上面变量名为D的变量</p><p>$(cat /usr/local/nginx/nginx.pid)：cat命令意思是查看。nginx.pid：存储的是nginx的主进程号。连起来的意思就是查看nginx主进程号，带上$(xx)就是说拿到xx</p><p>（3）定时执行某个文件，输入如下命令：(注意：运行crontab命令需要先用yum进行安装crontab，否则会出现command not found)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">crontab：定时执行某个文件</span><br><span class="line">crontab -e：编辑定时执行的内容</span><br></pre></td></tr></table></figure><p>（4）执行完（3）后会出现编辑器，输入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 59 *** &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;cutlog.sh</span><br></pre></td></tr></table></figure><p>即：在每天23点59分定时执行cutlog.sh文件，这样就实现了每天定时切割日志文件了。</p><p>原理：只是将手动切割写成个脚本。</p><p>如有需要每隔1个月就备份日志到其他地方并删除原位置的日志等类似需求都可以写个shell脚本，然后用linux的crontab来定时执行。</p><h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4 实例"></a>4 实例</h2><p>往往需要要对access_log、error_log日志进行切割。切割日志一般利用USR1信号让nginx产生新的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bashlogdir&#x3D;&quot;&#x2F;data&#x2F;logs&#x2F;nginx&quot; pid&#x3D;&#96;cat $logdir&#x2F;nginx.pid&#96; DATE&#x3D;&#96;date -d &quot;1 hours ago&quot; +%Y%m%d%H&#96; DATE_OLD&#x3D;&#96;date -d &quot;7 days ago&quot; +%Y%m%d&#96; for i in &#96;ls $logdir&#x2F;*access.log&#96;; do mv $i $i. $DATE done for i in &#96;ls $logdir&#x2F;*error.log&#96;; do mv $i $i. $DATE done kill -s USR1 $pid rm -v $logdir &quot;&#x2F;access.log.&quot; $DATE_OLD*rm -v $logdir&quot;&#x2F;error.log.&quot; $DATE_OLD*</span><br></pre></td></tr></table></figure><p><strong>1、分析：</strong>将上面的脚本放到crontab中，每小时执行一次（0 ），这样每小时会把当前日志重命名成一个新文件；然后发送USR1这个信号让Nginx 重新生成一个新的日志。（相当于备份日志）将前7天的日志删除；</p><p><strong>2、说明：</strong>在没有执行kill -USR1 $pid之前，即便已经对文件执行了mv命令而改变了文件名称，nginx还是会向新命名的文件”*access.log.2016032623”照常写入日志数据的。原因在于：linux系统中，内核是根据文件描述符来找文件的。</p><p><strong>3、logrotates：</strong>使用系统自带的logrotates，也可以实现nginx的日志分割，查看其bash源码，发现也是发送USR1这个信号。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swagger2学习与集成</title>
      <link href="/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/"/>
      <url>/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-Swagger2介绍"><a href="#1-Swagger2介绍" class="headerlink" title="1 Swagger2介绍"></a>1 Swagger2介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在都奉行<strong>前后端分离</strong>和<strong>微服务</strong>大行其道，分微服务及前后端分离后，前后端开发的沟通成本就增加了。所以一款强大的<strong>RestFul API</strong> 文档则十分重要，而目前在后端领域，基本上就是<font color="red">Swagger</font>的天下了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Swagger</strong>是一款RestFul接口的文档在线自动生成、功能测试功能框架。一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的Web服务，加上Swagger-ui，可以有很好的呈现。</p><a id="more"></a><h1 id="2-Spring-Boot-集成"><a href="#2-Spring-Boot-集成" class="headerlink" title="2 Spring Boot 集成"></a>2 Spring Boot 集成</h1><p>这里选用的Swagger版本：2.8.0</p><h2 id="2-1-POM依赖"><a href="#2-1-POM依赖" class="headerlink" title="2.1 POM依赖"></a>2.1 POM依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--swagger--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-2-编写配置文件-Swagger2Config-java"><a href="#2-2-编写配置文件-Swagger2Config-java" class="headerlink" title="2.2 编写配置文件(Swagger2Config.java)"></a>2.2 编写配置文件(Swagger2Config.java)</h2><p>主要是添加注解 <strong>@EnableSwagger2</strong> 和定义 <strong>Docket</strong> 的 <strong>bean</strong>类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@EnableSwagger2</span><br><span class="line">@Configuration</span><br><span class="line">public class SwaggerConfig&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;是否开启Swagger,正式环境一般是需要关闭的，可根据SpringBoot的多环境配置进行设置</span><br><span class="line">    @Value(value&#x3D;&quot;$&#123;swagger.enabled&#125;&quot;)</span><br><span class="line">    Boolean swaggerEnabled;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi()&#123;</span><br><span class="line">              return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())</span><br><span class="line">              &#x2F;&#x2F;是否开启</span><br><span class="line">             .enable(swaggerEnabled).select()</span><br><span class="line">             &#x2F;&#x2F;扫描的路径包</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(&quot;com.example.demo.controller&quot;))</span><br><span class="line">            &#x2F;&#x2F;指定路径处理 PathSelectors.any()代表所有的路径</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .pathMapping(&quot;&#x2F;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     private ApiInfo apiInfo()&#123;</span><br><span class="line">             return new ApiInfoBuilder()</span><br><span class="line">            .title(&quot;SpringBoot-Swagger2集成Demo &quot;)</span><br><span class="line">            .description(&quot;Allen&quot;)</span><br><span class="line">            &#x2F;&#x2F; 作者信息</span><br><span class="line">            .contact(new Contact(&quot;haoransun&quot;,&quot;demo.com&quot;,&quot;Wechat: SHR---97&quot;))</span><br><span class="line">            .version(&quot;1.0.0&quot;)</span><br><span class="line">            .build();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-添加文档内容-一般是在Controller，-请求参数上进行注解"><a href="#2-3-添加文档内容-一般是在Controller，-请求参数上进行注解" class="headerlink" title="2.3 添加文档内容(一般是在Controller， 请求参数上进行注解)"></a>2.3 添加文档内容(一般是在Controller， 请求参数上进行注解)</h2><p><img src="/2019/10/09/Swagger2%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9B%86%E6%88%90/ef7d3999287f12ba39cc345681993e8d.png" alt><br><strong>常用的注解<code>@Api</code>、<code>@ApiOperation</code>、<code>@ApiModel</code>、<code>@ApiModelProperty</code>示例中有进行标注，对于其他注解，大家可自动谷歌，毕竟常用的就这几个了。有了<code>swagger</code>之后，原本一些<code>post</code>请求需要<code>postman</code>这样的调试工具来进行发起，而现在直接在页面上就可以进行调试了，是不是很爽！对于服务的调用者而已，有了这份api文档也是一目了然，不需要和后端多少沟通成本，按着api说明进行前端开发即可。</strong></p><p>@ApilmplicatParams(name = “”,value=””,dataType=””,paramType=””)</p><p>paramType:<br>     query—@RequestParam<br>     header—@RequestHeader<br>     path —@PathVariable (RestFul风格)</p><p>ParameterBuilder tokenPar = new ParameterBuilder();<br>List<Parameter> pars = new ArrayList<Parameter>();<br>tokenPar.name(“Authorization”).description(“令牌”)<br>    .modelRef(new ModelRef(“string”)).parameterType(“header”)<br>    //header中的token参数非必填，传空也可以<br>    .required(false).build();<br>//根据每个方法名也知道当前方法在设置什么参数<br>pars.add(tokenPar.build());</Parameter></Parameter></p>]]></content>
      
      
      <categories>
          
          <category> Swagger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Swagger2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018-2019工作总结</title>
      <link href="/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/15/2018-2019%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-判断一个点是否在不规则多边形内部"><a href="#1-判断一个点是否在不规则多边形内部" class="headerlink" title="1  判断一个点是否在不规则多边形内部"></a>1  判断一个点是否在不规则多边形内部</h1><p>用途：<br>用于判断企业是否落在指定区域内</p><p>以一个点做射线，计算它与多边形边界的交点个数<br>       奇数个：在多边形内部<br>       偶数个：在多边形外部<br>推论：<br>如果点在多边形内部，射线第一次穿越边界一定是穿出多边形。<br>如果点在多边形外部，射线第一次穿越边界一定是进入多边形。</p><a id="more"></a><p>当射线穿越多边形边界的次数为偶数时，所有第偶数次（包括最后一次）穿越都是穿出，<br>因此所有第奇数次（包括第一次）穿越为穿入，由此可推断点在多边形外部。</p><p>当射线穿越多边形边界的次数为奇数时，所有第奇数次（包括第一次和最后一次）穿越都是穿出<br>由此可推断点在多边形内部。</p><p>判断难点：<br>点在多边形边上：                     点在线上，计算点与两个多边形顶点的连线斜率是否相等。<br>点和多边形的顶点重合：           比较坐标。<br>射线经过多边形顶点：              射线经过的点都属于射线以上的一侧<br>射线经过多边形的一条边：       射线连续经过多边形的两个相邻顶点。</p><p>需要客户提前给出待落区域的经纬度。</p><p>射线法： （java）<br>代码位置：com.aliyun.fin.rebengine.manager.job.task.AnalysisRegionOfEntDataTask</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 方法1   射线法：判断某一个点(经纬度)是否在一个多边形内  奇数个交点证明在多边形内部，偶数个交点在多边形外部</span><br><span class="line"> * @param longitude</span><br><span class="line"> * @param latitude</span><br><span class="line"> * @param points</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean judgeDom(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line">    int iSum, iCount, iIndex;</span><br><span class="line">    double dLon1 &#x3D; 0, dLon2 &#x3D; 0, dLat1 &#x3D; 0, dLat2 &#x3D; 0, dLon;</span><br><span class="line">    iSum&#x3D;0;</span><br><span class="line">    iCount &#x3D; points.size();</span><br><span class="line">    for(iIndex &#x3D; 0;iIndex&lt;iCount;iIndex++)&#123;</span><br><span class="line">        if(iIndex &#x3D;&#x3D; iCount-1)&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(0).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(0).getLatitude();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dLon1 &#x3D; points.get(iIndex).getLongitude();</span><br><span class="line">            dLat1 &#x3D; points.get(iIndex).getLatitude();</span><br><span class="line">            dLon2 &#x3D; points.get(iIndex+1).getLongitude();</span><br><span class="line">            dLat2 &#x3D; points.get(iIndex+1).getLatitude();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断给定点的纵坐标 是否在边的两端点的水平平行线之间，在则可能有交点，继续判断交点是否在左射线上</span><br><span class="line">        boolean isInArea &#x3D; ((latitude&gt;&#x3D;dLat1)&amp;&amp;(latitude&lt;dLat2))|| (latitude&gt;&#x3D;dLat2)&amp;&amp;(latitude&lt;dLat1);</span><br><span class="line">        if(isInArea)&#123;</span><br><span class="line">            &#x2F;&#x2F;因为要做分母，所以判断不能为0,</span><br><span class="line">            if(Math.abs(dLat1-dLat2)&gt;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;得到给定点向左射线与边的  交点  的  经度坐标</span><br><span class="line">                dLon &#x3D; dLon1 - ((dLon1-dLon2)*(dLat1-latitude))&#x2F;(dLat1-dLat2);</span><br><span class="line">                &#x2F;&#x2F;比较交点 经度坐标，如果交点在给定点的左侧：则当前交点是射线与边的交点</span><br><span class="line">                if(dLon&lt;longitude)&#123;</span><br><span class="line">                    iSum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if((iSum%BASE_EVEN)!&#x3D;0)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/**</p><ul><li><p>方法2   判断某一个点(经纬度)是否在一个多边形内  点在线内、线外、线上、面内、面外 来进行多层判断</p></li><li><p>@param longitude</p></li><li><p>@param latitude</p></li><li><p>@param points</p></li><li><p>@return</p></li><li><p>/</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public boolean judgeDom2(Double longitude,Double latitude,List&lt;AreaPoint&gt; points) &#123;</span><br><span class="line"></span><br><span class="line">    boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for(int i&#x3D;0, l&#x3D;points.size(),j&#x3D;l-1;i&lt;l;j&#x3D;i,i++)&#123;</span><br><span class="line"></span><br><span class="line">        double sx &#x3D; points.get(i).getLongitude();</span><br><span class="line"></span><br><span class="line">        double sy &#x3D; points.get(i).getLatitude();</span><br><span class="line"></span><br><span class="line">        double tx &#x3D; points.get(j).getLongitude();</span><br><span class="line"></span><br><span class="line">        double ty &#x3D; points.get(j).getLatitude();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;点与多边形顶点重合</span><br><span class="line"></span><br><span class="line">        boolean isCoincide &#x3D; (sx&#x3D;&#x3D;longitude&amp;&amp;sy&#x3D;&#x3D;latitude)||(tx&#x3D;&#x3D;longitude&amp;&amp;ty&#x3D;&#x3D;latitude);</span><br><span class="line"></span><br><span class="line">        if(isCoincide)&#123;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断线段两端点是否在射线两侧</span><br><span class="line"></span><br><span class="line">        boolean isTwoSide &#x3D; (sy&lt;latitude&amp;&amp;ty&gt;&#x3D;latitude)||(sy&gt;&#x3D;latitude&amp;&amp;ty&lt;latitude);</span><br><span class="line"></span><br><span class="line">        if(isTwoSide)&#123;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 线段上与坐标 Y 相同的 点 X 的坐标</span><br><span class="line"></span><br><span class="line">            double x &#x3D; sx+(latitude-sy)*(tx-sx)&#x2F;(ty-sy);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;点在多边形边上</span><br><span class="line"></span><br><span class="line">            if(x&#x3D;&#x3D;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                return true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;射线穿过多边形边界</span><br><span class="line"></span><br><span class="line">            if(x&gt;longitude)&#123;</span><br><span class="line"></span><br><span class="line">                flag &#x3D; !flag;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return  flag?true:false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-聚类经纬度"><a href="#2-聚类经纬度" class="headerlink" title="2 聚类经纬度"></a>2 聚类经纬度</h1><p>聚类经纬度数据（全景洞察-全景概览 五角星、实心圆）<br>从reb_ent_location中取出经纬度、企业信息等数据。</p><p>企业经纬度各分10等份（汇总各个区域的最大最小值）。<br>分别统计出 企业经纬度的最大最小值。</p><p>等分公式：对经纬度的 最大最小值分别计算<br>Quadrant:  (minLongitude,minLatitude)—à  (maxLongitude,maxLatitude)<br>在逻辑上勾画出一个象限经纬系。</p><p>勾画出10等份区域：[(max-min)/10]*i+min  i: 0-10</p><p>投射每一个企业对应的经纬度落在所画区域上<br>min + |(当前企业经度-min)/(max-min)/10|<em>(max-min)/10<br>min + |(当前企业维度-min)/(max-min)/10)|</em>(max-min)/10</p><p>| | ：是对其中的数据向下取整</p><p>返回100个左右的点，每一个点所对应的坐标是它周围点的坐标均值。<br>即：每一个点都可以想象成是一个 “黑洞”，吸收它附近的相近点<br>页面上：每一个点 都有它所对应的企业列表集合。</p><p>代码位置：com.aliyun.fin.rebengine.manager.job.task.ClusterEntLocationDataTask</p><h1 id="3-NLP分词。文章相似度"><a href="#3-NLP分词。文章相似度" class="headerlink" title="3 NLP分词。文章相似度"></a>3 NLP分词。文章相似度</h1><p>NLP分词、政策相似度判断<br>（依托于 hanlp jar包，具体用法靠参考官网 <a href="https://github.com/hankcs/HanLP）" target="_blank" rel="noopener">https://github.com/hankcs/HanLP）</a><br>A：政策关键词 + 政策重合度（onecompany提供政策数据）<br> B：热词云 + 舆情数据[公司品牌+企业高管…]（onecompany提供舆情数据）<br> C：自建停分词词典（需要积累）+ 客户自定义词词典。<br>D：舆情数据需要进行：公司品牌+企业高管+产品品质+服务质量+其他风险 的 摘选。</p><p>舆情分词分模块难点：<br>停分词词典需要积累数据，每天都会有新的舆情数据进来，会有新的热词产生，同时也需要追加新的停分词到词典中。（目前是每次对新舆情数据分词，人工过滤掉无意义词）<br>如何分辨当条舆情数据是当前所属公司的哪一类的舆情：（高管、品牌、产品、质量）（产品品质与服务质量没有明显的区分度）<br>特征词数据表：<br>reb_data_db-àpublic_custom  (舆情分类特征词样本太少，目标区分度不明显)<br>读取舆情正文+标题，只要正文中出现特征词，就将当前舆情分类。<br>政策相似度判断：（即：政策分词后的词列表A 与 词列表B 相似度分值）<br>相似度算法位置： com.aliyun.fin.rebengine.nlp.util.algorithm<br>  两两地区的政策进行相似度判断。需要自己进行阈值的调参。</p><h1 id="4-文章分类"><a href="#4-文章分类" class="headerlink" title="4 文章分类"></a>4 文章分类</h1><p>政策分类、扶持对象<br>临港项目： onecompany 对政策进行分类+扶持对象的判别。</p><p>   非临港项目：可能需要自己训练一个政策分类器。此处写自己的思路：<br>利用分布式爬虫框架 从网上抓取各省市县以往的各项政策，需要抓取的内容包含：<br>政策标题+政策正文+该项政策的分类（金融、农业、工业..等）+政策扶持对象。</p><p>利用已有的这些数据 “喂养” 自己的 分类器，（我个人觉得这不是一个线性问题，不是二分逻辑[0/1的问题]，是一个多分类问题，可能需要算法同学在隐藏层的激活函数设置的极好。[说的话都会说，关键在实现] ）<br>训练好分类器之后，就可以对现有的政策进行判别。</p><p>或者像 舆情分模块一样：生硬的将政策分类的特征词、政策扶持对象的特征词提取到表中：只要待判别的政策正文中出现了这些特征词，就给当前政策打上分类标记、扶持对象标记。</p><h1 id="5-Python脚本（参考）"><a href="#5-Python脚本（参考）" class="headerlink" title="5 Python脚本（参考）"></a>5 Python脚本（参考）</h1><p>python脚本（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import re</span><br><span class="line">import pymysql</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as  np</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">#数据库配置</span><br><span class="line">mysql_config &#x3D; &#123;</span><br><span class="line">    # 规则中心</span><br><span class="line">    &#39;rule&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    # 数据来源</span><br><span class="line">    &#39;data&#39;: &#123;</span><br><span class="line">        &#39;host&#39;: &#39;xxx1&#39;,</span><br><span class="line">        &#39;port&#39;: 3306,</span><br><span class="line">        &#39;user&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;passwd&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;db&#39;: &#39;xxx&#39;,</span><br><span class="line">        &#39;charset&#39;: &#39;utf8&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据处理类</span><br><span class="line">class DataDict:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 最值数据的枚举KEY</span><br><span class="line">        self._max_min &#x3D; &#39;max_min&#39;</span><br><span class="line">        self._conn_rule &#x3D; pymysql.connect(**mysql_config[&#39;rule&#39;])</span><br><span class="line">        self._conn_data &#x3D; pymysql.connect(**mysql_config[&#39;data&#39;])</span><br><span class="line"></span><br><span class="line">    # DataFrame转换字典</span><br><span class="line">    def _get_data_dict(self, v):</span><br><span class="line">        if len(v) &#x3D;&#x3D; 1:</span><br><span class="line">            return &#123;col: None if v.iloc[0][col] &#x3D;&#x3D; np.nan else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        elif not v.empty and len(v) &gt; 1:</span><br><span class="line">            min_max &#x3D; &#123;&#125;</span><br><span class="line">            for row in v.iterrows():</span><br><span class="line">                temp &#x3D; &#123;col: row[1][col] for col in v.columns&#125;</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]] &#x3D; temp</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;id&#39;)</span><br><span class="line">                min_max[temp[&#39;index_name&#39;]].pop(&#39;index_name&#39;)</span><br><span class="line">            min_max_temp &#x3D; &#123;&#125;</span><br><span class="line">            for key in min_max.keys():</span><br><span class="line">                min_max_temp.update(&#123;</span><br><span class="line">                    &#39;min_&#39; + key: min_max[key].get(&#39;min_value&#39;),</span><br><span class="line">                    &#39;max_&#39; + key: min_max[key].get(&#39;max_value&#39;),</span><br><span class="line">                &#125;)</span><br><span class="line">            return min_max_temp</span><br><span class="line">        elif v.empty and len(v) &lt;&#x3D; 0:</span><br><span class="line">            return None</span><br><span class="line">            # return &#123;col: 0.0 if v.empty else v.iloc[0][col] for col in v.columns&#125;</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    # 最值数据获取（用于归一化处理）</span><br><span class="line">    def _get_min_max_data(self, conn_data, sql_max_min):</span><br><span class="line">        _v &#x3D; pd.read_sql_query(sql_max_min, con&#x3D;conn_data)</span><br><span class="line">        _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">        return self._get_data_dict(_v)</span><br><span class="line"></span><br><span class="line">    # 获取评分项处理后的数据</span><br><span class="line">    def get_process_data(self, ent_name):</span><br><span class="line">        data_dict &#x3D; dict()</span><br><span class="line">        rts &#x3D; dict()</span><br><span class="line">        _s &#x3D; pd.read_sql_query(&quot;SELECT * FROM data_config &quot;, con&#x3D;self._conn_rule)</span><br><span class="line">        _s.set_index([&#39;index&#39;], inplace&#x3D;True)</span><br><span class="line">        raw_sqls &#x3D; _s.to_dict()[&#39;index_sql&#39;]</span><br><span class="line">        for k in raw_sqls:</span><br><span class="line">            if k in self._max_min:</span><br><span class="line">                data_dict[&#39;min_max&#39;] &#x3D; self._get_min_max_data(self._conn_data, raw_sqls[self._max_min])</span><br><span class="line">            else:</span><br><span class="line">                if &#39;%&#39; in raw_sqls[k]:</span><br><span class="line">                    raw_sqls[k] &#x3D; raw_sqls[k].replace(&quot;%&quot;, &quot;%%&quot;)</span><br><span class="line">                sql &#x3D; raw_sqls[k].replace(&#39;&#123;ent_name&#125;&#39;, &#39;%(ent_name)s&#39;)</span><br><span class="line">                _v &#x3D; pd.read_sql(sql, params&#x3D;&#123;&#39;ent_name&#39;: ent_name&#125;, con&#x3D;self._conn_data)</span><br><span class="line">                # _v.fillna(0, inplace&#x3D;True)</span><br><span class="line">                rts[k] &#x3D; self._get_data_dict(_v)</span><br><span class="line">        for k in rts:</span><br><span class="line">            if rts[k] is not None:</span><br><span class="line">                data_dict.update(rts[k])</span><br><span class="line">        return data_dict</span><br><span class="line"></span><br><span class="line">    # 评分卡数据</span><br><span class="line">    def get_score_card(self):</span><br><span class="line">        sql &#x3D; &#39;&#39;&#39;</span><br><span class="line">        SELECT</span><br><span class="line">   A.score_name,</span><br><span class="line">   A.default_value,</span><br><span class="line">   B.express,</span><br><span class="line">   B.score_value,</span><br><span class="line">   B.default_score</span><br><span class="line">FROM</span><br><span class="line">   base_score_card A,</span><br><span class="line">   base_score_card_item B</span><br><span class="line">WHERE</span><br><span class="line">   A.id &#x3D; B.card_id</span><br><span class="line">ORDER BY</span><br><span class="line">   A.id, B.order_no DESC</span><br><span class="line">        &#39;&#39;&#39;</span><br><span class="line">        score_card_df &#x3D; pd.read_sql_query(sql, self._conn_rule)</span><br><span class="line">        score_card_df_dict &#x3D; dict(list(score_card_df.groupby([&#39;score_name&#39;])))</span><br><span class="line">        score_card &#x3D; &#123;&#125;</span><br><span class="line">        for k in score_card_df_dict:</span><br><span class="line">            score_card[k] &#x3D; []</span><br><span class="line">            for index, row in score_card_df_dict[k].iterrows():</span><br><span class="line">                score_card[k].append((row[&#39;express&#39;], row[&#39;score_value&#39;], row[&#39;default_value&#39;], row[&#39;default_score&#39;]))</span><br><span class="line">        return score_card</span><br><span class="line"></span><br><span class="line">    # 获取自定义公式分数节点</span><br><span class="line">    def get_score_node(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM model_score_node&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        sn_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            sn_dict[row[&#39;score_node_id&#39;]] &#x3D; row[&#39;expression&#39;]</span><br><span class="line">        return sn_dict</span><br><span class="line"></span><br><span class="line">    # 获取分数层级数据字典</span><br><span class="line">    def get_socre_level(self):</span><br><span class="line">        _dim_score_define_df &#x3D; pd.read_sql_query(&#39;SELECT * FROM dimensional_score_define&#39;, con&#x3D;self._conn_rule)</span><br><span class="line">        level_dict &#x3D; &#123;&#125;</span><br><span class="line">        for index, row in _dim_score_define_df.iterrows():</span><br><span class="line">            level_dict[row[&#39;node_name&#39;]] &#x3D; &#123;col: row[col] for col in _dim_score_define_df.columns&#125;</span><br><span class="line">        return level_dict</span><br><span class="line"></span><br><span class="line">    def close_all_conn(self):</span><br><span class="line">        self._conn_rule.close()</span><br><span class="line">        self._conn_data.close()</span><br><span class="line"></span><br><span class="line"># 规则执行器</span><br><span class="line">class RuleExecutor:</span><br><span class="line">    def __init__(self, ent_name):</span><br><span class="line">        data_dict &#x3D; DataDict()</span><br><span class="line">        self._original_data_dict &#x3D; data_dict.get_process_data(ent_name)</span><br><span class="line">        self._score_card &#x3D; data_dict.get_score_card()</span><br><span class="line">        self._sn_dict &#x3D; data_dict.get_score_node()</span><br><span class="line">        self._level_dict &#x3D; data_dict.get_socre_level()</span><br><span class="line">        self._tree_node &#x3D; &#123;&#125;</span><br><span class="line">        self._temp &#x3D; []</span><br><span class="line">        self._re_pattern &#x3D; r&#39;(?&lt;&#x3D;\&#123;)[^&#125;]*(?&#x3D;\&#125;)&#39;</span><br><span class="line">        self._result_dict &#x3D; &#123;&#125;</span><br><span class="line">        data_dict.close_all_conn()</span><br><span class="line"></span><br><span class="line">    def _add_node(self, p, node):</span><br><span class="line">        # 节点list</span><br><span class="line">        p[&quot;children&quot;] &#x3D; []</span><br><span class="line">        for n in node:</span><br><span class="line">            if n.get(&quot;pid&quot;) &#x3D;&#x3D; p.get(&quot;id&quot;):</span><br><span class="line">                p[&quot;children&quot;].append(n)</span><br><span class="line">        # 递归子节点，查找子节点的子节点</span><br><span class="line">        for t in p[&quot;children&quot;]:</span><br><span class="line">            if not t.get(&quot;children&quot;):</span><br><span class="line">                t[&quot;children&quot;] &#x3D; []</span><br><span class="line">            t[&quot;children&quot;].append(self._add_node(t, node))</span><br><span class="line">        # 退出递归的条件</span><br><span class="line">        if len(p[&quot;children&quot;]) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def init_score_tree(self):</span><br><span class="line">        root &#x3D; []</span><br><span class="line">        node &#x3D; []</span><br><span class="line">        # 获取根节点 和 其他子节点 list</span><br><span class="line">        for k in self._level_dict:</span><br><span class="line">            if self._level_dict[k][&#39;pid&#39;] &#x3D;&#x3D; 0:</span><br><span class="line">                root.append(self._level_dict[k])</span><br><span class="line">            else:</span><br><span class="line">                node.append(self._level_dict[k])</span><br><span class="line">        # 查找子节点</span><br><span class="line">        for p in root:</span><br><span class="line">            self._add_node(p, node)</span><br><span class="line">        self._tree_node.update(root[0])</span><br><span class="line"></span><br><span class="line">    def _get_card_score(self, sn_id):</span><br><span class="line">        score_list &#x3D; self._score_card[sn_id]</span><br><span class="line"></span><br><span class="line">        for bds in score_list:</span><br><span class="line">            express &#x3D; bds[0]</span><br><span class="line">            score_value &#x3D; bds[1]</span><br><span class="line">            default_value &#x3D; None if np.isnan(bds[2]) else bds[2]</span><br><span class="line">            default_score &#x3D; None if np.isnan(bds[3]) else bds[3]</span><br><span class="line"></span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, express)</span><br><span class="line">            str_list &#x3D; list(set(str_list))</span><br><span class="line">            _data_dict &#x3D; &#123;&#125;</span><br><span class="line">            for c in str_list:</span><br><span class="line">                if c not in self._original_data_dict:</span><br><span class="line">                    return 0</span><br><span class="line">                _data_dict[c] &#x3D; default_score if self._original_data_dict[c] is None  else self._original_data_dict[c]</span><br><span class="line">            express_replaced &#x3D; express.format(**_data_dict)</span><br><span class="line"></span><br><span class="line">            try:</span><br><span class="line">                if eval(express_replaced):</span><br><span class="line">                    if &#39;&#123;&#39; in score_value:</span><br><span class="line">                        sv_express &#x3D; score_value.format(**self._original_data_dict)</span><br><span class="line">                        score_value &#x3D; float(eval(sv_express))</span><br><span class="line">                        score_value &#x3D; score_value if score_value !&#x3D; 0 else abs(score_value)</span><br><span class="line">                    break</span><br><span class="line">            except BaseException:</span><br><span class="line">                return default_value</span><br><span class="line">        return float(score_value)</span><br><span class="line"></span><br><span class="line">    # 执行sn表达式</span><br><span class="line">    def _get_sn_express_value(self, sn_id):</span><br><span class="line">        sn_node_express &#x3D; self._sn_dict[sn_id]</span><br><span class="line">        str_list &#x3D; re.findall(self._re_pattern, sn_node_express)</span><br><span class="line">        v_dict &#x3D; &#123;&#125;</span><br><span class="line">        for new_sn_id in str_list:</span><br><span class="line">            if new_sn_id in self._sn_dict.keys():</span><br><span class="line">                v_dict[new_sn_id] &#x3D; self._get_sn_express_value(new_sn_id)</span><br><span class="line">            else:</span><br><span class="line">                card_score &#x3D; self._get_card_score(new_sn_id)</span><br><span class="line">                v_dict[new_sn_id] &#x3D; card_score</span><br><span class="line">        score &#x3D; eval(sn_node_express.format(**v_dict))</span><br><span class="line">        # print(&quot;sn_id:%s,  %s    %s &#x3D; %s&quot; % (sn_id, sn_node_express, sn_node_express.format(**v_dict) ,score))</span><br><span class="line">        return score</span><br><span class="line"></span><br><span class="line">    # 执行dimensional_score_define的表达式</span><br><span class="line">    def _get_expression_value(self, node_name, level_dict):</span><br><span class="line">        self._temp.append(node_name)</span><br><span class="line"></span><br><span class="line">        item &#x3D; level_dict[node_name]</span><br><span class="line"></span><br><span class="line">        if item[&#39;expression&#39;] is None or item[&#39;expression&#39;] &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">            sn_id &#x3D; item[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line">        else:</span><br><span class="line">            expression &#x3D; item[&#39;expression&#39;]</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for var in str_list:</span><br><span class="line">                v_dict[var] &#x3D; self._get_expression_value(var, level_dict)[1]</span><br><span class="line">            score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line"></span><br><span class="line">            score_info &#x3D; (item[&#39;formula_id&#39;], score)</span><br><span class="line">            self._result_dict[node_name] &#x3D; &#123;&#39;formula_id&#39;: item[&#39;formula_id&#39;], &#39;value&#39;: score_info[1],</span><br><span class="line">                                            &#39;dis_name&#39;: item[&#39;node_display_name&#39;]&#125;</span><br><span class="line">            return score_info</span><br><span class="line"></span><br><span class="line">    def _computer_node_score(self, tree_node&#x3D;&#123;&#125;):</span><br><span class="line">        if tree_node[&#39;node_name&#39;] in self._temp:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        dis_name &#x3D; tree_node[&#39;node_display_name&#39;]</span><br><span class="line">        expression &#x3D; tree_node[&#39;expression&#39;]</span><br><span class="line">        result &#x3D; &#123;&quot;name&quot;: dis_name, &#39;score&#39;: 0&#125;</span><br><span class="line">        if expression is None:</span><br><span class="line">            sn_id &#x3D; tree_node[&#39;sn_id&#39;]</span><br><span class="line">            score &#x3D; self._get_sn_express_value(sn_id)</span><br><span class="line">            result[&#39;score&#39;] &#x3D; score</span><br><span class="line">        else:</span><br><span class="line">            str_list &#x3D; re.findall(self._re_pattern, expression)</span><br><span class="line">            v_dict &#x3D; &#123;&#125;</span><br><span class="line">            for score_id in str_list:</span><br><span class="line">                score_info &#x3D; self._get_expression_value(score_id, self._level_dict)</span><br><span class="line">                score &#x3D; score_info[1]</span><br><span class="line">                v_dict[score_id] &#x3D; score</span><br><span class="line">            total_score &#x3D; eval(expression.format(**v_dict))</span><br><span class="line">            result[&#39;score&#39;] &#x3D; total_score</span><br><span class="line">        self._result_dict[tree_node[&#39;node_name&#39;]] &#x3D; &#123;&#39;formula_id&#39;: tree_node[&#39;formula_id&#39;], &#39;value&#39;: result[&#39;score&#39;],</span><br><span class="line">                                                     &#39;dis_name&#39;: tree_node[&#39;node_display_name&#39;]&#125;</span><br><span class="line"></span><br><span class="line">    def _computer_score(self, tree_node):</span><br><span class="line">        children &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        self._computer_node_score(tree_node)</span><br><span class="line">        if len(children) &#x3D;&#x3D; 0:</span><br><span class="line">            return</span><br><span class="line">        for child_node in children:</span><br><span class="line">            self._computer_score(child_node)</span><br><span class="line"></span><br><span class="line">    def process_score(self):</span><br><span class="line">        self._computer_score(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def _get_standard_score(self, value, fid, df_value&#x3D;0):</span><br><span class="line">        min_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;min_&#39; + fid]</span><br><span class="line">        max_score &#x3D; self._original_data_dict[&#39;min_max&#39;][&#39;max_&#39; + fid]</span><br><span class="line">        std_score &#x3D; df_value if max_score - min_score &#x3D;&#x3D; 0 else pow((value - min_score) &#x2F; (max_score - min_score), 2) * 100</span><br><span class="line">        # print( &#39;fid:%s \t (%s - %s) &#x2F; (%s - %s ) x2 * 100 &#x3D; %s&#39; % (fid,value,min_score,max_score,min_score,std_score))</span><br><span class="line">        return std_score</span><br><span class="line"></span><br><span class="line">    def _rebuild_node_tree(self, tree_node):</span><br><span class="line">        for v in [&#39;id&#39;, &#39;model_id&#39;, &#39;pid&#39;, &#39;default_value&#39;, &#39;expression&#39;, &#39;sn_id&#39;, &#39;formula_id&#39;]:</span><br><span class="line">            tree_node.pop(v)</span><br><span class="line">        tree_node[&#39;score&#39;] &#x3D; self._get_standard_score(self._result_dict[tree_node[&#39;node_name&#39;]][&#39;value&#39;],</span><br><span class="line">                                                      self._result_dict[tree_node[&#39;node_name&#39;]][&#39;formula_id&#39;])</span><br><span class="line">        child_node &#x3D; tree_node[&#39;children&#39;]</span><br><span class="line">        if len(child_node) &gt; 0:</span><br><span class="line">            for node in child_node:</span><br><span class="line">                self._rebuild_node_tree(node)</span><br><span class="line">        else:</span><br><span class="line">            tree_node.pop(&#39;children&#39;)</span><br><span class="line">        return tree_node</span><br><span class="line"></span><br><span class="line">    def get_result(self):</span><br><span class="line">        return self._rebuild_node_tree(self._tree_node)</span><br><span class="line"></span><br><span class="line">    def print_data(self):</span><br><span class="line">        print(self._level_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init(context):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def calc_ent(ent_info, context):</span><br><span class="line"></span><br><span class="line">    rule_executor &#x3D; RuleExecutor(ent_info[&quot;ent_name&quot;])</span><br><span class="line"></span><br><span class="line">    # 初始化层级树</span><br><span class="line">    rule_executor.init_score_tree()</span><br><span class="line"></span><br><span class="line">    # 计算处理</span><br><span class="line">    rule_executor.process_score()</span><br><span class="line"></span><br><span class="line">    # 获取结果</span><br><span class="line">    result &#x3D; rule_executor.get_result()</span><br><span class="line"></span><br><span class="line">    return json.dumps(result,ensure_ascii&#x3D; False)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ent_info &#x3D; calc_ent(&#123;&quot;ent_name&quot;:&quot;东方成安资产管理有限公司&quot;&#125;,None)</span><br><span class="line">    print(ent_info)</span><br></pre></td></tr></table></figure><h1 id="6-SQL语句-拼接SQL"><a href="#6-SQL语句-拼接SQL" class="headerlink" title="6 SQL语句-拼接SQL"></a>6 SQL语句-拼接SQL</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select TABLE_NAME,</span><br><span class="line">concat( &#39;insert into &#39;, table_name, &#39;(&#39;, GROUP_CONCAT(COLUMN_NAME) , &#39;) select &#39;, GROUP_CONCAT(COLUMN_NAME),</span><br><span class="line">&#39;from reb_lingang_db.&#39;, TABLE_NAME,&#39;;&#39;)</span><br><span class="line">from information_schema.columns where table_schema &#x3D; &#39;reb_lingang_db&#39; and table_name regexp &#39;^dw_bc*&#39; and COLUMN_NAME not in (&#39;id&#39;)</span><br><span class="line">GROUP BY TABLE_NAME;</span><br></pre></td></tr></table></figure><h1 id="7-MySql导出表结构"><a href="#7-MySql导出表结构" class="headerlink" title="7 MySql导出表结构"></a>7 MySql导出表结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">COLUMN_NAME 字段,</span><br><span class="line">COLUMN_TYPE 数据类型,</span><br><span class="line">DATA_TYPE 字段类型,</span><br><span class="line">CHARACTER_MAXIMUM_LENGTH 长度,</span><br><span class="line">IS_NULLABLE 是否为空,</span><br><span class="line">COLUMN_KEY 是否为主键,</span><br><span class="line">COLUMN_DEFAULT 默认值,</span><br><span class="line">COLUMN_COMMENT 备注</span><br><span class="line">FROM</span><br><span class="line">INFORMATION_SCHEMA.COLUMNS</span><br><span class="line">where</span><br><span class="line">-- database为数据库名称，到时候只需要修改成你要导出表结构的数据库即可</span><br><span class="line">table_schema &#x3D;&#39;reb_db&#39;</span><br><span class="line">AND</span><br><span class="line">-- table_name为表名</span><br><span class="line">table_name &#x3D; &#39;reb_overview_comp_index_month&#39;;</span><br></pre></td></tr></table></figure><h1 id="8-多数据源（只是用来作为参考）"><a href="#8-多数据源（只是用来作为参考）" class="headerlink" title="8 多数据源（只是用来作为参考）"></a>8 多数据源（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; EngineDataSourceConfig.PACKAGE, sqlSessionFactoryRef &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">public class EngineDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.engine&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.engine&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSource engineDatasource() &#123;</span><br><span class="line">        return DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionFactory&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionFactory engineSqlSessionFactory(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource)</span><br><span class="line">        throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(</span><br><span class="line">            new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;engine&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineTransactionManager&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public DataSourceTransactionManager engineTransactionManager(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineSqlSessionTemplate&quot;)</span><br><span class="line">    @Primary</span><br><span class="line">    public SqlSessionTemplate engineSqlSessionTemplate(</span><br><span class="line">        @Qualifier(&quot;engineSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;engineJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;engineDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@MapperScan(basePackages &#x3D; RebDataSourceConfig.PACKAGE,sqlSessionFactoryRef &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">public class RebDataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    static final String PACKAGE &#x3D; &quot;com.aliyun.fin.rebengine.manager.mapper.reb&quot;;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebDatasource&quot;)</span><br><span class="line">    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource.reb&quot;)</span><br><span class="line">    public DataSource rebDatasource() &#123;</span><br><span class="line">        DataSource dataSource &#x3D; DataSourceBuilder.create().type(DruidDataSource.class).build();</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionFactory&quot;)</span><br><span class="line">    public SqlSessionFactory rebSqlSessionFactory(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) throws Exception &#123;</span><br><span class="line">        final SqlSessionFactoryBean bean &#x3D; new SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        &#x2F;&#x2F;指定mapper.xml路径</span><br><span class="line">        bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mapper&#x2F;reb&#x2F;*.xml&quot;));</span><br><span class="line">        return bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebTransactionManager&quot;)</span><br><span class="line">    public DataSourceTransactionManager rebTransactionManager(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebSqlSessionTemplate&quot;)</span><br><span class="line">    public SqlSessionTemplate rebSqlSessionTemplate(@Qualifier(&quot;rebSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123;</span><br><span class="line">        return new SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean(name &#x3D; &quot;rebJdbcTemplate&quot;)</span><br><span class="line">    public JdbcTemplate primaryJdbcTemplate(@Qualifier(&quot;rebDatasource&quot;) DataSource dataSource) &#123;</span><br><span class="line">        return new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    reb:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_lingang_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    engine:</span><br><span class="line">      url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;reb_data_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;allowMultiQueries&#x3D;true&amp;useSSL&#x3D;false&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;rewriteBatchedStatements&#x3D;true</span><br><span class="line">      username: root</span><br><span class="line">      password: 123456</span><br><span class="line">      driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  thymeleaf:</span><br><span class="line">     cache: false</span><br><span class="line">     encoding: utf-8</span><br><span class="line">     mode: HTML5</span><br><span class="line">     servlet:</span><br><span class="line">       content-type: text&#x2F;html</span><br><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line"></span><br><span class="line"># 日志配置</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    org:</span><br><span class="line">      springframework:</span><br><span class="line">        web: info</span><br><span class="line">        transaction: info</span><br><span class="line">    com:</span><br><span class="line">      aliyun:</span><br><span class="line">        fin:</span><br><span class="line">          rebengine:</span><br><span class="line">              manager:</span><br><span class="line">                mapper: error</span><br></pre></td></tr></table></figure><h1 id="9-JWTUtil（只是用来作为参考）"><a href="#9-JWTUtil（只是用来作为参考）" class="headerlink" title="9 JWTUtil（只是用来作为参考）"></a>9 JWTUtil（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line">    &#x2F;**过期时间30分钟*&#x2F;</span><br><span class="line">    private static final long EXPIRE_TIME &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 生成签名(生成token字符串)</span><br><span class="line">     * @param username 用户名</span><br><span class="line">     * @param secret 密码</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String sign(String username, String secret)&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            return JWT.create()</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获得token中的信息无需secret解密也能获得</span><br><span class="line">     * @return token中包含的用户名</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String getUsername(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DecodedJWT jwt &#x3D; JWT.decode(token);</span><br><span class="line">            return jwt.getClaim(&quot;username&quot;).asString();</span><br><span class="line">        &#125; catch (JWTDecodeException e) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 校验token是否正确</span><br><span class="line">     * @param token 密钥</span><br><span class="line">     * @param secret 用户的密码</span><br><span class="line">     * @return 是否正确</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static boolean verify(String token, String username, String secret) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(secret);</span><br><span class="line">            JWTVerifier verifier &#x3D; JWT.require(algorithm)</span><br><span class="line">                    .withClaim(&quot;username&quot;, username)</span><br><span class="line">                    .build();</span><br><span class="line">            DecodedJWT jwt &#x3D; verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; catch (Exception exception) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-JWTFilterConfig（只是用来作为参考）"><a href="#10-JWTFilterConfig（只是用来作为参考）" class="headerlink" title="10 JWTFilterConfig（只是用来作为参考）"></a>10 JWTFilterConfig（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class JWTFilterConfig implements Filter&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest httpRequest &#x3D; (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse httpResponse &#x3D; (HttpServletResponse) servletResponse;</span><br><span class="line">        String url &#x3D; httpRequest.getRequestURI().substring(httpRequest.getContextPath().length());</span><br><span class="line">        ServletContext sc &#x3D; httpRequest.getServletContext();</span><br><span class="line">        WebApplicationContext cxt &#x3D; WebApplicationContextUtils.getWebApplicationContext(sc);</span><br><span class="line">        if(cxt !&#x3D; null &amp;&amp; cxt.getBean(&quot;redisTemplate&quot;) !&#x3D; null &amp;&amp; redisTemplate &#x3D;&#x3D; null) &#123;</span><br><span class="line">            redisTemplate &#x3D; (RedisTemplate) cxt.getBean(&quot;redisTemplate&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 跨域请求</span><br><span class="line">         *&#x2F;</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Origin&quot;, httpRequest.getHeader(&quot;Origin&quot;));</span><br><span class="line">&#x2F;&#x2F;        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Content-Disposition&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Content-Type, Depth, User-Agent, X-File-Size, X-Requested-With, X-Requested-By, If-Modified-Since, X-File-Name, X-File-Type, Cache-Control, Origin&quot;);</span><br><span class="line">        &#x2F;&#x2F;是否支持cookie跨域</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);</span><br><span class="line">        &#x2F;&#x2F;允许在请求头里存放token</span><br><span class="line">        httpResponse.setHeader(&quot;Access-Control-Expose-Headers&quot;,&quot;Authorization,Content-Disposition&quot;);</span><br><span class="line"></span><br><span class="line">        String method &#x3D; httpRequest.getMethod();</span><br><span class="line">&#x2F;&#x2F;        filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line"></span><br><span class="line">        if (&quot;OPTIONS&quot;.equals(method)) &#123;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            String authorization &#x3D; httpRequest.getHeader(&quot;Authorization&quot;);</span><br><span class="line">            &#x2F;&#x2F;不需要拦截的路径</span><br><span class="line">            if (!url.contains(&quot;&#x2F;swagger&quot;) &amp;&amp; !url.contains(&quot;&#x2F;login&quot;) &amp;&amp; !url.contains(&quot;&#x2F;registerDepartmentSelected&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;getSecurityCode&quot;) &amp;&amp; !url.contains(&quot;&#x2F;register&quot;) &amp;&amp; !url.contains(&quot;&#x2F;downLoadExcel&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;&#x2F;exportEntRelation&quot;) &amp;&amp; !url.contains(&quot;&#x2F;exportCompanyList&quot;) &amp;&amp; !url.contains(&quot;&#x2F;api&#x2F;merchantsradar&quot;) &amp;&amp;</span><br><span class="line">                    !url.contains(&quot;.ico&quot;) &amp;&amp; !url.contains(&quot;.json&quot;) &amp;&amp; !url.contains(&quot;&#x2F;statics&quot;) &amp;&amp; !url.contains(&quot;.js&quot;) &amp;&amp; !url.contains(&quot;.css&quot;) &amp;&amp; !url.contains(&quot;&#x2F;static&quot;) &amp;&amp; !url.contains(&quot;&#x2F;media&quot;) &amp;&amp; !url.contains(&quot;&#x2F;synchronization&quot;)) &#123;</span><br><span class="line">                if (StringUtils.isNotBlank(authorization))&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String token &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F;避免redis为空报错，先一步校验key是否存在</span><br><span class="line">                        Boolean aBoolean &#x3D; redisTemplate.hasKey(&quot;reb_backend_&quot; + authorization);</span><br><span class="line">                        if (!aBoolean)&#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            token &#x3D; redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + authorization).toString();</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">                            redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + authorization, authorization, TokenUtil.getToken(), TimeUnit.SECONDS);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                            jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                            jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                            jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                            httpResponse.setStatus(200);</span><br><span class="line">                            httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                            httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;catch (Exception e)&#123;</span><br><span class="line">                        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                        jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                        jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                        jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                        httpResponse.setStatus(200);</span><br><span class="line">                        httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                        httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">                    jsonObject.put(&quot;errCode&quot;, 6001);</span><br><span class="line">                    jsonObject.put(&quot;errMsg&quot;, &quot;error&quot;);</span><br><span class="line">                    jsonObject.put(&quot;data&quot;, &quot;Roles have no access rights&quot;);</span><br><span class="line">                    httpResponse.setStatus(200);</span><br><span class="line">                    httpResponse.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">                    httpResponse.getWriter().write(JSON.toJSONString(jsonObject));</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.doFilter(httpRequest, httpResponse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-Login（只是用来作为参考）"><a href="#11-Login（只是用来作为参考）" class="headerlink" title="11 Login（只是用来作为参考）"></a>11 Login（只是用来作为参考）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;user&quot;)</span><br><span class="line">@RestController</span><br><span class="line">@Api(tags &#x3D; &#123;&quot;后台管理&quot;&#125;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(UserController.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;spring.rebBackend.token.expirationDate&#125;&quot;)</span><br><span class="line">    private long tokenExpirationDate;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户登录</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;10&#x2F;10 18:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户登录&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;account&quot;,value &#x3D; &quot;用户账号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;login&quot;)</span><br><span class="line">    public JSONObject login(String account, String password,HttpServletRequest request)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if(StringUtils.isBlank(password) )&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(account))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;account&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String userStatus &#x3D; (String) redisTemplate.opsForValue().get(&quot;reb_backend_&quot; + account);</span><br><span class="line">            String index &#x3D; &quot;3&quot;;</span><br><span class="line">            if (StringUtils.equals(userStatus,index))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误次数过多,请5分钟之后重试&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            if (null&#x3D;&#x3D;user)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户不存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index2 &#x3D; &quot;2&quot;;</span><br><span class="line">            if (user.getStatus().equals(index2))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户已被锁定&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String index3 &#x3D; &quot;3&quot;;</span><br><span class="line">            if (user.getStatus().equals(index3))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;账户正在审批中&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password,&quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            if (user.getPassword().equals(md5Password))&#123;</span><br><span class="line">                &#x2F;&#x2F;登录成功之后保存用户操作日志</span><br><span class="line">                UserLogger userLogger &#x3D; new UserLogger()&#123;&#123;</span><br><span class="line">                    setUserAccount(account);</span><br><span class="line">                    setUserName(user.getUsername());</span><br><span class="line">                    setLoggerType(&quot;1&quot;);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                userService.saveUserLogger(userLogger);</span><br><span class="line">                &#x2F;&#x2F;登录成功之后将token缓存到redis</span><br><span class="line">                String token &#x3D; JwtUtil.sign(account,user.getPassword());</span><br><span class="line">                RedisModel redisModel &#x3D; new RedisModel()&#123;&#123;</span><br><span class="line">                    setKey(&quot;reb_backend_&quot; + token);</span><br><span class="line">                    setValue(token);</span><br><span class="line">                &#125;&#125;;</span><br><span class="line">                redisTemplate.opsForValue().set(redisModel.getKey(),redisModel.getValue(),tokenExpirationDate,TimeUnit.SECONDS);</span><br><span class="line">                jsonObject.put(&quot;token&quot;,token);</span><br><span class="line">                jsonObject.put(&quot;username&quot;,user.getUsername());</span><br><span class="line">                jsonObject.put(&quot;userId&quot;,user.getId());</span><br><span class="line">                List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">                &#x2F;&#x2F;获取用户所属部门</span><br><span class="line">                Integer departmentId &#x3D; userService.findDepartmentIdByUserId(user.getId());</span><br><span class="line">                jsonObject.put(&quot;role&quot;,roleList.get(0));</span><br><span class="line">                jsonObject.put(&quot;departmentId&quot;,departmentId);</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                userStatus &#x3D; userStatus&#x3D;&#x3D;null ? &quot;1&quot; : Integer.parseInt(userStatus)  + 1 + &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                if (userStatus.equals(index3))&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300, TimeUnit.SECONDS);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    redisTemplate.opsForValue().set(&quot;reb_backend_&quot; + user.getAccount(),userStatus,300,TimeUnit.SECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-用户登录&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-登出接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;23 11:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @GetMapping(&quot;exit&quot;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-登出接口&quot;)</span><br><span class="line">    public JSONObject exit(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            redisTemplate.delete(&quot;reb_backend_&quot; + token);</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            userService.exit(user);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-登出接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户注册</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;11&#x2F;20 10:05</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册&quot;)</span><br><span class="line">    @GetMapping(&quot;register&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;,value &#x3D; &quot;用户密码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;code&quot;,value &#x3D; &quot;验证码&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject register(String username,String phone,Integer departmentId,String password,String code,HttpServletRequest request) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        String checkCode &#x3D; (String) request.getSession().getAttribute(&quot;code&quot;);</span><br><span class="line">        String newCheckCode &#x3D; checkCode.toLowerCase();</span><br><span class="line">        String newCode &#x3D; code.toLowerCase();</span><br><span class="line">        if (!newCode.equals(newCheckCode)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;验证码错误&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(username)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(phone)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(password)) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;校验账户是否存在</span><br><span class="line">        User user &#x3D; userService.findUserByAccount(phone);</span><br><span class="line">        if (user !&#x3D; null) &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, &quot;该手机号已被注册&quot;);</span><br><span class="line">            return jsonObject;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            String md5Password &#x3D; PasswordUtil.encode(password, &quot;fin_risk_management_reb_backend&quot;);</span><br><span class="line">            userService.register(username, phone, departmentId, md5Password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 后台管理-用户登录首次加载列表</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;10 13:53</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;后台管理-用户登录首次加载列表&quot;)</span><br><span class="line">    @GetMapping(&quot;userLoginFirstLoadList&quot;)</span><br><span class="line">    public JSONObject userLoginFirstLoadList(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            jsonObject &#x3D; userService.userLoginFirstLoadList(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;后台管理-用户登录首次加载列表&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-模块授权下拉</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;11 16:10</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-模块授权下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;authorizationModuleSelected&quot;)</span><br><span class="line">    public JSONObject authorizationModuleSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject &#x3D; userService.authorizationModuleSelected();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-模块授权下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;12 10:55</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readUserListShow&quot;)</span><br><span class="line">    public JSONObject readUserListShow(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;UserVO&gt; list &#x3D; userService.readUserListShow(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户列表展示&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-角色下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 10:06</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-角色下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readRoleSelected&quot;)</span><br><span class="line">    public JSONObject readRoleSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            JSONArray jsonArray &#x3D; userService.readRoleSelected(roleList.get(0));</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,jsonArray);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-角色下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号删除&#x2F;拒绝通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:26</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号删除&#x2F;拒绝通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;delAndRefuseUser&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    public JSONObject delAndRefuseUser(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delAndRefuseUser(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号删除&#x2F;拒绝通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-账号启用&#x2F;禁用通用接口</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 11:43</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-账号启用&#x2F;禁用通用接口&quot;)</span><br><span class="line">    @GetMapping(&quot;enableAndDisabledUser&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userStatus&quot;,value &#x3D; &quot;用户状态 1：启用 2：禁用 3：申请中&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    public JSONObject enableAndDisabledUser(Integer userId,Integer userStatus)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.enableAndDisabledUser(userId,userStatus);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-账号启用&#x2F;禁用通用接口&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-用户通过申请</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;13 14:41</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户通过申请&quot;)</span><br><span class="line">    @GetMapping(&quot;adoptUser&quot;)</span><br><span class="line">    public JSONObject adoptUser(Integer userId,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.adoptUser(userId,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户通过申请&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-管理员添加用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;14 17:08</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-管理员添加用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;adminAddUser&quot;)</span><br><span class="line">    public JSONObject adminAddUser(String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,0);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.adminAddUser(username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;用户管理-管理员添加用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改用户</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;17 14:45</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改用户&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;id&quot;,value &#x3D; &quot;用户ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;,value &#x3D; &quot;用户名&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;,value &#x3D; &quot;部门ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;phone&quot;,value &#x3D; &quot;手机号&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;roleId&quot;,value &#x3D; &quot;角色ID&quot;,paramType &#x3D; &quot;query&quot;,dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updateUser&quot;)</span><br><span class="line">    public JSONObject updateUser(Integer id,String username,Integer departmentId,String phone,Integer roleId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try&#123;</span><br><span class="line">            if (StringUtils.isBlank(username))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;username&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(phone))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;phone&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验手机号是否已存在</span><br><span class="line">            Integer userId &#x3D; userService.findUserIdByAccountAndUserId(phone,id);</span><br><span class="line">            if (userId !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;该登录账号已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updateUser(id,username,departmentId,phone,roleId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改用户&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-添加部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 10:12</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-添加部门&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentName&quot;, value &#x3D; &quot;部门名称&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;addDepartment&quot;)</span><br><span class="line">    public JSONObject addDepartment(String departmentName,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (StringUtils.isBlank(departmentName))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;departmentName&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(model))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;model&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;校验部门名称是否已存在</span><br><span class="line">            Integer id &#x3D; userService.findDepartmentByDepartmentName(departmentName);</span><br><span class="line">            if (id !&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;部门名称已存在&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.addDepartment(departmentName,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            logger.error(&quot;部门管理-添加部门&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-部门列表展示</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 11:00</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-部门列表展示&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentShow&quot;)</span><br><span class="line">    public JSONObject readDepartmentShow(@RequestHeader(&quot;Authorization&quot;) String token) &#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentShow(roleList.get(0), user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;, list);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(&quot;部门管理-部门列表展示&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-删除部门</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;29 9:52</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-删除部门&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;delDepartment&quot;)</span><br><span class="line">    public JSONObject delDepartment(Integer departmentId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.delDepartment(departmentId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-删除部门&#x3D;&#x3D;&#x3D;&quot;, e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;, ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 部门管理-授权模块</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 16:31</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;部门管理-授权模块&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;departmentId&quot;, value &#x3D; &quot;部门ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;model&quot;, value &#x3D; &quot;模块JSON&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;authorizationModule&quot;)</span><br><span class="line">    public JSONObject authorizationModule(Integer departmentId,String model)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            userService.authorizationModule(departmentId,model);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;部门管理-授权模块&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-部门下拉框</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;readDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject readDepartmentSelected(@RequestHeader(&quot;Authorization&quot;) String token)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            String account &#x3D; JwtUtil.getUsername(token);</span><br><span class="line">            &#x2F;&#x2F;根据用户账号获取用户信息</span><br><span class="line">            User user &#x3D; userService.findUserByAccount(account);</span><br><span class="line">            List&lt;String&gt; roleList &#x3D; userService.findRoleListByUserId(user.getId());</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.readDepartmentSelected(roleList.get(0),user.getId());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @Description: 用户管理-用户注册部门下拉框</span><br><span class="line">     * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">     * @date 2018&#x2F;12&#x2F;19 17:40</span><br><span class="line">     **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-用户注册部门下拉框&quot;)</span><br><span class="line">    @GetMapping(&quot;registerDepartmentSelected&quot;)</span><br><span class="line">    public JSONObject registerDepartmentSelected()&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            List&lt;DictDepartment&gt; list &#x3D; userService.registerDepartmentSelected();</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;data&quot;,list);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-用户注册部门下拉框&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-获取验证码</span><br><span class="line">      * @return void</span><br><span class="line">      * @date 2018&#x2F;12&#x2F;26 14:58</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-获取验证码&quot;)</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;getSecurityCode&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public void getSecurityCode(HttpServletResponse response, HttpServletRequest request,Integer random)&#123;</span><br><span class="line">        &#x2F;&#x2F; 设置响应的类型格式为图片格式</span><br><span class="line">        response.setContentType(&quot;image&#x2F;jpeg&quot;);</span><br><span class="line">        &#x2F;&#x2F; 通知浏览器不要缓存</span><br><span class="line">        response.setHeader(&quot;Expires&quot;, &quot;-1&quot;);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;, &quot;-1&quot;);</span><br><span class="line">        SecurityUtil util &#x3D; SecurityUtil.instance();</span><br><span class="line">        &#x2F;&#x2F; 将验证码输入到session中，用来验证</span><br><span class="line">        String code &#x3D; util.getString();</span><br><span class="line">        request.getSession().setAttribute(&quot;code&quot;, code);</span><br><span class="line">        &#x2F;&#x2F; 输出打web页面</span><br><span class="line">        try &#123;</span><br><span class="line">            ImageIO.write(util.getImage(), &quot;jpg&quot;, response.getOutputStream());</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-修改密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:21</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-修改密码&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;updatePassword&quot;)</span><br><span class="line">    public JSONObject updatePassword(Integer userId,String password)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.updatePassword(userId,password);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-修改密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-校验原密码是否正确</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:36</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-校验原密码是否正确&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;password&quot;, value &#x3D; &quot;密码&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;String&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @GetMapping(&quot;checkPassword&quot;)</span><br><span class="line">    public JSONObject checkPassword(String password,Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            if (StringUtils.isBlank(password))&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;password&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean check &#x3D; userService.checkPassword(userId,password);</span><br><span class="line">            if (!check)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_RESULT_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;密码错误&quot;);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-校验原密码是否正确&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">      * @Description: 用户管理-重置密码</span><br><span class="line">      * @return com.alibaba.fastjson.JSONObject</span><br><span class="line">      * @date 2019&#x2F;1&#x2F;10 14:57</span><br><span class="line">    **&#x2F;</span><br><span class="line">    @ApiOperation(&quot;用户管理-重置密码&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;userId&quot;, value &#x3D; &quot;用户ID&quot;, paramType &#x3D; &quot;query&quot;, dataType &#x3D; &quot;Integer&quot;)</span><br><span class="line">    @GetMapping(&quot;resetPassword&quot;)</span><br><span class="line">    public JSONObject resetPassword(Integer userId)&#123;</span><br><span class="line">        JSONObject jsonObject &#x3D; new JSONObject();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (userId &#x3D;&#x3D; null)&#123;</span><br><span class="line">                jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_PARAM_NULL);</span><br><span class="line">                jsonObject.put(&quot;errorMsg&quot;,&quot;userId&quot; + ResponseCode.MSG_PARAM_NULL);</span><br><span class="line">                return jsonObject;</span><br><span class="line">            &#125;</span><br><span class="line">            userService.resetPassword(userId);</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;,ResponseCode.CODE_SUCCESS);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_SUCCESS);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            logger.error(&quot;用户管理-重置密码&#x3D;&#x3D;&#x3D;&quot;,e.getMessage());</span><br><span class="line">            jsonObject.put(&quot;errorCode&quot;, ResponseCode.CODE_ERROR);</span><br><span class="line">            jsonObject.put(&quot;errorMsg&quot;,ResponseCode.MSG_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>12 Pom配置（只是用来作为参考）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;reb_backend&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;reb_service&lt;&#x2F;artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;reb_service&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;!-- FIXME change it to the project&#39;s website --&gt;</span><br><span class="line">    &lt;url&gt;http:&#x2F;&#x2F;www.example.com&lt;&#x2F;url&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">        &lt;shiro.version&gt;1.4.0&lt;&#x2F;shiro.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--Spring Boot中使用Swagger2构建强大的RESTful API文档--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.7.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- 连接池  --&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;druid-spring-boot-starter&lt;&#x2F;artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;version&gt;1.1.5&lt;&#x2F;version&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;&#x2F;dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- esay poi --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;!-- guava --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;18.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- shiro 配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;shiro.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.auth0&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;java-jwt&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- json --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 缓存 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;net.sf.ehcache&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;ehcache&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-io&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-io&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.aliyun&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reb_common&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.5&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--easypoi--&gt;</span><br><span class="line">        &lt;!--easypoi导出excel --&gt;</span><br><span class="line">        &lt;!--easypoi-base 导入导出的工具包,可以完成Excel导出,导入,Word的导出,Excel的导出功能 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-base&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;easypoi-annotation&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.0.3&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- springboot整合redis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;!-- 指定该Main Class为全局的唯一入口 --&gt;</span><br><span class="line">                    &lt;mainClass&gt;com.aliyun.finintell.rebbackend.RebBackendApplication&lt;&#x2F;mainClass&gt;</span><br><span class="line">                    &lt;layout&gt;ZIP&lt;&#x2F;layout&gt;</span><br><span class="line">                &lt;&#x2F;configuration&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;repackage&lt;&#x2F;goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt;</span><br><span class="line">                        &lt;&#x2F;goals&gt;</span><br><span class="line">                    &lt;&#x2F;execution&gt;</span><br><span class="line">                &lt;&#x2F;executions&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">            &lt;plugins&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-clean-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;!-- see http:&#x2F;&#x2F;maven.apache.org&#x2F;ref&#x2F;current&#x2F;maven-core&#x2F;default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-resources-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.7.0&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.20.1&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-jar-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;3.0.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-install-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.5.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">                &lt;plugin&gt;</span><br><span class="line">                    &lt;artifactId&gt;maven-deploy-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">                    &lt;version&gt;2.8.2&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;&#x2F;plugins&gt;</span><br><span class="line">        &lt;&#x2F;pluginManagement&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搬砖结晶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析-下部</title>
      <link href="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/"/>
      <url>/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="1-浅析最好、最坏、平均、均摊时间复杂度"><a href="#1-浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="1 浅析最好、最坏、平均、均摊时间复杂度"></a>1 浅析最好、最坏、平均、均摊时间复杂度</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最好情况时间法则度</font>(best case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">最坏情况时间复杂度</font>(worst case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">平均情况时间复杂度</font>(average case time complexity)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">均摊时间复杂度</font>(amortized time complexity)</p><a id="more"></a><h2 id="1-1-最好、最坏情况时间复杂度"><a href="#1-1-最好、最坏情况时间复杂度" class="headerlink" title="1.1 最好、最坏情况时间复杂度"></a>1.1 最好、最坏情况时间复杂度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码的功能：在一个无序的数组(array)中，查找变量x出现的位置。如果没有找到，就返回 -1。这段代码的时间复杂度就是 O(n)，其中，n代表数组的长度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，我们在数组中查找一个数据时，并不需要每次都把整个数据都遍历一遍，因为有可能中途找到提前结束循环了。因此，改写后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这段优化后的代码，时间复杂度还是O(n)吗？很显然，暂时还解决不了这个问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)，但如果数组中不存在变量 x , 那就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)，所以，不同情况下，这段代码的时间复杂度是不一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了表示代码在不同情况下的不同时间复杂度，需要3种概念：最好情况时间复杂度、最坏情况时间复杂度、平局情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>最好情况时间复杂度：最理想的情况下，执行这段代码的时间复杂度。</strong>如：在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这种情况下的时间复杂度即是最好情况时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，<strong>最坏情况时间复杂度，在最糟糕的情况下，执行这段代码的时间复杂度。</strong>如：在数组中没有要查找的变量 x , 需要把整个数组都遍历一遍才行，这种情况下的时间复杂度即是最坏情况时间复杂度。</p><h2 id="1-2-平均情况时间复杂度"><a href="#1-2-平均情况时间复杂度" class="headerlink" title="1.2 平均情况时间复杂度"></a>1.2 平均情况时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最好情况时间复杂度和最坏请款时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大为了更好地表示平均情况下的复杂度，需要引入一个新的概念：<strong>平均情况时间复杂度</strong>，即平均时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然是上述代码，要查找变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong> 和 <strong>不在数组中</strong>。把每种情况下，查找需要遍历的元素个数累加起来，再除以 n+1，就可以得到需要遍历的元素个数的平均值，即（等数列求和公式）：<br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 大O 标记法中，可以省略掉系数、低阶、常量，所以，简化后的平均时间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个结论是正确的，但是计算过程稍稍有点问题，因为有 n+1 种情况，出现的概率并不是一样的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要查找的变量 x, 要么在数组里，要不不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便理解，假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0<del>n-1 这 n 个位置的概率是一样的，为 1/n，所以，根据概率乘法法则，要查找的数组出现在 0</del> n-1 中任意位置的概率就是 1/(2n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<font color="red">前面推导的存在的最大问题就是，没有讲各种情况发生的概率考虑进去。如果我们把每种情况发生的概率考虑进去，那么平均时间复杂度的计算过程就变成饿了这样：</font><br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/36c0aabdac69032f8a43368f5e90c67f.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个值就是概率论中的<strong>加权平均值</strong>，即<strong>期望值</strong>，所以平均时间复杂度的全称就是<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引入概率之后，上述代码的加权平均值为(3n+1)/4。用 大O 表示法表示，去掉系数和常量，这段代码的加权平均时间复杂仍然是 O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，并不需要区分最好、最坏、平均时间复杂度三种情况。很多时候，只用一种复杂度就可以满足需求。<strong>只有同一块代码在不同的情况下，时间复杂度有量级的差距，才会使用这三种复杂度表示法来区分。</strong></p><h2 id="1-3-均摊时间复杂度"><a href="#1-3-均摊时间复杂度" class="headerlink" title="1.3 均摊时间复杂度"></a>1.3 均摊时间复杂度</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>均摊时间复杂度</strong>，一种更加高级的概念，它对应的分析方法，<strong>摊还分析(平摊分析)</strong> 。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度，听起来与平均时间复杂度有点像。长容易混淆，大部分情况下，并不需要区分最好、最坏、平均时间复杂度。平均复杂度只有在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum = sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 上述代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，用for循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再讲新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最理想的情况下，数组中有空闲空间，只需要将数据插入到数组下表为 count 的为位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况，数组中没有空闲空间了，需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平均时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假定数组的长度是 n,根据数据插入的位置的不同，就可以分为 n 种情况，每种情况的时间复杂度都是 O(1),除此之外，还有一种“额外“的情况，就是数组在没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率是一样的，即 1/(n+1)。所以，根据加权平均计算方法，求得的平均情况时间复杂度：<br><img src="/2019/08/12/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B%E9%83%A8/6df62366a60336d9de3bc34f488d8bed.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子的平均时间复杂度其实并不需要这么复杂，并不需要引入概率论的知识。由对比得知，insert() 的例子和 上面的那个 find() 的列子，会发现二者有很大的差别。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，find() 函数在极端情况下，时间复杂度采薇 O(1)。但是 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert() <strong>第一个</strong>区别于find() 的地方。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第二个</strong>，对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，后面紧跟着 n-1 个 O(1) 的插入操作，循环往复。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种特殊场景的复杂度分析，并不需要像之前将平均时间复杂度分析方法那样，找出所有的输入情况以及相应的发生概率，然后在计算加权平均值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此，引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度：<strong>均摊时间复杂度</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何用摊还分析发来分析算法的均摊时间复杂度呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续啊观看数组插入数的这个例子，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的<strong>那次操作</strong>均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均摊时间复杂度和摊还分析应用场景比较特殊，所以并不会经常用到，为了方便理解，简单总结他们的应用场景。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">对一个数据结构进行一组连续操作中，大部分情况下的时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，就可以将一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，<strong>在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好时间复杂度</strong>。</font></p><h1 id="2-总结"><a href="#2-总结" class="headerlink" title="2 总结"></a>2 总结</h1><p>一、复杂度分析的4个概念<br>1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。<br>2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。<br>3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p><p>二、为什么要引入这4个概念？<br>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><p>三、如何分析平均、均摊时间复杂度？<br>1.平均时间复杂度<br>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>2.均摊时间复杂度<br>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p><hr><h1 id="3-试试分析下面-add-函数"><a href="#3-试试分析下面-add-函数" class="headerlink" title="3 试试分析下面 add()函数"></a>3 试试分析下面 add()函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     array = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加一</span></span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1. 最好情况时间复杂度为 O(1)<br>2.最坏情况分析：<br>最坏情况代码执行的次数跟每次数组的长度有关<br>第1次调用insert的执行的次数为 n ,<br>第2次调用insert的执行的次数为 2n ,<br>第3次调用insert的执行的次数为 2^2 * n<br>第k次调用insert的执行的次数为 2^(k-1) * n<br>最坏时间复杂度为 O(n)。<br>3. 平均情况分析<br>当每次遇到最坏情况时数组会进行2倍扩容，原数组被导入新数组，虽然数组的长度变大了，但是插入操作落在的区间的长度是一样的，分别是0<del>len-1, len</del>(2len-1),….；<br>插入的情况仍是len+1种：0~len-1和插满之后的O(len)；所以每次插入的概率是：p= 1/len+1，<br>最后求出加权平均时间复杂度为 1<em>p + 2</em>p+ ▪▪▪ + len*p + len * p = O(1) ;<br>4. 均摊时间复杂度 O(1)<br>而均摊复杂度由于每次O(len)的出现都跟着len次O(1)，是前后连贯的，因而将O(len)平摊到前len次上，得出平摊复杂度是O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析-上部</title>
      <link href="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/"/>
      <url>/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，数据结构与算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，<font color="red">执行效率</font>是算法一个非常重要的考量指标。</p><h2 id="1-为什么需要复杂度分析？"><a href="#1-为什么需要复杂度分析？" class="headerlink" title="1 为什么需要复杂度分析？"></a>1 为什么需要复杂度分析？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我将代码跑一遍，通过统计、监控，就能得到算法执行时间个占用的内存大小。为什么要使用空间、时间复杂度分析呢？难道比我实实在在跑一遍得到的数据还要准确吗？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述评估算法执行效率的方法是正确的。大部分人称它为<strong>事后统计法</strong>，但它有非常大的局限性。</p><a id="more"></a><h3 id="1-1-测试结果非常依赖测试环境"><a href="#1-1-测试结果非常依赖测试环境" class="headerlink" title="1.1 测试结果非常依赖测试环境"></a>1.1 测试结果非常依赖测试环境</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试环境中硬件的不同会对测试结果有很大的影响。比如，用同样一段代码，用I9处理器与I3处理器，效率自然不同。</p><h3 id="1-2-测试结果受数据规模的影响很大"><a href="#1-2-测试结果受数据规模的影响很大" class="headerlink" title="1.2 测试结果受数据规模的影响很大"></a>1.2 测试结果受数据规模的影响很大</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对同一个排序算法，待排序数据的有序度不一样，排序的执行时间会有很大的差别。极端情况下，如果数据已经有序，排序算法不需要做任何操作，执行时间非常短。除此之外，如果测试数据规模小，测试结果可能无法真实的反应算法的性能。如：对于小规模的数据排序，插入排序可能反倒会比快速排序要快！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>–<font color="red">时间、空间复杂度分析方法</font>。</p><h2 id="2-大-O-复杂度表示法"><a href="#2-大-O-复杂度表示法" class="headerlink" title="2 大 O 复杂度表示法"></a>2 大 O 复杂度表示法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算法的执行效率，粗略的说，就是算法代码的执行时间。但是，如何在不运行代码的情况下，用 “肉眼” 得到一段代码的执行时间呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从CPU的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行对应的CPU执行的个数、执行的时间都不一样，但是，只是粗略的估计，所以可以假设每行代码的执行时间都一样，为<font color="red"> unit_time</font>。在这个假设的基础上，这段代码的总执行时间是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3行代码分别需要1个unit_time的执行时间，第4、5行代码都运行了n遍，所以需要2n &#42; unit_time的执行时间，所以这段代码总的执行时间就是 (2n+2) &#42;   unit_time</font>。因此， <strong>所有代码的执行时间T(n)与每行代码的执行次数成正比</strong>。</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这个思路，再次分析如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依旧假设每个语句的执行时间是 unit_time ，那么这段代码的总执行时间T(n)是多少呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">第2、3、4行代码，每行代码都需要1个 unit_time的执行时间，第5、6行代码循环执行了n遍，需要2n &#42; unit_time的执行时间，第7、8行代码循环执行了n<sup>2</sup>遍，所以需要2n<sup>2</sup> &#42; unit_time的执行时间。</font><font color="red">所以，整段代码的执行时间T(n)与每行代码的执行次数n成正比</font>。</p><h2 id="3-大-O-登场"><a href="#3-大-O-登场" class="headerlink" title="3 大 O 登场"></a>3 大 O 登场</h2><p><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/22900968aa2b190072c985a08b0e92ef.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T(n)已经解释过，表示代码的执行时间；n表示数据规模的大小；f(n)表示每行代码执行的次数总和。因为它是一个公式。所以用f(n)来表示。公式中的 O ，表示代码的执行时间T(n) 与 f(n) 表达式成正比。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，第一个例子中的T(n)=O(2n+2)，第二个例子中的T(n)=O(2n<sup>2</sup>+2n+3)。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，因此，也称之为<strong>渐进时间复杂度</strong>(asymptotic time complexity),即<strong>时间复杂度</strong>。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 n 很大时，可以把它想象成10000,10000000。而公式中的<font color="red">低阶、常量、系数</font>三部分并不左右增长趋势，所以可以忽略。因此，只需要记录一个最大量级就可以了，如果用大 O 表示法表示上述两段代码的时间复杂度，既可以记为：T(n)=O(n); T(n)=O(n<sup>2</sup>)</p><h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4 时间复杂度分析"></a>4 时间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了大 O 时间复杂度的由来和表示方法。现在看看如何分析一段代码的时间复杂度？</p><h3 id="4-1-只关注循环执行次数最多的一段代码"><a href="#4-1-只关注循环执行次数最多的一段代码" class="headerlink" title="4.1 只关注循环执行次数最多的一段代码"></a>4.1 只关注循环执行次数最多的一段代码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大 O 这种复杂度表示方法只是表示一种变化趋势。通常会忽略掉工事中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了，所以，<strong>在分析一个算法，一段代码的时间复杂度的时候，只关注循环执行次数最多的那一段代码就可以了。</strong>这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(;i&lt;=n;++i)&#123;</span><br><span class="line">      sum = sum+i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p><h3 id="4-2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#4-2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="4.2 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>4.2 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个代码分为3个部分分别是求sum_1、sum_2、sum_3。分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一段代码的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">这里强调一下，即便这段代码循环了10000次，1亿次，只要是一个已知的数，跟n无关。照样是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉，因为它本身对增长趋势并没有影响。</font><br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n) 和 O(n<sup>2</sup>)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合这三段代码的时间复杂度，取其中最大的量级，所以，整段代码的时间复杂度就为O(n<sup>2</sup>)。也就是说：<strong>总的时间复杂度就是等于量级最大的那段代码的时间复杂度</strong>。那可以讲规律抽象为公式：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)),O(g(n)))=O(max(f(n),g(n)))。</p><h3 id="4-3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#4-3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="4.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>4.3 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类比加法法则，乘法法则公式：T1(n)=O(f(n))，T2(n)=O(g(n));那么 T(n)=T1(n) &#42; T2(n)=O(f(n)) &#42; O(g(n))=O(f(n) &#42; g(n))。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设T1(n)=O(n)，T2(n)=O(n<sup>2</sup>)，则T1(n) &#42; T2(n) = O(n<sup>3</sup>)。落实到具体的代码中：可以把乘法法则看成是<strong>嵌套循环</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单独看cal()函数，假设f()只是一个普通的操作，那第4~6行的时间复杂度就是，T1(n) = O(n),但是f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以整个cal()函数的时间复杂度就是：T(n) = T1(n) &#42; T2(n) = O(n &#42; n) = O(n<sup>2</sup>)</p><h2 id="5-几种常见时间复杂度实例分析"><a href="#5-几种常见时间复杂度实例分析" class="headerlink" title="5 几种常见时间复杂度实例分析"></a>5 几种常见时间复杂度实例分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然代码千差万别，但是常见的复杂度量级并不多，以下几乎涵盖了所有一般代码的复杂度量级。<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述可粗略的分为两类：<strong>多项式量级</strong> 和 <strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当数据规模n越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度需要再次学习。</p><h3 id="5-1-O-1"><a href="#5-1-O-1" class="headerlink" title="5.1 O(1)"></a>5.1 O(1)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先必须知道，O(1)只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码，比如下面这段代码的时间复杂度就是 O(1)，而不是O(3)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> sum = i + j;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度都记作 O(1)，或者：<strong>一般情况下，只要算法中不存在循环、递归，即使有成千上万行的代码，其时间复杂度也是 O(1)</strong></p><h3 id="5-2-O-logn-、O-nlogn"><a href="#5-2-O-logn-、O-nlogn" class="headerlink" title="5.2 O(logn)、O(nlogn)"></a>5.2 O(logn)、O(nlogn)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第3行代码是循环执行次数最多的。所以，只要能计算出这行代码执行了多少次，就知道整段代码的时间复杂度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从代码中可以看出，变量i的值从1开始取，每循环一次就乘以2.当大于n时，循环结束。这就是一个等比数列。如下所示：<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/9b1c88264e7a1a20b5954be9bc4bec9a_20_281_29.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2<sup>x</sup>=n 求解这个x这个问题。x=log<sub>2</sub>n。所以这段代码的时间复杂度是O(log<sub>2</sub>n)。<br>下面呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间复杂度：O(log<sub>3</sub>n)</p><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，不管是以2位底、还是以3为底，还是以10位底，可以把所有对数阶的时间复杂度都记为O(logn)。为什么呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为对数可以互相转换的。<br>log<sub>3</sub>n = log<sub>3</sub>2 &#42; log<sub>2</sub>n，所以O(log<sub>3</sub>n) = O(C &#42; log<sub>2</sub>n)，其中 C = log<sub>3</sub>2 是一个常量。基于前面的一个理论：采用** 大O标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))** 。 因此，O(log<sub>2</sub>n) 等于 log<sub>3</sub>n，所以在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一标示为O（logn）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如此说来，O(nlogn)不难理解，就乘法法则而言，如果一段代码的时间复杂度是O(logn)，循环执行了n遍，其时间复杂度就是O(nlogn)。而且，O(nlogn)是一种非常常见的算法时间复杂度。如：归并排序、快速排序的时间复杂度都是O(nlogn)。</p><h3 id="5-3-O-m-n-、O-m-42-n"><a href="#5-3-O-m-n-、O-m-42-n" class="headerlink" title="5.3 O(m+n)、O(m &#42; n)"></a>5.3 O(m+n)、O(m &#42; n)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果代码的复杂度由<strong>两个数据的规模</strong>来决定的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由代码看出，m和n表示两个数据规模。无法事先评估m和n谁的量极大，所以在表示复杂度的时候，就不能简单的利用加法法则，省略掉一种一个。因此上面代码的时间复杂度就是O(m+n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种情况，原来的加法法则就不在正确，需要将加法法则改写：T1(m)+T2(n) = O(f(m) + g(n))。但是乘法法则依然有效：T1(m)&#42;T2(n) = O(f(m) &#42; f(n))。</p><h2 id="6-空间复杂度分析"><a href="#6-空间复杂度分析" class="headerlink" title="6 空间复杂度分析"></a>6 空间复杂度分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由上面得知，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。</strong>类比可知，空间复杂度全称就是<strong>渐进空间复杂度</strong>(asymptotic space complexity)，<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仿照时间复杂度，可以得知，第2行代码中，申请了一个空间存储变量 i , 但是它是常量阶，跟数据规模 n 没有关系，所以可以忽略。第 3 行申请了一个大小为n的int类型数组，除此之外剩下的代码都没有占用更多的空间，所以，整段代码的空间复杂度就是O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常见的空间复杂度是：O(1)，O(n),O(n<sup>2</sup>)，如O(logn)、O(nlogn)这样的对数阶复杂度平时很难用到。</p><h2 id="7-小结"><a href="#7-小结" class="headerlink" title="7 小结"></a>7 小结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复杂度也称为渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，由低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)。<br><img src="/2019/08/10/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A%E9%83%A8/497a3f120b7debee07dc0d03984faf04.jpg" alt></p><hr><h2 id="8-理解"><a href="#8-理解" class="headerlink" title="8 理解"></a>8 理解</h2><p>一、什么是复杂度分析？<br>1.数据结构和算法解决是“如何让计算机更快时间、更省空间的解决问题”。<br>2.因此需从执行时间和占用空间两个维度来评估数据结构和算法的性能。<br>3.分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。<br>4.复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。<br>二、为什么要进行复杂度分析？<br>1.和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。<br>2.掌握复杂度分析，将能编写出性能更优的代码，有利于降低系统开发和维护成本。<br>三、如何进行复杂度分析？<br>1.大O表示法<br>1）来源<br>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。<br>2）特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。<br>2.复杂度分析法则<br>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。<br>四、常用的复杂度级别？<br>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）<br>非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）<br>五、如何掌握好复杂度分析方法？<br>复杂度分析关键在于多练，所谓孰能生巧</p><hr><h3 id="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"><a href="#项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？" class="headerlink" title="项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？"></a>项目之前都进行性能测试，再做一次复杂度分析，多此一举吗？</h3><p>我不认为是多此一举，渐进时间，空间复杂度分析为我们提供了一个很好的理论分析的方向，并且它是宿主平台无关的，能够让我们对我们的程序或算法有一个大致的认识，让我们知道，比如在最坏的情况下程序的执行效率如何，同时也为我们交流提供了一个不错的桥梁，我们可以说，算法1的时间复杂度是O(n)，算法2的时间复杂度是O(logN)，这样我们立刻就对不同的算法有了一个“效率”上的感性认识。</p><p>当然，渐进式时间，空间复杂度分析只是一个理论模型，只能提供给粗略的估计分析，我们不能直接断定就觉得O(logN)的算法一定优于O(n), 针对不同的宿主环境，不同的数据集，不同的数据量的大小，在实际应用上面可能真正的性能会不同，个人觉得，针对不同的实际情况，进而进行一定的性能基准测试是很有必要的，比如在统一一批手机上(同样的硬件，系统等等)进行横向基准测试，进而选择适合特定应用场景下的最有算法。</p><p>综上所述，渐进式时间，空间复杂度分析与性能基准测试并不冲突，而是相辅相成的，但是一个低阶的时间复杂度程序有极大的可能性会优于一个高阶的时间复杂度程序，所以在实际编程中，时刻关心理论时间，空间度模型是有助于产出效率高的程序的，同时，因为渐进式时间，空间复杂度分析只是提供一个粗略的分析模型，因此也不会浪费太多时间，重点在于在编程时，要具有这种复杂度分析的思维。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法概览</title>
      <link href="/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
      <url>/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br><font color="red">学习来源：极客时间-算法之美，本人购买课程后依据图文讲解汇总成个人见解。</font></p><h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h1><p>&nbsp;&nbsp;&nbsp;广义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据结构</strong>：<font color="red">一组数据的存储结构</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>算法</strong>：<font color="red">操作数据的一组方法</font>。<br>&nbsp;&nbsp;&nbsp;狭义上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些<font color="red">著名</font>的数据结构与算法,如队列、栈、堆、二分查找、动态规划等等。</p><h1 id="2-二者关系"><a href="#2-二者关系" class="headerlink" title="2 二者关系"></a>2 二者关系</h1><p>&nbsp;&nbsp;&nbsp;数据结构与算法相辅相成。<font color="red">数据结构是为算法服务的，算法要作用在特定的数据结构之上</font>。因此，孤立而单独的讲解两者毫无意义。<br>&nbsp;&nbsp;&nbsp;比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但是我们选择链表这种数据结构，二分查找就无法工作了，因为链表不支持随机访问。<br>&nbsp;&nbsp;&nbsp;数据结构是<font color="red">静态</font>的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构是没有用的。</p><a id="more"></a><h1 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3 复杂度分析"></a>3 复杂度分析</h1><p>&nbsp;&nbsp;&nbsp;<font color="red">复杂度分析</font>占据了数据结构与算法的半壁江山，是数据结构与算法的精髓。<br>&nbsp;&nbsp;&nbsp;数据结构与算法解决的是如何更省、更快的存储和处理数据的问题，因此，需要考量效率和资源消耗的方法，这就是复杂度分析方法。所以，只掌握了数据结构与算法的特点、用法，没有学会复杂度分析，相当于只知口诀，而无心法，只有把心法了然于胸，才能做到无招胜有招！</p><h1 id="4-学习图"><a href="#4-学习图" class="headerlink" title="4 学习图"></a>4 学习图</h1><p><img src="/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/913e0ababe43a2d57267df5c5f0832a7.jpg" alt></p><h1 id="5-20个基础"><a href="#5-20个基础" class="headerlink" title="5 20个基础"></a>5 20个基础</h1><p>&nbsp;&nbsp;&nbsp;<font color="blue">10个数据结构</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树</font><br>&nbsp;&nbsp;&nbsp;<font color="blue">10个算法</font>：<br>&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法</font></p><h1 id="6-策略"><a href="#6-策略" class="headerlink" title="6 策略"></a>6 策略</h1><p>&nbsp;&nbsp;&nbsp;学习 <strong>‘它’</strong> 的<font color="red">来历、自身特点、适合解决的问题、实际应用场景</font>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-3-Docker容器用法</title>
      <link href="/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/10/3-3-Docker%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="1-Docker-容器"><a href="#1-Docker-容器" class="headerlink" title="1 Docker 容器"></a>1 Docker 容器</h2><p>容器是 Docker 又一核心概念。</p><p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p><h2 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2 启动容器"></a>2 启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><a id="more"></a><h3 id="2-1-新建并启动"><a href="#2-1-新建并启动" class="headerlink" title="2.1 新建并启动"></a>2.1 新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run ubuntu:14.04 &#x2F;bin&#x2F;echo &#39;Hello world&#39;</span><br><span class="line">Unable to find image &#39;ubuntu:14.04&#39; locally 14.04: Pulling from  library&#x2F;ubuntu cb56c90f0b30: Pull complete 0acc551e5716: Pull complete 8956dcd35143: Pull complete 908242721214: Pull complete b44ff14dd3bb: Pull complete Digest: sha256:5faf6cb681da2be979a177b60d8c18497f962e3d82268c49db6c74008d0c294d Status: Downloaded newer image for ubuntu:14.04 Hello world</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行 <code>/bin/echo &#39;hello world&#39;</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -t -i ubuntu:14.04 &#x2F;bin&#x2F;bash root@af8bae53bdd3:&#x2F;#</span><br></pre></td></tr></table></figure><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@af8bae53bdd3:&#x2F;# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">root@af8bae53bdd3:&#x2F;# ls</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@ba267838cc1b:&#x2F;# ps</span><br><span class="line">PID  TTY  TIME  CMD  </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="2-2-查看正在运行中的容器"><a href="#2-2-查看正在运行中的容器" class="headerlink" title="2.2 查看正在运行中的容器"></a>2.2 查看正在运行中的容器</h3><p>利用 <code>docker ps</code> 命令可以查看正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up  47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver</span><br></pre></td></tr></table></figure><h3 id="2-3-查看所有容器"><a href="#2-3-查看所有容器" class="headerlink" title="2.3 查看所有容器"></a>2.3 查看所有容器</h3><p>利用 <code>docker ps -a</code> 命令可以查看所有容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  25 minutes ago Exited (0) 25 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><h3 id="2-4-启动已终止的容器"><a href="#2-4-启动已终止的容器" class="headerlink" title="2.4 启动已终止的容器"></a>2.4 启动已终止的容器</h3><p>可以利用 <code>docker start</code> 命令和上面使用 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，直接将一个已经终止的容器启动运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker start relaxed_kilby</span><br><span class="line"></span><br><span class="line">relaxed_kilby</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot;  45 minutes ago Exited (0) 3 seconds ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:82-&gt;80&#x2F;tcp web2 </span><br><span class="line">71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world  &quot;&#x2F;hello&quot;  47 hours ago Exited (0) 47 hours ago peaceful_brown</span><br></pre></td></tr></table></figure><p>这里把 <strong>新建并启动</strong> 章节中的容器又启动了一次,这次这个容器和之前不一样,他启动之后就会被终止,不会输出一个 “Hello World”，之后才终止容器。可以看 <code>STATUS</code> 输出,这个容器的确被启动过.</p><h3 id="2-5-容器后台运行"><a href="#2-5-容器后台运行" class="headerlink" title="2.5 容器后台运行"></a>2.5 容器后台运行</h3><p>更多的时候，需要让 Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot; </span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world </span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出的结果(STDOUT)打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d ubuntu:14.04 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;  77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出的结果(STDOUT)打印到宿主机上面(输出结果可以用docker logs 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和docker run指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker ps</code> 命令来查看容器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</span><br><span class="line">77b2dc01fe0f ubuntu:14.04 &#x2F;bin&#x2F;sh -c &#39;while tr 2 minutes ago Up 1 minute agitated_wright</span><br></pre></td></tr></table></figure><p>要获取容器的输出信息，可以通过 <code>docker logs</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs [container ID  or  NAMES] hello world </span><br><span class="line">hello world </span><br><span class="line">hello world</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure><h3 id="2-6-终止容器"><a href="#2-6-终止容器" class="headerlink" title="2.6 终止容器"></a>2.6 终止容器</h3><p>可以使用 <code>docker stop</code> 命令和上面使用的 <code>docker ps -a</code> 查看到的 <code>CONTAINER ID</code>或 <code>NAMES</code>，来终止一个运行中的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop web2 </span><br><span class="line"></span><br><span class="line">web2</span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br><span class="line"></span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">1b6890b715ec ubuntu:14.04  &quot;&#x2F;bin&#x2F;echo &#39;Hello ...&quot; About an hour ago Exited (0) 15 minutes ago relaxed_kilby </span><br><span class="line">9dea98e12fc0 nginx:v2 &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Exited (0) 3  seconds ago web2 71e33c548d3d nginx &quot;nginx -g &#39;daemon ...&quot;  47 hours ago Up 47 hours 0.0.0.0:81-&gt;80&#x2F;tcp webserver </span><br><span class="line">e708a9002164 hello-world &quot;&#x2F;hello&quot;  2 days ago Exited (0) 2 days ago peaceful_brown</span><br></pre></td></tr></table></figure><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。例如启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止</p><h3 id="2-7-重启容器"><a href="#2-7-重启容器" class="headerlink" title="2.7 重启容器"></a>2.7 重启容器</h3><p><code>docker restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="3-进入容器"><a href="#3-进入容器" class="headerlink" title="3 进入容器"></a>3 进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，有很多种方法，包括使用 <code>docker attach</code> 命令或 <code>nsenter</code> 工具等。</p><h3 id="3-1-attach-命令"><a href="#3-1-attach-命令" class="headerlink" title="3.1 attach 命令"></a>3.1 attach 命令</h3><p><code>docker attach</code> 是Docker自带的命令。下面示例如何使用该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550  </span><br><span class="line">$ sudo docker ps </span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia</span><br><span class="line">$sudo docker attach nostalgic_hypatia root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><p>是使用 <code>attach</code> 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时,其他窗口也无法执行操作了。</p><h3 id="3-2-nsenter-命令"><a href="#3-2-nsenter-命令" class="headerlink" title="3.2 nsenter 命令"></a>3.2 nsenter 命令</h3><h4 id="3-2-1-安装"><a href="#3-2-1-安装" class="headerlink" title="3.2.1 安装"></a>3.2.1 安装</h4><p><code>nsenter</code> 工具在 util-linux 包2.23版本后包含。<br>可以使用 <code>nsenter -V</code> 查看系统是否安装了 <code>nsenter</code> 工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nsenter -V</span><br><span class="line"></span><br><span class="line">nsenter from util-linux  2.23.2</span><br></pre></td></tr></table></figure><p>如果系统中 util-linux 包没有该命令，可以按照下面的方法从源码安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;tmp; curl https:&#x2F;&#x2F;www.kernel.org&#x2F;pub&#x2F;linux&#x2F;utils&#x2F;util-linux&#x2F;v2.24&#x2F;util-linux-2.24.tar.gz | tar -zxf-; cd util-linux-2.24; </span><br><span class="line">$ .&#x2F;configure --without-ncurses </span><br><span class="line">$ make nsenter &amp;&amp; sudo cp nsenter &#x2F;usr&#x2F;local&#x2F;bin</span><br></pre></td></tr></table></figure><h4 id="3-2-2-使用"><a href="#3-2-2-使用" class="headerlink" title="3.2.2 使用"></a>3.2.2 使用</h4><p><code>senter</code> 启动一个新的shell进程(默认是/bin/bash), 同时会把这个新进程切换到和目标(target)进程相同的命名空间，这样就相当于进入了容器内部。nsenter 要正常工作需要有 root 权限。</p><p>为了连接到容器，你还需要找到容器的第一个进程的 PID，可以通过下面的命令获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PID&#x3D;$(docker inspect --format  &quot;&#123;&#123; .State.Pid &#125;&#125;&quot; &lt;container&gt;)</span><br></pre></td></tr></table></figure><p>通过这个 PID，就可以连接到这个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $PID  --mount  --uts  --ipc  --net  --pid</span><br></pre></td></tr></table></figure><p>如果无法通过以上命令连接到这个容器，有可能是因为宿主的默认 shell 在容器中并不存在，比如zsh，可以使用如下命令显式地使用bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  nsenter  --target  $pid  --mount  --uts  --ipc  --net  --pid  --  &#x2F;usr&#x2F;bin&#x2F;env  \  --ignore-environment  HOME&#x3D;&#x2F;root  &#x2F;bin&#x2F;bash  --login</span><br></pre></td></tr></table></figure><p>下面给出一个完整的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -idt ubunt</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line">$ sudo docker ps</span><br><span class="line">CONTAINER  ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES  </span><br><span class="line">243c32535da7 ubuntu:latest &quot;&#x2F;bin&#x2F;bash&quot;  18 seconds ago Up  17 seconds nostalgic_hypatia $ PID&#x3D;$(docker-pid 243c32535da7) 10981 </span><br><span class="line">$ sudo nsenter --target 10981 --mount --uts --ipc --net --pid </span><br><span class="line">root@243c32535da7:&#x2F;#</span><br></pre></td></tr></table></figure><h2 id="4-导出和导入容器快照"><a href="#4-导出和导入容器快照" class="headerlink" title="4 导出和导入容器快照"></a>4 导出和导入容器快照</h2><h3 id="4-1-导出容器快照"><a href="#4-1-导出容器快照" class="headerlink" title="4.1 导出容器快照"></a>4.1 导出容器快照</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">7691a814370e ubuntu:14.04  &quot;&#x2F;bin&#x2F;bash&quot;  36 hours ago Exited (0) 21 hours ago test </span><br><span class="line">$ sudo docker export  7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure><p>这样将导出容器快照到本地文件。</p><h3 id="4-2-导入容器快照"><a href="#4-2-导入容器快照" class="headerlink" title="4.2 导入容器快照"></a>4.2 导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu.tar | sudo docker import - test&#x2F;ubuntu:v1.0</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test&#x2F;ubuntu v1.0  </span><br><span class="line">9d37a6082e97 About a minute ago 171.3 MB</span><br></pre></td></tr></table></figure><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo</span><br></pre></td></tr></table></figure><p>*注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也$sudo docker rm trusting_newton trusting_newton要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p><h2 id="5-删除容器"><a href="#5-删除容器" class="headerlink" title="5 删除容器"></a>5 删除容器</h2><p>可以使用 <code>docker rm</code> 来删除一个处于终止状态的容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker rm trusting_newton trusting_newton</span><br></pre></td></tr></table></figure><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="6-清理所有处于终止状态的容器-不建议使用"><a href="#6-清理所有处于终止状态的容器-不建议使用" class="headerlink" title="6 清理所有处于终止状态的容器(不建议使用)"></a>6 清理所有处于终止状态的容器(不建议使用)</h2><p>用 <code>docker ps -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用 <code>docker rm $(docker ps -a -q)</code> 可以全部清理掉。</p><p>*注意：这个命令其实会试图删除所有的包括还在运行中的容器，不过就像上面提过的 <code>docker rm</code> 默认并不会删除运行中的容器</p><h2 id="7-私有仓库"><a href="#7-私有仓库" class="headerlink" title="7 私有仓库"></a>7 私有仓库</h2><p>有时候使用阿里云这样的公共仓库可能不方便，用户可以创建一个本地仓库供自己使用。</p><h3 id="7-1-如何使用本地仓库"><a href="#7-1-如何使用本地仓库" class="headerlink" title="7.1 如何使用本地仓库"></a>7.1 如何使用本地仓库</h3><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库</p><h3 id="7-2-安装运行-docker-registry"><a href="#7-2-安装运行-docker-registry" class="headerlink" title="7.2 安装运行 docker-registry"></a>7.2 安装运行 docker-registry</h3><h4 id="7-2-1-容器中运行-docker-registry"><a href="#7-2-1-容器中运行-docker-registry" class="headerlink" title="7.2.1 容器中运行 docker-registry"></a>7.2.1 容器中运行 docker-registry</h4><p>在安装了 Docker 后，可以通过获取官方 registry 镜像来运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 registry</span><br></pre></td></tr></table></figure><p>这将使用官方的 registry 镜像来启动本地的私有仓库。<br>用户可以通过指定参数来配置私有仓库位置，例如配置镜像存储到 Amazon S3 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run \ </span><br><span class="line">-e SETTINGS_FLAVOR&#x3D;s3 \ </span><br><span class="line">-e AWS_BUCKET&#x3D;acme-docker \ </span><br><span class="line">-e STORAGE_PATH&#x3D;&#x2F;registry \ </span><br><span class="line">-e AWS_KEY&#x3D;AKIAHSHB43HS3J92MXZ \ </span><br><span class="line">-e AWS_SECRET&#x3D;xdDowwlK7TJajV1Y7EoOZrmuPEJlHYcNP2k4j49T \ </span><br><span class="line">-e SEARCH_BACKEND&#x3D;sqlalchemy \ </span><br><span class="line">-p 5000:5000 \ </span><br><span class="line">registry</span><br></pre></td></tr></table></figure><p>此外，还可以指定本地路径（如 <code>/home/user/registry-conf</code> ）下的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;home&#x2F;user&#x2F;registry-conf:&#x2F;registry-conf  -e DOCKER_REGISTRY_CONFIG&#x3D;&#x2F;registry-conf&#x2F;config.yml registry</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>（v1 中是<code>/tmp/registry</code>）下。可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。</p><p>例如下面的例子将上传的镜像放到 <code>/opt/data/registry</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry registry</span><br></pre></td></tr></table></figure><h4 id="7-2-2-本地安装-docker-registry"><a href="#7-2-2-本地安装-docker-registry" class="headerlink" title="7.2.2 本地安装 docker-registry"></a>7.2.2 本地安装 docker-registry</h4><p>对于 CentOS 发行版，可以直接通过源安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y python-devel libevent-devel python-pip gcc xz-devel </span><br><span class="line">$ sudo python-pip install docker-registry</span><br></pre></td></tr></table></figure><p>也可以从 <a href="https://link.jianshu.com/?t=https://github.com/docker/docker-registry" target="_blank" rel="noopener">docker-registry</a> 项目下载源码进行安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install build-essential python-dev libevent-dev python-pip libssl-dev liblzma-dev libffi-dev </span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;docker-registry.git </span><br><span class="line">$ cd docker-registry </span><br><span class="line">$ sudo python setup.py install</span><br></pre></td></tr></table></figure><p>然后修改配置文件，主要修改 dev 模板段的 <code>storage_path</code> 到本地的存储仓库的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp config&#x2F;config_sample.yml config&#x2F;config.yml</span><br></pre></td></tr></table></figure><p>之后启动 Web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn -c contrib&#x2F;gunicorn.py docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gunicorn --access-logfile  -  --error-logfile  -  -k gevent -b  0.0.0.0:5000  -w  4  --max-requests  100 docker_registry.wsgi:application</span><br></pre></td></tr></table></figure><p>此时使用 curl 访问本地的 5000 端口，看到输出 docker-registry 的版本信息说明运行成功</p><p>*注：<code>config/config_sample.yml</code> 文件是示例配置文件。</p><h3 id="7-3-在私有仓库上传、下载、搜索镜像"><a href="#7-3-在私有仓库上传、下载、搜索镜像" class="headerlink" title="7.3 在私有仓库上传、下载、搜索镜像"></a>7.3 在私有仓库上传、下载、搜索镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库，别的机器上就可以下载下来了。例如私有仓库地址为 <code>192.168.7.26:5000</code>。</p><p>先在本机查看已有的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用<code>docker tag</code> 将 <code>ba58</code> 这个镜像标记为 <code>192.168.7.26:5000/test</code>（格式为 <code>docker tag IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker tag ba58 192.168.7.26:5000&#x2F;test</span><br><span class="line">root ~ # docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 14.04 ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">ubuntu latest ba5877dc9bec 6 weeks ago 192.7 MB </span><br><span class="line">192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><p>使用 <code>docker push</code> 上传标记的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker push 192.168.7.26:5000&#x2F;test</span><br><span class="line">The push refers to  a repository [192.168.7.26:5000&#x2F;test] (len: 1)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository 192.168.7.26:5000&#x2F;test (1 tags)</span><br><span class="line">Image 511136ea3c5a already pushed, skipping Image 9bad880da3d2 already pushed, skipping Image 25f11f5fb0cb already pushed, skipping Image ebc34468f71d already pushed, skipping Image 2318d26665ef already pushed, skipping Image ba5877dc9bec already pushed, skipping</span><br><span class="line">Pushing tag for rev [ba5877dc9bec] on &#123;http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;repositories&#x2F;test&#x2F;tags&#x2F;latest&#125;</span><br></pre></td></tr></table></figure><p>用 curl 查看仓库中的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http:&#x2F;&#x2F;192.168.7.26:5000&#x2F;v1&#x2F;search</span><br><span class="line">&#123;&quot;num_results&quot;:  7, &quot;query&quot;:  &quot;&quot;, &quot;results&quot;: [&#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;miaxis_j2ee&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;tomcat&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;ubuntu_office&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;desktop_ubu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;dockerfile&#x2F;ubuntu&quot;&#125;, &#123;&quot;description&quot;:  &quot;&quot;, &quot;name&quot;:  &quot;library&#x2F;test&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>{&quot;description&quot;: &quot;&quot;, &quot;name&quot;: &quot;library/test&quot;}</code>，表明镜像已经被成功上传了。</p><p>现在可以到另外一台机器去下载这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker pull 192.168.7.26:5000&#x2F;test</span><br><span class="line">Pulling repository 192.168.7.26:5000&#x2F;test</span><br><span class="line">ba5877dc9bec: Download complete </span><br><span class="line">511136ea3c5a: Download complete </span><br><span class="line">9bad880da3d2: Download complete </span><br><span class="line">25f11f5fb0cb: Download complete </span><br><span class="line">ebc34468f71d: Download complete </span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line">$ sudo docker images</span><br><span class="line">REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE 192.168.7.26:5000&#x2F;test latest ba5877dc9bec 6 weeks ago 192.7 MB</span><br></pre></td></tr></table></figure><h2 id="8-Docker-数据管理"><a href="#8-Docker-数据管理" class="headerlink" title="8 Docker 数据管理"></a>8 Docker 数据管理</h2><h3 id="8-1-数据卷"><a href="#8-1-数据卷" class="headerlink" title="8.1 数据卷"></a>8.1 数据卷</h3><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li><li>注意：数据卷的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的数据卷。<h3 id="8-2-创建一个数据卷"><a href="#8-2-创建一个数据卷" class="headerlink" title="8.2 创建一个数据卷"></a>8.2 创建一个数据卷</h3></li></ul><p>在用 <code>docker run</code> 命令的时候，使用 <code>-v</code> 标记来创建一个数据卷并挂载到容器里。在一次 run 中多次使用可以挂载多个数据卷。</p><p>下面创建一个名为 web 的容器，并加载一个数据卷到容器的 <code>/webapp</code> 目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>*注意：也可以在 Dockerfile 中使用 <code>VOLUME</code> 来添加一个或者多个新的卷到由该镜像创建的任意容器。</p><h3 id="8-3-删除数据卷"><a href="#8-3-删除数据卷" class="headerlink" title="8.3 删除数据卷"></a>8.3 删除数据卷</h3><p>数据卷是被设计用来持久化数据的，它的生命周期独立于容器，Docker不会在容器被删除后自动删除数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。无主的数据卷可能会占据很多空间，要清理会很麻烦。Docker官方正在试图解决这个问题，相关工作的进度可以查看这个<a href="https://github.com/moby/moby/pull/8484" target="_blank" rel="noopener">PR</a>。</p><h3 id="8-4-挂载一个主机目录作为数据卷"><a href="#8-4-挂载一个主机目录作为数据卷" class="headerlink" title="8.4 挂载一个主机目录作为数据卷"></a>8.4 挂载一个主机目录作为数据卷</h3><p>使用 <code>-v</code> 标记也可以指定挂载一个本地主机的目录到容器中去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code><br>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p><p>*注意：Dockerfile 中不支持这种用法，这是因为 Dockerfile 是为了移植和分享用的。然而，不同操作系统的路径格式不一样，所以目前还不能支持。</p><p>Docker 挂载数据卷的默认权限是读写，用户也可以通过 <code>:ro</code> 指定为只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web -v &#x2F;src&#x2F;webapp:&#x2F;opt&#x2F;webapp:ro training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>加了 <code>:ro</code> 之后，就挂载为只读了。</p><h3 id="8-5-查看数据卷的具体信息"><a href="#8-5-查看数据卷的具体信息" class="headerlink" title="8.5 查看数据卷的具体信息"></a>8.5 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看指定容器的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect web </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在输出的内容中找到其中和数据卷相关的部分，可以看到所有的数据卷都是创建在主机的<code>/var/lib/docker/volumes/</code>下面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Volumes&quot;: &#123; &quot;&#x2F;webapp&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;fac362...80535&quot; </span><br><span class="line">&#125;,</span><br><span class="line">&quot;VolumesRW&quot;: &#123; &quot;&#x2F;webapp&quot;: true &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注：从Docker 1.8.0起，数据卷配置在”Mounts”Key下面，可以看到所有的数据卷都是创建在主机的<code>/mnt/sda1/var/lib/docker/volumes/....</code>下面了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mounts&quot;: [ </span><br><span class="line">    &#123; </span><br><span class="line">        &quot;Name&quot;: &quot;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&quot;, </span><br><span class="line">        &quot;Source&quot;: &quot;&#x2F;mnt&#x2F;sda1&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;b53ebd40054dae599faf7c9666acfe205c3e922fc3e8bc3f2fd178ed788f1c29&#x2F;_data&quot;, </span><br><span class="line">        &quot;Destination&quot;: &quot;&#x2F;webapp&quot;, </span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;, </span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;, </span><br><span class="line">        &quot;RW&quot;: true, </span><br><span class="line">        &quot;Propagation&quot;: &quot;&quot; </span><br><span class="line">    &#125; </span><br><span class="line">] </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="8-6-挂载一个本地主机文件作为数据卷"><a href="#8-6-挂载一个本地主机文件作为数据卷" class="headerlink" title="8.6 挂载一个本地主机文件作为数据卷"></a>8.6 挂载一个本地主机文件作为数据卷</h3><p><code>-v</code> 标记也可以从主机挂载单个文件到容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm -it -v ~&#x2F;.bash_history:&#x2F;.bash_history ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>这样就可以记录在容器输入过的命令了。</p><p>*注意：如果直接挂载一个文件，很多文件编辑工具，包括 <code>vi</code> 或者 <code>sed --in-place</code>，可能会造成文件 inode 的改变，从 Docker 1.1<br>.0起，这会导致报错误信息。所以最简单的办法就直接挂载文件的父目录。</p><h3 id="8-7-数据卷容器"><a href="#8-7-数据卷容器" class="headerlink" title="8.7 数据卷容器"></a>8.7 数据卷容器</h3><p>如果你有一些持续更新的数据需要在容器之间共享，最好创建数据卷容器。</p><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。</p><p>首先，创建一个名为 dbdata 的数据卷容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -v &#x2F;dbdata --name dbdata training&#x2F;postgres echo Data-only container for postgres</span><br></pre></td></tr></table></figure><p>然后，在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --volumes-from dbdata --name db1 training&#x2F;postgres </span><br><span class="line">$ sudo docker run -d --volumes-from dbdata --name db2 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>可以使用超过一个的 <code>--volumes-from</code> 参数来指定从多个容器挂载不同的数据卷。<br>也可以从其他已经挂载了数据卷的容器来级联挂载数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db3 --volumes-from db1 training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>*注意：使用 <code>--volumes-from</code> 参数所挂载数据卷的容器自己并不需要保持在运行状态。</p><p>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。<br>这可以让用户在容器之间升级和移动数据卷。</p><h2 id="9-利用数据卷容器来备份、恢复、迁移数据卷"><a href="#9-利用数据卷容器来备份、恢复、迁移数据卷" class="headerlink" title="9 利用数据卷容器来备份、恢复、迁移数据卷"></a>9 利用数据卷容器来备份、恢复、迁移数据卷</h2><p>可以利用数据卷对其中的数据进行进行备份、恢复和迁移</p><h3 id="9-1-备份"><a href="#9-1-备份" class="headerlink" title="9.1 备份"></a>9.1 备份</h3><p>首先使用 <code>--volumes-from</code> 标记来创建一个加载 dbdata 容器卷的容器，并从主机挂载当前目录到容器的 /backup 目录。命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata -v $(pwd):&#x2F;backup ubuntu tar cvf &#x2F;backup&#x2F;backup.tar &#x2F;dbdata</span><br></pre></td></tr></table></figure><p>容器启动后，使用了 <code>tar</code> 命令来将 dbdata 卷备份为容器中 /backup/backup.tar 文件，也就是主机当前目录下的名为 <code>backup.tar</code> 的文件。</p><h3 id="9-2-恢复"><a href="#9-2-恢复" class="headerlink" title="9.2 恢复"></a>9.2 恢复</h3><p>如果要恢复数据到一个容器，首先创建一个带有空数据卷的容器 dbdata2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -v &#x2F;dbdata --name dbdata2 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>然后创建另一个容器，挂载 dbdata2 容器卷中的数据卷，并使用 <code>untar</code> 解压备份文件到挂载的容器卷中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --volumes-from dbdata2 -v $(pwd):&#x2F;backup busybox tar xvf &#x2F;backup&#x2F;backup.tar</span><br></pre></td></tr></table></figure><p>为了查看/验证恢复的数据，可以再启动一个容器挂载同样的容器卷来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run  --volumes-from dbdata2 busybox &#x2F;bin&#x2F;ls &#x2F;dbdata</span><br></pre></td></tr></table></figure><h2 id="10-Docker-中的网络功能介绍"><a href="#10-Docker-中的网络功能介绍" class="headerlink" title="10 Docker 中的网络功能介绍"></a>10 Docker 中的网络功能介绍</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id="10-1-外部访问容器"><a href="#10-1-外部访问容器" class="headerlink" title="10.1 外部访问容器"></a>10.1 外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 -P 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p><p>使用 <code>docker ps</code> 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P training&#x2F;webapp python app.py</span><br><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">bc533791f3f5 training&#x2F;webapp:latest python app.py 5 seconds ago Up 2 seconds 0.0.0.0:49155-&gt;5000&#x2F;tcp nostalgic_morse</span><br></pre></td></tr></table></figure><p>同样的，可以通过 <code>docker logs</code> 命令来查看应用的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker logs -f nostalgic_morse</span><br><span class="line">* Running on http:&#x2F;&#x2F;0.0.0.0:5000&#x2F;</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F; HTTP&#x2F;1.1&quot;  200 -</span><br><span class="line">10.0.2.2 - - [23&#x2F;May&#x2F;2014  20:16:31] &quot;GET &#x2F;favicon.ico HTTP&#x2F;1.1&quot;  404 -</span><br></pre></td></tr></table></figure><p>-p（小写的）则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="10-2-映射所有接口地址"><a href="#10-2-映射所有接口地址" class="headerlink" title="10.2 映射所有接口地址"></a>10.2 映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-3-映射到指定地址的指定端口"><a href="#10-3-映射到指定地址的指定端口" class="headerlink" title="10.3 映射到指定地址的指定端口"></a>10.3 映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1:5000:5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-4-映射到指定地址的任意端口"><a href="#10-4-映射到指定地址的任意端口" class="headerlink" title="10.4 映射到指定地址的任意端口"></a>10.4 映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 127.0.0.1::5000 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>还可以使用 udp 标记来指定 udp 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p 使用 &#96;docker port&#96; 来查看当前映射的端口配置，也可以查看到绑定的地址127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="10-5-查看映射端口配置"><a href="#10-5-查看映射端口配置" class="headerlink" title="10.5 查看映射端口配置"></a>10.5 查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker port nostalgic_morse 5000</span><br><span class="line">127.0.0.1:49155.</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</li><li>-p 标记可以多次使用来绑定多个端口<br>例如<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -p  5000:5000  -p  3000:80 training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><h2 id="11-容器互联"><a href="#11-容器互联" class="headerlink" title="11 容器互联"></a>11 容器互联</h2>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。</li></ul><p>该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息</p><h3 id="11-1-自定义容器命名"><a href="#11-1-自定义容器命名" class="headerlink" title="11.1 自定义容器命名"></a>11.1 自定义容器命名</h3><p>连接系统依据容器的名称来执行。因此，首先需要自定义一个好记的容器命名。</p><p>虽然当创建容器的时候，系统默认会分配一个名字。自定义命名容器有2个好处</p><ul><li>自定义的命名，比较好记，比如一个web应用容器我们可以给它起名叫web</li><li>当要连接其他容器时候，可以作为一个有用的参考点，比如连接web容器到db容器</li></ul><p>使用 <code>--name</code> 标记可以为容器自定义命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -P --name web training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>使用 <code>docker ps</code> 来验证设定的命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker ps -l</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 12 hours ago Up 2 seconds 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>也可以使用 <code>docker inspect</code> 来查看容器的名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker inspect -f  &quot;&#123;&#123; .Name &#125;&#125;&quot; aed84ee21bde</span><br><span class="line">&#x2F;web</span><br></pre></td></tr></table></figure><p>注意：容器的名称是唯一的。如果已经命名了一个叫 web 的容器，当你要再次使用 web 这个名称的时候，需要先用<code>docker rm</code> 来删除之前创建的同名容器。</p><p>在执行 <code>docker run</code> 的时候如果添加 <code>--rm</code> 标记，则容器在终止后会立刻删除。注意，<code>--rm</code> 和 <code>-d</code>参数不能同时使用。</p><h3 id="11-2-容器互联"><a href="#11-2-容器互联" class="headerlink" title="11.2 容器互联"></a>11.2 容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的进行交互。</p><p>下面先创建一个新的数据库容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --name db training&#x2F;postgres</span><br></pre></td></tr></table></figure><p>除之前创建的 web 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm -f web</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将它连接到 db 容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d  -P  --name web --link db:db training&#x2F;webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。</p><p><code>--link</code> 参数的格式为 <code>--link name:alias</code>，其中 <code>name</code> 是要链接的容器的名称，<code>alias</code> 是这个连接的别名。</p><p>使用 <code>docker ps</code> 来查看容器的连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES </span><br><span class="line">349169744e49 training&#x2F;postgres:latest su postgres -c &#39;&#x2F;usr About a minute ago Up About a minute 5432&#x2F;tcp db, web&#x2F;db </span><br><span class="line">aed84ee21bde training&#x2F;webapp:latest python app.py 16 hours ago Up 2 minutes 0.0.0.0:49154-&gt;5000&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>可以看到自定义命名的容器，db 和 web，db 容器的 names 列有 db 也有 web/db。这表示 web 容器链接到 db 容器，web 容器将被允许访问 db 容器的信息。</p><p>Docker 在两个互联的容器之间创建了一个安全隧道，而且不用映射它们的端口到宿主主机上。在启动 db 容器的时候并没有使用 <code>-p</code> 和 <code>-P</code> 标记，从而避免了暴露数据库端口到外部网络上。</p><p>Docker 通过 2 种方式为容器公开连接信息</p><ul><li>环境变量</li><li>更新 <code>/etc/hosts</code> 文件<br>使用 <code>env</code> 命令来查看 web 容器的环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run --rm --name web2 --link db:db training&#x2F;webapp env</span><br><span class="line">. . .</span><br><span class="line">DB_NAME&#x3D;&#x2F;web2&#x2F;db DB_PORT&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP&#x3D;tcp:&#x2F;&#x2F;172.17.0.5:5432 DB_PORT_5000_TCP_PROTO&#x3D;tcp DB_PORT_5000_TCP_PORT&#x3D;5432 DB_PORT_5000_TCP_ADDR&#x3D;172.17.0.5</span><br><span class="line">. . .</span><br></pre></td></tr></table></figure>其中 DB_ 开头的环境变量是供 web 容器连接 db 容器使用，前缀采用大写的连接别名。</li></ul><p>除了环境变量，Docker 还添加 host 信息到父容器的 <code>/etc/hosts</code> 的文件。下面是父容器 web 的 hosts 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -t -i --rm --link db:db training&#x2F;webapp &#x2F;bin&#x2F;bash</span><br><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# cat &#x2F;etc&#x2F;hosts</span><br><span class="line">172.17.0.7 aed84ee21bde</span><br><span class="line">. . . </span><br><span class="line">172.17.0.5 db</span><br></pre></td></tr></table></figure><p>这里有 2 个 hosts，第一个是 web 容器，web 容器用 id 作为他的主机名，第二个是 db 容器的 ip 和主机名。 </p><p>可以在 web 容器中安装 ping 命令来测试跟db容器的连通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@aed84ee21bde:&#x2F;opt&#x2F;webapp# apt-get install -yqq inetutils-ping root@aed84ee21bde:&#x2F;opt&#x2F;webapp# ping db  </span><br><span class="line">PING db (172.17.0.5):  48 data bytes </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;0 ttl&#x3D;64 time&#x3D;0.267 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;1 ttl&#x3D;64 time&#x3D;0.250 ms </span><br><span class="line">56 bytes from 172.17.0.5: icmp_seq&#x3D;2 ttl&#x3D;64 time&#x3D;0.256 ms</span><br></pre></td></tr></table></figure><p>用 ping 来测试db容器，它会解析成 <code>172.17.0.5</code>。<br>*注意：官方的 ubuntu 镜像默认没有安装 ping，需要自行安装。</p><p>用户可以链接多个父容器到子容器，比如可以链接多个 web 到 db 容器上。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2-Docker镜像用法</title>
      <link href="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/"/>
      <url>/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://blog.csdn.net/xc_zhou/article/details/80952307" target="_blank" rel="noopener">https://blog.csdn.net/xc_zhou/article/details/80952307</a></p><h2 id="1-使用-Dockerfile-定制镜像"><a href="#1-使用-Dockerfile-定制镜像" class="headerlink" title="1 使用 Dockerfile 定制镜像"></a>1 使用 Dockerfile 定制镜像</h2><p>从刚才的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><a id="more"></a><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx&#x2F;</span><br><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code></p><h2 id="2-FROM-指定基础镜像"><a href="#2-FROM-指定基础镜像" class="headerlink" title="2 FROM 指定基础镜像"></a>2 FROM 指定基础镜像</h2><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定<strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><h2 id="3-RUN-执行命令"><a href="#3-RUN-执行命令" class="headerlink" title="3 RUN 执行命令"></a>3 RUN 执行命令</h2><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><p><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockrfile 中的 <code>RUN</code>指令就是这种格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li><li><p><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</p></li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每一层构建需要的命令写出来,比如这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line">RUN buildDeps&#x3D;&#39;gcc libc6-dev make&#39;  \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y  $buildDeps  \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz &quot;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.5.tar.gz&quot;  \  &amp;&amp; mkdir -p &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C &#x2F;usr&#x2F;src&#x2F;redis --strip-components&#x3D;1  \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; make -C &#x2F;usr&#x2F;src&#x2F;redis install \</span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r &#x2F;usr&#x2F;src&#x2F;redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h2 id="4-构建镜像"><a href="#4-构建镜像" class="headerlink" title="4 构建镜像"></a>4 构建镜像</h2><p>再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure><p><img src="/2019/06/05/3-2-Docker%E9%95%9C%E5%83%8F%E7%94%A8%E6%B3%95/23fb64e2-2346-432d-8f39-dad51df5c6a3.png" alt></p><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2/2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>785a648f6b86</code>，执行了所要求的命令，并最后提交了这一层 <code>3974e15fde03</code>，随后删除了所用到的这个容器 <code>785a648f6b86</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径&#x2F;URL&#x2F;-&gt;</span><br></pre></td></tr></table></figure><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h2 id="5-镜像构建上下文（Context）"><a href="#5-镜像构建上下文（Context）" class="headerlink" title="5 镜像构建上下文（Context）"></a>5 镜像构建上下文（Context）</h2><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，我原本以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定<strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY .&#x2F;package.json &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是_相对路径_。这也是新人经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t nginx:v3 . </span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个<strong>空目录下</strong>，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h2 id="6-Dockerfile-指令详解"><a href="#6-Dockerfile-指令详解" class="headerlink" title="6 Dockerfile 指令详解"></a>6 Dockerfile 指令详解</h2><h3 id="6-1-COPY-复制文件"><a href="#6-1-COPY-复制文件" class="headerlink" title="6.1 COPY 复制文件"></a>6.1 COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json &#x2F;usr&#x2F;src&#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* &#x2F;mydir&#x2F;</span><br><span class="line">COPY hom?.txt &#x2F;mydir&#x2F;</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="6-2-ADD-更高级的复制文件"><a href="#6-2-ADD-更高级的复制文件" class="headerlink" title="6.2 ADD 更高级的复制文件"></a>6.2 ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz &#x2F;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code>命令了。</p><p>在 Docker 官方的最佳实践文档中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code></p><h3 id="6-3-CMD-容器启动命令"><a href="#6-3-CMD-容器启动命令" class="headerlink" title="6.3 CMD 容器启动命令"></a>6.3 CMD 容器启动命令</h3><p>Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。<br><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li><li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li><li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD echo  $HOME</span><br></pre></td></tr></table></figure><p>在实际执行中，会将其变更为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。0</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD service nginx start</span><br></pre></td></tr></table></figure><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure><h3 id="6-4-ENTRYPOINT-入口点"><a href="#6-4-ENTRYPOINT-入口点" class="headerlink" title="6.4 ENTRYPOINT 入口点"></a>6.4 ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>NTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p><h4 id="6-4-1场景一：让镜像变成像命令一样使用"><a href="#6-4-1场景一：让镜像变成像命令一样使用" class="headerlink" title="6.4.1场景一：让镜像变成像命令一样使用"></a>6.4.1场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$docker run myip -i </span><br><span class="line">docker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in $PATH\&quot;\n&quot;.</span><br></pre></td></tr></table></figure><p>们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip curl -s http:&#x2F;&#x2F;ip.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROM ubuntu:16.04 </span><br><span class="line">RUN apt-get update \ </span><br><span class="line">&amp;&amp; apt-get install -y curl \ </span><br><span class="line">&amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http:&#x2F;&#x2F;ip.cn&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ docker run myip </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通 </span><br><span class="line">$ docker run myip -i </span><br><span class="line">HTTP&#x2F;1.1  200 OK </span><br><span class="line">Server: nginx&#x2F;1.8.0  </span><br><span class="line">Date: Tue, 22 Nov 2016  05:12:40 GMT </span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UTF-8 </span><br><span class="line">Vary: Accept-Encoding </span><br><span class="line">X-Powered-By: PHP&#x2F;5.6.24-1~dotdeb+7.1</span><br><span class="line">X-Cache: MISS from cache-2 </span><br><span class="line">X-Cache-Lookup: MISS from cache-2:80</span><br><span class="line">X-Cache: MISS from proxy-2_6 </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Via: 1.1  cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive </span><br><span class="line">当前 IP：61.148.226.66 来自：北京市 联通</span><br></pre></td></tr></table></figure><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="6-4-2-场景二：应用运行前的准备工作"><a href="#6-4-2-场景二：应用运行前的准备工作" class="headerlink" title="6.4.2 场景二：应用运行前的准备工作"></a>6.4.2 场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code>身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4  </span><br><span class="line">... </span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis </span><br><span class="line">... </span><br><span class="line">ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] </span><br><span class="line"></span><br><span class="line">EXPOSE 6379 CMD [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">... </span><br><span class="line"># allow the container to be started with &#96;--user&#96;  </span><br><span class="line">if [ &quot;$1&quot; &#x3D; &#39;redis-server&#39;  -a  &quot;$(id -u)&quot; &#x3D; &#39;0&#39; ]; then </span><br><span class="line">chown -R redis . </span><br><span class="line">exec su-exec redis &quot;$0&quot;  &quot;$@&quot;  </span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec  &quot;$@&quot;</span><br></pre></td></tr></table></figure><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it redis id uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root)</span><br></pre></td></tr></table></figure><h3 id="6-5-ENV-设置环境变量"><a href="#6-5-ENV-设置环境变量" class="headerlink" title="6.5 ENV 设置环境变量"></a>6.5 ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION&#x3D;1.0 DEBUG&#x3D;on \ </span><br><span class="line">NAME&#x3D;&quot;Happy Feet&quot;</span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \ </span><br><span class="line">&amp;&amp; curl -SLO  &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot; \ </span><br><span class="line">&amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \ </span><br><span class="line">&amp;&amp; grep  &quot; node-v$NODE_VERSION-linux-x64.tar.xz\$&quot; SHASUMS256.txt | sha256sum -c -\ </span><br><span class="line">&amp;&amp; tar -xJf &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; -C &#x2F;usr&#x2F;local --strip-components&#x3D;1 \ </span><br><span class="line">&amp;&amp; rm &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot; SHASUMS256.txt.asc SHASUMS256.txt \ </span><br><span class="line">&amp;&amp; ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodejs</span><br></pre></td></tr></table></figure><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量引用： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>。</p><p>以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="6-6-ARG-构建参数"><a href="#6-6-ARG-构建参数" class="headerlink" title="6.6 ARG 构建参数"></a>6.6 ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p><h3 id="6-7-VOLUME-定义匿名卷"><a href="#6-7-VOLUME-定义匿名卷" class="headerlink" title="6.7 VOLUME 定义匿名卷"></a>6.7 VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul><p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME &#x2F;data</span><br></pre></td></tr></table></figure><p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -v mydata:&#x2F;data xxxx</span><br></pre></td></tr></table></figure><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="6-8-EXPOSE-声明端口"><a href="#6-8-EXPOSE-声明端口" class="headerlink" title="6.8 EXPOSE 声明端口"></a>6.8 EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="6-9-WORKDIR-指定工作目录"><a href="#6-9-WORKDIR-指定工作目录" class="headerlink" title="6.9 WORKDIR 指定工作目录"></a>6.9 WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN cd &#x2F;app </span><br><span class="line">RUN echo  &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure><p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><h3 id="6-10-HEALTHCHECK-健康检查"><a href="#6-10-HEALTHCHECK-健康检查" class="headerlink" title="6.10 HEALTHCHECK 健康检查"></a>6.10 HEALTHCHECK 健康检查</h3><p>格式</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常.</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code>格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* </span><br><span class="line">HEALTHCHECK --interval&#x3D;5s --timeout&#x3D;3s \ </span><br><span class="line">CMD curl -fs http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myweb:v1 .</span><br></pre></td></tr></table></figure><p>构建好了后，我们启动一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker  run  -d  --name  web  -p 80:80  myweb:v1</span><br></pre></td></tr></table></figure><p>当运行该镜像后，可以通过 <code>docker ps</code> 看到最初的状态为 <code>(health: starting)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  3  seconds ago Up 2  seconds (health: starting) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>在等待几秒钟后，再次 <code>docker ps</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 &quot;nginx -g &#39;daemon off&quot;  18  seconds ago Up 16  seconds (healthy) 80&#x2F;tcp, 443&#x2F;tcp web</span><br></pre></td></tr></table></figure><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code></p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect --format &#39;&#123;&#123;json .State.Health&#125;&#125;&#39; web | python -m json.tool </span><br><span class="line">&#123; </span><br><span class="line">    &quot;FailingStreak&quot;: 0, </span><br><span class="line">    &quot;Log&quot;: [ </span><br><span class="line">        &#123; &quot;End&quot;: &quot;2016-11-25T14:35:37.940957051Z&quot;, </span><br><span class="line">        &quot;ExitCode&quot;: 0, </span><br><span class="line">        &quot;Output&quot;: &quot;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;&#x2F;title&gt;\n&lt;style&gt;\n body &#123;\n width: 35em;\n margin: 0 auto;\n font-family: Tahoma, Verdana, Arial, sans-serif;\n &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;&#x2F;h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;&#x2F;p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.org&#x2F;\&quot;&gt;nginx.org&lt;&#x2F;a&gt;.&lt;br&#x2F;&gt;\nCommercial support is available at\n&lt;a href&#x3D;\&quot;http:&#x2F;&#x2F;nginx.com&#x2F;\&quot;&gt;nginx.com&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n&quot;, </span><br><span class="line">        &quot;Start&quot;: &quot;2016-11-25T14:35:37.780192565Z&quot; </span><br><span class="line">    &#125; </span><br><span class="line">], </span><br><span class="line">&quot;Status&quot;: &quot;healthy&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-11-ONBUILD-镜像复用及项目环境管理"><a href="#6-11-ONBUILD-镜像复用及项目环境管理" class="headerlink" title="6.11 ONBUILD 镜像复用及项目环境管理"></a>6.11 ONBUILD 镜像复用及项目环境管理</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F; </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。�第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim </span><br><span class="line">RUN mkdir &#x2F;app </span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node </span><br><span class="line">COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新</p><p>么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line">ONBUILD COPY .&#x2F;package.json &#x2F;app </span><br><span class="line">ONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ] </span><br><span class="line">ONBUILD COPY . &#x2F;app&#x2F;</span><br><span class="line">CMD [ &quot;npm&quot;, &quot;start&quot; ]</span><br></pre></td></tr></table></figure><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h2 id="7-删除本地镜像"><a href="#7-删除本地镜像" class="headerlink" title="7 删除本地镜像"></a>7 删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker rmi</code> 命令，其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><em>注意 <code>docker rm</code> 命令是删除容器，不要混淆</em></p><h3 id="7-1-用-ID、镜像名、摘要删除镜像"><a href="#7-1-用-ID、镜像名、摘要删除镜像" class="headerlink" title="7.1 用 ID、镜像名、摘要删除镜像"></a>7.1 用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。<br>比如我们有这么一些镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images </span><br><span class="line">REPOSITORY  TAG  IMAGE  ID  CREATED  SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5  MB redis alpine 501ad78535f0  3 weeks ago 21.03  MB docker latest cf693ec9b5c7 3 weeks ago 105.1  MB nginx latest e43d811ce2f4 5 weeks ago 181.5  MB</span><br></pre></td></tr></table></figure><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker images</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi 501</span><br><span class="line">Untagged: redis:alpine Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7 Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23 Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3 Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</span><br></pre></td></tr></table></figure><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi centos </span><br><span class="line">Untagged: centos:latest</span><br><span class="line">Untagged:centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c </span><br><span class="line">Deleted:sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</span><br><span class="line">Deleted:sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</span><br></pre></td></tr></table></figure><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images --digests </span><br><span class="line">REPOSITORY  TAG  DIGEST  IMAGE  ID  CREATED  SIZE node slim sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228 6e0c4c8e3913 3 weeks ago 214  MB  $ docker rmi node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br></pre></td></tr></table></figure><h3 id="7-2-用-docker-images-命令来配合"><a href="#7-2-用-docker-images-命令来配合" class="headerlink" title="7.2 用 docker images 命令来配合"></a>7.2 用 docker images 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker images -q</code> 来配合使用 <code>docker rmi</code>，这样可以成批的删除希望删除的镜像。如删除虚悬镜像的指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f dangling&#x3D;true)</span><br></pre></td></tr></table></figure><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q redis)</span><br></pre></td></tr></table></figure><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi $(docker images -q -f before&#x3D;mongo:3.2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1-Docker用法</title>
      <link href="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/"/>
      <url>/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-开启docker服务"><a href="#1-开启docker服务" class="headerlink" title="1 开启docker服务"></a>1 开启docker服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">启动并加入开机启动</span><br><span class="line"></span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line">验证安装是否成功</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line">有 client 和 server两部分即表示安装成功。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-获取镜像命令-docker-pull"><a href="#2-获取镜像命令-docker-pull" class="headerlink" title="2 获取镜像命令 docker pull"></a>2 获取镜像命令 docker pull</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，而镜像名称的格式：</p><ul><li><p>Docker Registry地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，既 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像.一定要配置镜像加速器,不然下载速度很慢。<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure><h3 id="2-1-pull下来的-镜像-存储在哪里呢？"><a href="#2-1-pull下来的-镜像-存储在哪里呢？" class="headerlink" title="2.1 pull下来的 镜像 存储在哪里呢？"></a>2.1 pull下来的 镜像 存储在哪里呢？</h3></li></ul><p>1 进入 docker目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd &#x2F;var&#x2F;lib&#x2F;docker&#x2F;</span><br><span class="line">ls</span><br><span class="line">builder  buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes</span><br></pre></td></tr></table></figure><p>2 进入containers,每一个序列号，都是一个镜像，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd containers&#x2F;</span><br><span class="line"></span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a</span><br><span class="line">a0356a312020a4941b257ada41d72efb041f7034a70a987ec3d0f44e9cc19402</span><br><span class="line">b81decb15c1f1f821d1c56bdadc15b62506b6cc102a6f083ec7a9b5f89c2685b</span><br><span class="line">ea1236fd8c7f4ce919c0f56b87b642487ecd2bbec243d416dd1e34b313b27b92</span><br></pre></td></tr></table></figure><p>3 进入其中一个镜像，发现目录结构如下，这就是这个镜像的内容了，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun 61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a]# ls</span><br><span class="line">61458898f83eeb13b56d4f13bb744ba9b8e543f91dbb450a5196226284deba8a-json.log  hostconfig.json  mounts</span><br><span class="line">checkpoints                                                                hostname         resolv.conf</span><br><span class="line">config.v2.json                                                             hosts            resolv.conf.hash</span><br></pre></td></tr></table></figure><p>4 在containers同级目录，有个叫image的文件夹，进入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cd images&#x2F;aufs</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution imagedb layerdb repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br><span class="line"></span><br><span class="line">如果image没有aufs目录的，可能是这样的</span><br><span class="line"></span><br><span class="line">cd image&#x2F;overlay2&#x2F;</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line">distribution  imagedb  layerdb  repositories.json</span><br><span class="line"></span><br><span class="line">里面有个repositories.json的文件，详细记录了镜像的一些信息</span><br></pre></td></tr></table></figure><h2 id="3-查看已下载的镜像-docker-images"><a href="#3-查看已下载的镜像-docker-images" class="headerlink" title="3 查看已下载的镜像 docker images"></a>3 查看已下载的镜像 docker images</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">列表 包含了仓库名、标签、镜像ID、创建时间、所占空间。</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><p>有了镜像后，我们就可以以这个镜像为基础启动一个容器来运行。以上面的 ubuntu:14.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@haoransun docker]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              14.04               2c5e00d77a67        3 weeks ago         188MB</span><br><span class="line">hello-world         latest              fce289e99eb9        5 months ago        1.84kB</span><br><span class="line">[root@haoransun docker]# docker run -it --rm ubuntu:14.04 bash</span><br><span class="line">root@9de828f70b6d:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;14.04.6 LTS, Trusty Tahr&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 14.04.6 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;14.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;http:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;http:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">root@9de828f70b6d:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>docker run 就是运行容器的命令</p><ul><li><p><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:14.04</code>：这是指用<code>ubuntu:14.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 <code>Shell</code>，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 14.04.5 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="5-定制镜像"><a href="#5-定制镜像" class="headerlink" title="5 定制镜像"></a>5 定制镜像</h2><p>以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost" target="_blank" rel="noopener">http://localhost</a> 如果使用的是 Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址,还要配置安全组放通对应的端口。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/749278bc-1a21-42ee-9643-a541b55dd3b5.png" alt></p><p>现在，改动这个欢迎页面，改成<code>Hello, Docker!</code>，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker exec -it webserver bash</span><br><span class="line">root@6415ebcbd369:&#x2F;# echo &#39;&lt;h1&gt;Hello,Docker!&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html </span><br><span class="line">root@6415ebcbd369:&#x2F;# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。<br><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e2cf02a5-8db5-451b-ad15-7144d09e93f2.png" alt></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker diff webserver</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/dd927ddb-c0ba-47dc-96fa-e7a5f48e5d4f.png" alt></p><h2 id="6-保存镜像"><a href="#6-保存镜像" class="headerlink" title="6 保存镜像"></a>6 保存镜像</h2><p>现在已经定制好了,那我们如何把它保存下来形成镜像?</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而<strong>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像</strong>。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br></pre></td></tr></table></figure><p>下面的命令将容器保存为镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun &#x2F;]# docker commit --author &#39;haoransun&lt;xxxx@qq.com&gt;&#39; --message &#39;修改Nginx欢迎页面&#39; webserver nginx:v2</span><br><span class="line">sha256:cef47606fca7dd6a5ee72986d18641ac754973120312a7015bb228dee64cc02a</span><br></pre></td></tr></table></figure><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/d21dbdd8-e230-4888-b179-46ba0b5d22fd.png" alt></p><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。</p><p>可以用 <code>docker images</code> 命令看到这个新定制的镜像：</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/e168773c-e547-4d5a-86fb-d72e60cee08d.png" alt></p><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><p><img src="/2019/05/24/3-1-Docker%E7%94%A8%E6%B3%95/782171db-773a-4ade-8335-092e6da4d2d6.png" alt></p><p>新的镜像定制好后，我们可以来运行这个镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。否则访问 虚拟机的地址如：192.168.121.100:81。</p><p>完成了第一次定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h2 id="7-慎用-docker-commit"><a href="#7-慎用-docker-commit" class="headerlink" title="7 慎用  docker commit"></a>7 慎用  docker commit</h2><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心没有清理，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为<strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 <code>docker diff</code> 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><p><code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制行为应该使用 <code>Dockerfile</code> 来完成。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2-Docker启动报错</title>
      <link href="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/"/>
      <url>/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>出处：<a href="https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2GNKmRJtBGHhUyVBRbRgeA</a></p><h2 id="1-Docker虚拟化故障"><a href="#1-Docker虚拟化故障" class="headerlink" title="1 Docker虚拟化故障"></a>1 Docker虚拟化故障</h2><p>Docker虚拟化主要有三类故障：<br><strong>应用故障：</strong>应用执行状态与预期不一致。</p><p><strong>容器故障：</strong>无法正确创建、停止、更新容器等。</p><p><strong>集群故障：</strong>集群创建失败、更新失败、无法连接等。</p><a id="more"></a><h2 id="2-Docker-虚拟化故障排错"><a href="#2-Docker-虚拟化故障排错" class="headerlink" title="2 Docker 虚拟化故障排错"></a>2 Docker 虚拟化故障排错</h2><p>所有的Docker虚拟化故障排查诊断，都可以通过Docker命令行工具或者Web控制台来完成。</p><p>通过WEB控制台查看，需要自建控制台，对于Docker运维管理员来说，命令行工具排错是一个不错的帮手。</p><h3 id="2-1-案例1"><a href="#2-1-案例1" class="headerlink" title="2.1 案例1"></a>2.1 案例1</h3><p><strong>案例描述：</strong><br>生产环境，全新安装的Docker无法启动，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl  start  docker.service</span><br><span class="line">Job for docker.service failed because the control process exited with  error code.See</span><br><span class="line">&quot;systemctl status docker.service&quot;  and  &quot;journalctl -xe&quot;  for details</span><br></pre></td></tr></table></figure><p>通过journalctl -xe命令查看启动的详细日志，启动daemon错误，因为Selinux不支持，Selinux阻挡了Docker引擎的启动，如图所示：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/bffe455a-b137-4cd1-b009-874dbeaaebf8.jpg" alt></p><p><strong>解决方案：</strong><br>如上问题，解决方法有两种：</p><p>1.Selinux主配置文件：</p><p>/etc/selinux/config，将配置文件中enforcing设置为disabled，然后重启系统，然后重启docker引擎即可。</p><p>2.docker主配置文件：</p><p>/etc/sysconfig/docker，将配置文件中–selinux-enabled选项为false，改成：–selinux-enabled=false即可。</p><h3 id="2-2-案例2"><a href="#2-2-案例2" class="headerlink" title="2.2 案例2"></a>2.2 案例2</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown  socket at step GROUP: No such process</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/3bf44228-5466-47a3-a7fb-eae0c2c85e13.jpg" alt></p><p><strong>解决方案：</strong><br>如上错误提示是因为Docker无法找到Group组信息，docker组有可能被误删除，解决方法有两种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.创建宿主机docker组即可，命令：groupadd docker；</span><br><span class="line">2.&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.socket文件，SocketGroup&#x3D;修改为root也可以；</span><br></pre></td></tr></table></figure><h3 id="2-3-案例3"><a href="#2-3-案例3" class="headerlink" title="2.3 案例3"></a>2.3 案例3</h3><p><strong>案例描述：</strong><br>Docker虚拟化引擎报错信息如下：<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/4c8256fb-0669-4cc5-9381-30b95b45422f.jpg" alt></p><p>如上错误提示是因为Linux操作系统没有更多的Loopback 设备给Docker使用。</p><p><strong>解决方案：</strong><br>创建更多的Loopback设备即可，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i inseq 0 6;do mknod -m 0660 &#x2F;dev&#x2F;loop$i b 7 $i;done</span><br></pre></td></tr></table></figure><h3 id="2-4-案例4"><a href="#2-4-案例4" class="headerlink" title="2.4 案例4"></a>2.4 案例4</h3><p><strong>案例描述：</strong></p><p>Docker命令执行，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to the Docker daemon at unix:</span><br><span class="line">&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure><p>根据如上错误提示，该错误很明显可能是docker没有启动。</p><p><strong>解决方案：</strong></p><p>检测docker进程是否启动，ps -ef|grep docker，如果没有启动，启动Docker即可。</p><p>检测Docker进程存在，但是无法连接，可以重启一下Docker服务，检测一下Sock路径是否正确；<br><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/0e4560e9-3eff-484b-8da3-96e821d660ab.jpg" alt></p><h3 id="2-5-案例5"><a href="#2-5-案例5" class="headerlink" title="2.5 案例5"></a>2.5 案例5</h3><p><strong>案例描述：</strong><br>Docker获取远程镜像，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get https:&#x2F;&#x2F;registry-1.docker.io&#x2F;v2&#x2F;: dial tcp: lookup registry-1.docker.io</span><br></pre></td></tr></table></figure><p><img src="/2019/05/23/2-2-Docker%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99/57f33576-3246-41b0-be58-c5382485a341.png" alt></p><p>该错误表示无法连接远程仓库Docker.io。</p><p><strong>解决方案：</strong></p><p>查看本地是否配置DNS，能否ping通docker.io；</p><p>如果能够ping通，但是下载还是比较慢，可以修改Docker仓库源为国内或者自建的仓库源；</p><p>Docker镜像修改方法，vim /etc/docker/daemon.json，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">at&gt;&#x2F;etc&#x2F;docker&#x2F;daemon.json&lt;&lt;EOF</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">service docker restart</span><br></pre></td></tr></table></figure><h3 id="2-6-案例6"><a href="#2-6-案例6" class="headerlink" title="2.6 案例6"></a>2.6 案例6</h3><p><strong>案例描述：</strong><br>启动Docker容器，报错信息如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;&#x2F;bin&#x2F;bash\&quot;: executable file not found in $PATH&quot;.</span><br></pre></td></tr></table></figure><p>如上报错，通常是由于容器启动时，不支持该命令：/bin/bash。</p><p><strong>解决方案：</strong></p><p>解决方法有如下两种：</p><p>修改启动命令为正确的Docker容器启动命令，例如修改为：/bin/sh或者sleep 99999d等；</p><p>Docker镜像自身问题或者Docker引擎版本比较低导致，可以升级Docker引擎版本服务；</p><h3 id="2-7-案例7"><a href="#2-7-案例7" class="headerlink" title="2.7 案例7"></a>2.7 案例7</h3><p><strong>案例描述：</strong><br>Docker虚拟化运行中，报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br><span class="line">Docker no space left on device</span><br></pre></td></tr></table></figure><p>如上错误，表示Docker虚拟化引擎平台，没有多月的空间设备所使用，证明容器磁盘不足或者物理机磁盘不足。</p><p><strong>解决方案：</strong></p><p>手工删除Docker容器占用数据比较大的目录；</p><p>或者通过docker system prune自动删除一些日志目录，此种方法会停止所有容器；</p><p>或者临时增加Docker存储硬盘等；</p><h3 id="2-8-案例8"><a href="#2-8-案例8" class="headerlink" title="2.8 案例8"></a>2.8 案例8</h3><p><strong>案例描述：</strong><br>Docker push上传镜像至本地仓库报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [106.12.133.186:5000&#x2F;busybox] Get https:&#x2F;&#x2F;106.12.133.186:5000&#x2F;v1&#x2F;_ping: http: server gave HTTP response to HTTPS client</span><br></pre></td></tr></table></figure><p>根据如上错误提示，错误是由于客户端采用https，docker registry未采用https服务所致。一种处理方式是把客户对地址“106.12.133.186:5000”请求改为http。</p><p><strong>解决方案：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件。</span><br><span class="line">在文件中写入：&#123; &quot;insecure-registries&quot;:[&quot;106.12.133.186:5000&quot;] &#125; 。</span><br></pre></td></tr></table></figure><p>保存退出后，重启docker服务，问题即可解决。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-Docker安装与部署</title>
      <link href="/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/05/18/2-Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-系统要求"><a href="#1-系统要求" class="headerlink" title="1 系统要求"></a>1 系统要求</h2><p>Docker 需要安装在 CentOS 7 64 位的平台，并且内核版本不低于 3.10. CentOS 7.× 满足要求的最低内核版本要求，但由于 CentOS 7 内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。所以建议大家升级到最新的 CentOS 版本,并且内核也更新到最新的稳定版本.</p><a id="more"></a><p><strong>centos-extras</strong> 库必须启用。默认情况下，此存储库已启用，但是如果将其禁用，则需要<strong>重启启用它</strong>。（自行搜索）</p><p>overlay2 建议使用存储驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r # 可查看内核版本</span><br></pre></td></tr></table></figure><h2 id="2-卸载旧版本"><a href="#2-卸载旧版本" class="headerlink" title="2 卸载旧版本"></a>2 卸载旧版本</h2><p>旧版本的Docker被称为 docker 或 docker-engine。如果已安装这些，请卸载它们及相关的依赖项、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line">如果 yum报告没有安装这些软件包，则可以了、</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F; 保留包括图像、容器、卷和网络在内的内容。现在调用Docker CE包  docker-ce。</span><br></pre></td></tr></table></figure><h2 id="3-安裝-Docker"><a href="#3-安裝-Docker" class="headerlink" title="3 安裝 Docker"></a>3 安裝 Docker</h2><p>参考0-Docker</p><p><strong>Docker 通过运行 hello-world 映像验证是否正确安装。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>此命令下载测试镜像并在容器中运行它。当容器运行时，它打印一条信息消息并退出。如果你没有配置镜像加速器的话,运行 hello-world 命令来验证也是不会成功的.因为国内网络的原因,无法下载测试镜像,更别说运行测试镜像了,<font color="red">配置镜像加速器–参考0</font></p><h2 id="4-查看当前Docker版本"><a href="#4-查看当前Docker版本" class="headerlink" title="4 查看当前Docker版本"></a>4 查看当前Docker版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br><span class="line"></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO学习</title>
      <link href="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一、高并发互联网应用架构设计"><a href="#一、高并发互联网应用架构设计" class="headerlink" title="一、高并发互联网应用架构设计"></a>一、高并发互联网应用架构设计</h2><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/428003e0-81bd-46c5-9fd9-a97c25281220.jpg" alt></p><a id="more"></a><h3 id="1-架构的演变过程"><a href="#1-架构的演变过程" class="headerlink" title="1 架构的演变过程"></a>1 架构的演变过程</h3><h4 id="1-1-单一应用架构"><a href="#1-1-单一应用架构" class="headerlink" title="1.1 单一应用架构"></a>1.1 单一应用架构</h4><p>简单，维护成本高<br>ORM</p><h4 id="1-2-垂直应用架构"><a href="#1-2-垂直应用架构" class="headerlink" title="1.2 垂直应用架构"></a>1.2 垂直应用架构</h4><p>各司其职<br>MVC</p><h4 id="1-3-分布式服务架构"><a href="#1-3-分布式服务架构" class="headerlink" title="1.3 分布式服务架构"></a>1.3 分布式服务架构</h4><p>Cross JVM | Cross Machine<br>RPC (Remote Procedure Call)</p><h4 id="1-4-流动计算架构"><a href="#1-4-流动计算架构" class="headerlink" title="1.4 流动计算架构"></a>1.4 流动计算架构</h4><p>资源调度和服务治理<br>SOA (Service-Oriented Architecture)</p><h3 id="2-高并发网站的设计原则"><a href="#2-高并发网站的设计原则" class="headerlink" title="2 高并发网站的设计原则"></a>2 高并发网站的设计原则</h3><ol><li>X轴：硬件(水平扩展，比性能的垂直提升成本低-摩尔定律)、应用水平复制(应用无状态) 水平扩展</li><li>Y轴：硬件、业务垂直拆分 各司其职(泳道设计)</li><li>Z轴：X和Y轴打包之后 物理隔离</li></ol><h3 id="3-如何设计高效、高性能的应用服务？"><a href="#3-如何设计高效、高性能的应用服务？" class="headerlink" title="3 如何设计高效、高性能的应用服务？"></a>3 如何设计高效、高性能的应用服务？</h3><p>在分布式服务架构中，我们需要Cross JVM 或者 Cross Machine 传输数据，所以高效的RPC通信木星(Socket+IO) 是设计关键</p><h2 id="二、Java中网络-IO-模型"><a href="#二、Java中网络-IO-模型" class="headerlink" title="二、Java中网络(IO)模型"></a>二、Java中网络(IO)模型</h2><h3 id="1-IO模型分类"><a href="#1-IO模型分类" class="headerlink" title="1 IO模型分类"></a>1 IO模型分类</h3><h4 id="1-1-BIO"><a href="#1-1-BIO" class="headerlink" title="1.1 BIO"></a>1.1 BIO</h4><p>传统IO 或者 Blocking IO<br>特点：面向流 Input | Output</p><h4 id="1-2-NIO"><a href="#1-2-NIO" class="headerlink" title="1.2 NIO"></a>1.2 NIO</h4><p>New IO 或者 Non Blocking IO<br>特点：面向缓冲区 Buffer(基于通道)</p><h4 id="1-3-AIO-Async-Non-Blocking-IO"><a href="#1-3-AIO-Async-Non-Blocking-IO" class="headerlink" title="1.3 AIO(Async Non Blocking IO)"></a>1.3 AIO(Async Non Blocking IO)</h4><h3 id="2-BIO"><a href="#2-BIO" class="headerlink" title="2 BIO"></a>2 BIO</h3><ol><li>方向————输入、输出流(InputStream | OutputStream)</li><li>类型————字节、字符流(Reader | Writer)</li><li>功能————节点、过滤流(BufferedInputStream |BufferedOutputStream)</li></ol><h3 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3 NIO"></a>3 NIO</h3><h4 id="3-1-Channel"><a href="#3-1-Channel" class="headerlink" title="3.1 Channel"></a>3.1 Channel</h4><p>通道、双向、可读可写<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2ffb3a8b-93fd-4ee4-bb66-9e61078a565c.jpg" alt></p><p>Channel的主要实现类有：</p><ul><li>FileChannel       —-文件IO</li><li>DatagramChannel   —-UDP</li><li>SocketChannel     —-TCP Client</li><li>ServerSocketChannel —-TCP Server</li></ul><h4 id="3-2-Buffer"><a href="#3-2-Buffer" class="headerlink" title="3.2 Buffer"></a>3.2 Buffer</h4><p>缓冲区<br>Buffer的主要实现类有：</p><ul><li>除boolean外的其余七种基本类型(ByteBuffer、ShortBuffer、IntBuffer等)</li></ul><h4 id="3-3-Selector"><a href="#3-3-Selector" class="headerlink" title="3.3 Selector"></a>3.3 Selector</h4><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/a3cad6d4-ec4c-46c6-b8e7-1374afcf5482.jpg" alt></p><h3 id="4-NIO-Buffer详解"><a href="#4-NIO-Buffer详解" class="headerlink" title="4 NIO Buffer详解"></a>4 NIO Buffer详解</h3><p>一个用于特定基本类型的数据容器，除数据内容外，还包含以下属性：</p><ol><li>capacity 缓冲区大小，常量不可变</li><li>limit 缓冲区允许读写操作的最大范围</li><li>position 缓冲区下一个可读写元素的索引</li></ol><p><strong>注：所有可操作的数据在position和limit之间</strong><br>操作图示：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3cbb0329-a79a-4926-903a-3f148f94acb4.jpg" alt></p><p>示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5ac188f8-dc23-4ab1-973d-3135401f0371.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/610fb173-c877-443f-b39c-224a341cdd5d.png" alt></p><p>测试结果：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/ce63f053-3583-46d2-b91a-fa4e5faa1bbf.jpg" alt></p><h3 id="5-NIO-IO操作-文件拷贝"><a href="#5-NIO-IO操作-文件拷贝" class="headerlink" title="5 NIO IO操作(文件拷贝)"></a>5 NIO IO操作(文件拷贝)</h3><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/49016de5-5e38-4d09-a159-7efc2b832248.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/2bc74fd6-297d-4d5c-b7df-009a7c86a5ca.png" alt></p><h3 id="6-BIO-网络编程"><a href="#6-BIO-网络编程" class="headerlink" title="6 BIO 网络编程"></a>6 BIO 网络编程</h3><h4 id="6-1-服务器：ServerSocket"><a href="#6-1-服务器：ServerSocket" class="headerlink" title="6.1 服务器：ServerSocket"></a>6.1 服务器：ServerSocket</h4><ol><li>初始化服务器ServerSocket，绑定监听端口</li><li>等待客户端连接 ServerSocket.accept();</li><li>处理请求/响应 Socket.getInputStream(); / socket.getOutputStream();</li><li>关闭资源</li></ol><h4 id="6-2-客户端：Socket"><a href="#6-2-客户端：Socket" class="headerlink" title="6.2 客户端：Socket"></a>6.2 客户端：Socket</h4><ol><li>初始化客户端 Socket, 绑定服务器IP/端口</li><li>发起请求/获取响应 socket.getOutputStream(); /socket.getInputStream();</li><li>关闭资源</li></ol><p>客户端示例代码:<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bbfb9d5c-9766-4fe3-b51f-3500cd3356ed.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c36c47b4-7966-40b2-a434-a39c8667e2d8.jpg" alt></p><p>服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/db0236b3-4aea-47c6-a98e-f4c5da6c6a2b.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8bbcb471-fb02-4bc9-ae4c-8f247cb24bbb.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/18da21e4-9afa-4e04-be65-29c3c41596e7.jpg" alt></p><ol><li><strong>特点:</strong> accept() 是一个阻塞方法，当有客户端连接时，返回Socket对象，通过Socket对象的InputStream()或者 OutputStream() 接受请求发送响应结果。单请求服务器模型只能处理一个客户端的请求。</li><li><strong>缺点:</strong> 服务器必须能够处理多个客户端的请求和响应</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/53c62143-1d4a-4bdf-b96e-b98298b6d3f5.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/52bb442e-2f83-4bd4-a439-fd2067698169.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/78634985-5e0e-4fc7-a847-07ec068d69ae.png" alt></p><ol><li><strong>特点:</strong> 通过循环可以不断的接受客户端请求</li><li><strong>缺点:</strong> 请求的接受和IO处理在同一个线程中，客户端请求本质上是串行处理，无法支持高并发。</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/1f73e9db-1e95-49c7-b31c-b679f600d0b7.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/3c1cd1d2-7b7b-4e09-bacc-caab7b0638c5.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/5b2a809a-51e3-4776-802d-9acbc0d6063e.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/69989ce9-07a8-4342-b41b-5a4d44b897e0.png" alt></p><ol><li><strong>特点:</strong> 请求转发和IO处理，主线程只负责接受请求，IO的处理通过子线程完成。实现服务器的高性能</li><li><strong>缺点:</strong> 缺乏弹性伸缩能力，当客户端的访问量增加后，服务器的线程个数和客户端并发访问数量1:1正比关系，线程是宝贵的系统资源，数量过多，会造成系统性能急剧下降，导致服务器“宕机”</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/bc55ffeb-ac01-4ddb-a223-ff3e4a57b0ab.jpg" alt></p><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/aa445693-1c30-4853-a53c-3b4d37fb14aa.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/50c35557-c48e-4dd3-b338-fe76d919f54b.png" alt></p><ol><li><strong>特点:</strong> 通过线程池有效的管理线程，避免线程的重复创建、销毁而导致的系统资源过渡开销</li><li><strong>缺点:</strong> 限制了线程的数量，当有大量的并发请求时，超过最大线程数量的请求只能等待，直到线程池中有空闲的线程可以使用。对于BIO，当你发送一个请求的时候，你必须等待直到你获得返回结果。在服务端，这个意味着，一个线程同一时间最多只能和一个传入的连接相关联（直到这个连接被关闭)。<strong>先开线程，在线程中可能没有就绪的IO，导致线程的利用率不高。</strong></li></ol><h3 id="7-NIO-网络编程"><a href="#7-NIO-网络编程" class="headerlink" title="7 NIO 网络编程"></a>7 NIO 网络编程</h3><ul><li><strong>使用NIO API，替换BIO的多请求多线程版网络模型</strong></li></ul><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8db4046c-68c2-431c-91d3-ffcd02f72d11.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/92f0ac56-8ad0-456d-88d4-1515df43a651.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8080c448-9917-4193-aa79-f9f393884649.png" alt></p><ol><li><strong>特点:</strong> 使用NIO的API，通过面向通道的编程方式替换了BIO的编程模型</li><li><strong>缺点:</strong> 此模型跟BIO编程模型本质上没有区别(API差异)，实际上也没有解决IO的阻塞问题</li></ol><ul><li><strong>Selector</strong></li></ul><p>在NIO使用Channel管理所有的IO操作，<strong>Selector</strong>用于管理通道（注：需确保通道的操作都是非阻塞的），Channel和Selector配合使用</p><ol><li>通道需注册到选择器中（通道+关注的事件类型+附件信息）</li><li>选择器中的通道必须是非阻塞的</li><li>常用的事件类型<br>a. SelectionKey.OP_CONNECT 连接就绪<br>b. SelectionKey.OP_ACCEPT 接受就绪<br>c. SelctionKey.OP_READ 读就绪</li></ol><p><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b26ac541-513f-4b25-adaa-f94cb240c700.jpg" alt></p><ul><li><p>NIO服务器示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/15810dee-7cc1-429e-b4b7-a4f0d829fd3b.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/93b80458-99c0-4549-ac2a-f250076da709.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/c43ce081-8600-4fae-8794-36245c068850.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/8d05f649-64ab-4946-ab58-b8de71bfe6f1.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/322d23d0-d305-4dbc-b80d-ea44129accf5.png" alt></p></li><li><p>NIO客户端示例代码：<br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/b76038c5-9207-4c33-8bc2-58e724a01935.jpg" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/23afa843-b264-4730-b742-ed428cc6420c.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/0eb2fee4-d836-469f-8d88-e62cb7557156.png" alt><br><img src="/2019/05/15/NIO%E5%AD%A6%E4%B9%A0/9cebd7f5-558c-4fa3-8f11-183f7206899b.png" alt></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> NIO </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Docker缘由</title>
      <link href="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/"/>
      <url>/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>作者：雪雁<br><a href="https://www.cnblogs.com/codelove/p/10030439.html" target="_blank" rel="noopener">文章转载出自这里</a>：<a href="https://www.cnblogs.com/codelove/" target="_blank" rel="noopener">https://www.cnblogs.com/codelove/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着生产力的发展尤其是弹性架构的广泛应用（如微服务），许多一流开发者都将应用托管到了应用容器上，如Google、微软、亚马逊、阿里、京东、新浪等等。</p><a id="more"></a><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093206616-399407280.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093217472-1718656903.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093230803-632908603.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093244576-449593766.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093301329-915864692.png" alt></p><p>从未来的发展方向来看，容器引擎将会越来越成为主流，哪怕不是弹性架构，托管到应用容器也将是一种趋势——因为更低的开发运维和托管成本以及对服务器资源的优化配置，而且未来一个很大的趋势是————<strong>无服务器计算服务</strong></p><p>因为相对于软件、硬件在本地设备上的分裂，云计算的一大特性就是将服务构建在云上，供多种设备同时无缝调用。但事实上，云服务在发展的过程中还没能实现<strong>共融共通</strong>的理想————比如，各家的云服务是相对割裂的，开发者基于Google云服务构建的软件拿到亚马逊的AWS上也许就不能用了，阿里云的应用迁移到腾讯云可能就存在问题了；在任务执行层面，为防止互相干扰，云服务厂商在同一台服务器上执行多个任务时也会将他们隔离进行、很明显，这样的实例情况和云服务器的初始理念相去甚远。而利用容器技术，软件可以快速在各类云服务和基础设施上转换。而且，当割裂问题被解决后，软件也有希望在瞬间获取大量的计算能力。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093417505-465374977.png" alt></p><p>而Docker,就是容器引擎中的佼佼者，并且已经得到了广泛的实践和应用。有了Docker之后，软件的开发工作将会变得更加容易。如：开发者在笔记本电脑上写完一个软件后，可以将它转移到云服务上运行而无需做出更改；无论是自己的服务器、数据中心还是Google、微软、阿里云的云计算服务器，开发人员都可以按自己的想法在任何基础设施之间转移自己的软件。这也是未来的一个愿景——————<strong>机器和基础设施之间是可以互相替代的，整个互联网就是一个巨大的计算机</strong>。</p><p>Docker是如此的令人向往和引人深入，但是在国内，开发者普遍迁移到云端基本上也都是只用到了虚拟机等基础设施，其实大家都听过Docker,但是有一些偏见：</p><ul><li>缺乏完整的系统的教程和实践。开发者普遍认为使用Docker很麻烦，只有大公司用，门槛高‘</li><li>云端容器服务产品用户体验不多，对于初学者门槛太高——————此处是指消化这列概念和理念，并且能够掌握和可控。</li><li>对容器服务的认知还不够，对它的好处及吸引之处不太了解。</li><li>认为对现有系统、架构改造太大，成本太高；</li><li>认为Docker只是一种单纯的相对先进的技术，并不能给现有的开发带来什么概念；</li></ul><h2 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1 什么是Docker"></a>1 什么是Docker</h2><p><strong>Docker</strong>是一个开源的应用容器引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在本地编译通过的容器可以批量的在生产环境中部署，包括VMs(虚拟机)、bare metal、OpenStack集群和其他的基础应用平台。</p><p>简单理解，Docker类似于集装箱，各式各样的货物，经过集装箱的标准化进行托管，而集装箱和集装箱之间没有影响。也就是说，Docker平台就是一个软件集装箱化平台，这就意味着我们可以构建应用程序，将其依赖关系一起打包到一个容器中，然后这容器就很容易运送到其他的机器上进行运行，而且非常易于装载、复制、移除，非常适合软件弹性架构。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093811704-1643592196.png" alt></p><p>因此，就像船只、火车或卡车运输集装箱而不论其内部的货物一样，软件容器就充当着 软件部署 的标准单元，其中可以包含不同的代码和依赖项。按照这种方式的容器化软件。开发人员和IT专业人员只需要进行极少修改或者不修改，即可将其部署到不同的环境。</p><p>总而言这，Docker是一个开放平台，使开发人员和管理员可以在称为容器的松散隔离的环境中构建镜像、交付和运行分布式应用程序。以便在开发、QA和生产环境之间进行高效的应用程序生命周期管理。</p><h2 id="2-Docker和虚拟机的区别"><a href="#2-Docker和虚拟机的区别" class="headerlink" title="2 Docker和虚拟机的区别"></a>2 Docker和虚拟机的区别</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093906502-569967575.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093915205-139200956.png" alt><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128093934953-2128627412.png" alt></p><p>如上图所示，由于容器所需的资源要少很多（例如，他们不需要一个完整的OS），所以它们易于部署且可以快速启动、这使得你能够具有更高部署密度。即<strong>允许在同一硬件单元上运行更多服务，从而降低了成本。</strong></p><p>在同一内核上运行的时候，你获得的隔离比VM少。</p><p><font color="red">镜像的主要目标是使环境（依赖项）在不同的部署中保持不变。</font>，即可以在计算机上调试它，然后将其部署到保证具有相同环境的另一台计算机上。</p><p>借助容器镜像，可打包应用或者服务 并采用可靠且可重现的方式对其进行部署。可以说Docker不只是一种技术，还是一种原理和过程。</p><p>在使用Docker之前，经常听到，“这个问题在开发环境是正常的！”。而在使用Docker后，你不会听到开发人员说：“为什么它能在我的计算机上使用却不能用在生产中？”。开发人员只需要说 “它在Docker上运行”，因为打包的Docker应用程序可在任何支持的Docker环境上执行，而且它在所有部署目标（开发、QA、暂停和生产）上都按期运行。</p><h2 id="3-基本概念"><a href="#3-基本概念" class="headerlink" title="3 基本概念"></a>3 基本概念</h2><h3 id="3-1-镜像：一个特殊的文件系统"><a href="#3-1-镜像：一个特殊的文件系统" class="headerlink" title="3.1 镜像：一个特殊的文件系统"></a>3.1 镜像：一个特殊的文件系统</h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂在root文件系统为其提供用户空间支持。而Docker镜像相当于是一个root文件系统。</p><p><strong>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（匿名卷、环境变量、用户等）。</strong></p><p>镜像是不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时。就充分利用 <strong>Union FS</strong>技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如：删除前一层文件的操作，实际上不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像时，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变得更为容易，甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的容器，构建新的镜像。</p><h3 id="3-2-容器：镜像运行时的实体"><a href="#3-2-容器：镜像运行时的实体" class="headerlink" title="3.2 容器：镜像运行时的实体"></a>3.2 容器：镜像运行时的实体</h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中 类 和 实例一样，镜像时静态的定义，容器是进行运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己独立的命名空间，前面说过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生命周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按着Docker最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态变化。</p><p>所有文件的写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生命周期独立于容器，容器消亡，数据卷不会消亡。因此使用数据卷后，容器可以随意删除、重新run，数据却不会丢失。</p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094117580-274999612.png" alt></p><p><strong><font color="red">注意：</font></strong><br>容器在整个应用程序生命周期工作流中提供以下优点：隔离性、可移植性、灵活性、可伸缩性和可控性。最重要的优点是可在开发和运营之间提供隔离。</p><h3 id="3-3-仓库：集中存放镜像文件的地方"><a href="#3-3-仓库：集中存放镜像文件的地方" class="headerlink" title="3.3 仓库：集中存放镜像文件的地方"></a>3.3 仓库：集中存放镜像文件的地方</h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务。<strong>Docker Registry</strong>就是这样的服务。</p><p>一个Docker Registry 中可以包含多个仓库（Repository）:每个仓库可以包含多个标签（Tag）;每个标签对应一个镜像。</p><p>所以说，镜像仓库是Docker用来集中存放镜像文件的地方，类似于我们之前的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件那个版本的镜像。如果不给出标签，将以latest作为默认标签。</p><p>这里补充一下：Docker Registry公开服务和私有 Docker Registry 的概念。</p><p>一般这类公共服务允许用户免费上传、下载公开镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常用的Registry 公开服务是官方的 <a href="hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>在国内访问Docker Hub可能比较慢，国内有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了公开服务外，用户还可以在本地搭建私有Docker Registry。Docker官方提供了 Docker Registry 镜像，可以直接使用作为私有Registry服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API的服务端实现，足以支持Docker命令，不影响使用，但不含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h2 id="4-Docker的主要应用场景"><a href="#4-Docker的主要应用场景" class="headerlink" title="4 Docker的主要应用场景"></a>4 Docker的主要应用场景</h2><h3 id="4-1-简化配置"><a href="#4-1-简化配置" class="headerlink" title="4.1 简化配置"></a>4.1 简化配置</h3><p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p><p>简单来说，容器镜像打包完成后，它就是个独立的个体了，丢到哪里都能跑，而无需针对各个平台去独立配置。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094246244-759574629.png" alt></p><h3 id="4-2-代码流水线（Code-Pipeline）管理"><a href="#4-2-代码流水线（Code-Pipeline）管理" class="headerlink" title="4.2 代码流水线（Code Pipeline）管理"></a>4.2 代码流水线（Code Pipeline）管理</h3><p>前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094322089-159857776.png" alt></p><h3 id="4-3-提高开发效率"><a href="#4-3-提高开发效率" class="headerlink" title="4.3 提高开发效率"></a>4.3 提高开发效率</h3><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想要快速搭建开发环境。</p><p>使用Docker非常简单的就能实现这两点，哪怕是开发环境的机器配置一般的情况下搭建多个生产服务应用。一台一般配置服务器或者开发机器也能轻松的跑起多个Docker应用，而无需额外增加机器配置。因为Docker有个非常NB的特性，<strong>拥有虚拟化的特性</strong>，而几乎没有额外的开销。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094410700-1435124978.png" alt></p><h3 id="4-4-隔离应用"><a href="#4-4-隔离应用" class="headerlink" title="4.4 隔离应用"></a>4.4 隔离应用</h3><p>很多情况下，我们需要在一台服务器上运行多个不同的应用，比如上面提到的提高开发效率的场景等。</p><p>考虑三点：一是因为要降低成本而进行服务器整合，二是讲一个整体式的应用拆分成松耦合的单个服务（如微服务架构），三是还需要考虑应用之间的兼容性。而对于Docker来说，支持起来非常简单。同一台机器，可以同时运行N个Docker Web应用，托管到不同的Web服务器（Kestrel、Nginx、Tomcat），而无需担心他们会搞起3Q大战，也不用担心开发机器跑步起来。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094456537-87357208.png" alt></p><h3 id="4-5-整合服务器"><a href="#4-5-整合服务器" class="headerlink" title="4.5 整合服务器"></a>4.5 整合服务器</h3><p>虚拟机可以整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p><p>这意味着资源得到更有效的利用——————可以做更多的衣服，而且没有边角料，成本更低。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094534267-1497649789.png" alt></p><h3 id="4-6-调试能力"><a href="#4-6-调试能力" class="headerlink" title="4.6 调试能力"></a>4.6 调试能力</h3><p>Docker提供很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多功能，包含可以设置容器检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094617391-1947396056.png" alt></p><h3 id="4-7-多租户环境"><a href="#4-7-多租户环境" class="headerlink" title="4.7 多租户环境"></a>4.7 多租户环境</h3><p>在多租户的应用中，它可以避免关键应用的重写。比如IoT(物联网)的应用中，开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间、也浪费金钱。</p><p>使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。</p><p>就如同我们现在写了一个不支持多租户的业务程序，而实际的业务中经常会出现需要支持多租户或者有新客户需要使用的场景，这时们通常的简单是——————部署一套新的代码。当站点达到一定量的适合，要么重写程序，要么维护人员Game Over。</p><h3 id="4-8-快速部署"><a href="#4-8-快速部署" class="headerlink" title="4.8 快速部署"></a>4.8 快速部署</h3><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。虚拟化技术（Virtualization）将这个时间缩短到了分钟级别。而Docker通过为进程仅仅创建一个容器而无需启动一个操作系统，再次将这个过程缩短到了秒级。</p><p>你可以在服务器中或云端创建销毁资源而无需担心重新启动带来的开销。通常情况下，服务器的资源利用率只有30%，而通过使用Docker并进行有效的资源分配可以提高资源的利用率。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094717810-819940111.png" alt></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094748866-356935721.png" alt></p><p>Docker 带来的敏捷性（响应速度和灵活性）吸引了越来越多的开发者。他们不仅能知道容器内部到底跑了什么，也能进一步理解 Docker 如何加速了软件开发进程。另外，41% 的用户表示应用的可移植性是他们决定使用 Docker 的关键因素。</p><p><strong>通过 DevOps 的实践，Docker 正在给应用交付带来很多可以量化的提升</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094834979-29905994.png" alt></p><p>大约一半的受访者表示已经采用了持续集成（CI）和 DevOps，并且希望把这些实战经验应用到生产环境的持续交付中。剩下的受访者则准备尽快跟上步伐，尽快尝试 DevOps 和持续集成。另外，据调查显示，用户使用 Docker 发布应用的频率平均提升了 13 倍。</p><p><strong>Docker 对混合云策略至关重要，它使得用户可以根据需求自由选择私有和公有环境</strong><br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094910142-643670153.png" alt></p><p>通过容器来交付的应用可以在任何基础设施之上灵活迁移，同时这些基础设施又可以提供不同层次的应用管理方式，而当业务在多个服务供应商之中寻求混合云或全云模式时，又可以完美避免被平台捆绑。</p><p>对于按需部署或部署到云环境，Docker 提供了独一无二的选择。 80% 的用户表示 Docker 已经成为他们云策略的一部分，超过 35% 的用户使用 Docker 来避免被云服务供应商绑定。</p><p><strong>Docker 实现了微服务架构，也让遗留的单体应用转变为现代应用</strong></p><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128094948673-1019599700.png" alt></p><p>Docker 使得微服务架构的快速发展成为可能，同时它也将传统的业务迁移到容器环境中，以此使得应用程序变得更加可移植。<strong>使用微服务架构进行交付是 Docker 的关键优势！</strong></p><h2 id="5-Docker改变了什么？"><a href="#5-Docker改变了什么？" class="headerlink" title="5 Docker改变了什么？"></a>5 Docker改变了什么？</h2><ul><li><p>Docker改变了云服务，使云服务的共融共通的理想逐步成为了可能。并且Docker 已经是云策略的一部分，许多开发者正在计划使用 Docker 将业务迁移到云端。另外，为了避免被云服务供应商绑定，Docker成为很多开发者的首选。</p></li><li><p>Docker改变了产品交付，为产品的整个生命周期提供了一整套的解决方案和流程。</p></li><li><p>Docker改变了开发方式，提供了简化的环境配置、封装的运行环境以及统一的环境。并且提供了快速部署的方式。</p></li><li><p>Docker改变了测试，多版本测试变得极为方便，快速构建测试环境也变得更加简单并且无需开发人员干预或者搭建。</p></li><li><p>Docker改变了运维，环境的一致性让运维变得更加简单，同时热更新的支持让运维不再需要半夜加班部署更新，更新可以随时进行。当出现重大问题时，还能快速回滚到指定版本。</p></li><li><p>Docker改变了架构，自动化扩容支持让架构变得更加简单，分布式系统也更加易于搭建和支持。同时遗留的单体应用也很易于转变为现代应用。</p></li></ul><p>总之，在某种程度上，Docker改变了产品开发中的一些游戏规则。虽然Docker是一项技术，但是它也带来了新的思维，新的流程和工作方法，Docker在推动行业的发展，Docker已经在改变世界，并且在逐步的变为事实……<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181128095105560-528324521.png" alt></p><h2 id="6-Docker持续开发工作流"><a href="#6-Docker持续开发工作流" class="headerlink" title="6  Docker持续开发工作流"></a>6  Docker持续开发工作流</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203093658359-1691324108.png" alt></p><h2 id="7-DockerFile"><a href="#7-DockerFile" class="headerlink" title="7 DockerFile"></a>7 DockerFile</h2><p><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094045768-1316009773.png" alt></p><p>虽然我们可以通过docker commit命令来手动创建镜像，但是通过Dockerfile文件，可以帮助我们自动创建镜像，并且能够自定义创建过程。本质上，Dockerfile就是由一系列<strong>命令</strong>和<strong>参数</strong>构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。它简化了从头到尾的构建流程并极大的简化了部署工作。使用dockerfile构建镜像有以下好处：</p><ul><li><p>像编程一样构建镜像，支持分层构建以及缓存；</p></li><li><p>可以快速而精确地重新创建镜像以便于维护和升级；</p></li><li><p>便于持续集成；</p></li><li><p>可以在任何地方快速构建镜像</p></li></ul><h3 id="7-1-Dockerfile-指令"><a href="#7-1-Dockerfile-指令" class="headerlink" title="7.1 Dockerfile 指令"></a>7.1 Dockerfile 指令</h3><p>Dockerfile 指令为 Docker 引擎提供了创建容器映像所需的步骤。这些指令按顺序逐一执行。</p><h4 id="7-1-1-FROM"><a href="#7-1-1-FROM" class="headerlink" title="7.1.1 FROM"></a>7.1.1 FROM</h4><p>ROM 指令用于设置在新镜像创建过程期间将使用的容器映像。<br>格式：FROM<br>示例：<br>FROM nginx</p><h4 id="7-1-2-RUN"><a href="#7-1-2-RUN" class="headerlink" title="7.1.2 RUN"></a>7.1.2 RUN</h4><p>RUN 指令指定将要运行并捕获到新容器映像中的命令。 这些命令包括安装软件、创建文件和目录，以及创建环境配置等。<br>格式：<br>RUN [“”, “”, “”]<br>RUN<br>示例：<br>RUN apt-get update<br>RUN mkdir -p /usr/src/redis<br>RUN apt-get update &amp;&amp; apt-get install -y libgdiplus<br>RUN [“apt-get”,”install”,”-y”,”nginx”]</p><p>注意：<font color="red">每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。使用换行符时，可能会遇到一些问题，具体可以参阅下节的转义字符</font>。</p><h4 id="7-1-3-COPY"><a href="#7-1-3-COPY" class="headerlink" title="7.1.3 COPY"></a>7.1.3 COPY</h4><p>COPY 指令将文件和目录复制到容器的文件系统。文件和目录需位于相对于 Dockerfile 的路径中。<br>式：<br>COPY<br>如果源或目标包含空格，请将路径括在方括号和双引号中。<br>COPY [“”, “”]<br>示例：<br>COPY . .<br>COPY nginx.conf /etc/nginx/nginx.conf<br>COPY . /usr/share/nginx/html<br>COPY hom* /mydir/</p><h4 id="7-1-4-ADD"><a href="#7-1-4-ADD" class="headerlink" title="7.1.4 ADD"></a>7.1.4 ADD</h4><p>ADD 指令与 COPY 指令非常类似，但它包含更多功能。除了将文件从主机复制到容器映像，ADD 指令还可以使用 URL 规范从远程位置复制文件。<br>格式：<br>ADD<source> <destination><br>示例：<br>ADD <a href="https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe" target="_blank" rel="noopener">https://www.python.org/ftp/python/3.5.1/python-3.5.1.exe</a> /temp/python-3.5.1.exe<br>此示例会将 Python for Windows下载到容器映像的 c:\temp 目录。</destination></p><h4 id="7-1-5-WORKDIR"><a href="#7-1-5-WORKDIR" class="headerlink" title="7.1.5 WORKDIR"></a>7.1.5 WORKDIR</h4><p>WORKDIR 指令用于为其他 Dockerfile 指令（如 RUN、CMD）设置一个工作目录，并且还设置用于运行容器映像实例的工作目录。<br>格式：<br>WORKDIR<br>示例：<br>WORKDIR /app</p><h4 id="7-1-6-CMD"><a href="#7-1-6-CMD" class="headerlink" title="7.1.6 CMD"></a>7.1.6 CMD</h4><p>CMD指令用于设置部署容器映像的实例时要运行的默认命令。例如，如果该容器将承载 NGINX Web 服务器，则 CMD 可能包括用于启动Web服务器的指令，如 nginx.exe。 如果 Dockerfile 中指定了多个CMD 指令，只会计算最后一个指令。<br>格式：<br>CMD [“&lt;executable”, “<br>CMD<br>示例：<br>CMD [“c:\Apache24\bin\httpd.exe”, “-w”]<br>CMD c:\Apache24\bin\httpd.exe -w</p><h4 id="7-1-7-ENTRYPOINT"><a href="#7-1-7-ENTRYPOINT" class="headerlink" title="7.1.7 ENTRYPOINT"></a>7.1.7 ENTRYPOINT</h4><p>配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个ENTRYPOINT，当指定多个时，只有最后一个起效。<br>格式：<br>ENTRYPOINT [“”, “”]<br>示例：<br>ENTRYPOINT [“dotnet”, “Magicodes.Admin.Web.Host.dll”]</p><h4 id="7-1-8-ENV"><a href="#7-1-8-ENV" class="headerlink" title="7.1.8 ENV"></a>7.1.8 ENV</h4><p>ENV命令用于设置环境变量。这些变量以”key=value”的形式存在，并可以在容器内被脚本或者程序调用。这个机制给在容器中运行应用带来了极大的便利。<br>格式：<br>ENV==…<br>示例：<br>ENV VERSION=1.0 DEBUG=on <br>NAME=”Magicodes”</p><h4 id="7-1-9-EXPOSE"><a href="#7-1-9-EXPOSE" class="headerlink" title="7.1.9 EXPOSE"></a>7.1.9 EXPOSE</h4><p>EXPOSE用来指定端口，使容器内的应用可以通过端口和外界交互。<br>格式：<br>EXPOSE<br>示例：<br>EXPOSE 80<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094342684-400475059.png" alt></p><h2 id="8-优化"><a href="#8-优化" class="headerlink" title="8 优化"></a>8 优化</h2><p>有几点值得注意的是：</p><ol><li><p>不能忽视dockerfile的优化，通常情况下，我们可以忽略那些细小的优化，但是我们需要知道优化的原理，为什么要优化</p></li><li><p>不能为了优化而优化。镜像的构建过程视业务情况情况不同，指令就有多到少的区别，在很多情况下，我们先要以满足业务目标为准，而不是镜像层数。如果需要减少镜像的层数，我们一定要选择合适的基础镜像，或者创建符合我们需要的基础镜像。</p></li></ol><p>优化准则：</p><ul><li><p>选择合适的基础镜像</p><p>这点相对最为重要。为什么这么说，我们结合现实社会也可以看到，在大部分情况下，一个人一生的成就更多的是看出身。很多情况下，基因和出身决定了你的高度和终点，这点拿到技术层面来说，也是有很大道理的，因此我们需要选择合适的父母——一个合适的镜像。</p><p>一个合适的基础镜像是指能满足运行应用所需要的最小的镜像，理论上是能用小的就不要用大的，能用轻量的就不要用重量级的，能用性能好的就不要用性能差的。这里有时候还需要考虑那些能够减少我们构建层数的基础镜像。</p></li><li><p>优化指令顺序</p><p>Docker会缓存Dockerfile中尚未更改的所有步骤，但是，如果更改任何指令，将重做其后的所有步骤。也就是指令3有变动，那么4、5、6就会重做。因此，我们需要将最不可能产生更改的指令放在前面，按照这个顺序来编写dockerfile指令。这样，在构建过程中，就可以节省很多时间。比如，我们可以把WORKDIR、ENV等命令放前面，COPY、ADD放后面。</p></li><li><p>合并指令</p><p>前面其实我们提到过这点，甚至还特地讲到了转义字符，其实主要是为此服务。前面我们说到了，每一个指令都会创建一层，并构成新的镜像。当运行多个指令时，会产生一些非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。因此，在很多情况下，我们可以合并指令并运行，例如：RUN apt-get update &amp;&amp; apt-get install -y libgdiplus。在命令过多时，一定要注意格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p></li><li><p>删除多余文件和清理没用的中间结果</p><p>这点很易于理解，通常来讲，体积更小，部署更快！因此在构建过程中，我们需要清理那些最终不需要的代码或文件。比如说，临时文件、源代码、缓存等等。</p></li><li><p>使用 .dockerignore</p><p>.dockerignore文件用于忽略那些镜像构建时非必须的文件，这些文件可以是开发文档、日志、其他无用的文件。例如:<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181203094654908-278191045.png" alt></p></li></ul><h2 id="9-创建自定义Docker镜像"><a href="#9-创建自定义Docker镜像" class="headerlink" title="9 创建自定义Docker镜像"></a>9 创建自定义Docker镜像</h2><p>创建了Dockerfile之后，需为应用程序中的每项服务创建一个相关镜像。如果应用程序由单个服务或 Web 应用程序组成，则只需创建一个镜像。</p><p>我们可以使用docker build命令来创建镜像，例如：<br>docker build ./ -t {镜像名称}</p><p>镜像打包好后，我们使用docker image ls命令即可查看当前镜像。</p><p>注意：Docker镜像使用分层存储的架构，也就是说镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。因为分层存储的特征，使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。所以，当我们使用Docker images命令，会列出这么多的镜像，我们可以定期清理那些无用的镜像。</p><h2 id="10-在-docker-compose-yml中定义服务"><a href="#10-在-docker-compose-yml中定义服务" class="headerlink" title="10 在 docker-compose.yml中定义服务"></a>10 在 docker-compose.yml中定义服务</h2><h3 id="10-1-关于-Compose"><a href="#10-1-关于-Compose" class="headerlink" title="10.1 关于 Compose"></a>10.1 关于 Compose</h3><p>Compose是一个用于定义和运行多Docker应用程序的工具。使用Compose，我们可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，我们就可以从配置中创建并启动所有服务。</p><p>Compose适用于所有环境：生产环境、模拟（演示）环境、开发环境和测试环境以及CI工作流程。</p><p>主要功能和特性：</p><ul><li><p>单个主机上的多个隔离环境</p><p>Compose使用项目名称来隔离环境，因此可以根据不同的环境要求来进行定义。</p></li><li><p>创建容器时保留卷数据</p><p>Compose会保留服务使用的所有卷和数据。当使用docker-compose up命令运行时，如果发现该服务之前运行过，它会将进行增量操作，可确保在卷中创建的数据都不会丢失。</p></li><li><p>仅重新创建已更改的容器</p><p>Compose存在缓存，可用于创建容器。当重新启动未更改的服务时，Compose将重用现有容器。</p></li><li><p>可以定义变量，而且可以根据不同环境不同用户之间进行组合使用</p><p>Compose支持Compose文件的变量定义，我们可以使用这些变量为不同环境或不同用户进行自定义组合。</p></li></ul><p>另外，Compose能够通过命令管理应用程序的整个生命周期，通过命令可以：</p><ul><li><p>启动，停止和重建服务等</p></li><li><p>查看正在运行的服务的状态</p></li><li><p>通过流输出正在运行的服务的日志</p></li><li><p>对某个服务执行命令</p></li></ul><h2 id="11-常见场景"><a href="#11-常见场景" class="headerlink" title="11 常见场景"></a>11 常见场景</h2><ul><li><p>开发或本地环境运行多个服务</p><p>在开发过程时，在隔离环境中运行应用程序并与之交互的能力至关重要。Compose命令行工具可用于创建环境并与之交互。比如通过Compose文件，配置所有应用程序的服务依赖（数据库，消息队列，高速缓存，Web服务的API，等等），然后使用单个命令（docker-compose up）为每个依赖项创建和启动一个或多个容器，使整个程序能够正常运行起来。</p></li><li><p>自动化测试环境</p><p>任何持续部署或持续集成过程的一个重要部分是自动化测试套件。自动化端到端测试需要一个运行测试的环境。Compose提供了一种方便的方法来创建和销毁隔离的测试环境。我们只需要通过在Compose文件，即可定义完整环境，并且可以在几个命令中创建和销毁这些环境，如下所示：</p></li></ul><h2 id="12-使用Compose"><a href="#12-使用Compose" class="headerlink" title="12 使用Compose"></a>12 使用Compose</h2><p>使用Compose有以下三个步骤：</p><ol><li><p>使用Dockerfile定义应用环境，以便在任意地方进行复制</p></li><li><p>在 docker-compose.yml 中定义组合应用，以便它们可以在隔离的环境中一起运行</p></li><li><p>最后，执行docker-compose up命令，Compose 将启动并运行整个应用程序。</p></li></ol><h2 id="13-了解docker-compose-yml"><a href="#13-了解docker-compose-yml" class="headerlink" title="13 了解docker-compose.yml"></a>13 了解docker-compose.yml</h2><p>借助 docker-compose.yml 文件，我们可以定义一组相关服务，通过部署命令将其部署为组合应用程序。简单的说，我们可以通过docker-compose.yml来定义多个服务，以便一次执行。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094402699-10239551.png" alt></p><h2 id="14-了解YAML语言"><a href="#14-了解YAML语言" class="headerlink" title="14 了解YAML语言"></a>14 了解YAML语言</h2><p>YAML 是一种简洁的非标记语言。YAML以数据为中心，使用空白，缩进，分行组织数据，从而使得表示更加简洁易读。</p><p>这里提供一个YAML语法验证网站：<a href="http://nodeca.github.io/js-yaml/" target="_blank" rel="noopener">http://nodeca.github.io/js-yaml/</a></p><p>基本规则</p><ol><li><p>大小写敏感</p></li><li><p>使用缩进表示层级关系</p></li><li><p>禁止使用tab缩进，只能使用空格键</p></li><li><p>缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级</p></li><li><p>使用#表示注释</p></li><li><p>字符串可以不用引号标注</p></li></ol><p>YAML中允许表示三种格式，分别是常量值，对象和数组，如下所示：<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094613899-1061816782.png" alt></p><h2 id="15-docker-compose-yml文件配置项"><a href="#15-docker-compose-yml文件配置项" class="headerlink" title="15 docker-compose.yml文件配置项"></a>15 docker-compose.yml文件配置项</h2><p>docker-compose.yml 文件不仅指定正在使用的容器，还指定如何单独配置各容器。常用的配置项如下所示：</p><ul><li><p>uild：定义镜像生成，可以指定Dockerfile文件所在的目录路径，支持绝对路径和相对路径；</p></li><li><p>image：从指定的镜像中启动容器，可以是存储仓库、标签以及镜像 ID，如果镜像不存在，Compose 会自动拉去镜像；</p></li><li><p>environment：定义环境变量和配置；</p></li><li><p>ports：定义端口映射，比如上面配置中将容器上的公开端口 80 转接到主机上的外部端口 9901和9902；</p></li><li><p>depends_on，定义依赖关系。此定义会让当前服务处于等待状态，直到这些依赖服务启动。比如某个服务依赖数据库服务，那么通过此配置解决了服务的启动顺序的问题；</p></li><li><p>volumes，挂载一个目录或者一个已存在的数据卷容器，可以直接使用 HOST:CONTAINER 这样的格式，或者使用 HOST:CONTAINER:ro 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统；</p></li><li><p>context，指定Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url；</p></li><li><p>args,指定构建参数，这些参数只能在构建过程中访问；</p></li><li><p>target，定义构建指定的阶段Dockerfile，比如针对不同阶段使用不同的dockerfile，开发阶段使用支持编译调试的dockerfile，而生产环境，则使用轻量级的dockerfile；command，覆盖默认命令；</p></li><li><p>container_name，指定自定义容器名称，而不是生成的默认名称。<br><img src="/2019/05/12/1-Docker%E7%BC%98%E7%94%B1/70544-20181205094653278-1319182904.png" alt></p></li></ul><p>小技巧：</p><ul><li><p>可以通过配置项depends_on来定义依赖关系，这点对于控制服务的执行顺序尤为重要，比如先启动数据库然后再启动web服务。</p></li><li><p>如何使用JSON文件进行配置？可以指定文件名称，如下所示：</p><p>docker-compose -f docker-compose.json up</p></li><li><p>如何分阶段构建？推荐使用target配置项。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-Docker配置国内免费registry_mirror</title>
      <link href="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/"/>
      <url>/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于国内特殊的网络环境，往往我们从 <strong><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></strong>中拉取镜像并不能成功，而且速度特别慢。</p><p>那么我们可以给Docker配置一个国内的registry mirror，当我们需要的镜像在mirror中则直接返回，如果没有则从Docker Hub中拉取。<font color="red">是否使用registry mirror对Docker用户来说是透明的</font>。</p><p>DaoCloud在国内提供了首个Docker Hub镜像服务，而且免费，大大提高了国内Docker用户的使用热情。</p><a id="more"></a><h2 id="1-DaoCloud使用方法"><a href="#1-DaoCloud使用方法" class="headerlink" title="1 DaoCloud使用方法"></a>1 DaoCloud使用方法</h2><p>修改Docker配置文件/etc/default/docker如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;--registry-mirror&#x3D;http:&#x2F;&#x2F;aad0405c.m.daocloud.io&quot;</span><br></pre></td></tr></table></figure><p>使用<code>service docker restart</code>重启Docker服务即可。</p><p>在使用docker下载镜像时，在国内使用官方的Docker registry下载时速度很慢，庆幸国内还镜像加速服务。目前支持Docker镜像的有阿里云和DaoCloud两家。本文将详细讲解镜像服务的具体配置方法。</p><h2 id="2-Docker使用阿里云镜像库加速（推荐）"><a href="#2-Docker使用阿里云镜像库加速（推荐）" class="headerlink" title="2 Docker使用阿里云镜像库加速（推荐）"></a>2 Docker使用阿里云镜像库加速（推荐）</h2><p>注册阿里云开发者账号<br><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></p><p>登陆后取得专属加速器地址，类似这样 <code>https://9mpi2k3r.mirror.aliyuncs.com</code></p><h2 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3 步骤"></a>3 步骤</h2><h3 id="3-1-安装-升级Docker客户端"><a href="#3-1-安装-升级Docker客户端" class="headerlink" title="3.1 安装/升级Docker客户端"></a>3.1 安装/升级Docker客户端</h3><p>推荐安装1.10.0以上版本的Docker客户端，参考文档 <a href="https://yq.aliyun.com/articles/110806?spm=5176.8351553.0.0.13be1991qOQrLG" target="_blank" rel="noopener">docker-ce</a></p><h3 id="3-2-Docker-CE镜像源站"><a href="#3-2-Docker-CE镜像源站" class="headerlink" title="3.2 Docker CE镜像源站"></a>3.2 Docker CE镜像源站</h3><p>官网下载手册</p><h3 id="3-3-CentOS7（使用yum进行安装-阿里云）"><a href="#3-3-CentOS7（使用yum进行安装-阿里云）" class="headerlink" title="3.3 CentOS7（使用yum进行安装-阿里云）"></a>3.3 CentOS7（使用yum进行安装-阿里云）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># Step 3: 更新并安装 Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"># Step 4: 开启Docker服务</span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line">注意：其他注意事项在下面的注释中</span><br><span class="line"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span><br><span class="line"># vim &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo</span><br><span class="line">#   将 [docker-ce-test] 下方的 enabled&#x3D;0 修改为 enabled&#x3D;1</span><br><span class="line">#</span><br><span class="line"># 安装指定版本的Docker-CE:</span><br><span class="line"># Step 1: 查找Docker-CE的版本:</span><br><span class="line"># yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="line">#   Loading mirror speeds from cached hostfile</span><br><span class="line">#   Loaded plugins: branch, fastestmirror, langpacks</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span><br><span class="line">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span><br><span class="line">#   Available Packages</span><br><span class="line"># Step2 : 安装指定版本的Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span><br><span class="line"># sudo yum -y install docker-ce-[VERSION]</span><br><span class="line"># 注意：在某些版本之后，docker-ce安装出现了其他依赖包，如果安装失败的话请关注错误信息。例如 docker-ce 17.03 之后，需要先安装 docker-ce-selinux。</span><br><span class="line"># yum list docker-ce-selinux- --showduplicates | sort -r</span><br><span class="line"># sudo yum -y install docker-ce-selinux-[VERSION]</span><br><span class="line"></span><br><span class="line"># 通过经典网络、VPC网络内网安装时，用以下命令替换Step 2中的命令</span><br><span class="line"># 经典网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br><span class="line"># VPC网络：</span><br><span class="line"># sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.could.aliyuncs.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3-4-安装校验"><a href="#3-4-安装校验" class="headerlink" title="3.4 安装校验"></a>3.4 安装校验</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure><h3 id="3-5-配置镜像加速器"><a href="#3-5-配置镜像加速器" class="headerlink" title="3.5 配置镜像加速器"></a>3.5 配置镜像加速器</h3><p>针对Docker客户端版本大于 1.10.0 的用户</p><p><img src="/2019/05/08/0-Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E5%85%8D%E8%B4%B9registry-mirror/1f87538c-e8a2-455e-af33-8e0b3ff4a3f9.png" alt></p><p>您可以通过修改daemon配置文件（没有的话，需手动创建）<code>/etc/docker/daemon.json</code>来使用加速器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker </span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: # 此处使用自己的加速器[&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;]&#125;EOF </span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="4-daemon-json"><a href="#4-daemon-json" class="headerlink" title="4 daemon.json"></a>4 daemon.json</h2><p><strong>docker安装后默认是没有 daemon.json此配置文件的，需手动创建。</strong></p><p>daemon.json文件可配置的参数表，我们在配置的过程中，只需要设置我们需要的参数即可，不必全部写出来。详细参考官网。</p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/configuration-reloading。</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#options" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#options</a></p><p>官方的配置地址：<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/#/linux-configuration-file</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;api-cors-header&quot;:&quot;&quot;,</span><br><span class="line">&quot;authorization-plugins&quot;:[],</span><br><span class="line">&quot;bip&quot;: &quot;&quot;,</span><br><span class="line">&quot;bridge&quot;:&quot;&quot;,</span><br><span class="line">&quot;cgroup-parent&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store&quot;:&quot;&quot;,</span><br><span class="line">&quot;cluster-store-opts&quot;:&#123;&#125;,</span><br><span class="line">&quot;cluster-advertise&quot;:&quot;&quot;,</span><br><span class="line">&quot;debug&quot;: true, #启用debug的模式，启用后，可以看到很多的启动信息。默认false</span><br><span class="line">&quot;default-gateway&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-gateway-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;default-runtime&quot;:&quot;runc&quot;,</span><br><span class="line">&quot;default-ulimits&quot;:&#123;&#125;,</span><br><span class="line">&quot;disable-legacy-registry&quot;:false,</span><br><span class="line">&quot;dns&quot;: [&quot;192.168.1.1&quot;], # 设定容器DNS的地址，在容器的 &#x2F;etc&#x2F;resolv.conf文件中可查看。</span><br><span class="line">&quot;dns-opts&quot;: [], # 容器 &#x2F;etc&#x2F;resolv.conf 文件，其他设置</span><br><span class="line">&quot;dns-search&quot;: [], # 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的 主机时，DNS不仅搜索host，还会搜</span><br><span class="line">索host.example.com 。 注意：如果不设置， Docker 会默认用主机上的 &#x2F;etc&#x2F;resolv.conf 来配置容器。</span><br><span class="line"> </span><br><span class="line">&quot;exec-opts&quot;: [],</span><br><span class="line">&quot;exec-root&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr&quot;:&quot;&quot;,</span><br><span class="line">&quot;fixed-cidr-v6&quot;:&quot;&quot;,</span><br><span class="line">&quot;graph&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃已废弃，使用data-root代替,这个主要看docker的版本</span><br><span class="line">&quot;data-root&quot;:&quot;&#x2F;var&#x2F;lib&#x2F;docker&quot;, ＃Docker运行时使用的根路径,根路径下的内容稍后介绍，默认&#x2F;var&#x2F;lib&#x2F;docker</span><br><span class="line">&quot;group&quot;: &quot;&quot;, #Unix套接字的属组,仅指&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">&quot;hosts&quot;: [], #设置容器hosts</span><br><span class="line">&quot;icc&quot;: false,</span><br><span class="line">&quot;insecure-registries&quot;: [], #配置docker的私库地址</span><br><span class="line">&quot;ip&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">&quot;iptables&quot;: false,</span><br><span class="line">&quot;ipv6&quot;: false,</span><br><span class="line">&quot;ip-forward&quot;: false, #默认true, 启用 net.ipv4.ip_forward ,进入容器后使用 sysctl -a | grepnet.ipv4.ip_forward 查看</span><br><span class="line"> </span><br><span class="line">&quot;ip-masq&quot;:false,</span><br><span class="line">&quot;labels&quot;:[&quot;nodeName&#x3D;node-121&quot;], # docker主机的标签，很实用的功能,例如定义：–label nodeName&#x3D;host-121</span><br><span class="line"> </span><br><span class="line">&quot;live-restore&quot;: true,</span><br><span class="line">&quot;log-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-level&quot;:&quot;&quot;,</span><br><span class="line">&quot;log-opts&quot;: &#123;&#125;,</span><br><span class="line">&quot;max-concurrent-downloads&quot;:3,</span><br><span class="line">&quot;max-concurrent-uploads&quot;:5,</span><br><span class="line">&quot;mtu&quot;: 0,</span><br><span class="line">&quot;oom-score-adjust&quot;:-500,</span><br><span class="line">&quot;pidfile&quot;: &quot;&quot;, #Docker守护进程的PID文件</span><br><span class="line">&quot;raw-logs&quot;: false,</span><br><span class="line">&quot;registry-mirrors&quot;:[&quot;xxxx&quot;], #镜像加速的地址，增加后在 docker info中可查看。</span><br><span class="line">&quot;runtimes&quot;: &#123;</span><br><span class="line">&quot;runc&quot;: &#123;</span><br><span class="line">&quot;path&quot;: &quot;runc&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;custom&quot;: &#123;</span><br><span class="line">&quot;path&quot;:&quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;my-runc-replacement&quot;,</span><br><span class="line">&quot;runtimeArgs&quot;: [</span><br><span class="line">&quot;--debug&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;selinux-enabled&quot;: false, #默认 false，启用selinux支持</span><br><span class="line"> </span><br><span class="line">&quot;storage-driver&quot;:&quot;&quot;,</span><br><span class="line">&quot;storage-opts&quot;: [],</span><br><span class="line">&quot;swarm-default-advertise-addr&quot;:&quot;&quot;,</span><br><span class="line">&quot;tls&quot;: true, #默认 false, 启动TLS认证开关</span><br><span class="line">&quot;tlscacert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;ca.pem，通过CA认证过的的certificate文件路径</span><br><span class="line">&quot;tlscert&quot;: &quot;&quot;, #默认 ~&#x2F;.docker&#x2F;cert.pem ，TLS的certificate文件路径</span><br><span class="line">&quot;tlskey&quot;: &quot;&quot;, #默认~&#x2F;.docker&#x2F;key.pem，TLS的key文件路径</span><br><span class="line">&quot;tlsverify&quot;: true, #默认false，使用TLS并做后台进程与客户端通讯的验证</span><br><span class="line">&quot;userland-proxy&quot;:false,</span><br><span class="line">&quot;userns-remap&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述是官网docs提供的一个示例配置，我们可以参考，选择性的配置其中的部分内容。</p><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5 示例"></a>5 示例</h2><p>1、如何配置 registry 私库相关的参数<br>涉及以下2个参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;insecure-registries&quot;: [],  #这个私库的服务地址</span><br><span class="line">&quot;registry-mirrors&quot;: [],    #私库加速器</span><br></pre></td></tr></table></figure><p>2.配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line"></span><br><span class="line"># 配置阿里云镜像加速器 ：此处需使用自己个人加速器</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&quot;],</span><br><span class="line"></span><br><span class="line"># 私库服务地址：个人一般用不到</span><br><span class="line">&quot;insecure-registries&quot;: [&quot;https:&#x2F;&#x2F;ower.site.com&quot;]，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 重载配置文件</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"># 重启docker服务</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"># 查看状态</span><br><span class="line">sudo systemctl status docker -i</span><br><span class="line"># 查看服务</span><br><span class="line">sudo docker info</span><br><span class="line"># 当我们需要对docker服务进行调整配置时，不用去修改主文件 docker.service的参数，通过daemon.json配置文件来管理，更为安全、合理。</span><br></pre></td></tr></table></figure><h2 id="6-docker-hub官网提供国内镜像"><a href="#6-docker-hub官网提供国内镜像" class="headerlink" title="6 docker hub官网提供国内镜像"></a>6 docker hub官网提供国内镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;registry.docker-cn.com</span><br></pre></td></tr></table></figure><h2 id="7-检查加速器是否生效"><a href="#7-检查加速器是否生效" class="headerlink" title="7 检查加速器是否生效"></a>7 检查加速器是否生效</h2><p>如果 加速器太慢，可以更改加速器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br><span class="line"># 如果看到如下，则表示配置成功</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https:&#x2F;&#x2F;9mpi2k3r.mirror.aliyuncs.com&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea常用插件及个性化配置</title>
      <link href="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Idea常用插件"><a href="#Idea常用插件" class="headerlink" title="Idea常用插件"></a>Idea常用插件</h1><h2 id="1-阿里代码规约检查"><a href="#1-阿里代码规约检查" class="headerlink" title="1 阿里代码规约检查"></a>1 阿里代码规约检查</h2><p>Alibaba Java Coding Guidelines</p><h2 id="2-lombok"><a href="#2-lombok" class="headerlink" title="2 lombok"></a>2 lombok</h2><p>一个在编译阶段修改增强Java类的工具，使用方式基于注解，常用于:</p><ul><li>为Java POJO生成属性对应的getter,setter等</li><li>为Java POJO生成builder构造器模式的实现</li><li>为Java类自动添加其他重复性代码，比如日志记录的声明代码可以通过@Slf4j注解添加</li></ul><p>项目中是否引入Lombok一直是个存在争议，它的主要优势在于消除Java类的部分臃肿代码，提高开发效率，降低代码维护成本；缺点是需要IDE插件支持，需要团队统一规范，另外某些注解生成的隐性实现可能导致问题跟踪调试困难。</p><p>第一步 下载插件<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/6b41d245-56a5-477e-9bc5-41a1b73cdf7f.png" alt></p><p>开启编译，防止编译时出错<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/963fd399-a722-4f50-b2c1-c5d6331ec897.png" alt></p><p>使用前需引入依赖<br>第二步：引入 lombok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.18.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>使用：</p><ul><li><p><strong>@Data</strong>：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法,相当于同时加上以下注解@Setter @Getter,@ToString,@EqualsAndHashCode</p></li><li><p>@Setter、@Getter：注解在类和属性上；为属性提供 setting、getting 方法</p></li><li><p>@ToString：生成toString方法，默认情况下，会输出类名、所有属性，属性按照顺序输出，以逗号分割。</p></li><li><p>@EqualsAndHashCode：实现equals()方法和hashCode()方法</p></li><li><p><strong>@Builder</strong>：构建 建造者模式</p></li><li><p><strong>@NonNull</strong>：该注解快速判断是否为空,如果为空,则抛出java.lang.NullPointerException</p></li><li><p>@Synchronized：该注解自动添加到同步机制,有趣的是,生成的代码并不是直接锁方法,而是锁代码块， 作用范围是方法上</p></li><li><p>@Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象</p></li><li><p><strong>@NoArgsConstructor</strong>：注解在类上；为类提供一个无参的构造方法</p></li><li><p>@RequiredArgsConstructor：_注解在类上；为类提供一个部分参的构造方法(使用类中所有带有@NonNull注解的或者带有final修饰的成员变量生成对应的构造方法)</p></li><li><p><strong>@AllArgsConstructor</strong>：注解在类上；为类提供一个全参的构造方法</p></li><li><p>@Cleanup：用于确保已分配的资源被释放,如IO的连接关闭</p></li><li><p>@SneakyThrows：抛异常</p></li><li><p>@Accessors(chain = true)：使用链式结构</p></li></ul><h2 id="3-Free-Mybatis-plugin"><a href="#3-Free-Mybatis-plugin" class="headerlink" title="3 Free Mybatis plugin"></a>3 Free Mybatis plugin</h2><p><strong>Free Mybatis plugin</strong> 方便于在Mapper接口与XML文件之间进行跳转。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/a3f8ca1f-fab4-4cdf-a3b1-4850634b4d17.jpg" alt></p><h2 id="4-Maven-Helper"><a href="#4-Maven-Helper" class="headerlink" title="4 Maven Helper"></a>4 Maven Helper</h2><p>手动打依赖树，使用 mvn dependency : tree 查看太过于繁琐。</p><p>Maven Helper是一个将maven依赖树可视化的插件，可以方便的查看依赖以及处理依赖冲突问题。对经常使用maven的同学来说可以说是神器。</p><p>安装好后，在 pom.xmlwe文件底部会多出一个 <strong>Dependency Analyzer</strong>选项<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/7db0ae9c-0721-424e-8ff6-ab30c72b934f.jpg" alt></p><p>点开后：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/9538d5c0-930b-462d-a2c4-ffe66d59d836.jpg" alt></p><p>找到冲突，点击右键，然后选择<strong>Exclude</strong>即可排除冲突版本的Jar包。</p><p>除此之外，还可以用Idea自带的——————Maven依赖结构图，打开Maven窗口，选择Dependencies，然后点击那个图标（Show Dependencies）或者使用快捷键（Ctrl+Alt+Shift+U），即可打开Maven依赖关系结构图</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/70199fe8-e8f3-4359-a8ea-8072b950f91e.jpg" alt></p><p>在图中，我们可以看到有一些红色的实线，这些红色实线就是依赖冲突，蓝色实线则是正常的依赖。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/3d90c5ad-10b7-47ad-9c68-6df72f2d4ac6.jpg" alt></p><h2 id="5-GsonFormat"><a href="#5-GsonFormat" class="headerlink" title="5 GsonFormat"></a>5 GsonFormat</h2><p>GsonFormat插件将JSONObject格式的字符串解析成实体，自动生成实体类。</p><p>自定义个javaBean(无任何内容，就一个空的类)</p><p>复制你要解析的json</p><p>然后alt+insert弹出如下界面 或者使用快捷键 alt+s</p><p>通过快捷键调出该插件<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/f4855842-db99-434b-8eee-634ea1e3dec3.png" alt></p><p>粘贴到如下界面：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/045a4ed2-faf5-4494-ba29-fb4f6478b63a.jpg" alt></p><p>点击ok,自动生成对应javaBean的代码：<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/42f62daf-8b8d-4e72-932c-196b1e218cf9.png" alt></p><h2 id="6-GenerateAllSetter"><a href="#6-GenerateAllSetter" class="headerlink" title="6 GenerateAllSetter"></a>6 GenerateAllSetter</h2><p>方法： 在实例上 使用  alt + enter</p><p>GenerateAllSetter是一键调用一个对象的所有set方法并且赋予默认值的插件。在对象字段 多的时候非常方便，相当给力。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/cecc423d-87d8-4999-be78-947ac0090cd4.jpg" alt></p><h2 id="7-BashSupport"><a href="#7-BashSupport" class="headerlink" title="7 BashSupport"></a>7 BashSupport</h2><p>一个可以编写调试shell脚本的插件。</p><p>使用插件执行脚本<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/573c64f8-6302-451c-929c-e4e9168b1a17.png" alt></p><h2 id="8-PlantUml"><a href="#8-PlantUml" class="headerlink" title="8  PlantUml"></a>8  PlantUml</h2><p>PlantUml是一个画类图、时序图等的一个插件。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/ec4fed5a-e3b3-44d4-ba34-37cc528c43a5.jpg" alt></p><h2 id="9-Mybatis-log-plugin"><a href="#9-Mybatis-log-plugin" class="headerlink" title="9 Mybatis-log-plugin"></a>9 Mybatis-log-plugin</h2><p>开发的项目一般都少不了日志系统，而我们在书写mysql语句的时候，参数的对应，往往有时候会忽略，mybatis自己控制的参数编译对应，个人感觉有点反人类，我们可以使用这个插件变成自己比较直观的对应~</p><p>选中需要转换的mybatis log日志，然后点击右键，选择Restore sql from slection</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/01296088-a0b1-4b9b-b532-803a2a464f32.jpg" alt></p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/2cf0bc35-cadc-4257-a5b4-e48a0138bc85.jpg" alt></p><h2 id="9-Activate-power-mode或者Intellij-power-mode-II"><a href="#9-Activate-power-mode或者Intellij-power-mode-II" class="headerlink" title="9 Activate-power-mode或者Intellij_power_mode_II"></a>9 Activate-power-mode或者Intellij_power_mode_II</h2><p>个人感觉 没啥实用。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/20181029180853386.gif" alt></p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/20181029180908797.gif" alt></p><h1 id="Idea-个人习惯配置"><a href="#Idea-个人习惯配置" class="headerlink" title="Idea 个人习惯配置"></a>Idea 个人习惯配置</h1><h2 id="1-全局-默认-vs-当前"><a href="#1-全局-默认-vs-当前" class="headerlink" title="1 全局(默认) vs 当前"></a>1 全局(默认) vs 当前</h2><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/36bf81b8-0e9a-489c-b926-522f644df29f.jpg" alt></p><h2 id="2-全局JDK（默认配置）"><a href="#2-全局JDK（默认配置）" class="headerlink" title="2 全局JDK（默认配置）"></a>2 全局JDK（默认配置）</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settins -&gt; Default Project Structure -&gt; SDKs -&gt; JDK</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/88efb046-ae74-4693-9636-1052abbf1e53.jpg" alt></p><h2 id="3-全局-Maven-默认配置"><a href="#3-全局-Maven-默认配置" class="headerlink" title="3 全局 Maven(默认配置)"></a>3 全局 Maven(默认配置)</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Build &amp; Tools -&gt; Maven</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/c39b5ad9-2240-46de-a80d-238fdfa44929.jpg" alt></p><p>Maven配置文件</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/dfc2de6d-d0f3-41b5-bbfe-c4849560bc43.jpg" alt></p><p>Idea Maven神器</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/eca92eff-d2e7-4120-9a4d-e14b862e2755.jpg" alt></p><h2 id="4-配置Git"><a href="#4-配置Git" class="headerlink" title="4 配置Git"></a>4 配置Git</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Version Control -&gt; Git</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/e985cecb-db9d-4c3b-bf1a-8895cf8e7ec6.jpg" alt></p><h2 id="5-自动导包和只能移除-默认配置"><a href="#5-自动导包和只能移除-默认配置" class="headerlink" title="5 自动导包和只能移除(默认配置)"></a>5 自动导包和只能移除(默认配置)</h2><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Auto Import</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/622053f5-c434-4650-92fa-6a76fbd17656.jpg" alt></p><h2 id="7-Tomcat-Server"><a href="#7-Tomcat-Server" class="headerlink" title="7 Tomcat Server"></a>7 Tomcat Server</h2><p>配置Tomcat方法： File -&gt; Settings -&gt; Deployment -&gt; Application Servers -&gt; Tomcat Server</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/47e4f3f2-a15e-45ea-9d24-b7bcc9cb671b.jpg" alt></p><h2 id="8-SpringBoot-在IDEA中实现热部署"><a href="#8-SpringBoot-在IDEA中实现热部署" class="headerlink" title="8 SpringBoot 在IDEA中实现热部署"></a>8 SpringBoot 在IDEA中实现热部署</h2><h3 id="1-开启Idea自动编译-静态"><a href="#1-开启Idea自动编译-静态" class="headerlink" title="1 开启Idea自动编译(静态)"></a>1 开启Idea自动编译(静态)</h3><p>具体步骤：顶部工具栏  File -&gt;Other Settings -&gt; Default Settings -&gt; Auto Import</p><p>说明：开启自动编译之后，结合Ctrl+Shift+F9 会有热更新效果。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/f73b541d-257c-45c1-bf73-cf0733c268a7.jpg" alt></p><h3 id="2-开启Idea自动编译（Runtime-动态"><a href="#2-开启Idea自动编译（Runtime-动态" class="headerlink" title="2 开启Idea自动编译（Runtime)(动态)"></a>2 开启Idea自动编译（Runtime)(动态)</h3><p><strong>动态</strong><br>具体步骤： 敲击 Ctrl + Shift + Alt + /  然后双击Shift搜索进入Registry 勾选自动编译并调整延时参数。<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/17bd9c5d-fdd3-4c62-8d15-8b47b54bc9ca.jpg" alt></p><ul><li><p>compiler.automake.allow.when.app.running -&gt; 自动编译</p></li><li><p>compile.document.save.trigger.delay -&gt; 自动更新文件</p></li></ul><p>第二个 它主要是针对静态文件如JS CSS的更新，将延迟时间减少后，直接按F5刷新页面就能看到效果！<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/2eee77bf-d3dd-44c9-a02a-4b7cee835e13.jpg" alt></p><h3 id="3-开启Idea热部署策略-重要"><a href="#3-开启Idea热部署策略-重要" class="headerlink" title="3 开启Idea热部署策略(重要)"></a>3 开启Idea热部署策略(重要)</h3><p>具体步骤：顶部菜单- &gt;Edit Configurations-&gt;SpringBoot插件-&gt;目标项目-&gt;勾选热更新。</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/6ea010c3-9cc3-42a8-afd7-ff16c5d935ba.jpg" alt></p><h3 id="4-在项目添加热部署插件（可选）"><a href="#4-在项目添加热部署插件（可选）" class="headerlink" title="4 在项目添加热部署插件（可选）"></a>4 在项目添加热部署插件（可选）</h3><p>如果因为旧项目十分臃肿，导致每次都自动热重启很慢而影响开发效率，笔者建议直接在POM移除<code>spring-boot-devtools</code>依赖，然后使用Control+Shift+F9进行手工免启动快速更新！！</p><p>具体步骤：在POM文件添加热部署插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="5-关闭浏览器缓存-重要"><a href="#5-关闭浏览器缓存-重要" class="headerlink" title="5 关闭浏览器缓存(重要)"></a>5 关闭浏览器缓存(重要)</h3><p>打开谷歌浏览器，打开F12的Network选项栏，然后勾选【✅】Disable cache 。、<br><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/c11b086a-4714-4bf2-8eb6-c21967514511.jpg" alt></p><h2 id="9-调整字体类型和字体大小"><a href="#9-调整字体类型和字体大小" class="headerlink" title="9 调整字体类型和字体大小"></a>9 调整字体类型和字体大小</h2><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/0a9450ae-f0f5-4e4c-9a4f-110c7011eba2.jpg" alt></p><h2 id="10-打开常用工具栏"><a href="#10-打开常用工具栏" class="headerlink" title="10 打开常用工具栏"></a>10 打开常用工具栏</h2><p>具体步骤：顶部导航栏 - View -&gt; 勾选 Toolbar &amp; Tool Buttons</p><p><img src="/2019/04/19/Idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/b5d4d1d4-712a-4325-bd16-1f65b9ad88de.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT学习</title>
      <link href="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 文章出处： JSON Web Token–摘自<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>JSON Web Token</strong>(缩写 JWT)是目前最流行的跨域认证解决方案。</p><h1 id="1-跨域认证的问题"><a href="#1-跨域认证的问题" class="headerlink" title="1 跨域认证的问题"></a>1 跨域认证的问题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网离不开用户认证，一般流程是下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户向服务器发送用户名和密码。</span><br><span class="line">服务器验证通过后，在当前会话（session）里面保存相关数据，比如用户角色、登录时间等。</span><br><span class="line">服务器向用户返回一个 session_id，写入用户的Cookie。</span><br><span class="line">用户随后的每一次请求，都会通过Cookie，将 session_id 回传服务器。</span><br><span class="line">服务器收到 session_id ，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式的问题在于：扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例来说，A网站和B网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一种解决方案是 session数据持久化，写入数据库或别的持久层。各种服务受到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种方案是服务器索性不保存 session数据了，所有数据都保存在客户端，每次请求都回传服务器。<strong>JWT</strong>就是这种方案的一个代表。</p><h1 id="2-JWT的原理"><a href="#2-JWT的原理" class="headerlink" title="2 JWT的原理"></a>2 JWT的原理</h1><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/874963-20180707150229764-2037235703.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT的原理是，服务器认证后，生成一个<strong>JSON 对象</strong>，发回给用户，就像下面这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;:&quot;superadmin”</span><br><span class="line"> &quot;role&quot;:&quot;manager&quot;</span><br><span class="line"> &quot;expire_time：“2018-5-5 16:16:16”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以后，用户与服务端通信的时候，都要发挥这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器再生成这个对象的时候，会家上<strong>签名</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器不再保存任何session数据了，即：服务器变成无状态了，从而较容易实现扩展。</p><h1 id="3-JWT的数据结构"><a href="#3-JWT的数据结构" class="headerlink" title="3 JWT的数据结构"></a>3 JWT的数据结构</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的JWT大概就像下面这样：<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/bg2018072304.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它是一个很长的字符串。中间用点(.)分割成三个部分。注意。JWT内部是没有换行的，这里只是为了便与便于展示，将它写成了几行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JWT的三个部分依次如下：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）<br>即：Header.Payload.Signature<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/bg2018072303.jpg" alt></li></ul><h2 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Header</strong>部分就是一个JSON对象。描述了JWT的元数据，通常是下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;:&quot;HS256&quot;</span><br><span class="line">  &quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面代码中，<font color="red"><strong>alg</strong>属性表示签名的算法（algorithm）,默认是HMAC SHA256(写成HS256)；<strong>typ</strong>属性标识这个令牌（Token）的类型（type），<strong>JWT</strong>令牌统一写成<strong>JWT</strong></font>。</p><h2 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Payload</strong>部分也是一个JSON对象，用来存放实际需要传递的数据。JWT官方规定了7个字段，供使用。</p><ul><li>iss（issuer) 签发人</li><li>exp(expiration time): 过期时间</li><li>sub(subject): 主体</li><li>aud(audience): 受众</li><li>nbf(Not Before): 生效时间</li><li>iat(Issued At): 签发时间</li><li>jti(JWT ID): 编号<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了官方字段，你可以在这个部分定义私有字段，如下所示：</li></ul><p>{<br> “sub” :”123456”<br> “name”:”superadmin”<br> “admin”:true</p><p>}</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。这个JSON对象也要使用<strong>Base64URL算法</strong>转成字符串。</p><h2 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Signature</strong> 部分是对前两部分的签名。防止数据篡改。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，需要指定一个密钥（secret)。这个密钥只有服务器才知道，不能泄露给用户。然后，使用Header里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名。</p><p>HMACSHA256<br>(<br>       base64URLEncode(header)+”.”+<br>       base64URLEncode(payload),<br>       secret<br>)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用”点”(.)分割，即可返回给用户。</p><h2 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到，Header和Payload串行化的算法是Base64URL。这个算法跟Base64算法基本类似，但不同的是：<br><strong>JWT</strong>作为一个令牌（token)，有些场合可能会放到URL（如：api.example.com/token=xxx)。Base64有3个字符+、/和=。在URL里面有特殊含义，所以要被替换掉：=被省略、+替换成-、/换成_。这是Base64URL算法。</p><h1 id="4-JWT-的使用方式"><a href="#4-JWT-的使用方式" class="headerlink" title="4 JWT 的使用方式"></a>4 JWT 的使用方式</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端收到服务器返回的JWT，可以存储到<strong>Cookie</strong>里面，也可以存储到<strong>localStorage</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此后，客户端每次与服务器通信，都要带上这个JWT。你可以把她它放在Cookie里面自动发送，但是这样不能跨域，所以更好地做法是放在<strong>HTTP</strong>请求的头信息<font color="red">Authorrization</font>字段里面。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Authorization：Bearer<Token><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种做法是，跨域的时候，</Token></strong>JWT<strong>就放在</strong>POST**请求的数据体里面。</p><h1 id="5-JWTI的几个特点"><a href="#5-JWTI的几个特点" class="headerlink" title="5 JWTI的几个特点"></a>5 JWTI的几个特点</h1><p>（1）JWT默认是不加密，但也可以加密。生成原始Token以后，可以使用密钥再加密一次。<br>（2）JWT不加密的情况下，不能将秘密数据写入JWT。<br>（3）JWT不仅可以用于认证，也可以用户交换信息，有效使用JWT，可以降低服务器查询数据库的次数。<br>（4）JWT的最大缺点是：由于服务器不保存Session状态，因此无法再使用过程中废止某个token。<br>（5）JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置的比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>（6）为了减少盗用。JWT不应该使用<strong>HTTP</strong>协议明码传输，要使用<strong>HTTPS</strong>协议传输。</p><h1 id="六-SpringBoot2-0集成JWT作鉴权"><a href="#六-SpringBoot2-0集成JWT作鉴权" class="headerlink" title="六 SpringBoot2.0集成JWT作鉴权"></a>六 SpringBoot2.0集成JWT作鉴权</h1><p>项目架构：<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/5113607d-e98b-408c-ad9b-8765836fdc84.png" alt></p><p>entity   —&gt;&gt;&gt;    User:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line"> private String name;</span><br><span class="line"> private String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils    —&gt;&gt;&gt;    JwtUtil:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class JwtUtil &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">      * 过期时间为1天</span><br><span class="line">      * 正式上线更换为15分钟</span><br><span class="line">      *&#x2F;</span><br><span class="line">  private static final long EXPIRE_TIME &#x3D; 24*60*60*1000;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">    * token 私钥</span><br><span class="line">    *&#x2F;</span><br><span class="line">  private static final String TOKEN_SECRET &#x3D; &quot;joijsdfjlsjfljfljl5135313135&quot;;</span><br><span class="line"></span><br><span class="line"> public static String sign(String username,String userId)&#123;</span><br><span class="line">        &#x2F;&#x2F;过期时间</span><br><span class="line">  Date date &#x3D; new Date(System.currentTimeMillis() + EXPIRE_TIME);</span><br><span class="line">  &#x2F;&#x2F;私钥及加密算法</span><br><span class="line">  Algorithm algorithm &#x3D; Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">  &#x2F;&#x2F;设置头信息</span><br><span class="line">  HashMap&lt;String,Object&gt; header &#x3D; new HashMap&lt;&gt;(2);</span><br><span class="line">  header.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line">  header.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">  &#x2F;&#x2F;附带username和userId生成签名</span><br><span class="line">  return JWT.create().withHeader(header)</span><br><span class="line">                .withClaim(&quot;loginName&quot;,username)</span><br><span class="line">                .withClaim(&quot;userId&quot;,userId)</span><br><span class="line">                .withExpiresAt(date)</span><br><span class="line">                .sign(algorithm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean verity(String token) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm &#x3D; Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">  JWTVerifier verifier &#x3D; JWT.require(algorithm).build();</span><br><span class="line">  DecodedJWT jwt &#x3D; verifier.verify(token);</span><br><span class="line"> return true;  &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">  &#125; catch (JWTVerificationException e) &#123;</span><br><span class="line">            return false;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义状态码<br>utils —&gt;&gt;&gt; AjaxResult</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">public class AjaxResult extends HashMap&lt;String,Object&gt; &#123;</span><br><span class="line"> private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line"></span><br><span class="line"> public static final String CODE_TAG &#x3D; &quot;code&quot;;</span><br><span class="line"></span><br><span class="line"> public static final String MSG_TAG &#x3D; &quot;msg&quot;;</span><br><span class="line"></span><br><span class="line"> public static final String DATA_TAG &#x3D; &quot;data&quot;;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 状态类型</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public enum Type</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;** 成功 *&#x2F;</span><br><span class="line">  SUCCESS(0),</span><br><span class="line">  &#x2F;**失败*&#x2F;</span><br><span class="line">  FAIL(1),</span><br><span class="line">  &#x2F;** 警告 *&#x2F;</span><br><span class="line">  WARN(301),</span><br><span class="line">  &#x2F;** 错误 *&#x2F;</span><br><span class="line">  ERROR(500);</span><br><span class="line"> private final int value;</span><br><span class="line"></span><br><span class="line">  Type(int value)</span><br><span class="line">        &#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">        public int value()</span><br><span class="line">        &#123;</span><br><span class="line">            return this.value;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 状态类型 *&#x2F;</span><br><span class="line">  private Type type;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 状态码 *&#x2F;</span><br><span class="line">  private int code;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 返回内容 *&#x2F;</span><br><span class="line">  private String msg;</span><br><span class="line"></span><br><span class="line">  &#x2F;** 数据对象 *&#x2F;</span><br><span class="line">  private Object data;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象，使其表示一个空消息。</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象</span><br><span class="line">  *</span><br><span class="line"> * @param type 状态类型</span><br><span class="line">  * @param msg 返回内容</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult(Type type, String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        super.put(CODE_TAG, type.value);</span><br><span class="line"> super.put(MSG_TAG, msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 初始化一个新创建的 AjaxResult 对象</span><br><span class="line">  *</span><br><span class="line"> * @param type 状态类型</span><br><span class="line">  * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public AjaxResult(Type type, String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        super.put(CODE_TAG, type.value);</span><br><span class="line"> super.put(MSG_TAG, msg);</span><br><span class="line"> super.put(DATA_TAG, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.success(&quot;操作成功&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.success(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回成功消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult success(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.SUCCESS, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.fail(&quot;操作失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.fail(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回失败消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 成功消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult fail(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.FAIL, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回警告消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult warn(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.warn(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回警告消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult warn(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.WARN, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error()</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.error(&quot;操作失败&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        return AjaxResult.error(msg, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 返回错误消息</span><br><span class="line">  *</span><br><span class="line"> * @param msg 返回内容</span><br><span class="line">  * @param data 数据对象</span><br><span class="line">  * @return 警告消息</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static AjaxResult error(String msg, Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        return new AjaxResult(Type.ERROR, msg, data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Type getType()</span><br><span class="line">    &#123;</span><br><span class="line">        return type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(Type type)</span><br><span class="line">    &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(int code)</span><br><span class="line">    &#123;</span><br><span class="line">        this.code &#x3D; code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg()</span><br><span class="line">    &#123;</span><br><span class="line">        return msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg)</span><br><span class="line">    &#123;</span><br><span class="line">        this.msg &#x3D; msg;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData()</span><br><span class="line">    &#123;</span><br><span class="line">        return data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data)</span><br><span class="line">    &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface IUserService &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 校验用户信息</span><br><span class="line">  * @param loginName</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  boolean checkUser(String loginName, String passWord);</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line"> * 查询用户信息</span><br><span class="line">  * @param loginName</span><br><span class="line">  * @return</span><br><span class="line">  *&#x2F;</span><br><span class="line">  User getUser(String loginName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service 接口实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements IUserService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public boolean checkUser(String loginName, String passWord) &#123;</span><br><span class="line">        return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">  public User getUser(String loginName) &#123;</span><br><span class="line">        User user &#x3D; new User();</span><br><span class="line">  user.setName(&quot;李四&quot;);</span><br><span class="line">  user.setPassword(&quot;123&quot;);</span><br><span class="line"> return user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping</span><br><span class="line">public class LoginController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">  private IUserService userService;</span><br><span class="line"></span><br><span class="line">  @PostMapping(&quot;login&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">  public AjaxResult login (@RequestBody Map&lt;String,String&gt; map)&#123;</span><br><span class="line">        String loginName &#x3D; map.get(&quot;loginName&quot;);</span><br><span class="line">  String passWord &#x3D; map.get(&quot;passWord&quot;);</span><br><span class="line">  &#x2F;&#x2F;身份验证</span><br><span class="line">  boolean isSuccess &#x3D;  userService.checkUser(loginName,passWord);</span><br><span class="line"> if (isSuccess) &#123;</span><br><span class="line">            &#x2F;&#x2F;模拟数据库查询</span><br><span class="line">  User user &#x3D; userService.getUser(loginName);</span><br><span class="line"> if (user !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;返回token</span><br><span class="line">  String token &#x3D; JwtUtil.sign(loginName, passWord);</span><br><span class="line"> if (token !&#x3D; null) &#123;</span><br><span class="line">                    return AjaxResult.success(&quot;成功&quot;,token);</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return AjaxResult.fail();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;getUser&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">  public AjaxResult getUserInfo(HttpServletRequest request, @RequestBody Map&lt;String, String&gt; map)&#123;</span><br><span class="line">        String loginName &#x3D; map.get(&quot;loginName&quot;);</span><br><span class="line">  String token &#x3D; request.getHeader(&quot;token&quot;);</span><br><span class="line"> boolean verity &#x3D; JwtUtil.verity(token);</span><br><span class="line"> if (verity) &#123;</span><br><span class="line">            User user &#x3D; userService.getUser(loginName);</span><br><span class="line"> if (user !&#x3D; null) &#123;</span><br><span class="line">                HashMap &lt;String ,Object&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">  hashMap.put(&quot;name&quot;,user.getName());</span><br><span class="line">  hashMap.put(&quot;password&quot;,user.getPassword());</span><br><span class="line"> return AjaxResult.success(&quot;成功&quot;, new JSONObject(hashMap).toString());</span><br><span class="line">  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return AjaxResult.fail();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8089</span><br><span class="line">  servlet:</span><br><span class="line">    context-path: &#x2F;milo</span><br></pre></td></tr></table></figure><p>postman进行测试<br><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/464b01dc-045d-4361-ac55-2e974b033a84.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/ea715e2d-70b6-456c-a225-8e25eda825c3.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/e7e93afb-69fd-4121-9641-7791116399ad.png" alt></p><p><img src="/2019/04/09/JWT%E5%AD%A6%E4%B9%A0/a19a5f87-30de-426b-bf9a-b6089c250f20.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Jwt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-GitLab简单操作</title>
      <link href="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-国内为什么普遍使用GitLab"><a href="#1-国内为什么普遍使用GitLab" class="headerlink" title="1 国内为什么普遍使用GitLab"></a>1 国内为什么普遍使用GitLab</h2><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">https://about.gitlab.com/</a><br>大公司有能力自己基于GitLab做二次开发，有利于将代码保存在自己手中。</p><a id="more"></a><h2 id="2-GitLab上有哪些核心功能"><a href="#2-GitLab上有哪些核心功能" class="headerlink" title="2 GitLab上有哪些核心功能"></a>2 GitLab上有哪些核心功能</h2><p>几乎包含一个项目的所有开发流程。<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/f06b4b21-3b4a-4c7b-b3a7-5ef2d7a60ce4.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/79e63bc0-48e9-4b18-bb60-1ebbc1745ace.png" alt></p><h2 id="3-GitLab如何做项目管理"><a href="#3-GitLab如何做项目管理" class="headerlink" title="3 GitLab如何做项目管理"></a>3 GitLab如何做项目管理</h2><p>主要是通过 <strong>issues</strong> 对项目进行追踪管理<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/24bbbb0d-d736-4783-90d9-c6f063636555.png" alt></p><p>也可以看仪表盘等等。</p><h2 id="4-GitLab怎样做-code-review"><a href="#4-GitLab怎样做-code-review" class="headerlink" title="4 GitLab怎样做 code review"></a>4 GitLab怎样做 code review</h2><p><strong>Merge Requests</strong></p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e0577ac-52cb-4cd8-b700-633abb8d59aa.png" alt></p><p><strong>仓库设置及变更保护</strong><br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/3f1d9ab7-f837-4b7c-a463-b3004d9a02a7.jpg" alt></p><h2 id="5-GitLab怎样保证集成质量"><a href="#5-GitLab怎样保证集成质量" class="headerlink" title="5 GitLab怎样保证集成质量"></a>5 GitLab怎样保证集成质量</h2><p>配置.gitlab-ci.yml文件 + 跑 runners</p><p><strong>GitLab</strong> 有自己的<strong>CI</strong><br>通过源文件可以查看</p><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/aa33cc03-7b0f-405e-8203-8e0ea05d0644.png" alt></p><p>在自己的项目中可以看到 Runners：就是跑CI/CD的代理，类似于管家，有了它之后，GitLab自身的CI才能运行起来、<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/834dfa86-48f3-474f-a4ca-a2cfa2e1ca68.jpg" alt></p><p>跑一套之后的效果（做一个完备的检查）<br><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a88563d3-da82-4ecc-a297-c27baf6646c7.jpg" alt></p><hr><p><img src="/2019/03/25/8-GitLab%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/39ad396c-484a-4e12-a44a-cbfdea758b81.jpg" alt></p><h2 id="6-如何把应用部署到AWS上"><a href="#6-如何把应用部署到AWS上" class="headerlink" title="6 如何把应用部署到AWS上"></a>6 如何把应用部署到AWS上</h2><p>见 GitLab Help文档</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven打Jar包-服务器运行Spring-Boot-jar</title>
      <link href="/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/"/>
      <url>/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-推荐run方式：-前后不能有空格"><a href="#1-推荐run方式：-前后不能有空格" class="headerlink" title="1 推荐run方式：(=前后不能有空格)"></a>1 推荐run方式：(=前后不能有空格)</h1><font color="red">[root@haoransun src]# nohup java -jar -Dserver.port=8888 demo-0.0.1-SNAPSHOT.jar >config.log 2>&1 &</font><h1 id="2-查看端口、进程"><a href="#2-查看端口、进程" class="headerlink" title="2 查看端口、进程"></a>2 查看端口、进程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep java</span><br><span class="line"></span><br><span class="line">netstat -anp | grep port</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="3-服务器后台运行，日志过多？"><a href="#3-服务器后台运行，日志过多？" class="headerlink" title="3 服务器后台运行，日志过多？"></a>3 服务器后台运行，日志过多？</h1><p>SpringBoot 打成的可执行jar包，想要在服务器上运行，只需要服务器有jdk即可。（<strong>SpringBoot自带Tomcat</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ***.jar  即可</span><br></pre></td></tr></table></figure><p><font color="red">仅仅如上面运行jar吗，关掉了xshell等页面，程序就会停掉。因此需要使用</font><strong>nohup</strong>对它进行后台运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar &amp; 即可</span><br></pre></td></tr></table></figure><p>可以在运行时指很多参数，如端口号等等。<strong>基本上在配置文件配置的参数都可以指定</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar --server.port&#x3D;9090 &amp;</span><br></pre></td></tr></table></figure><p>上面的程序会默认将日志打印到所在目录的nohup.out文件中。一个定时任务甚至会产生上百G的日志。我们可以指定只打印不同级别的日志。也可以利用<strong>Linux的黑洞</strong>，/dev/null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar ***.jar --server.port&#x3D;9090 &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>&amp;：代表在后台运行，当前ssh不会被锁定，当窗口关闭时，程序终止运行</strong></p><p><strong>nohup</strong>：不挂断运行，即使终端关闭，程序仍然运行**</p><h2 id="3-1-Shell-脚本—-dev-null-2-gt-amp-1-详解"><a href="#3-1-Shell-脚本—-dev-null-2-gt-amp-1-详解" class="headerlink" title="3.1 Shell 脚本—-/dev/null 2&gt;&amp;1 详解"></a>3.1 Shell 脚本—-/dev/null 2&gt;&amp;1 详解</h2><ul><li><strong>1</strong> 可以将/dev/null 看做“黑洞”，他等价于一个只写文件，所有写入它的文件都会永远丢失。而从他那读取内容则什么也没有，然而，/dev/null 对命令行和脚本都非常有用。</li></ul><p><strong>禁止标准输出</strong>： 1 cat $filename&gt;/dev/null #文件内容丢失，而不会输出的标准输出。<br><strong>禁止标准错误</strong>： 2&gt;/dev/null 错误信息被丢到了太平洋。</p><ul><li><strong>2</strong> 1&gt;/dev/null 2&gt;&amp;1含义<blockquote><p>代表重定向到哪里，例如：echo “123” &gt; /home/123.txt<br>1 表示stdout标准输出，系统默认值是1，所以”&gt;/dev/null”等同于”1&gt;/dev/null”<br>2 表示stderr标准错误<br>&amp; 表示等同于的意思，2&gt;&amp;1，表示2的输出重定向等同于1</p></blockquote></li></ul><h2 id="3-2-重定向"><a href="#3-2-重定向" class="headerlink" title="3.2 重定向"></a>3.2 重定向</h2><p>1&gt;/dev/null 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。<br>2&gt;&amp;1 接着，标准错误输出重定向等同于 标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p><ul><li><strong>3</strong> /dev/zero文件代表一个永远输出 0的设备文件，使用它作输入可以得到全为空的文件。因此可用来创建新文件和以覆盖的方式清除旧文件。</li></ul><p>下面使用dd命令将从zero设备中创建一个10K大小（bs决定每次读写1024字节，count定义读写次数为10次），但内容全为0的文件。<br>dd if=/dev/zero of=file count=10 bs=1024</p><p>最常用的方式有：</p><p>command &gt; file 2&gt;file  与command &gt; file 2&gt;&amp;1<br>首先command &gt; file 2&gt;file 的意思是将命令所产生的标准输出信息,和错误的输出信息送到file 中.command  &gt; file 2&gt;file 这样的写法,stdout和stderr都直接送到file中, file会被打开两次,这样stdout和stderr会互相覆盖,这样写相当使用了FD1和FD2两个同时去抢占file 的管道。<br>      而command &gt;file 2&gt;&amp;1 这条命令就将stdout直接送向file, stderr 继承了FD1管道后,再被送往file,此时,file 只被打开了一次,也只使用了一个管道FD1,它包括了stdout和stderr的内容。<br>      从IO效率上,前一条命令的效率要比后面一条的命令效率要低,所以在编写shell脚本的时候,较多的时候我们会command &gt; file 2&gt;&amp;1 这样的写法。</p><h2 id="3-3-三个文件状态"><a href="#3-3-三个文件状态" class="headerlink" title="3.3 三个文件状态"></a>3.3 三个文件状态</h2><p>总有三个文件处于打开状态：0：标准输入 1：标准输出 2：标准错误</p><h1 id="4-Maven打Jar包"><a href="#4-Maven打Jar包" class="headerlink" title="4  Maven打Jar包"></a>4  Maven打Jar包</h1><p><img src="/2019/03/19/Maven%E6%89%93Jar%E5%8C%85-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E8%A1%8Cjar/2b568ec5-912a-4f3b-93a3-ca1476e15403.png" alt></p><p>依赖<br>spring-boot-maven-plugin插件，并且指定 mainClass</p><h1 id="5-Maven-常用命令"><a href="#5-Maven-常用命令" class="headerlink" title="5 Maven 常用命令"></a>5 Maven 常用命令</h1><p>mvn dependency :tree 打印依赖树</p><p>mvn dependency :tree -Dverbose 显示详情</p><p>mvn dependency :analyze 分析依赖</p><h1 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6 生命周期"></a>6 生命周期</h1><p>清理-编译-测试-打包-安装-部署<br>mvn clean<br>mvn install<br>mvn package<br>跳过测试并安装<br>mvn install -Dmaven.test.skip=true</p>]]></content>
      
      
      <categories>
          
          <category> Jar包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jar包运行 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-基于GitHub进行团队协作</title>
      <link href="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
      <url>/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-创建团队项目"><a href="#1-创建团队项目" class="headerlink" title="1 创建团队项目"></a>1 创建团队项目</h2><p>先在settings中创建组织类型的托管。然后在组织中创建团队的仓库。</p><a id="more"></a><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/64446d90-2b9c-449f-a087-5f965818e04e.png" alt><br>点击 Create后出现当前画面</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e2f857e9-f884-4e0c-9add-09e13a4c4d6f.png" alt></p><p>给予不同的人不同的权限</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31adef54-e872-40b9-899a-b1de0bc43a23.png" alt></p><hr><p>创建Team</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/205f2e23-e3a9-4ef3-9ead-a885002f398b.png" alt></p><h2 id="2-选择适合自己团队的工作流"><a href="#2-选择适合自己团队的工作流" class="headerlink" title="2 选择适合自己团队的工作流"></a>2 选择适合自己团队的工作流</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a8c719c7-af57-49cd-be78-22c37ef1a453.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/20094dc9-d19f-4455-bcf6-a6cd1ba16704.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/ca8f17b4-8f25-4a4b-9f72-3fa4220767c9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/86497509-61d6-475f-9e09-644a4c11269b.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fd472e76-3fdf-41d3-99f4-cfa77888cc46.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/36620676-47e4-41be-9609-c4511a38485e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/10ed3ecd-acac-457e-862b-520139270bd8.jpg" alt></p><h2 id="3-挑选合适的分支集成策略"><a href="#3-挑选合适的分支集成策略" class="headerlink" title="3 挑选合适的分支集成策略"></a>3 挑选合适的分支集成策略</h2><p>Insights &gt;&gt; Network 中可以查看版本树的演进。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/49ab1fe1-5685-40f2-aa6c-27e585533b76.jpg" alt></p><p>集成策略：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/051f3a09-38a5-4957-9510-dfcbb34c93d2.png" alt></p><p>有的团队希望最后的历史树像<strong>一条线</strong>一样，应选择 *<em>Allow rebase merging 或者 squash *</em></p><p><font color="red"><strong>Beijing为例</strong></font></p><p><strong>Merge</strong>：特性分支合并到base分支上</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/a9ee48f2-74ca-4d36-9461-ff631b46c870.jpg" alt></p><p><strong>Squash</strong>: 特性分支不动，base分支自动添加特性分支的所有变更为1个（如特性分支上有5个commit，base分支会5合1）</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5b3df45b-80df-4c4c-93a8-81b8c641fa1a.jpg" alt></p><p><strong>Rebase</strong>: 不改变特性分支，base分支会自动添加特性分支的所有变更，且<strong>不会</strong>合成一个</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3010b401-fd66-4425-b675-4556c67cb407.jpg" alt></p><h2 id="4-启用issue跟踪需求和任务"><a href="#4-启用issue跟踪需求和任务" class="headerlink" title="4 启用issue跟踪需求和任务"></a>4 启用issue跟踪需求和任务</h2><p>选用 stars:&gt;100000 的开源项目来查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/16e07275-4d2b-402a-a50e-0648631716e4.png" alt></p><p>点击 Lables 以 标签的形式查看</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0a6cc850-3f29-4abd-b282-26daee4a2e06.png" alt></p><p>如何启用issue呢？</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfe21652-2b4e-46e1-b534-4c02ec6dd531.png" alt></p><p>建立 issue后会出现类似的文件</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/186c0666-1dfa-4ced-b588-ece60d6c9605.png" alt></p><h2 id="5-使用project管理issue"><a href="#5-使用project管理issue" class="headerlink" title="5 使用project管理issue"></a>5 使用project管理issue</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/fc10fa87-3b54-48a4-9a20-1723d6b72ed3.png" alt></p><p>不同的看板类型 显示效果不一样，以bug为例：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/1ecccc60-40dd-40be-b6ed-2befb2a266ad.png" alt></p><p>可以对任务分发，项目进度把握进行观察</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/026076bc-ccd1-4208-ae96-196c3982138e.png" alt></p><h2 id="6-项目内部如何-code-review"><a href="#6-项目内部如何-code-review" class="headerlink" title="6 项目内部如何 code review"></a>6 项目内部如何 code review</h2><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c53619b8-9fdc-4d69-8d0b-436f94468ad2.png" alt></p><p>根据需求对匹配到的不同分支做限制。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b0768be8-0078-4c68-8538-0197138b47a6.png" alt></p><p>下面做了限制，防止对远端代码造成破坏。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/2c20094b-8f8e-405c-90e5-65521154518c.png" alt></p><h2 id="7-团队协作如何做多分支的集成"><a href="#7-团队协作如何做多分支的集成" class="headerlink" title="7 团队协作如何做多分支的集成"></a>7 团队协作如何做多分支的集成</h2><p>特性分支总是有先有后的合成到base分支上，看看GitHub上是如何做</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b118050-ca7b-4d73-a633-2f02ae35ad12.jpg" alt></p><p><strong>Merge</strong>:</p><p>beijing merge 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e3a600d5-8897-42c2-bcaf-1f138379e255.jpg" alt></p><p>shanghai  也要 merge 到 base:</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/075b0539-7ff0-49aa-ba54-01f29e128bf4.jpg" alt></p><p>在线编辑解决冲突。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/770e44a3-857c-4cc6-810b-05eee2d4640c.jpg" alt></p><p>此时的代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b1137354-7eef-4570-8d51-5be16c5b72a8.jpg" alt></p><p>pull request 选择 merge 后查看代码树的变化：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfec3bde-f53e-4737-bb7a-08ff0189c793.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8d941049-4846-4bac-9876-0c50d213395a.jpg" alt></p><p>为了演示，将分支回退到之前的版本，实际上禁止这样处理</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/275f14ab-7c2e-4403-bd7b-63d28bc0ace3.jpg" alt></p><p><font color="red">此时 master 回退</font></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d645c180-1732-4ec9-a945-263f855089fa.jpg" alt></p><p><strong>Squash</strong>:</p><p>beijing  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55844bec-4ee4-4da7-aa6e-2242bf65c3db.jpg" alt></p><p>将 beijing 特性分支上做的3次变更 集成到 master分支上，且3合1<br>新生成1个commit,不会改动特性分支。</p><p>shanghai  squash 到 base后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f7b90cae-d238-40a6-8895-fb271e1f7ab9.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/55521f26-e985-4afb-bbb1-5eb2375edf5e.jpg" alt></p><p>选中后就会报错 不能自动的merge,需要手动处理冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/70de5e05-2d68-44b3-9a05-ea28bf2ab4df.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d096a3d6-a46e-4b96-99f8-03635923aa0f.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/c88f62c3-680b-49c3-b6f7-12777c634d2f.jpg" alt></p><hr><p>手动解决冲突后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5828e5a1-55a6-496c-a2f6-9b1e609e5eaa.jpg" alt></p><hr><p>冲突解决，但还没有接收时的代码树</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/69ea69db-7c60-424b-8a16-7eed94c30365.jpg" alt></p><hr><p>点击 Squash按钮后：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9db23230-b878-4b45-acf0-7fc0f9c371a5.jpg" alt></p><hr><p>查看当前代码树：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7d9e5cd9-21fe-4eff-9752-e8b9c2786ca1.jpg" alt></p><p><font color="red">master 再次回退</font></p><p>回到初始的状态：<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/d43b9b20-2748-454c-85ba-ab06784a9b30.jpg" alt></p><p><strong>Rebase</strong>:</p><p>beijing  rebase 到 base后：<br>不改变特性分支，将 beijing分支的变更如实更新到 master分支上，不做合成。</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/f84fabeb-04ca-4b79-b384-3ee85c5447ec.jpg" alt></p><p>shanghai  rebase 到 base后：<br>会发生冲突，解决冲突后但还没有接收squash：</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/babdf2f4-c1d6-475b-9f81-d33e8bbbfbf0.jpg" alt></p><p>此时 pull request 已经走到死胡同，不能再往下走了</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dc90bc8a-b9d6-4e46-99b9-46ff0b5d10cb.jpg" alt></p><p>此时 Github 已经无能为力，但团队还是坚持要用 rebase。<br>可以将 shanghai 回退到 s这个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av  &#x2F;&#x2F;确保本地分支在 s节点</span><br><span class="line">git push -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6a45a1fa-e5f2-4a3d-a427-beb97e84abb7.jpg" alt></p><p>我们应该回到ShangHai分支，让 ShangHai分支执行变基的操作，基于远端的master分支进行变基。</p><p><strong>繁琐处理：</strong><br>在本地做这件事，需要将远端的 master 拉取到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0dad0ce9-8fb5-49af-a819-02504d24859f.jpg" alt></p><p>切换到需要变基的分支，即 ShangHai分支，基于远端的 Master分支进行变基。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;master &#x2F;&#x2F;自然会报冲突 readme文件出了冲突</span><br><span class="line"></span><br><span class="line">vi readme &#x2F;&#x2F;解决冲突即可</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理</span><br><span class="line"></span><br><span class="line">vi readme</span><br><span class="line">git add .</span><br><span class="line">git rebase --continue &#x2F;&#x2F; 如果再次报冲突，继续处理，直到没有冲突</span><br><span class="line"></span><br><span class="line">git status &#x2F;&#x2F; 工作区是干净的即可</span><br><span class="line">gitk --all &#x2F;&#x2F; 查看分支树</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/31e04eb9-1c49-4316-83be-475ed0fd6e80.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/4678ec2a-0cea-4d3d-8ff2-e2708c2d1ee0.jpg" alt></p><p>继续推送即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git push origin Shanghai &#x2F;&#x2F; 会报 非 fast-forwards</span><br><span class="line"></span><br><span class="line">同分支的本地往远端推送，必须是 fast-forwards才行</span><br><span class="line"></span><br><span class="line">除非加上 -f</span><br><span class="line"></span><br><span class="line">git push  -f origin Shanghai</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/9ad43201-005f-4c37-ae62-fca6815ba55e.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/08d08193-5c71-429f-aeca-660996a4ebea.jpg" alt></p><p>此时，代码树发生了变化</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/dfde1fd2-0a28-4abe-9b15-9136dbb27095.jpg" alt></p><p>再次查看 pull request发现可以 Rebase<br>即 远端的 master分支 与 远端的 ShangHai分支处理 Fast-Forward状态，不会再有冲突</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b46166ab-7e19-4488-aae2-a2f54768c735.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f03a16a-3dae-41f5-9247-5a348f33a90f.jpg" alt></p><hr><p>有两个头像，一个是源文件的作者，一个是该文件的提交者。<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/cf7e6f21-0886-46c1-a51a-fe2f04c70abf.jpg" alt></p><p><strong>特殊处理：</strong></p><p>Git官网：找到 Documentation —&gt;&gt; Pro Git book 选择 简体中文<br><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/df38e4ff-6c68-4d2b-bc30-46d62c978bb7.png" alt></p><p>因为经过繁琐处理已经没有冲突，需要将ShangHai版本恢复到 远端 s节点继续演示</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/95fc6d9d-5048-4e44-8358-518ccc9f6b49.jpg" alt></p><p>Master 分支也需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/965989da-0f55-4cfb-bc05-7aff3973a755.jpg" alt></p><p>开启 rerere</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global rerere.enabled true</span><br><span class="line">git checkout ShangHai</span><br><span class="line">git merge master &#x2F;&#x2F;  只有看到Recorded resolution for ... 才算开始记录解决冲突的办法     当前报冲突，解决冲突</span><br><span class="line">vim readme</span><br><span class="line">git add .</span><br><span class="line">git commit -am &quot;temp&quot;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/24000499-5018-466d-8553-0d3c12da0a50.jpg" alt></p><p>因为只是为了记录解决冲突的方法，temp 这个 commit并不需要，所以需要回退</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/e0fa0fb5-c7cb-42c3-bcdb-7a4d7ec91854.jpg" alt></p><p>现在 ShangHai  等待着与 远端的 Master 做 rebase，并且使用 rerere<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8444c3f4-821d-4ea5-846e-2a784608b009.jpg" alt></p><p>基于 master(7425314) 做 rebase</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8a6e2f89-ecea-4176-ae48-843348aa2b7d.jpg" alt></p><p>虽然报了冲突，但进去 readme看后发现 冲突内容被自动解决了<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7f1a0406-9d6b-4222-876d-afd6a0d9e767.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git rebase  --continue</span><br><span class="line">vi readme &#x2F;&#x2F;冲突也没有 根据提示 添加 readme</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add readme</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git rebase  --continue</span><br><span class="line">git status  &#x2F;&#x2F;一直到不再报冲突为止</span><br><span class="line"></span><br><span class="line">git log -n5  &#x2F;&#x2F; 查看commit是否如实更新上去</span><br></pre></td></tr></table></figure><h2 id="8-如何保证集成质量"><a href="#8-如何保证集成质量" class="headerlink" title="8 如何保证集成质量"></a>8 如何保证集成质量</h2><p>通过 settings 中的 各种保险设置进行控制</p><p>也可在 市场中搜索各种 插件 APP 进行集成管控自己的代码。</p><h2 id="9-产品如何发布到GitHub上"><a href="#9-产品如何发布到GitHub上" class="headerlink" title="9 产品如何发布到GitHub上"></a>9 产品如何发布到GitHub上</h2><p><strong>Release</strong><br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/83c9516e-1095-4441-adcb-fb43d32f54e9.png" alt></p><p>如果是以 travis为例，需要在 .travis.yml文件中编写deploy的各种配置<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/88dbd0f3-6076-4eb1-9195-d55b17dffd1d.jpg" alt></p><hr><p>api_key 不能暴露， 通过变量方式获取<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/3b822c8e-5eef-4bb5-a123-879c578f650a.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/434cac1a-1033-4a93-b1e4-2b15e43e3e99.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/5a4f266e-313d-40fb-a626-d64e1f6b7996.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7cad2344-3d21-445e-a558-9cbe2cc12142.jpg" alt></p><p>name 是yml文件中的变量名称</p><p>value 在如下图中：在个人 setting 的 token中</p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/b568e180-66fc-4606-9fe2-891c81a305a1.jpg" alt></p><hr><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/8042988e-13b1-4398-99ae-b54c5a8e7d97.jpg" alt></p><hr><p>pull request merge到主分支</p><p>经过 travis ci 各种审查后，点击 release即可看到<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/6fde5cb5-4e6e-4894-8079-6426d91dd358.jpg" alt></p><p>即通过 travis ci 通过 配置 travis.yml文件 将 java 工程部署到GitHub的 release中，期间要配置Token。</p><h2 id="10-如何给项目添加详细的指导文档-Wiki"><a href="#10-如何给项目添加详细的指导文档-Wiki" class="headerlink" title="10 如何给项目添加详细的指导文档 (Wiki)"></a>10 如何给项目添加详细的指导文档 (Wiki)</h2><p><strong>GitHub提供了 Wiki 功能</strong></p><p><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/0b05b38d-5d3a-49b4-a38e-82c28270a5a1.jpg" alt></p><p>挑选别的开源项目中 wiki写的比较好的 下载下来，推送到自己的项目中才能进行各种 edit。</p><p>此时远端的 wiki 中 会出现别人的 wiki<br><img src="/2019/03/09/7-%E5%9F%BA%E4%BA%8EGitHub%E8%BF%9B%E8%A1%8C%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/7a33688d-e6b3-4177-9b88-0c9a405dbe47.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-GitHub的认识与使用</title>
      <link href="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-GitHub为什么会火"><a href="#1-GitHub为什么会火" class="headerlink" title="1 GitHub为什么会火"></a>1 GitHub为什么会火</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/53d51f84-9a62-4dde-9be4-7cbb9d0b1dae.jpg" alt></p><a id="more"></a><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/fbc94ced-1d7f-4a8d-9efb-22dbc218846e.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/7dbd21e1-01d8-4279-b7dd-0b5735565315.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/68ad18d1-6b50-49fb-82cb-0c64ea04cd9d.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a0c7cf11-f98f-40e9-9a73-b965ec8584c5.jpg" alt></p><h2 id="2-GitHub都有哪些核心功能"><a href="#2-GitHub都有哪些核心功能" class="headerlink" title="2 GitHub都有哪些核心功能"></a>2 GitHub都有哪些核心功能</h2><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/89cbfdee-4587-495e-82eb-983f400ed9cc.png" alt></p><hr><p><strong>CI/CD</strong>：持续集成Continuous Integration（CI）和持续交付Continuous Delivery（CD）</p><p><strong>安全开发</strong><br><strong>代码审查</strong><br><strong>应用程序</strong><br><strong>托管代码</strong><br><strong>项目管理</strong><br><strong>团队管理</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/3cb0ab88-815b-4ad4-9c5b-89f1b59abea5.png" alt></p><h2 id="3-怎么快速淘到感兴趣的开源项目"><a href="#3-怎么快速淘到感兴趣的开源项目" class="headerlink" title="3 怎么快速淘到感兴趣的开源项目"></a>3 怎么快速淘到感兴趣的开源项目</h2><p>通过搜索匹配<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4b02d18e-520c-411a-8f1b-3d38afb83285.png" alt></p><p>或者使用<strong>高级搜索</strong></p><p><strong>git 最好学习资料 in:readme stars:&gt;1000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a7f07365-78c6-4406-bc0e-a8badd887228.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8d66d247-f9d2-4b44-9809-f0ff9af00b91.png" alt></p><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/e0a543a9-3b11-4b7b-94e2-71cb628b8f7f.png" alt></p><p>如果不登录去搜索的话，code 后会跟着 ？ 提示必须登录后才能享受代码的功能</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/1511493f-8f4e-4be8-8bb2-e91d1313ea5c.png" alt></p><h2 id="4-怎样在GitHub上搭建个人博客"><a href="#4-怎样在GitHub上搭建个人博客" class="headerlink" title="4 怎样在GitHub上搭建个人博客"></a>4 怎样在GitHub上搭建个人博客</h2><p><strong>blob easily start in:readme stars:&gt;5000</strong></p><p>此处以 <a href="https://github.com/barryclark" target="_blank" rel="noopener">barryclark</a>/<strong><a href="https://github.com/barryclark/jekyll-now" target="_blank" rel="noopener">jekyll-now</a></strong> 为例进行搭建。</p><p>按照步骤</p><ol><li>fork 到自己的仓库中，然后修改仓库名字</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4e3677f9-8877-40b8-86bf-dfbf3e6e56c6.png" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/839c82a3-253a-436a-aa2c-2b8df57bc2c3.png" alt></p><ol start="2"><li>修改配置文件</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/42ba975b-f1b0-4736-ae7a-3dda0f2493ce.png" alt></p><p>根据需求自己做调整</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2d59fd09-1072-47de-bc65-8fd2e7b06287.png" alt></p><ol start="3"><li>修改_post文件</li></ol><p>可以直接修改 2014-3-3-Hello-World.md 文件<br>或者<br>Create new file 文件<br><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/0b11316b-70c3-40bc-91ad-6bf75f768c45.png" alt></p><ol start="4"><li>有效日期+标题 2018-12-24-HaoRan-First-Blob.md</li></ol><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/a8784c54-f7a4-42bf-a3e0-9499b47a336b.png" alt></p><p>5.域名在settings中查找</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/6ff2ad0f-c4c6-47da-85bd-4e5486d8b547.png" alt></p><p>6.个人Blob展示</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/71e8cffb-3861-4936-a53e-66ce6f73d2a4.png" alt></p><h2 id="5-开源项目怎么保证代码质量"><a href="#5-开源项目怎么保证代码质量" class="headerlink" title="5 开源项目怎么保证代码质量"></a>5 开源项目怎么保证代码质量</h2><p>进入GitHub主页，点击 pull request</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/5b9b398f-0281-48b8-a47e-fb6ec287203d.jpg" alt></p><p>被merge吸纳的是紫色的，被拒绝的是红色的</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/4289a643-491e-4fd5-b8d0-462039459ff2.jpg" alt></p><p>可以看到，有代码审查，有智能监测，owner在做了一系列检查后，才决定是否将他人的request merge到 master上来。</p><h2 id="6-为何需要组织类型的仓库"><a href="#6-为何需要组织类型的仓库" class="headerlink" title="6 为何需要组织类型的仓库"></a>6 为何需要组织类型的仓库</h2><p>在个人 porfile中 会有组织这种类型的仓库。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/8aa1d29e-38ec-447a-9442-a772f0d0ef97.jpg" alt></p><p>举一个例子：<br>现阶段，我可能在A公司工作，A公司有一些公共开源的项目在GitHub上托管。过段时间，又加入到B公司的开源项目中工作。根据组织的成员也在流动中，所以需要组织类型的仓库对成员进行管理。</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/cf97a418-e69a-4362-aa8c-dd3232217ec2.jpg" alt></p><hr><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f55a9a52-345a-4102-bc92-04ef177994db.jpg" alt></p><p><strong>邀请成员</strong></p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/f18431a3-248e-4591-b865-8adb5025ae98.jpg" alt></p><p><strong>Team</strong>可以对仓库进行精细化的管控</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/2c3267ca-ec77-4685-a2a0-49e63e697928.jpg" alt></p><p>可以加入教师团队的人员</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/32809d24-79a6-47e3-8abe-dcafff4219d9.jpg" alt></p><p>可以给人员分配仓库不同的权限</p><p><img src="/2019/02/25/6-GitHub%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E4%BD%BF%E7%94%A8/142f6b99-9f3e-49e6-8dd1-fe543d886344.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-Git集成使用禁忌</title>
      <link href="/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/"/>
      <url>/2019/02/15/5-Git%E9%9B%86%E6%88%90%E4%BD%BF%E7%94%A8%E7%A6%81%E5%BF%8C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-禁止向集成分支执行push-f-操作"><a href="#1-禁止向集成分支执行push-f-操作" class="headerlink" title="1.禁止向集成分支执行push -f 操作"></a>1.禁止向集成分支执行push -f 操作</h2><p><strong>git push -f：会强制推送，对团队造成危害（虽然远程仓库有特殊机制制止这种变更）</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline</span><br><span class="line">git reset --hard 回退到某个古老的ID号</span><br><span class="line">git push -f &#x2F;&#x2F;会销毁远端最新最近的提交，所以禁止执行这个命令</span><br></pre></td></tr></table></figure><h2 id="2-禁止向集成分支执行变更历史的操作"><a href="#2-禁止向集成分支执行变更历史的操作" class="headerlink" title="2.禁止向集成分支执行变更历史的操作"></a>2.禁止向集成分支执行变更历史的操作</h2><p>团队协同工作时，<strong>公共分支严禁拉取到本地做rebase变基活动的</strong>，公共分支是团队一起一天天积累下来的，只能往前走，不能做历史变更。</p><p><strong>集成分支不能被改变历史</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内地图坐标系转换</title>
      <link href="/2019/02/08/%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/02/08/%E5%9B%BD%E5%86%85%E5%9C%B0%E5%9B%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>文章出处<br><a href="https://blog.csdn.net/m0_37738114/article/details/80452485" target="_blank" rel="noopener">https://blog.csdn.net/m0_37738114/article/details/80452485</a></p><h2 id="一、国内常用坐标系"><a href="#一、国内常用坐标系" class="headerlink" title="一、国内常用坐标系"></a>一、国内常用坐标系</h2><p>1、WGS-84坐标系：地心坐标系，GPS原始坐标体系<br>在中国，任何一个地图产品都<font color="red">不允许使用<a href="https://www.baidu.com/s?wd=GPS%E5%9D%90%E6%A0%87&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">GPS坐标</a></font>，据说是为了保密。</p><p>2、GCJ-02 坐标系：国测局坐标，火星坐标系<br>1）国测局02年发布的坐标体系，它是一种对经纬度数据的加密算法，即加入随机的偏差。<br>2）互联网地图在国内必须至少使用GCJ-02进行首次加密，不允许直接使用WGS-84坐标下的地理数据，同时任何坐标系均不可转换为WGS-84坐标。<br>3）是国内最广泛使用的坐标体系，高德、腾讯、Google中国地图都使用它。</p><p>3、CGCS2000坐标系：国家大地坐标系<br>该坐标系是通过中国GPS 连续运行基准站、 空间大地控制网以及天文大地网与空间地网联合平差建立的地心大地坐标系统。</p><p>4、BD-09坐标系<br>百度中国地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><a id="more"></a><p>5、搜狗坐标系<br>搜狗地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><p>6、图吧坐标系<br>图吧地图所采用的坐标系，由GCJ-02进行进一步的偏移算法得到。</p><h2 id="二、国内地图软件所采用的坐标系简介"><a href="#二、国内地图软件所采用的坐标系简介" class="headerlink" title="二、国内地图软件所采用的坐标系简介"></a>二、国内地图软件所采用的坐标系简介</h2><table>    <tr>        <td>1、百度地图1）境内（包括港澳台）：BD09a、在GCJ-02坐标系基础上再次加密b、支持WGS-84、GCJ-02转换成BD09，反向不支持，并且批量转换一次有条数限制2）境外：WGS-84</td>        <td>2、高德地图:1）境内：GCJ-02a、WGS-84——>GCJ-02（高德有接口提供，反过来没有）2）境外：暂不支持3）AMap 就是高德地图，是高德地图在纳斯达克上市用的名字，主要面向互联网企业或个人提供免费API服务4）MapABC 是高德集团底下的图盟公司，主要面向大众型企业或政府机关，并提供付费的有偿服务5）Amap和MapABC，数据和服务都是共享的，所以Mapabc用Amap的API是正常的</td>    </tr>    <tr>        <td>3、google地图1）境内：GCJ-02a、数据来源于高德，两者互通2）境外：WGS-84</td>        <td>4、天地图全球统一：CGCS2000</td>    </tr>    <tr>        <td>5、腾讯地图：soso地图境内：GCJ02</td>        <td>6、微软bing地图：BingMap全球统一：WGS-84</td>    </tr>    <tr>        <td>7、搜狗地图境内：搜狗坐标系a、在GCJ-02坐标系基础上再次加密b、支持WGS-84、GCJ-02、BD09转换成搜狗坐标，反向不支持</td>        <td>8、图吧地图: MapBar境内：图吧坐标系a、在GCJ-02坐标系基础上再次加密</td>    </tr>    <tr>        <td>9、阿里云地图境内：GCJ-02</td>        <td>10、灵图地图：51ditu境内：GCJ-02</td>    </tr></table><h2 id="三、各个坐标系之间的转换"><a href="#三、各个坐标系之间的转换" class="headerlink" title="三、各个坐标系之间的转换"></a>三、各个坐标系之间的转换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">1、以下代码，提供的转换算法如下：</span><br><span class="line">1）WGS-84 ——&gt; GCJ02</span><br><span class="line">2）GCJ02 ——&gt; WGS-84</span><br><span class="line">3）GCJ02 ——&gt; BD09</span><br><span class="line">4）BD09 ——&gt; GCJ02</span><br><span class="line">5）BD09 ——&gt; WGS-84</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.   package com.xy;  </span><br><span class="line">2.</span><br><span class="line">3.   &#x2F;** </span><br><span class="line">4.    * 各地图API坐标系统比较与转换; </span><br><span class="line">5.    * WGS84坐标系：即地球坐标系，国际上通用的坐标系。设备一般包含GPS芯片或者北斗芯片获取的经纬度为WGS84地理坐标系, </span><br><span class="line">6.    * 谷歌地图采用的是WGS84地理坐标系（中国范围除外）; </span><br><span class="line">7.    * GCJ02坐标系：即火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。 </span><br><span class="line">8.    * 谷歌中国地图和搜搜中国地图采用的是GCJ02地理坐标系; BD09坐标系：即百度坐标系，GCJ02坐标系经加密后的坐标系; </span><br><span class="line">9.    * 搜狗坐标系、图吧坐标系等，估计也是在GCJ02基础上加密而成的。  </span><br><span class="line">10.  *&#x2F;  </span><br><span class="line"></span><br><span class="line">11. public class PositionUtil &#123;  </span><br><span class="line">12.       </span><br><span class="line">13.     public static final String BAIDU_LBS_TYPE &#x3D; &quot;bd09ll&quot;;  </span><br><span class="line">14.       </span><br><span class="line">15.     public static double pi &#x3D; 3.1415926535897932384626;  </span><br><span class="line">16.     public static double a &#x3D; 6378245.0;  </span><br><span class="line">17.     public static double ee &#x3D; 0.00669342162296594323;  </span><br><span class="line">18.   </span><br><span class="line">19.     &#x2F;** </span><br><span class="line">20.      * 84 to 火星坐标系 (GCJ-02) World Geodetic System &#x3D;&#x3D;&gt; Mars Geodetic System </span><br><span class="line">21.      *  </span><br><span class="line">22.      * @param lat </span><br><span class="line">23.      * @param lon </span><br><span class="line">24.      * @return </span><br><span class="line">25.      *&#x2F;  </span><br><span class="line">26.     public static Gps gps84_To_Gcj02(double lat, double lon) &#123;  </span><br><span class="line">27.         if (outOfChina(lat, lon)) &#123;  </span><br><span class="line">28.             return null;  </span><br><span class="line">29.         &#125;  </span><br><span class="line">30.         double dLat &#x3D; transformLat(lon - 105.0, lat - 35.0);  </span><br><span class="line">31.         double dLon &#x3D; transformLon(lon - 105.0, lat - 35.0);  </span><br><span class="line">32.         double radLat &#x3D; lat &#x2F; 180.0 * pi;  </span><br><span class="line">33.         double magic &#x3D; Math.sin(radLat);  </span><br><span class="line">34.         magic &#x3D; 1 - ee * magic * magic;  </span><br><span class="line">35.         double sqrtMagic &#x3D; Math.sqrt(magic);  </span><br><span class="line">36.         dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * pi);  </span><br><span class="line">37.         dLon &#x3D; (dLon * 180.0) &#x2F; (a &#x2F; sqrtMagic * Math.cos(radLat) * pi);  </span><br><span class="line">38.         double mgLat &#x3D; lat + dLat;  </span><br><span class="line">39.         double mgLon &#x3D; lon + dLon;  </span><br><span class="line">40.         return new Gps(mgLat, mgLon);  </span><br><span class="line">41.     &#125;  </span><br><span class="line">42.   </span><br><span class="line"></span><br><span class="line">43.     &#x2F;** </span><br><span class="line">44.      * * 火星坐标系 (GCJ-02) to 84 * * @param lon * @param lat * @return </span><br><span class="line">45.      * *&#x2F;  </span><br><span class="line">46.     public static Gps gcj_To_Gps84(double lat, double lon) &#123;  </span><br><span class="line">47.         Gps gps &#x3D; transform(lat, lon);  </span><br><span class="line">48.         double lontitude &#x3D; lon * 2 - gps.getWgLon();  </span><br><span class="line">49.         double latitude &#x3D; lat * 2 - gps.getWgLat();  </span><br><span class="line">50.         return new Gps(latitude, lontitude);  </span><br><span class="line">51.     &#125;  </span><br><span class="line">52.   </span><br><span class="line"></span><br><span class="line">53.     &#x2F;** </span><br><span class="line">54.      * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 将 GCJ-02 坐标转换成 BD-09 坐标 </span><br><span class="line">55.      *  </span><br><span class="line">56.      * @param gg_lat </span><br><span class="line">57.      * @param gg_lon </span><br><span class="line">58.      *&#x2F;  </span><br><span class="line">59.     public static Gps gcj02_To_Bd09(double gg_lat, double gg_lon) &#123;  </span><br><span class="line">60.         double x &#x3D; gg_lon, y &#x3D; gg_lat;  </span><br><span class="line">61.         double z &#x3D; Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * pi);  </span><br><span class="line">62.         double theta &#x3D; Math.atan2(y, x) + 0.000003 * Math.cos(x * pi);  </span><br><span class="line">63.         double bd_lon &#x3D; z * Math.cos(theta) + 0.0065;  </span><br><span class="line">64.         double bd_lat &#x3D; z * Math.sin(theta) + 0.006;  </span><br><span class="line">65.         return new Gps(bd_lat, bd_lon);  </span><br><span class="line">66.     &#125;  </span><br><span class="line"></span><br><span class="line">67.   </span><br><span class="line">68.     &#x2F;** </span><br><span class="line">69.      * * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换算法 * * 将 BD-09 坐标转换成GCJ-02 坐标 * * @param </span><br><span class="line">70.      * bd_lat * @param bd_lon * @return </span><br><span class="line">71.      *&#x2F;  </span><br><span class="line">72.     public static Gps bd09_To_Gcj02(double bd_lat, double bd_lon) &#123;  </span><br><span class="line">73.         double x &#x3D; bd_lon - 0.0065, y &#x3D; bd_lat - 0.006;  </span><br><span class="line">74.         double z &#x3D; Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * pi);  </span><br><span class="line">75.         double theta &#x3D; Math.atan2(y, x) - 0.000003 * Math.cos(x * pi);  </span><br><span class="line">76.         double gg_lon &#x3D; z * Math.cos(theta);  </span><br><span class="line">77.         double gg_lat &#x3D; z * Math.sin(theta);  </span><br><span class="line">78.         return new Gps(gg_lat, gg_lon);  </span><br><span class="line">79.     &#125;  </span><br><span class="line"></span><br><span class="line">80.   </span><br><span class="line"></span><br><span class="line">81.     &#x2F;** </span><br><span class="line">82.      * (BD-09)--&gt;84 </span><br><span class="line">83.      * @param bd_lat </span><br><span class="line">84.      * @param bd_lon </span><br><span class="line">85.      * @return </span><br><span class="line">86.      *&#x2F;  </span><br><span class="line"></span><br><span class="line">87.     public static Gps bd09_To_Gps84(double bd_lat, double bd_lon) &#123;  </span><br><span class="line">88.   </span><br><span class="line">89.         Gps gcj02 &#x3D; PositionUtil.bd09_To_Gcj02(bd_lat, bd_lon);  </span><br><span class="line">90.         Gps map84 &#x3D; PositionUtil.gcj_To_Gps84(gcj02.getWgLat(),  </span><br><span class="line">91.                 gcj02.getWgLon());  </span><br><span class="line">92.         return map84;  </span><br><span class="line">93.   </span><br><span class="line">94.     &#125;  </span><br><span class="line"></span><br><span class="line">95.   </span><br><span class="line">96.     public static boolean outOfChina(double lat, double lon) &#123;  </span><br><span class="line">97.         if (lon &lt; 72.004 || lon &gt; 137.8347)  </span><br><span class="line">98.             return true;  </span><br><span class="line">99.         if (lat &lt; 0.8293 || lat &gt; 55.8271)  </span><br><span class="line">100.              return true;  </span><br><span class="line">101.          return false;  </span><br><span class="line">102.      &#125;  </span><br><span class="line">103.    </span><br><span class="line">104.      public static Gps transform(double lat, double lon) &#123;  </span><br><span class="line">105.          if (outOfChina(lat, lon)) &#123;  </span><br><span class="line">106.              return new Gps(lat, lon);  </span><br><span class="line">107.          &#125;  </span><br><span class="line">108.          double dLat &#x3D; transformLat(lon - 105.0, lat - 35.0);  </span><br><span class="line">109.          double dLon &#x3D; transformLon(lon - 105.0, lat - 35.0);  </span><br><span class="line">110.          double radLat &#x3D; lat &#x2F; 180.0 * pi;  </span><br><span class="line">111.          double magic &#x3D; Math.sin(radLat);  </span><br><span class="line">112.          magic &#x3D; 1 - ee * magic * magic;  </span><br><span class="line">113.          double sqrtMagic &#x3D; Math.sqrt(magic);  </span><br><span class="line">114.          dLat &#x3D; (dLat * 180.0) &#x2F; ((a * (1 - ee)) &#x2F; (magic * sqrtMagic) * pi);  </span><br><span class="line">115.          dLon &#x3D; (dLon * 180.0) &#x2F; (a &#x2F; sqrtMagic * Math.cos(radLat) * pi);  </span><br><span class="line">116.          double mgLat &#x3D; lat + dLat;  </span><br><span class="line">117.          double mgLon &#x3D; lon + dLon;  </span><br><span class="line">118.          return new Gps(mgLat, mgLon);  </span><br><span class="line">119.      &#125;  </span><br><span class="line">120.    </span><br><span class="line">121.      public static double transformLat(double x, double y) &#123;  </span><br><span class="line">122.          double ret &#x3D; -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y  </span><br><span class="line">123.                  + 0.2 * Math.sqrt(Math.abs(x));  </span><br><span class="line">124.          ret +&#x3D; (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">125.          ret +&#x3D; (20.0 * Math.sin(y * pi) + 40.0 * Math.sin(y &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">126.          ret +&#x3D; (160.0 * Math.sin(y &#x2F; 12.0 * pi) + 320 * Math.sin(y * pi &#x2F; 30.0)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">127.          return ret;  </span><br><span class="line">128.      &#125;  </span><br><span class="line">129.    </span><br><span class="line">130.      public static double transformLon(double x, double y) &#123;  </span><br><span class="line">131.          double ret &#x3D; 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1  </span><br><span class="line">132.                  * Math.sqrt(Math.abs(x));  </span><br><span class="line">133.          ret +&#x3D; (20.0 * Math.sin(6.0 * x * pi) + 20.0 * Math.sin(2.0 * x * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">134.          ret +&#x3D; (20.0 * Math.sin(x * pi) + 40.0 * Math.sin(x &#x2F; 3.0 * pi)) * 2.0 &#x2F; 3.0; </span><br><span class="line">135.          ret +&#x3D; (150.0 * Math.sin(x &#x2F; 12.0 * pi) + 300.0 * Math.sin(x &#x2F; 30.0  </span><br><span class="line">136.                  * pi)) * 2.0 &#x2F; 3.0;  </span><br><span class="line">137.          return ret;  </span><br><span class="line">138.      &#125;  </span><br><span class="line">139.    </span><br><span class="line">140.      public static void main(String[] args) &#123;  </span><br><span class="line">141.    </span><br><span class="line">142.          &#x2F;&#x2F; 北斗芯片获取的经纬度为WGS84地理坐标 31.426896,119.496145  </span><br><span class="line">143.          Gps gps &#x3D; new Gps(31.426896, 119.496145);  </span><br><span class="line">144.          System.out.println(&quot;gps :&quot; + gps);  </span><br><span class="line">145.          Gps gcj &#x3D; gps84_To_Gcj02(gps.getWgLat(), gps.getWgLon());  </span><br><span class="line">146.          System.out.println(&quot;gcj :&quot; + gcj);  </span><br><span class="line">147.          Gps star &#x3D; gcj_To_Gps84(gcj.getWgLat(), gcj.getWgLon());  </span><br><span class="line">148.          System.out.println(&quot;star:&quot; + star);  </span><br><span class="line">149.          Gps bd &#x3D; gcj02_To_Bd09(gcj.getWgLat(), gcj.getWgLon());  </span><br><span class="line">150.          System.out.println(&quot;bd  :&quot; + bd);  </span><br><span class="line">151.          Gps gcj2 &#x3D; bd09_To_Gcj02(bd.getWgLat(), bd.getWgLon());  </span><br><span class="line">152.          System.out.println(&quot;gcj :&quot; + gcj2);  </span><br><span class="line">153.      &#125;  </span><br><span class="line">154.  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">2、百度在线转换API</span><br><span class="line">1.   http:&#x2F;&#x2F;api.map.baidu.com&#x2F;ag&#x2F;coord&#x2F;convert?from&#x3D;0&amp;to&#x3D;4&amp;x&#x3D;longitude&amp;y&#x3D;latitude   </span><br><span class="line">2.   from: 来源坐标系   （0表示WGS-84坐标，2表示GCJ-02坐标）  </span><br><span class="line">3.   to: 转换后的坐标  (4就是百度自己啦，这个必须是4才行）  </span><br><span class="line">4.   x: 精度  </span><br><span class="line">5.   y: 纬度</span><br><span class="line">得到的经纬度需要进一步转换才能得到BD-09坐标</span><br><span class="line">1.   import java.io.BufferedReader;  </span><br><span class="line">2.   import java.io.IOException;  </span><br><span class="line">3.   import java.io.InputStream;  </span><br><span class="line">4.   import java.io.InputStreamReader;  </span><br><span class="line">5.   import java.io.OutputStreamWriter;  </span><br><span class="line">6.   import java.net.URL;  </span><br><span class="line">7.   import java.net.URLConnection;  </span><br><span class="line">8.   import com.sun.org.apache.xerces.internal.impl.dv.util.Base64;  </span><br><span class="line">9.   public class BaiduAPIConverter extends Thread &#123;  </span><br><span class="line">10.   public static void testPost(String x, String y) throws IOException &#123;  </span><br><span class="line">11.     try &#123;  </span><br><span class="line">12.       URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;api.map.baidu.com&#x2F;ag&#x2F;coord&#x2F;convert?from&#x3D;2&amp;to&#x3D;4&amp;x&#x3D;&quot;+ </span><br><span class="line">13.                                        x + &quot;&amp;y&#x3D;&quot; + y);  </span><br><span class="line">14.       URLConnection connection &#x3D; url.openConnection();  </span><br><span class="line">15.       connection.setDoOutput(true);  </span><br><span class="line">16.       OutputStreamWriter out &#x3D; new OutputStreamWriter(connection.getOutputStream(), &quot;utf-8&quot;);  </span><br><span class="line">17.       &#x2F;&#x2F; remember to clean up   </span><br><span class="line">18.       out.flush();  </span><br><span class="line">19.       out.close();  </span><br><span class="line">20.       &#x2F;&#x2F; 一旦发送成功，用以下方法就可以得到服务器的回应：   </span><br><span class="line">21.       String sCurrentLine, sTotalString;  </span><br><span class="line">22.       sCurrentLine &#x3D; sTotalString &#x3D; &quot;&quot;;  </span><br><span class="line">23.       InputStream l_urlStream;  </span><br><span class="line">24.       l_urlStream &#x3D; connection.getInputStream();  </span><br><span class="line">25.       BufferedReader l_reader &#x3D; new BufferedReader(new InputStreamReader(l_urlStream));  </span><br><span class="line">26.       while ((sCurrentLine &#x3D; l_reader.readLine()) !&#x3D; null) &#123;  </span><br><span class="line">27.         if (!sCurrentLine.equals(&quot;&quot;))  </span><br><span class="line">28.           sTotalString +&#x3D; sCurrentLine;  </span><br><span class="line">29.       &#125;  </span><br><span class="line">30.       sTotalString &#x3D; sTotalString.substring(1, sTotalString.length() - 1);  </span><br><span class="line">31.       String[] results &#x3D; sTotalString.split(&quot;\\,&quot;);  </span><br><span class="line"></span><br><span class="line">32.       if (results.length &#x3D;&#x3D; 3) &#123;  </span><br><span class="line">33.         if (results[0].split(&quot;\\:&quot;)[1].equals(&quot;0&quot;)) &#123;  </span><br><span class="line">34.           String mapX &#x3D; results[1].split(&quot;\\:&quot;)[1];  </span><br><span class="line">35.           String mapY &#x3D; results[2].split(&quot;\\:&quot;)[1];  </span><br><span class="line">36.           mapX &#x3D; mapX.substring(1, mapX.length() - 1);  </span><br><span class="line">37.           mapY &#x3D; mapY.substring(1, mapY.length() - 1);  </span><br><span class="line">38.           mapX &#x3D; new String(Base64.decode(mapX));  </span><br><span class="line">39.           mapY &#x3D; new String(Base64.decode(mapY));  </span><br><span class="line">40.           System.out.println(&quot;\t&quot; + mapX + &quot;\t&quot; + mapY);  </span><br><span class="line">41.         &#125;  </span><br><span class="line">42.       &#125;  </span><br><span class="line">43.      sleep(10000);  </span><br><span class="line">44.     &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">45.       &#x2F;&#x2F; TODO Auto-generated catch block   </span><br><span class="line">46.       e.printStackTrace();  </span><br><span class="line">47.     &#125;  </span><br><span class="line">48.   &#125;  </span><br><span class="line">49.   &#x2F;** </span><br><span class="line">50.    * @param args </span><br><span class="line">51.    * @throws IOException </span><br><span class="line">52.    *&#x2F;  </span><br><span class="line">53.   public static void main(String[] args) throws IOException &#123;  </span><br><span class="line">54.     testPost(&quot;120.151379&quot;, &quot;30.184678&quot;);  </span><br><span class="line">55.     System.out.println(&quot;ok&quot;);  </span><br><span class="line">56.   &#125;  </span><br><span class="line">57. &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">3、百度地图获取WGS-84坐标</span><br><span class="line"></span><br><span class="line">在百度地图中取得WGS-84坐标，调用如下方法：</span><br><span class="line">BMapManager.getLocationManager().setLocationCoordinateType(</span><br><span class="line"></span><br><span class="line">MKLocationManager.MK_COORDINATE_WGS84);</span><br><span class="line">这样从百度api中取得的坐标就是WGS-84了，可是这种坐标如果显示到百度地图上就会偏移，也就是说取出一个坐标，原封不动的显示上去就偏移了，所以为了显示也是正常就需要在绘制到百度地图上之前转换成BD-09。</span><br><span class="line">转换成BD-09，调用方法：</span><br><span class="line">  GeoPoint wgs84;</span><br><span class="line">GeoPoint bd09 &#x3D; CoordinateConvert.bundleDecode(CoordinateConvert.fromWgs84ToBaidu(wgs84))；</span><br><span class="line">这里实在不明白为何要设计成CoordinateConvert.fromWgs84ToBaidu(wgs84)返回了一个Bundle，所以还需要CoordinateConvert.bundleDecode()再转成GeoPoint。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4、CGCS2000坐标与WGS-84坐标的转换</span><br><span class="line"></span><br><span class="line">CGCS2000与WGS84的基本定义是一致的，采用的参考椭球非常相近，椭球常数中仅扁率有细微差别，虽然因此会造成同一点在两个坐标系中的值会有微小差异，但是，在当前测量精度水平下这种微小差值是可以忽略的，因此，可以认为CGCS2000和WGS84是相容的，在坐标系的实现精度范围内两种坐标系下的坐标是一致的。</span><br><span class="line"></span><br><span class="line">另一方面，由于两者本身就不是由彼此加密或者解密就可以得到的关系，所以转换的算法十分复杂。通常采用工具软件来进行转换，如ArcGIS、BIGEMAP等。</span><br></pre></td></tr></table></figure><h2 id="四、取自一段大神的总结"><a href="#四、取自一段大神的总结" class="headerlink" title="四、取自一段大神的总结"></a>四、取自一段大神的总结</h2><p>采用自家坐标体系，而不采用国内通用的火星坐标体系，实在是自寻短处。当然，百度是因为做的足够大、足够好，所以很霸道，也为以后一统天下而不让别人瓜分之而做准备吧。搜狗虽然用自家坐标体系，但能将地球坐标直接导入，此举也属唯一。而图吧地图不知道学什么加密方式，以前用地球坐标用的好好的，现在用图吧自己的坐标，难道是因为给百度做过所以也来了这么一招？或者沿用百度？不得而知。</p><p>做地图开发的时候，不希望被一家地图API迁就，所以采用火星坐标GCJ-02是正确的选择，希望本文能够对选择使用谁家API的开发者提供一点帮助吧。就我个人而言，我绝不会使用非火星坐标系统的地图API，虽然百度地图API很好很强大确实很吸引我。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 地图坐标转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-Git多人单分支集成协作时的常见场景</title>
      <link href="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-不同人修改不同文件如何处理"><a href="#1-不同人修改不同文件如何处理" class="headerlink" title="1.不同人修改不同文件如何处理"></a>1.不同人修改不同文件如何处理</h2><p><strong>JavaSsun用户修改 readme文件</strong><br><strong>haoran用户修改index文件</strong><br><strong>远端仓库新建一个名字为 feature/add_git_commands的分支</strong></p><p>为了在单机模拟两个人做操作，需要从远端克隆一个 命名为 git_learning_02 以 JavaSsun为用户的仓库</p><a id="more"></a><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/462c8fe6-41e9-448d-811b-af9aea07d29f.png" alt></p><p>再变更email</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/64daaa82-8983-411c-914a-61cc63b451e5.png" alt></p><p>基于远端刚才新建的分支在本地新建一个分支，并切换到该分支上（二者联系起来）</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/cc5a524a-5f7e-4b81-8c97-b773ac2f3224.png" alt></p><p>JavaSsun在git_learning_02仓库中修改readme文件，commit后 推送到远端仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push   即可（为什么不用加分支名了呢，因为上面命令中本地分支与远端分支做了关联）</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/0c2fe061-aebc-4a6e-ad4e-e191f9c57912.png" alt></p><p>远端仓库也有了最新的变更</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/c8d976b1-c8ee-4e78-900b-d01fe34540d4.png" alt></p><p><strong>至此，JavaSsun开发人员修改完了readme，并提交到了远程仓库。</strong></p><p>切换到haoran所属的git_learning 仓库，查看后发现没有 feature/add_git_commands分支，需要拉取下来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git fetch github</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/16f7fea5-27cc-43cc-b7cc-1ed31bc51048.png" alt></p><p>将本地新建分支并与远端的分支做关联（名字最好一致，并查看hash值后发现确实是一致的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature&#x2F;add_git_commands github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/fba96bf8-4ef8-4dfb-8edf-c0004c9c1b76.png" alt></p><p><font color="red">Hash值都是 27582a7</font></p><p>haoran用户修改index文件，commit完成。<br>JavaSsun用户又修改了readme文件，并且push到远程。<br>此时，haoran用户push自己的index文件到远端，会报错，如下图：</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/7286fc61-21d2-43b1-884c-c86d466a2394.png" alt></p><p>如何解决呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch github  尝试拉取远端的最新变更</span><br><span class="line">git branch -av</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/95006c82-d402-4b55-a1b4-a26869cad23d.png" alt></p><p>发现有一个是 ahead 1 , behind 1 即本地比远端多一个，远端也比本地多一个。</p><p><strong>如果团队不要求用线性树的模式的话，可以用merge 与远端的进行合并</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/86e9dc79-a8f3-4759-a9b1-5d7311f7b625.png" alt></p><p>查看readme文件，发现将JavaSsun用户提交的内容都合了进来。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/6e46ee55-4829-4bf3-b871-082e599fb039.png" alt></p><p>此时在使用 <strong>git push github</strong> 就不会报错</p><h2 id="2-不同人修改同文件不同区域如何处理"><a href="#2-不同人修改同文件不同区域如何处理" class="headerlink" title="2.不同人修改同文件不同区域如何处理"></a>2.不同人修改同文件不同区域如何处理</h2><p>开发之前都需要将自己的分支与远端做一次同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p><strong>haoran</strong>：  对index.html文件做了变更，并做了commit<br><strong>JavaSsun</strong>: 对index.html文件做了变更，并做了commit</p><p><strong>haoran</strong>用户将自己的变更推送到了远端。此时 JavaSsun用户并不知道远端发生了新变更，也想推送自己的变更，自然就被拒绝。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/ac9f49fa-3b5c-4606-be44-1157432c6d45.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/340a928c-76a7-45fd-b5c8-fd34a7fca38d.png" alt></p><p>出现比远端做一个commit，同时比远端少一个commit,做merge即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -av</span><br><span class="line">git merge origin&#x2F;feature&#x2F;add_git_commands(远端分支或者分支ID号)</span><br></pre></td></tr></table></figure><p>默认缺省即可，查看发现有了其他人添加的内容。</p><h2 id="3-不同人修改同文件同一区域如何处理"><a href="#3-不同人修改同文件同一区域如何处理" class="headerlink" title="3.不同人修改同文件同一区域如何处理"></a>3.不同人修改同文件同一区域如何处理</h2><p>工作区先进行同步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>都对index.html文件的同一区域做了相同的变更，JavaSsun用户将自己的变更推送到了远端，haoran用户想推送自己的变更时被拒绝了。</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/954bba88-adef-4176-9d20-f77bfcb8d8df.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果用 merge 直接与远端进行合并，又发现 Already up to date，但又push不上去。</span><br><span class="line">git merge github&#x2F;feature&#x2F;add_git_commands</span><br></pre></td></tr></table></figure><p>此时，需要用 git pull 命令,出现了冲突（需手动解决）<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/07f361a2-d594-4c27-84e9-ae0abfafec0e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/100853e3-cee0-4abe-8583-8575cde7c76e.png" alt></p><p><strong>&lt;&lt;&lt;&lt;&lt;HEAD 到 ===========是自己的变更</strong><br><strong>=========到&gt;&gt;&gt;&gt;&gt;&gt;&gt;是别人的变更</strong></p><p>留下双方都需要的变更<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/e869d140-31d9-4126-8225-bcbd683321fd.png" alt></p><p>使用 <strong>git status</strong> 出现提示信息<br><strong>git commit 保留二者的变更。 **<br>**git merge –abort 不想让这两个分支merge，恢复到merge之前的状态。</strong></p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/57b10dc7-595f-4c3f-a5cc-97f6922ab404.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git push github 推送即可</span><br><span class="line"></span><br><span class="line">另一个人</span><br><span class="line">git pull  拉取远端最新的变更即可</span><br></pre></td></tr></table></figure><h2 id="4-同时变更了文件名和文件内容如何处理"><a href="#4-同时变更了文件名和文件内容如何处理" class="headerlink" title="4.同时变更了文件名和文件内容如何处理"></a>4.同时变更了文件名和文件内容如何处理</h2><p>A变更了文件名，B变更了文件内容，但还是按照原来的文件名推送。</p><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git mv index.html index.htm</span><br><span class="line">git status</span><br><span class="line">git commit -am &quot;Mv index.html to index.htm&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/08718508-fa10-4155-8729-c6735a141a07.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim index.html</span><br><span class="line">git commit -am &quot;....&quot;</span><br><span class="line">git push  &#x2F;&#x2F;会报错</span><br><span class="line">git pull  &#x2F;&#x2F; 默认缺省值 :wq</span><br><span class="line">ll -al   &#x2F;&#x2F;文件名已经更改过来 index.htm</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/82033f41-57ba-40ec-b694-0002adfa4244.png" alt></p><h2 id="5-同一文件改成了不同的文件名如何处理"><a href="#5-同一文件改成了不同的文件名如何处理" class="headerlink" title="5.同一文件改成了不同的文件名如何处理"></a>5.同一文件改成了不同的文件名如何处理</h2><p><strong>haoran用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index2.html</span><br><span class="line">git commit -am &quot;Mv index to index2&quot;</span><br><span class="line">git push github</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/b2ff7258-bf35-4458-ad39-32d94e263c1b.png" alt></p><p><strong>JavaSsun用户</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git mv index.htm index1.html</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push &#x2F;&#x2F;报错</span><br><span class="line">git pull &#x2F;&#x2F;报冲突</span><br><span class="line">ll -al   &#x2F;&#x2F;发现出现两个文件</span><br><span class="line">diff index1.htm index2.htm  &#x2F;&#x2F;只是文件名不同，内容是一致的</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f685d46e-0796-4f75-9f98-67064df101dd.png" alt></p><p>查看状态，需要协作者一起协商文件名的选取</p><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/aaca27e6-94be-4348-b12a-72e295a477ef.png" alt></p><p>如果选择 index1.htm这个名字，需要按以下命令更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git rm index.htm index2.htm</span><br><span class="line">git add index1.htm</span><br><span class="line">git commit -am &quot;Mv index to index1&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/f7faceed-f423-43e3-bbd6-9813f5e448a2.png" alt></p><p>远端的已经变成了index1.htm<br><img src="/2019/02/08/4-Git%E5%A4%9A%E4%BA%BA%E5%8D%95%E5%88%86%E6%94%AF%E9%9B%86%E6%88%90%E5%8D%8F%E4%BD%9C%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF/33006191-16a2-4668-ba75-aba5a7837028.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-Git与GitHub简单同步</title>
      <link href="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-注册一个GitHub账号"><a href="#1-注册一个GitHub账号" class="headerlink" title="1.注册一个GitHub账号"></a>1.注册一个GitHub账号</h2><p>略<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/3f130bd8-80ca-4c71-973a-0c3bd9146ea3.png" alt></p><a id="more"></a><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/2f0d55c7-f1f5-463a-9c1d-503aea9d7070.png" alt></p><p>将公钥粘贴到GitHub上来，方便推送。</p><h2 id="2-配置公私钥"><a href="#2-配置公私钥" class="headerlink" title="2.配置公私钥"></a>2.配置公私钥</h2><p><strong>查看是否之前有过公私钥</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;.ssh</span><br><span class="line">ll -al</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/27b6c3ca-54d0-4f78-9fd0-d4efc9cc81b9.png" alt></p><p><strong>如果没有配置过，是不会出现 id_rsa 与 id_rsa.pub这两个文件的</strong></p><p><strong>生成公私钥命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;2642487764@qq.com&quot;</span><br><span class="line">一路回车即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/79ea4449-83f0-4a0c-9920-d8ff5cf7902b.jpg" alt></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/b21dc469-dfff-40c2-abfd-c661b11de310.png" alt></p><p>复制到GitHub的账户上即可、<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a35abfab-8c9d-4e94-a132-f502155abb62.png" alt></p><p><strong>好处</strong>：ssh协议做push活动时不需要再输入用户名密码，可以智能识别，允许自己往对应的GitHub账户上推送内容。</p><h2 id="3-GitHub上创建个人仓库"><a href="#3-GitHub上创建个人仓库" class="headerlink" title="3.GitHub上创建个人仓库"></a>3.GitHub上创建个人仓库</h2><p><strong>MIT License 可以直接拿过来用</strong></p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/c7414606-ca57-4231-be64-3d36af153932.png" alt></p><p>点开会拥有 MIT lecense标识<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/07a92364-782e-48a4-8d2f-c0744488765b.png" alt></p><h2 id="4-本地仓库同步到GitHub"><a href="#4-本地仓库同步到GitHub" class="headerlink" title="4.本地仓库同步到GitHub"></a>4.本地仓库同步到GitHub</h2><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a9b74e0a-dc0e-4a35-9b3d-0de613b6569b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add github git@github.com:JavaSsun&#x2F;git_learning.git</span><br><span class="line"></span><br><span class="line">添加远程站点 并更名为  github</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/adf9277a-96d2-4318-a877-134fd63b77cb.png" alt></p><p><strong>有了上述github后 即可与远端建立联系</strong></p><p>因为 远端有了 License文件 ，在本地直接push的时候会报错，提示push前需要把远端的先pull下来。</p><p><strong>没有pull之前的版本树</strong><br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/617d8530-f5e2-447f-b4b9-a9976b5a926f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch github master  拉取远端 master上的文件到本地，仅仅是拉取，没有与本地分支做merge</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6d78b45d-b26e-4c80-9596-9268d916ce74.png" alt></p><p>此时 远端的 LICENSE已经被fetch下来</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d21ef24-88fc-48de-a48d-ff36c39e4efa.png" alt></p><p>将本地master与远端master进行merge，但是会报错<br><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/4eff67a2-224d-4ed5-ac26-b46ca787549f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge -h  查找帮助</span><br><span class="line">git merge --allow-unrelated-histories github&#x2F;master</span><br><span class="line">在交互界面使用默认缺省值即可</span><br></pre></td></tr></table></figure><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/8efd7ace-e75e-4fcb-8fb6-95d762d59e44.png" alt></p><p>查看merge后的当前树（发现有两个父亲，rebase则是线性的，只有一个）</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/1d37e621-8bac-43f7-b421-33b8974df6f5.png" alt></p><p>此时再将本地push到远方，不会再报错</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/6b3b24b8-517f-417d-b87d-c04e67347a95.png" alt></p><p>查看当前树</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/a48de224-c5cd-428b-a7c0-66acd18e58bb.png" alt></p><p>查看远端仓库</p><p><img src="/2019/01/20/3-Git%E4%B8%8EGitHub%E7%AE%80%E5%8D%95%E5%90%8C%E6%AD%A5/da932435-ce0a-4a69-ab63-161987e1bb6d.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Git常用场景</title>
      <link href="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97<br>图片来源：极客时间，需个人购买教程。</p><h2 id="1-删除无用分支"><a href="#1-删除无用分支" class="headerlink" title="1.删除无用分支"></a>1.删除无用分支</h2><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cbe35443-f8b1-43e6-a798-b0828a836ef3.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name             &#x2F;&#x2F; 删除分支(会有提示是否确认删除)</span><br><span class="line">git branch -D branch_name             &#x2F;&#x2F; 删除分支（确认删除情况下）</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-修改本地最新commit的messagee"><a href="#2-修改本地最新commit的messagee" class="headerlink" title="2.修改本地最新commit的messagee"></a>2.修改本地最新commit的messagee</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend               &#x2F;&#x2F;可以对最新的commit的message做变更</span><br></pre></td></tr></table></figure><h2 id="3-修改本地老旧commit的message"><a href="#3-修改本地老旧commit的message" class="headerlink" title="3.修改本地老旧commit的message"></a>3.修改本地老旧commit的message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i  待修改commit的父ID号        &#x2F;&#x2F; -i交互式</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/caa4ac95-c0c9-491e-b4df-26f9c7faf1ba.png" alt><br>将第一个 pick 改为 reword / r 然后保存,会再次进入交互界面。</p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/8c965b60-3093-4927-b588-f07df7b8ef5d.png" alt></p><p>修改变更的信息后保存，查看信息。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/61baa9ed-06a6-4f23-b99a-442093cfbe82.png" alt></p><h2 id="4-连续多个本地commit整理成1个"><a href="#4-连续多个本地commit整理成1个" class="headerlink" title="4.连续多个本地commit整理成1个"></a>4.连续多个本地commit整理成1个</h2><p>将中间两个合并成一个commit<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f95841b5-9286-4c80-a1b9-2db49e5b147d.png" alt></p><p>此时，应该基准是中间两个的父ID号，即 7f7e472c30</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c30</span><br></pre></td></tr></table></figure><p>选用 squash 或者 s 进行合并<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/e7eec623-3f36-4ca8-b02d-8f36a2f92b0d.png" alt></p><p>添加合并信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/f2c191d1-ebab-4b52-b01b-fa120ae984a1.png" alt></p><p>git log –graph            //查看日志<br><strong>会对整理后的commit生成一个新的ID号</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/032b9093-e06b-4dbe-80c4-dd35b5ab5300.png" alt></p><h2 id="4-多个本地-间隔commit整理成1个"><a href="#4-多个本地-间隔commit整理成1个" class="headerlink" title="4.多个本地 间隔commit整理成1个"></a>4.多个本地 间隔commit整理成1个</h2><p><strong>将最新的一个与第一个合成一个commit</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/b9d3b699-43ee-4d12-b475-94be40a3bac9.png" alt></p><p>因为最早的一个没有父亲，所以直接使用rebase变更命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i 7f7e472c</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/5db8b72f-677d-4a87-acf5-ecad61863d6d.png" alt></p><p>添加   pick 7f7e471c 命令      //最古老的那一个    <strong>合并上限</strong><br>将        s 96764b86 添加到上面命令的下一行  //    <strong>合并下限</strong><br>删除   pick 96764b8  命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase --continue   &#x2F;&#x2F;继续  使用这个继续操作</span><br><span class="line">git rebase --abort      &#x2F;&#x2F;舍弃</span><br></pre></td></tr></table></figure><p>添加变更信息<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/59279101-2af0-414e-9235-7ad4bdab712d.png" alt></p><p>合并成功，生成新的commit ID号<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/3b7309ee-3845-4d28-9106-cff524594bd5.png" alt></p><p>此时出现两个（树）根 可以看情况删除非master所在的根<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/6e3b571f-984d-4c1a-be95-15d2c6d66dbf.png" alt></p><h2 id="5-比较暂存区与HEAD所含文件的差异"><a href="#5-比较暂存区与HEAD所含文件的差异" class="headerlink" title="5.比较暂存区与HEAD所含文件的差异"></a>5.比较暂存区与HEAD所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变更内容后使用 git add 添加到暂存区</span><br><span class="line">git status</span><br><span class="line">git diff --cached            &#x2F;&#x2F;查看暂存区与HEAD所指向文件的具体变化</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/832bbece-3ea4-4ef6-a4d2-ff94c99a10b0.png" alt></p><h2 id="6-比较暂存区与工作区所含文件的差异"><a href="#6-比较暂存区与工作区所含文件的差异" class="headerlink" title="6.比较暂存区与工作区所含文件的差异"></a>6.比较暂存区与工作区所含文件的差异</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git diff                    &#x2F;&#x2F;默认查看工作区与暂存区所有文件的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name      &#x2F;&#x2F;查看指定文件在工作区与暂存区的变化</span><br><span class="line"></span><br><span class="line">git diff  -- file_name1 file_name2  file_nameN</span><br></pre></td></tr></table></figure><h2 id="7-将暂存区恢复成HEAD所处状态-变暂存区用-reset"><a href="#7-将暂存区恢复成HEAD所处状态-变暂存区用-reset" class="headerlink" title="7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)"></a>7.将暂存区恢复成HEAD所处状态   (变暂存区用 reset)</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区有了新的优化方案。此前暂存区的内容不想保留，想回溯到之前的HEAD所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD                &#x2F;&#x2F;取消暂存区中的文件（文件由绿变红）</span><br><span class="line">git diff --cached             &#x2F;&#x2F;比较暂存区与HEAD 返回为空，即撤销成功</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/4da5296d-6b61-4e5e-92db-15f3430d4179.png" alt></p><h2 id="8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）"><a href="#8-将工作区的文件恢复为暂存区所处状态（变工作区用-checkout）" class="headerlink" title="8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）"></a>8.将工作区的文件恢复为暂存区所处状态（变工作区用 checkout）</h2><p>即 工作区内容变化后，添加到暂存区，后来发现工作区做了变化后，发现没有暂存区的好。<br>想舍弃工作区当前的更改，回溯到暂存区所处状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file_name   &#x2F;&#x2F; 舍弃工作区的变更，恢复为暂存区的内容</span><br><span class="line">git diff file_name          &#x2F;&#x2F; 没有返回信息，工作区与暂存区一致</span><br></pre></td></tr></table></figure><h2 id="9-取消暂存区部分文件的更改"><a href="#9-取消暂存区部分文件的更改" class="headerlink" title="9.取消暂存区部分文件的更改"></a>9.取消暂存区部分文件的更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD -- file_name1 file_name2</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/58261fc0-c409-42c7-9c92-9a22d67bc86a.png" alt></p><h2 id="10-消除最近的几次提交"><a href="#10-消除最近的几次提交" class="headerlink" title="10.消除最近的几次提交"></a>10.消除最近的几次提交</h2><p>恢复到提交的前几次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  ID                &#x2F;&#x2F;  回退到指定的commit的ID号</span><br></pre></td></tr></table></figure><h2 id="11-不同提交、分支的指定文件的差异化比较"><a href="#11-不同提交、分支的指定文件的差异化比较" class="headerlink" title="11.不同提交、分支的指定文件的差异化比较"></a>11.不同提交、分支的指定文件的差异化比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff branch_name1 branch_name2    &#x2F;&#x2F;比较两个分支的差异</span><br><span class="line">git diff branch_name1 branch_name2 -- file_name   &#x2F;&#x2F;比较指定文件在指定分支上的差异</span><br><span class="line"></span><br><span class="line">git diff 分支1对应的commit的ID号 分支2对应的commit的ID号   &#x2F;&#x2F;与上述一致</span><br></pre></td></tr></table></figure><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>常规做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm  指定文件名    &#x2F;&#x2F;删除工作区文件</span><br><span class="line">git status       &#x2F;&#x2F;变红色，说明仅仅是删除了工作区中的，</span><br><span class="line">git rm 指定文件名 &#x2F;&#x2F;删除暂存区文件</span><br><span class="line">git status       &#x2F;&#x2F;变绿色，说明暂存区中文件被删除</span><br><span class="line"></span><br><span class="line">git reset --hard HEAD  &#x2F;&#x2F;废除刚才所有变动</span><br></pre></td></tr></table></figure><p><strong>git 做法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm 指定文件名</span><br><span class="line">git status &#x2F;&#x2F; 变绿色</span><br></pre></td></tr></table></figure><h2 id="13-开发中临时添加紧急任务（stash）"><a href="#13-开发中临时添加紧急任务（stash）" class="headerlink" title="13.开发中临时添加紧急任务（stash）"></a>13.开发中临时添加紧急任务（stash）</h2><p>工作区与暂存区中的内容暂时还不能提交，但是当前又有一个更为紧急的任务需要完成时，可以把工作区与暂存区中的内容存放到另一个空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git diff       &#x2F;&#x2F; 工作区与暂存区是有差异的</span><br><span class="line">git stash      &#x2F;&#x2F; 将未commit的内容存放另一个空间</span><br><span class="line">git stash list &#x2F;&#x2F; 可以看到类似于存放在有ID号的堆栈中</span><br><span class="line">git status     &#x2F;&#x2F; 工作区与暂存区是干净的</span><br></pre></td></tr></table></figure><p><strong>此时可以处理紧急任务，add到暂存区，commit到仓库后，再回来继续当前开发，需要将之前存储在另一个空间的内容恢复出来</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git stash apply &#x2F;&#x2F; 将内容弹出，但不删除空间中的内容，可反复使用</span><br><span class="line">git stash list  &#x2F;&#x2F; 依然存在</span><br><span class="line">git stash pop   &#x2F;&#x2F; 弹出且删除空间中的内容</span><br><span class="line">git stash list  &#x2F;&#x2F; 什么也没有</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/348f60ab-06f0-4957-8551-9c7dae0ef36c.png" alt></p><p><strong>处理完紧急任务后弹出内容</strong><br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/9578d032-8074-4f0c-b3d6-5d30c9bfd9bb.png" alt></p><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/cf033f3f-a3b8-4607-826a-f034b1aee126.png" alt></p><h2 id="14-指定不需要Git管理的文件"><a href="#14-指定不需要Git管理的文件" class="headerlink" title="14.指定不需要Git管理的文件"></a>14.指定不需要Git管理的文件</h2><p><strong>建立一个文件，指定文件名为 .gitignore</strong></p><p>在文件中添加需要Git版本忽略的文件即可。</p><p>可在GitHub上查看<br><a href="https://github.com/github-tools/github/blob/master/.gitignore" target="_blank" rel="noopener">https://github.com/github-tools/github/blob/master/.gitignore</a></p><h2 id="15-备份Git仓库到本地"><a href="#15-备份Git仓库到本地" class="headerlink" title="15.备份Git仓库到本地"></a>15.备份Git仓库到本地</h2><p>常用的传输协议<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/be6aa585-e6f5-4670-95d0-f34a4c1623d7.jpg" alt></p><p><strong>哑协议与智能协议</strong></p><p><strong>直观区别</strong>：哑协议传输进度不可见；智能协议传输可见。<br><strong>传输速度</strong>：智能协议比哑协议传输速度快。<br><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/35a50a7b-3fbb-4413-9cec-692c4b2bdb72.jpg" alt></p><p><strong>哑协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare &#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git ya.git</span><br><span class="line">从本地另一个Git仓库中克隆一个文件到当前仓库</span><br><span class="line">--bare 是只克隆仓库中的内容，不可隆工作区中的内容</span><br><span class="line">将 .git 文件更名为 ya.git文件</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/ac7afc75-38b6-48e2-a671-8c6c719c2199.png" alt></p><p><strong>智能协议</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --bare file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;git_learning&#x2F;.git zhineng.git</span><br><span class="line"></span><br><span class="line">前面添加    file:&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/18/2-Git%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF/a1a209cd-6efb-40d7-9b5c-e090082711ed.png" alt></p><p><strong>本地推远端仓库（demo）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add zhineng file:&#x2F;&#x2F;&#x2F;f&#x2F;Git&#x2F;666-backup&#x2F;zhineng.git</span><br><span class="line">git brach -av</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-Git安装及简单操作</title>
      <link href="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p>图片来源：极客时间，需个人购买教程。</p><h2 id="前言-Git下载路径"><a href="#前言-Git下载路径" class="headerlink" title="前言 Git下载路径"></a>前言 Git下载路径</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><h2 id="参考-廖雪峰-Git文档"><a href="#参考-廖雪峰-Git文档" class="headerlink" title="参考 廖雪峰 Git文档"></a>参考 廖雪峰 Git文档</h2><p>廖雪峰 Git文档<br><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version     &#x2F;&#x2F;可查看版本即安装成功</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-使用Git前的小配置"><a href="#1-使用Git前的小配置" class="headerlink" title="1 使用Git前的小配置"></a>1 使用Git前的小配置</h2><h3 id="1-1-配置User信息-（user-name-和-user-email）"><a href="#1-1-配置User信息-（user-name-和-user-email）" class="headerlink" title="1.1 配置User信息  （user.name 和 user.email）"></a>1.1 配置User信息  （user.name 和 user.email）</h3><p>方便代码变更时展示变更人信息 及 通知协作者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  &#39;your_name&#39;</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure><h3 id="1-2-config-作用域"><a href="#1-2-config-作用域" class="headerlink" title="1.2 config 作用域"></a>1.2 <font color="red">config 作用域</font></h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6075a03d-a390-4546-ad59-1b2a2a5c1795.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list</span><br><span class="line">git config --local user.name</span><br><span class="line">git config --local user.email</span><br></pre></td></tr></table></figure><h2 id="2-建Git仓库"><a href="#2-建Git仓库" class="headerlink" title="2 建Git仓库"></a>2 建Git仓库</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/025b15b1-6dd2-4a50-9d4d-b152d763370d.jpg" alt></p><h3 id="2-1-常用命令"><a href="#2-1-常用命令" class="headerlink" title="2.1 常用命令"></a>2.1 常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git add                 &#x2F;&#x2F; 添加文件到暂存区</span><br><span class="line">git commit -m &#39;变更内容&#39; &#x2F;&#x2F; 添加文件到Git仓库</span><br><span class="line">git status              &#x2F;&#x2F; 查看文件状态</span><br><span class="line">git log                 &#x2F;&#x2F; 查看提交日志</span><br><span class="line"></span><br><span class="line">git checkout branc_name &#x2F;&#x2F;切换分支</span><br><span class="line">git checkout -b branch_name &#x2F;&#x2F;创建并切换新分支</span><br><span class="line"></span><br><span class="line">git commit -am &#39;变更信息&#39; &#x2F;&#x2F;直接推到仓库，跳过暂存区，不推荐使用</span><br></pre></td></tr></table></figure><h3 id="2-2-优先级"><a href="#2-2-优先级" class="headerlink" title="2.2 优先级"></a>2.2 优先级</h3><p><font color="red"> local 优先级高于 global，即全局设置的global会被某一个local仓库的信息给覆盖</font></p><h2 id="3-工作区与暂存区"><a href="#3-工作区与暂存区" class="headerlink" title="3 工作区与暂存区"></a>3 工作区与暂存区</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/0ea1afe7-4fd5-4f90-825e-d0f280c38dbb.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -u            &#x2F;&#x2F; 可以将已修改的 Git所管理的文件 一起提到暂存区，如下所示</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9ff91e2a-397a-450e-b95c-5d266c60d2e3.jpg" alt></p><h2 id="4-Git-中的文件重命名"><a href="#4-Git-中的文件重命名" class="headerlink" title="4 Git 中的文件重命名"></a>4 Git 中的文件重命名</h2><p>常规步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv old_name  new_name       &#x2F;&#x2F; 重命名</span><br><span class="line">git add  new_name           &#x2F;&#x2F; 添加新文件进入暂存区</span><br><span class="line">git rm old_name             &#x2F;&#x2F; 删除暂存区中旧的文件</span><br><span class="line">git status                  &#x2F;&#x2F; Git智能的认为是文件重命名</span><br><span class="line">---  太繁琐  ---</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/cf8ae066-98f1-4e68-bbe9-7839f0e8fba7.png" alt></p><p><font color="red">Git方式重命名</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git mv old_name  new_name  &#x2F;&#x2F; Git重命名文件   3合1</span><br><span class="line">git status                 &#x2F;&#x2F; 查看状态</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e6ad4c3-298d-4359-92df-fe65f2eb8ee5.png" alt></p><h2 id="5-git-log-查看版本演变历史"><a href="#5-git-log-查看版本演变历史" class="headerlink" title="5 git log 查看版本演变历史"></a>5 git log 查看版本演变历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git log                        &#x2F;&#x2F; 查看当前分支详细版本历史</span><br><span class="line"></span><br><span class="line">git log --oneline              &#x2F;&#x2F; 查看当前分支简略版本历史</span><br><span class="line"></span><br><span class="line">git log -n2                    &#x2F;&#x2F; 查看当前分支最近的两次版本提交记录</span><br><span class="line">git log -n2 --oneline          &#x2F;&#x2F; 组合使用</span><br><span class="line"></span><br><span class="line">git branch -a                  &#x2F;&#x2F; 查看有多少分支(简略)</span><br><span class="line">git branch -v                  &#x2F;&#x2F; 查看有多少分支(详细)</span><br><span class="line">git branch -av                 &#x2F;&#x2F; 常用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git log                        &#x2F;&#x2F; 查看当前分支版本</span><br><span class="line"></span><br><span class="line">git log temp                   &#x2F;&#x2F; 查看指定分支temp的历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline temp         &#x2F;&#x2F; 查看指定分支temp的简略历史版本</span><br><span class="line"></span><br><span class="line">git log --oneline --all temp   &#x2F;&#x2F; 此时 依然是查看所有分支的历史版本，temp不再起作用</span><br><span class="line"></span><br><span class="line">git log --all                  &#x2F;&#x2F; 查看所有分支版本历史</span><br><span class="line"></span><br><span class="line">git log --all --graph          &#x2F;&#x2F; 以图形化的方式查看所有分支（父子关系分支）关系</span><br></pre></td></tr></table></figure><p><font color="red">按需求组合：</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5db3e9f7-aabf-4ef3-9864-42aed7a2099e.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all -n4 --graph         &#x2F;&#x2F; 查看简略ID</span><br><span class="line">git log --pretty&#x3D;oneline --all -n4 --graph  &#x2F;&#x2F; 查看详细ID</span><br></pre></td></tr></table></figure><p><strong>使用网页方式查看相关命令帮助</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git help --web  log            &#x2F;&#x2F; 以网页方式查看log命令用法</span><br><span class="line">git help --web  commit         &#x2F;&#x2F; 以网页方式查看commit命令用法</span><br></pre></td></tr></table></figure><h2 id="6-gitk-通过图形界面工具查看版本演变历史"><a href="#6-gitk-通过图形界面工具查看版本演变历史" class="headerlink" title="6 gitk   通过图形界面工具查看版本演变历史"></a>6 gitk   通过图形界面工具查看版本演变历史</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br><span class="line"></span><br><span class="line">gitk --all</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ddf34b16-0714-4641-8483-02fffa3fcc0c.png" alt></p><h2 id="7-探索-git目录"><a href="#7-探索-git目录" class="headerlink" title="7 探索.git目录"></a>7 探索.git目录</h2><h3 id="7-1-HEAD文件"><a href="#7-1-HEAD文件" class="headerlink" title="7.1 HEAD文件"></a>7.1 HEAD文件</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28fe4315-38cf-495f-8da8-0731f13553d7.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat HEAD        &#x2F;&#x2F;查看HEAD文本内容 HEAD是一个引用，指向当前工作分支，指向的是refs文件夹下的heads文件夹下的某个分支的ID号</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/d99a688c-7472-48a0-a725-d089915e1249.png" alt></p><p><font color="red">切换回master分支后，HEAD内容发生变化</font><br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/03ef6a79-099b-4929-be05-36bb21a766f4.png" alt></p><h3 id="7-2-config配置文件"><a href="#7-2-config配置文件" class="headerlink" title="7.2 config配置文件"></a>7.2 config配置文件</h3><p>对config作用域的user信息的修改直接保存到该文件中。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/98e5bb44-5de4-4ee8-8226-019330ad2950.png" alt></p><p>将user.name 由 local1 改为local2后，再次查看该文件发现已经更改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local --list      &#x2F;&#x2F;列出本地所有可以看得信息</span><br><span class="line">git config --local user.nane   &#x2F;&#x2F;列出指定信息（如user.name）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c595b00-c8c0-47d9-a8aa-793465e69f43.png" alt></p><p><strong>再次修改回去</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &#39;local1&#39;</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6c514813-a599-410d-98f0-144f247436ab.png" alt></p><h3 id="7-3-refs文件夹"><a href="#7-3-refs文件夹" class="headerlink" title="7.3 refs文件夹"></a>7.3 refs文件夹</h3><p>heads: 分支，一个独立的开发空间，前后端各1个分支，互不影响，需要集成时，合并到一个共同的分支上。<br>tags: 标签/里程碑 标明一个版本等。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/28046633-46c0-4af5-8ad1-36344f509e92.png" alt></p><p><strong>heads文件夹</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t ID号前几位        &#x2F;&#x2F;查看存放的对象是一个什么类型 （commit类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/e0e52020-8d55-44b6-8a0a-392604927f6c.png" alt></p><p><strong>tags文件夹</strong></p><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/9c392142-567a-466e-b72a-f7bff540600f.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p ID号前几位         &#x2F;&#x2F; 查看内容（tag类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/76815d92-3063-4ae0-8e1e-9d260cf93fac.png" alt></p><h3 id="7-4-objects文件夹"><a href="#7-4-objects文件夹" class="headerlink" title="7.4 objects文件夹"></a>7.4 objects文件夹</h3><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/6659db73-a48b-4935-b5fe-33b9af5f6978.png" alt></p><p><strong>查看98文件夹下存放的类型与内容</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -t 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看类型（tree类型）</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/09cba8a4-0998-4c2b-a306-a57336988f2b.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git cat-file -p 98拼上里面存放的ID号前几位   &#x2F;&#x2F;看内容</span><br><span class="line"></span><br><span class="line">blob 文本类型   再次查看blob ID号对应的内容是文本信息</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/a2cd87bf-3284-4f0f-ad62-b512505b0199.png" alt></p><p>内容是文本里的内容信息</p><p><font color="red">核心类型：</font><br><strong>TREE  / COMMIT  /  BLOB</strong></p><h2 id="8-commit、tree、blob-三者关系"><a href="#8-commit、tree、blob-三者关系" class="headerlink" title="8 commit、tree、blob 三者关系"></a>8 commit、tree、blob 三者关系</h2><p>Git眼中，文件内容完全相同，就被认为是同一个对象。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c6b17719-a3a1-4b69-9edb-76ed250c6cef.jpg" alt><br>**<br>一个commit 对应一个 tree<br>blob 对应文本文件<br>tree 对应文件夹，文件夹下可能有tree或者blob<br>**<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/ae5fb42a-36b4-4df1-bf33-9c3f29353970.png" alt></p><h2 id="9-tree的个数"><a href="#9-tree的个数" class="headerlink" title="9 tree的个数"></a>9 tree的个数</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/c44300e9-0b7b-462a-b9d4-bc00140c4c3a.jpg" alt></p><p>查看某个目录下类型是文件的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find .git&#x2F;objects -type f</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/96621697-d0f6-4774-8282-e08b68043fb7.png" alt></p><p>2个tree，1个commit，1个blob</p><h2 id="10-分离头指针时的注意事项（detached-HEAD）"><a href="#10-分离头指针时的注意事项（detached-HEAD）" class="headerlink" title="10 分离头指针时的注意事项（detached HEAD）"></a>10 分离头指针时的注意事项（detached HEAD）</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2ed04c46-8f7f-4bf7-b619-2df3653fb36b.png" alt></p><p>如果此时对某些文件做了修改，并提交到仓库后，切换分支时，会提示是否给当前没有依赖的变更创建新的分支，如果不创建，会丢失这次修改。<br>在Git看来，如果没有将某个commit与分支或者tag绑定，都会被清除<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/5dc33929-8d2e-418e-96a5-1aea442dfbd6.png" alt></p><p>按照提示 git branch branch_name ID号 进行分支的挂钩，即可保留修改。<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1b1a7c5a-850a-4d0f-bc42-b388bf34e891.png" alt></p><p><strong>因此，分离头指针指的是 某个变更没有基于branch进行，在切换分支时，分离头指针下的commit会被Git当做垃圾清理掉。如果这些变更是重要的，要与某个分支绑定在一起。</strong></p><h2 id="11-HEAD-与-branch"><a href="#11-HEAD-与-branch" class="headerlink" title="11  HEAD 与 branch"></a>11  HEAD 与 branch</h2><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/dcec9acc-64e3-4422-8b45-58ac5b9e8b40.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b new_branch_name      &#x2F;&#x2F;基于当前分支创建新分支</span><br><span class="line">git checkout -b new_branch_name old_branch_name   &#x2F;&#x2F;基于指定分支创建新分支</span><br></pre></td></tr></table></figure><p><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/587b9e50-28f3-40ec-bd1c-8ae109102004.png" alt></p><p>此时 .git/HEAD 的引用也指向了新的分支<br><img src="/2019/01/15/1-Git%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/2e96d652-d2b3-45c8-84b0-a6e6aec3a29f.png" alt></p><p><strong>HEAD 既可以指向最后一次提交的分支，也可以不与任何分支挂钩（即处于分离头指针状态下），整个HEAD指向了某个 commit上。当做分支切换时，HEAD指向新分支</strong></p><p><font color="red">HEAD 指向分支，分支指向commit，或者HEAD直接指向commit</font>.</p><p><strong>比较两次commit的差异性</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff 待比较ID1  待比较ID2     &#x2F;&#x2F; ID1与ID2的提交比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD^1             &#x2F;&#x2F; 当前HEAD所指向的commit与他的父亲（上一次）比较</span><br><span class="line">git diff HEAD HEAD^1^1           &#x2F;&#x2F; 当前HEAD所指向的commit与他的爷爷（上两次）比较</span><br><span class="line"></span><br><span class="line">git diff HEAD HEAD~n             &#x2F;&#x2F; 当前HEAD所指向的commit与 上n次 比较</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper学习</title>
      <link href="/2019/01/10/ZooKeeper/"/>
      <url>/2019/01/10/ZooKeeper/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h2><p><a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a></p><h2 id="1-2-介绍"><a href="#1-2-介绍" class="headerlink" title="1.2 介绍"></a>1.2 介绍</h2><p><strong>ZooKeeper</strong>是一个开源的分布式应用协调服务系统，主要用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。<br>问题：<br><img src="/2019/01/10/ZooKeeper/ac1656df-ca7c-45ee-9688-6201ee09006f.png" alt> </p><a id="more"></a><p><strong>Zookeeper特点</strong><br><img src="/2019/01/10/ZooKeeper/7d94097e-7d38-4b30-b02e-f4a0e8e8f2af.jpg" alt><br>&nbsp;&nbsp;1. Zookeeper有一个层次化的名称空间，很像一个分布式文件系统（树形层次结构）<br>&nbsp;&nbsp;2. Zookeeper树中的每个节点被称为—-<strong>Znode</strong><br>&nbsp;&nbsp;3. <strong>Znode</strong>，兼具文件和目录两种特点。既像文件一样维护者数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分。</p><p><strong>ZNode类型</strong><br>&nbsp;&nbsp;Zookeeper中的节点分为<strong>临时节点</strong>、<strong>永久节点</strong>、<strong>顺序节点</strong>。节点的类型在创建时即被确定，并且不能改变。<br>&nbsp;&nbsp;1. <strong>临时节点（Ephemeral Node）</strong>：该节点的生命周期依赖于创建他们的会话。一旦会话（Session）结束，临时节点将被自动删除，Zookeeper的临时节点不允许拥有子节点。<br>&nbsp;&nbsp;2. <strong>永久节点（Persistent Node）</strong>：该节点的生命周期不依赖于会话，并且只有在客户端执行删除操作的时候，他们才能被删除。<br>&nbsp;&nbsp;3. <strong>顺序节点（Sequential Node）</strong>：顺序节点可以是持久的或者临时的。当一个新的Znode被创建为顺序节点时，Zookeeper通过将10位的序列号附加到原始名称来设置ZNode的路径。例如：如果将具有路径** /myapp<strong>的Znode创建为顺序节点，则Zookeeper会将路径更改为</strong>/myapp0000000001**，并且下一个序列号设置为0000000002.</p><p><strong>Watches</strong><br>&nbsp;&nbsp;客户端可以在节点上设置Watch，称之为监视器。当节点状态发生改变时（ZNode的增删改）将会触发Watch所对应的操作。当Watch被触发时，Zookeeper将会向客户端发送且仅发送一条通知。</p><h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>&nbsp;&nbsp;注：单机模式为例<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 配置JDK的环境变量<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 下载<br><code>wget http://mirrors.shu.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</code><br>&nbsp;&nbsp;&nbsp;&nbsp;3. 解压<br><code>tar -zxvf zookeeper-3.4.11.tar.gz -C /usr</code><br>&nbsp;&nbsp;&nbsp;&nbsp;4. 修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改配置文件</span><br><span class="line">cp &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo_sample.cfg &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line"># 修改配置文件</span><br><span class="line">vi &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line"> tickTime&#x3D;2000</span><br><span class="line"> dataDir&#x3D;&#x2F;root&#x2F;zkData</span><br><span class="line"> clientPort&#x3D;2181</span><br></pre></td></tr></table></figure><h2 id="2-2-启动"><a href="#2-2-启动" class="headerlink" title="2.2 启动"></a>2.2 启动</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1. 启动 ZK Server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;zookeeper-3.4.11&#x2F;bin</span><br><span class="line">.&#x2F;zkServer.sh start ..&#x2F;conf&#x2F;zoo.cfg</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;2. 启动成功<br><img src="/2019/01/10/ZooKeeper/e16f5df3-83c2-4ff4-bfae-076bdcaaffff.jpg" alt></p><h1 id="三、Zookeeper指令操作"><a href="#三、Zookeeper指令操作" class="headerlink" title="三、Zookeeper指令操作"></a>三、Zookeeper指令操作</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用 客户端脚本连接ZK Server **<br><code>./zkCli.sh -server ip:port</code><br>&nbsp;&nbsp;</strong>常用指令**</p><ul><li>help 帮助</li><li>connect host:port 连接到指定 zk server</li><li>get path [watch] 获取指定节点数据</li><li>ls path [watch] 查看指定节点的所有子节点</li><li>set path data [version] 给指定节点设置数据</li><li>rmr path 递归删除指定节点</li><li>quit 退出客户端</li><li>create [-s] [-e] path data acl 创建节点 -s 顺序节点 -e 临时节点</li><li>close 关闭连接</li><li>delete path [version] 删除节点<h1 id="四、JAVA-API-操作"><a href="#四、JAVA-API-操作" class="headerlink" title="四、JAVA API 操作"></a>四、JAVA API 操作</h1><h2 id="4-1-Maven-依赖坐标"><a href="#4-1-Maven-依赖坐标" class="headerlink" title="4.1 Maven 依赖坐标"></a>4.1 Maven 依赖坐标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;com.101tec&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;zkclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;0.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-2-增、删、改、查操作"><a href="#4-2-增、删、改、查操作" class="headerlink" title="4.2 增、删、改、查操作"></a>4.2 增、删、改、查操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.baizhi.zookeeper;</span><br><span class="line">import org.I0Itec.zkclient.ZkClient;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author haoransun</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ZkClientOperation &#123;</span><br><span class="line">     private ZkClient zkClient &#x3D; null;</span><br><span class="line">     @Before</span><br><span class="line">     public void before()&#123;</span><br><span class="line">         zkClient &#x3D; new ZkClient(&quot;192.168.128.160&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;**</span><br><span class="line">     * 增删改查</span><br><span class="line">     *&#x2F;</span><br><span class="line">     @Test</span><br><span class="line">     public void zkCRUD()&#123;</span><br><span class="line">         &#x2F;&#x2F; 创建持久节点</span><br><span class="line">         zkClient.createPersistent(&quot;&#x2F;tencent&quot;,true);</span><br><span class="line">         &#x2F;&#x2F; 创建临时节点</span><br><span class="line">         zkClient.createEphemeral(&quot;&#x2F;zpark&quot;,&quot;bzjy&quot;);</span><br><span class="line">         &#x2F;&#x2F; 创建临时顺序节点</span><br><span class="line">         String e1 &#x3D; zkClient.createEphemeralSequential(&quot;&#x2F;tencent&#x2F;league-of-legends&quot;, &quot;lol&quot;);</span><br><span class="line">         String e2 &#x3D; zkClient.createEphemeralSequential(&quot;&#x2F;tencent&#x2F;cross-fire&quot;, &quot;cf&quot;);</span><br><span class="line">         System.out.println(&quot;创建的临时顺序节点e1：&quot;+e1);</span><br><span class="line">         System.out.println(&quot;创建的临时顺序节点e2：&quot;+e2);</span><br><span class="line">         &#x2F;&#x2F; 获取节点列表</span><br><span class="line">         List&lt;String&gt; list &#x3D; zkClient.getChildren(&quot;&#x2F;tencent&quot;);</span><br><span class="line">         list.forEach(n -&gt; System.out.println(n));</span><br><span class="line">         &#x2F;&#x2F; 删除节点</span><br><span class="line">         boolean result &#x3D; zkClient.deleteRecursive(&quot;&#x2F;tencent&quot;);</span><br><span class="line">         System.out.println(&quot;删除结果：&quot;+result);</span><br><span class="line">         &#x2F;&#x2F; 获取节点内容</span><br><span class="line">         Object data &#x3D; zkClient.readData(&quot;&#x2F;zpark&quot;);</span><br><span class="line">         System.out.println(&quot;&#x2F;zpark 保存的数据为：&quot;+data);</span><br><span class="line">        &#x2F;&#x2F; 更新节点内容</span><br><span class="line">        监听接口 订阅方法 取消订阅方法</span><br><span class="line">        IZkChildListener subscribeChildChanges unsubscribeChildChanges</span><br><span class="line">        IZkDataListener subscribeDataChanges unsubscribeDataChanges</span><br><span class="line">        注册监听</span><br><span class="line">        在ZkClient中客户端可以通过注册相关的事件监听来实现对Zookeeper服务端事件的订阅，其中</span><br><span class="line">        ZkClient提供的常⽤监听事件接口有以下几种：</span><br><span class="line">        测试代码：</span><br><span class="line">         zkClient.writeData(&quot;&#x2F;zpark&quot;,new Date());</span><br><span class="line">         Object newData &#x3D; zkClient.readData(&quot;&#x2F;zpark&quot;);</span><br><span class="line">         System.out.println(&quot;&#x2F;zpark 更新后数据为：&quot;+newData);</span><br><span class="line">     &#125;</span><br><span class="line">         @After</span><br><span class="line">         public void after()&#123;</span><br><span class="line">             zkClient.close();</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注册监听"><a href="#注册监听" class="headerlink" title="注册监听"></a>注册监听</h2><p>&nbsp;&nbsp;在ZkClient中客户端可以通过注册相关的事件监听来实现对Zookeeper服务端事件的订阅，其中ZkClient提供的常用事件监听接口有以下几种：</p><table><thead><tr><th>监听接口</th><th>订阅方法</th><th>取消订阅方法</th></tr></thead><tbody><tr><td>IZkChildListener</td><td>subscribeChildChanges</td><td>unsubscribeChildChanges</td></tr><tr><td>IZkDataListener</td><td>subscribeDataChanges</td><td>unsubscribeDataChanges</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.baizhi.zookeeper;</span><br><span class="line">import org.I0Itec.zkclient.IZkChildListener;</span><br><span class="line">import org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line">import org.I0Itec.zkclient.ZkClient;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @author gaozhy</span><br><span class="line">* @date 2018&#x2F;4&#x2F;20.17:32</span><br><span class="line">*&#x2F;</span><br><span class="line">public class ZKListener &#123;</span><br><span class="line">     public static void main(String[] args) throws IOException &#123;</span><br><span class="line">         ZkClient zkClient &#x3D; new ZkClient(&quot;192.168.128.160:2181&quot;);</span><br><span class="line">         &#x2F;&#x2F; 订阅⼦节点改变</span><br><span class="line">         zkClient.subscribeChildChanges(&quot;&#x2F;tencent&quot;, new IZkChildListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleChildChange(String parentPath, List&lt;String&gt;currentChilds) throws Exception &#123;</span><br><span class="line">             System.out.println(&quot;parentPath: &quot;+parentPath);</span><br><span class="line">             currentChilds.forEach( n -&gt; System.out.println(&quot;child node:&quot;+n));</span><br><span class="line">             System.out.println(&quot;-----------------------------------&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         &#x2F;&#x2F; 订阅数据改变</span><br><span class="line">         zkClient.subscribeDataChanges(&quot;&#x2F;tencent&quot;, new IZkDataListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleDataChange(String dataPath, Object data)throws Exception &#123;</span><br><span class="line">             System.out.println(&quot;data change: &quot;+dataPath + &quot;,changedata: &quot;+data);</span><br><span class="line">         &#125;</span><br><span class="line">         @Override</span><br><span class="line">         public void handleDataDeleted(String dataPath) throws Exception&#123;</span><br><span class="line">             System.out.println(&quot;delete node path: &quot;+dataPath);</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         System.in.read();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、应用"><a href="#五、应用" class="headerlink" title="五、应用"></a>五、应用</h1><h2 id="5-1-命名服务（Naming-Service"><a href="#5-1-命名服务（Naming-Service" class="headerlink" title="5.1 命名服务（Naming Service)"></a>5.1 命名服务（Naming Service)</h2><p>如：阿⾥巴巴集团开源的分布式服务框架Dubbo中使⽤ZooKeeper来作为其命名服务，维护全局的服务地址列表。在Dubbo实现中： 服务提供者在启动的时候，向ZK上的指定节点/dubbo/${serviceName}/providers目录下写入自己的URL地址，这个操作就完成了服务的发布。服务消费者启动的时候，订阅/dubbo/${serviceName}/providers目录下的提供者URL地址，并向/dubbo/${serviceName}/consumers目录下写入自己的URL地址,注意：所有向ZK上注册的地址都是临时节点，这样能够保证服务提供者和消费者能够自动感应资源的变化。</p><p><img src="/2019/01/10/ZooKeeper/9fbc88b2-8d78-49c7-b59b-b38aebb6c49a.jpg" alt></p><h2 id="5-2-集群管理与Master选举"><a href="#5-2-集群管理与Master选举" class="headerlink" title="5.2 集群管理与Master选举"></a>5.2 集群管理与Master选举</h2><p>利用Zookeeper有两个特性，就可以实现另一种集群机器存活性能监控系统：</p><ol><li>客户端在节点X上注册一个Wather，那么如果X的子节点变化了，会通知客户端、</li><li>创建EPHEMERAL类型的节点，一旦客户端和服务器的会话结束或过期，那么该节点就会消失。<h2 id="5-3-数据发布与订阅（配置中心）"><a href="#5-3-数据发布与订阅（配置中心）" class="headerlink" title="5.3 数据发布与订阅（配置中心）"></a>5.3 数据发布与订阅（配置中心）</h2>发布与订阅模型，即所谓的配置中⼼，顾名思义就是发布者将数据发布到ZK节点上，供订阅者动态获<br>取数据，实现配置信息的集中式管理和动态更新。例如全局的配置信息，服务式服务框架的服务地址<br>列表等就⾮常适合使⽤。<h2 id="5-4-分布式锁"><a href="#5-4-分布式锁" class="headerlink" title="5.4 分布式锁"></a>5.4 分布式锁</h2>分布式锁，这个主要得益于ZooKeeper为我们保证了数据的强⼀致性。锁服务可以分为两类，⼀个是<br>保持独占，另⼀个是控制时序。</li></ol><p>更详细的应用场景，可参考：</p><ol><li><a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="noopener">http://jm.taobao.org/2011/10/08/1232/</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></li></ol><p>yum install -y wget</p>]]></content>
      
      
      <categories>
          
          <category> ZooKeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用架构演变过程</title>
      <link href="/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p>看了好多大佬的架构设计经验，也看到好多大型网站的基本架构，始终是老虎吃天-无从下手，个人在此乱画一下，记录当前的经验见解。</p><a id="more"></a><p><img src="/2018/12/20/%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map-Reduce学习</title>
      <link href="/2018/12/20/Map-Reduce%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/20/Map-Reduce%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><p><font color="red">Map-Reduce的过程与MongoDB如出一辙</font>（如下图）<br><img src="/2018/12/20/Map-Reduce%E5%AD%A6%E4%B9%A0/b8211209-31ef-425b-b480-9765994698c9.jpg" alt></p><h2 id="1-Map-Reduce简介"><a href="#1-Map-Reduce简介" class="headerlink" title="1 Map-Reduce简介"></a>1 Map-Reduce简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapReduce</strong>是一种编程模型，用于大规模数据集（大于<strong>1TB</strong>）的并行运算。该运算充分利用<strong>Hadoop</strong>存储节点（<strong>DateNode</strong>）所在物理主机的CPU、内存、网络以及少许磁盘完成分布式计算。通过在<strong>DateNode</strong>所在的主机上启动<strong>NodeManager</strong>进程，该进程负责启动计算任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapReduce</strong>计算框架将分布式计算分为两个阶段：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Map</strong>阶段：在任务计算初期，计算框架会提前计算好任务切片（对数据做区域划分），然后<font color="red">根据切片数目</font>启动MapTask，对切片所映射的数据做局部的分析/计算，将计算的临时结果存储到对应物理主机的磁盘（<strong>MapTask</strong>的溢写）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Reduce</strong>阶段：在<strong>Map</strong>阶段的所有操作完成计算任务后，计算框架会选择若干机器（手动指定）执行ReduceTask，完成对<strong>Map</strong>阶段计算数据的汇总（<strong>shuffle</strong><font color="red">洗牌</font>）。</p><a id="more"></a><h2 id="2-Map-Reduce计算过程"><a href="#2-Map-Reduce计算过程" class="headerlink" title="2 Map-Reduce计算过程"></a>2 Map-Reduce计算过程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">修路的故事</font>：我们要修一条从<font color="red">西藏</font>到<font color="red">上海</font>的高速公路，由<strong>西北</strong>到<strong>东南</strong>；首先呢，这个工程量是十分巨大的，我们不能让一个工程队去修这条路，（从理论上来讲，是可行的，从祖父到重孙….）但是周期太长，中间会不会发生变故，还不好说。所以一个大的工程出现后，要有一个合理的时间规划，假如期限是1年内搞定，那怎么办呢？此时就需要路段区间同时施工，但区间同时施工又会产生一个问题，这个事儿该由谁来主持呢？史某一个人来主持吗？不可能，修路这种东西，尤其是跨地区修路，是非常难的。每个省、市。区都有自己的特殊的东西，如：钉子户的解决，拆迁的成本等。修路是一个国家的大事，不是某个人可以单独解决的。这就由每个地区的国土资源部来审核、主持。但是跨地区呢？由中央国土资源管理中心来审核、主持各个地区的国土资源部。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提议：修一条从西藏到上海的路，带动周边经济。中央的国土资源部拿到这个请求后，会开会商讨，觉得此事儿可行，靠谱。中央会下发文件，给该工程起代号。中央可以审批，但是有一个前提：就是在我审批之后，未来这个路的具体修法不可能让国家领导人来操心吧，所以：中央审批完成后，会由第一人做三件事，<strong>1.</strong> <font color="red">具体的施工区间（这条路会经过哪些省份、地区）路段</font>（方便各国土资源部进行各自的土地划量，区间同时作业）。<strong>2.</strong> 当地具体该怎么修这条路呢，是修水泥路呢？还是沥漆呢？路面有多宽，多厚？需不需要修建  绿化带呢？即<font color="red">修路的标准要定好</font>。<strong>3.</strong><font color="red">路段的对接标准</font>:各个工程队都不傻，都会只负责各自的划分区域，那些交接的区域该怎么对接呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在整理好上述三件事后，要将文件进行公示，<font color="red">即所有人都能看到</font> <strong>4</strong>.将文件详情上传给中央后，中央说：修吧。<strong>5.</strong> 中央会让河南省的国土资源部推荐一个人，即<font color="red">工程总监</font>，全权负责西藏到上海的修路事宜。 当地的（河南省）的国土资源部会选举、指派一个<font color="red">工程总监</font>作为<font color="red">负责人</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个负责人可能一晚上都睡不好觉了，因为这是一个大项目，搞砸了咋笨呢？此人心里会思考：这么大的工程量我该怎样去检测、去实施呢？<strong>6.</strong><font color="red">修路的管理规范定制好</font>，每隔多长时间，<font color="red">各个工程队要向我汇报各个区间的施工进度</font>，有什么难题向我汇报，我要知道工程的施工进度（假如说在施工期间，某个施工队因为技术达不到而修不了某一区间段内的路，要及时通报我，我会从其他地方抽调专业的施工队来帮助你修路）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个工程总监想了一夜终于想好后，紧接着该第七步路。<strong>7.</strong> 工程总监从网上下载<font color="red">初期的公示文件</font>：因为要看路段从哪到哪，经过哪些区域，需要哪一个地区的国土资源部配合我的工作等详细信息；<strong>8.</strong> 一切就绪后，负责人就开始<font color="red">向中央申请资金</font>了，<strong>9.</strong> 工程总监将资金、工程区间段的图纸、施工信息等下发给拨给各个地区的<font color="red">国土资源部</font>，交给他们去具体的修路。<strong>10.</strong> 各地区国土资源部拿到拨款后，会在<font color="red">当地进行招标</font>，(带动当地经济，肥水不流外人田)  钱已经给到了<font color="red">工程队</font>。<font color="red">工程队</font>拿到钱后，并不是立马开始修路的，他要去根据<font color="red">公示文件</font>去判断区间范围和修路标准，<strong>11.</strong> 各地区中标<font color="red">工程队开始施工修路</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<font color="red">施工期间</font>要注意的事项：各个地区开始同时施工，施工的第一阶段，<font color="blue">所有的工程队只修自己所负责的区间段，按照既定的标准去修就OK了</font>；各个施工队汇报工程进度时，汇报对象不再是当地政府，而是<font color="red">工程总监</font>，可能出现的状况：当地政府指定了某一个施工队，但是没有考虑施工的具体难易，本地的工程队儿干不了，向工程总监反馈，工程总监考虑从其他地区调工程队来（不到万不得已，不会调，因为有人力、物力、财力流失浪费）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">当所有的工程队把自己所下发的区间段修完后，工程总监就知道了</font>，此时路段该对接了，第一阶段的Map，因为有公示文件订好了，照着干就行，工程总监干预不了，而第二阶段的Reduce阶段则由<strong>工程总监</strong>说了算。（不可能让某一个区域的个人去做对接，效率太慢，也不可能让所有的工程队都参与对接，浪费资源）由工程总监去指定若干个工程队去进行工程的对接（原来1000,现在改为10个或不等个）。</p><h3 id="2-1-举例"><a href="#2-1-举例" class="headerlink" title="2.1 举例"></a>2.1 举例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>1. Client JVM</strong><font color="red">(提议人)</font>，向<strong>ResourceManager</strong><font color="red">(中央国土资源中心)</font>进行<strong>Job</strong><font color="red">(提议)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>2. ResourceManager</strong>会下发一个文件<strong>get new application(授权)</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>3. Client JVM<font color="red">(客户端)</font></strong> 要<strong>copy job resource</strong><font color="red">(公示自己的文件)</font>，工程所用到的资源：路段信息、施工标准、运行上下文等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>4. Client JVM</strong><font color="red">(提议人)</font>，向<strong>ResourceManager</strong><font color="red">(中央)</font>进行<strong>submit applications</strong><font color="red">(施工文档的提交)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>5a. ResourceManager</strong><font color="red">(中央)</font>会<strong>start container</strong><font color="red">(下发命令)</font>，给地方的<strong>NodeManager</strong><font color="red">(国土资源中心)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>5b. NodeManager</strong><font color="red">(当地政府)</font>除了找工程队外，还要选举、启动<strong>MRAppMaster</strong><font color="red">(工程总监)</font>，<strong>MRAppMaster只有一个</strong>。所有的地方政府都要听他的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>6. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>Initialize Job</strong><font color="red">(初始化Job)</font>，即相当于先将任务的<font color="red">监测进程</font>启动好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>7. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>retrieve input splits</strong><font color="red">(查看输入切片，相当于区域路段信息，)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>8. MRAppMaster</strong><font color="red">(工程总监)</font> <strong>allocate resources</strong><font color="red">(拨款,请求资源：Cpu、内存等)</font> from <strong>ResourceManager</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>9a. MRAppMaster</strong><font color="red">(工程总监)</font>会<strong>start container</strong><font color="red">(发号指令)</font>给<strong>NodeManager</strong><font color="red">(地方政府)</font>，去跟地方国土资源中心说：中央给你拨了那么多款，你去把路给我修好了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>9b. NodeManagerr</strong><font color="red">(地方政府)</font>会<strong>launch</strong><font color="red">(启动)</font>一个本地的<strong>YarnChild</strong><font color="red">(工程队)</font>,此处的YarnChild是一个统称，它既可以是MapTask(区域施工)，也可以工程对接（Reduce Task）.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>10. YarnChild</strong><font color="red">(工程队)</font>会<strong>retrieve job resources</strong><font color="red">(查询确认自己的到底要修那条路，施工。对接标准如何，取决于启动的是区间作业工程队，还是工程对接工程队)</font>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>11. YarnChild</strong><font color="red">(工程队)</font><strong>run</strong> 任务，第一阶段一定是<strong>MapTask</strong>,这个任务量取决于有多少个<strong>切片</strong>（splits），第二阶段由<strong>MRAppMaster</strong>去找寻指定的<strong>NodeManager</strong>启动<strong>ReduceTask</strong>。<br><font color="red">路修完后：工程总监<strong>MRAppMaster</strong>、YarnChild<strong>工程队</strong>的头衔头没有了，当地政府还存在，所以整个<strong>Yarn框架</strong>的核心进程就两个：<strong>ResourceManager</strong>和<strong>NodeManager</strong>，MRAppMaster和YarnChild属于计算过程中的进程，用完就回收。</font></p><p><img src="/2018/12/20/Map-Reduce%E5%AD%A6%E4%B9%A0/wpsA77A.tmp.jpg" alt><br><strong>ResourceManager</strong>：资源管理中心，管理<strong>NodeManager</strong>、分配任务资源<br><strong>NodeManager</strong>：启动<strong>MRAppMaster</strong>、<strong>YarnChild</strong><br><font color="red">以上两个是Yarn框架的常驻内存进程。</font><br><strong>MRAppMaster</strong>：监测任务运行（一个任务，只有一个）<br><strong>YarnChild</strong>：MapTask或者ReduceTask的总称，具体计算进程。<br><strong>YarnChild</strong>进程数目：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>MapTask</strong>：切片控制（数据逻辑映射区间）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ReduceTask</strong>：程序手动指定。</p><h2 id="3-搭建YARN计算环境"><a href="#3-搭建YARN计算环境" class="headerlink" title="3 搭建YARN计算环境"></a>3 搭建YARN计算环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS ~]# cp &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml.template &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;mapred-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;yarn-site.xml</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.nodemanager.aux-services&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;mapreduce_shuffle&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;yarn.resourcemanager.hostname&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;CentOS&lt;&#x2F;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">启动Yarn</span><br><span class="line">[root@CentOS ~]# start-yarn.sh</span><br><span class="line">[root@CentOS ~]# jps</span><br><span class="line">1628 SecondaryNameNode</span><br><span class="line">1780 ResourceManager</span><br><span class="line">1447 DataNode</span><br><span class="line">1905 Jps</span><br><span class="line">1363 NameNode</span><br><span class="line">1863 NodeManager</span><br></pre></td></tr></table></figure><p>访问：<a href="http://centos:8088/cluster" target="_blank" rel="noopener">http://centos:8088/cluster</a> 即可看到MapReduce的界面化管理。<br><a href="https://www.jianshu.com/p/20ed705ed5b6?utm_campaign" target="_blank" rel="noopener">参考文档</a></p><h2 id="4-掌握Map-Reduce编程模型"><a href="#4-掌握Map-Reduce编程模型" class="headerlink" title="4 掌握Map-Reduce编程模型"></a>4 掌握<strong>Map-Reduce</strong>编程模型</h2><p>未完待续</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop学习</title>
      <link href="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="1-BigData是什么？"><a href="#1-BigData是什么？" class="headerlink" title="1 BigData是什么？"></a>1 BigData是什么？</h2><p>&nbsp;&nbsp; 巨量资料,需要利用目前主流软件工具在合理的时间范围内对数据进行截取，转换已达到帮助企业获取有用资讯的目的。<br>&nbsp;&nbsp; 数据量极大：GB、TB、PB数据样板足够大。<br>&nbsp;&nbsp; 数据时效性：time-value 数据处理速度快，合理的时间范围。<br>&nbsp;&nbsp; 数据多样性：数据存在形式多样化。<br>&nbsp;&nbsp; 数据可疑性：数据要有价值。—清洗、降噪（沙海淘金）</p><h2 id="2-BigData面临的问题？"><a href="#2-BigData面临的问题？" class="headerlink" title="2 BigData面临的问题？"></a>2 BigData面临的问题？</h2><p>&nbsp;&nbsp; 存储、分析：<br>&nbsp;&nbsp; 方案：<br>&nbsp;&nbsp; 垂直提升：升级硬件，成本高 &nbsp;&nbsp; 计算机-摩尔定律（每18个月，成本不变-性能提升1倍）<br>&nbsp;&nbsp; <font color="red">水平扩展：成本可线性控制–分布式思维&nbsp;&nbsp; √</font><br>&nbsp;&nbsp; <strong>Hadoop</strong>就是在通过线性服务扩展，去解决大数据所面临的存储和计算。<br>&nbsp;&nbsp; <strong>Hadoop</strong>有两个模块：<br>&nbsp;&nbsp; &nbsp;&nbsp; <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS</a> hadoop distributed file system：解决大数据存储问题。<br>&nbsp;&nbsp; &nbsp;&nbsp; MapReduce:通过Map阶段和Reduce阶段实现对大数据的分布式并行计算。</p><a id="more"></a><h2 id="3-Hadoop生态："><a href="#3-Hadoop生态：" class="headerlink" title="3 Hadoop生态："></a>3 Hadoop生态：</h2><p>&nbsp;&nbsp; HDFS：分布式文件存储系统<br>&nbsp;&nbsp; MapReduce：分布式计算引擎<br>&nbsp;&nbsp; HBase：基于HDFS上的一款列存储NoSQL数据库<br>&nbsp;&nbsp; Flume：分布式日志采集<br>&nbsp;&nbsp; Kafka：分布式消息队列<br>&nbsp;&nbsp; <strong>Mahout：机器学习算法库，绝大多数算法通过MapReduce计算模型实现</strong><br>&nbsp;&nbsp; Zookeeper：分布式协调服务<br><strong>大数据计算</strong><br>&nbsp;&nbsp; 离线计算：Hadoop Map Reduce<br>&nbsp;&nbsp; 近实时计算：Spark Core(离线计算)<br>&nbsp;&nbsp; 实时计算：Storm、KafkaStream、SparkStram</p><p><strong>HDFS安装（单机环境-伪分布式）</strong><br>1）CentOS-6.5 64 bit 基本配置<br>&nbsp;&nbsp;&nbsp;&nbsp;1.主机名必须CentOS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;sysconfig&#x2F;network </span><br><span class="line">NETWORKING&#x3D;yes</span><br><span class="line">HOSTNAME&#x3D;CentOS</span><br><span class="line">然后reboot即可。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp; 2.修改主机名和ip的映射关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;hosts</span><br><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.80.100 CentOS</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp; 3.关闭本机的防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">关机开机自启</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure><p>2）安装 JDK 配置 JAVA_HOME环境变量<br><font color="blue"><br>附注：yum install -y lrzsz     使用rz进行上传<br>lrzsz自行百度（是一款在linux可代替ftp上传和下载的程序）<br></font><br>在usr/local安装jdk-rpm后，使用 <code>ls /usr/java/latest</code>可以产看安装信息<br><font color="red">配置用户环境变量</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS local]# vi .bashrc</span><br><span class="line"># .bashrc</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;latest</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line"></span><br><span class="line">wq保存退出后使用 source .bashrc命令使其立即生效</span><br></pre></td></tr></table></figure><p>使用jps看是否识别：jps [用于查看java进程]</p><p>3）配置 CentOS 系统的 SSH免密码登录（<strong>基于密钥的安全验证</strong>）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原始带密码用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.80.100</span><br><span class="line">ssh 身份@主机名</span><br><span class="line">输入 yes 输入密码即可</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSH 为 Secure Shell的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两种安全验证级别：</p><ol><li><p>基于口令的安全验证<br>&nbsp;&nbsp;&nbsp;&nbsp;只要你知道你自己的账号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，即受到<font color="red">中间人</font>这种方式的攻击。</p></li><li><p>基于密钥的安全验证<br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/167b4606-c285-4335-a8c4-f35058d2ea44.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;需要依靠<a href="https://baike.baidu.com/item/%E5%AF%86%E5%8C%99" target="_blank" rel="noopener">密匙</a>，也就是你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。用这种方式，你必须知道自己密匙的<a href="https://baike.baidu.com/item/%E5%8F%A3%E4%BB%A4" target="_blank" rel="noopener">口令</a>。但是，与第一种级别相比，第二种级别不需要在网络上传送口令。<br>第二种级别不仅加密所有传送的数据，而且“中间人”这种攻击方式也是不可能的（因为他没有你的私人密匙）。但是整个登录的过程可能需要10秒</p><h3 id="3-1-在自己的机器上产生公私钥对"><a href="#3-1-在自己的机器上产生公私钥对" class="headerlink" title="3.1 在自己的机器上产生公私钥对"></a>3.1 在自己的机器上产生公私钥对</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa         使用rsa算法生成公私钥对（按4次回家即可）</span><br><span class="line">在用户的家目录下</span><br><span class="line">ls -al .ssh&#x2F;              即可看到</span><br><span class="line">使用 ssh-copy-id CentOS   添加到目标机的目录下（CentOS为目标机名称）</span><br><span class="line">被添加到 .ssh&#x2F;authorized_keys文件中</span><br><span class="line">ls -al .ssh&#x2F;              即可看到</span><br></pre></td></tr></table></figure><p>有了 .ssh/authorized_keys 才可免密码登录，使用 ssh root@CentOS 验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .ssh&#x2F;id_rsa.pub &gt;&gt; .ssh&#x2F;authorized_keys</span><br><span class="line">与</span><br><span class="line">ssh-copy-id CentOS 等价</span><br></pre></td></tr></table></figure><p>4）<strong>安装配置 Hadoop（单机环境）</strong></p><ol><li>解压Hadoop tar包 到 /usr/目录下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf hadoop-2.6.0_x64.tar.gz -C &#x2F;usr&#x2F;</span><br><span class="line">ls &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;</span><br></pre></td></tr></table></figure></li><li>配置hadoop环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> vi .bashrc</span><br><span class="line"> HADOOP_HOME&#x3D;&#x2F;usr&#x2F;hadoop-2.6.0</span><br><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;latest</span><br><span class="line">PATH&#x3D;\$PATH:\$JAVA_HOME&#x2F;bin:\$HADOOP_HOME&#x2F;bin:\$HADOOP_HOME&#x2F;sbin</span><br><span class="line">CLASSPATH&#x3D;.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br><span class="line">export HADOOP_HOME</span><br><span class="line">:wq保存退出</span><br><span class="line">source .bashrc 使其立即生效</span><br></pre></td></tr></table></figure>附注：hadoop的安装目录结构 使用插件 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y tree</span><br><span class="line">使用 tree -L 2 &#x2F;usr&#x2F;hadoop-2.6.0&#x2F; </span><br><span class="line">可以查看hadoop的两级目录，2：代表看2级  1：看1级目录</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/02eec767-36ad-402f-8810-01714d9289b5.jpg" alt></p><p>配置参考 <a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-common/SingleCluster.html</a></p><p>这里的/tmp/hadoop-${user.name} 改成 /usr/hadoop-2.6.0/hadoop-${user.name}   安装在父级目录下</p><ol start="3"><li>修改hadoop配置文件(参考上面的链接地址)<br>1 core-site.xml<br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/67e36864-d57b-4d53-a6ee-1caeec63c5cf.png" alt></li></ol><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/8c22fd03-3996-41ba-b054-73e5e67183c2.png" alt></p></li></ol><p><font color="red">此处配置的是访问Namenode服务节点的入口CentOS:9000</font></p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/20153575-b524-4128-ac34-156fb6b3c75e.png" alt></p><p><font color="red">而CentOS:50010是访问Datenode服务节点的入口</font></p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/1673b7cd-f5a0-42fc-b25d-04238010169f.png" alt></p><p><strong>/usr/hadoop-2.6.0/hadoop-root</strong> 此处是整个Hdoop存储的基准目录（无论是Namenode存储元数据，还是Datenode存储块数据）他们都要存储在此基准目录下。（因为用户名是root，所以${user.name}被替换为root)</p><p><strong>使用命令行</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree -L 2 &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;hadoop-root&#x2F;</span><br><span class="line">即可看到 dfs下有data（存储块数据）、name(存储元数据)、namesecondary(秘书)三个文件目录。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;core-site.xml</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;fs.defaultFS&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;hdfs:&#x2F;&#x2F;CentOS:9000&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property&gt;</span><br><span class="line">            &lt;name&gt;hadoop.tmp.dir&lt;&#x2F;name&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;usr&#x2F;hadoop-2.6.0&#x2F;hadoop-$&#123;user.name&#125;&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>  2 hdfs-site.xml</p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/323d8f26-c7c4-40a9-b33e-108dc55f2c8a.png" alt><br><font color="red">此处设置副本集，因为当前是伪分布式，只有一个机器，所以设置为1，块没有副本。</font><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/7c75db69-b861-4a39-8462-59b60988daeb.png" alt><br><font color="red">此处只有CentOS存储了</font></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;&#x2F;hdfs-site.xml</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">    &lt;property&gt;</span><br><span class="line">        &lt;name&gt;dfs.replication&lt;&#x2F;name&gt;</span><br><span class="line">        &lt;value&gt;1&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure><p>   3 slaves<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;hadoop-2.6.0&#x2F;etc&#x2F;hadoop&#x2F;slaves </span><br><span class="line">将 localhost 改为 CentOS  即当前的主机名</span><br></pre></td></tr></table></figure><br> <strong>启动 HDFS服务</strong><br>第一次启动时参考链接，使用如下命令进行启动：<br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/3fc6c3f7-29e9-4bab-bd63-a57bb4d70d88.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format  （仅第一次启动时需要）</span><br><span class="line"></span><br><span class="line">start-dfs.sh   启动（其中需要输入yes即可）</span><br><span class="line">jps 出现如下即成功</span><br><span class="line">DataNode</span><br><span class="line">NameNode</span><br><span class="line">SecondaryNameNode</span><br><span class="line">Jps</span><br><span class="line"></span><br><span class="line">也可通过 浏览器 192.168.80.100:50070访问</span><br><span class="line">                本机IP:50070访问</span><br><span class="line">出现Hadoop页面即成功启动</span><br><span class="line"></span><br><span class="line">stop-dfs.sh  （使用此命令关闭hadoop服务）</span><br></pre></td></tr></table></figure><p>使用如下命令进行<font color="red">上传、删除</font>操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -put &#x2F;root&#x2F;hadoop-2.6.0_x64.tar.gz &#x2F;</span><br><span class="line">hdfs dfs -rm -r -f &#x2F;hadoop-2.6.0_x64.tar.gz</span><br><span class="line">创建目录：hdfs dfs -mkdir &#x2F;dir</span><br><span class="line">查看目录：hdfs dfs -ls &#x2F;</span><br></pre></td></tr></table></figure><p>页面效果：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/7a72e903-35e7-4c4e-aa3b-f0a0e7496aa6.png" alt><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/9d8d0169-e01e-4092-8998-399a69eec890.png" alt></p><p><strong>为什么需要使用hdfs namenode -format 对“老大”格式化呢？</strong><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/a832df60-4c67-4993-a064-460b7f98de50.png" alt><br>使用 tree /usr/hadoop-2.6.0/hadoop-root/命令可以看到name下的block元数据，例如当前是 <font color="red">blk_1073741827和blk_1073741828</font>，对比下图，可知页面此处存储的是元数据。<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/d1a8e8f4-1c4d-4a7b-a55d-b7f9a2ebf371.png" alt>)<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/8c0f6317-7dac-4998-8639-ae08f1ae312a.png" alt><br><strong>如果启动不起来，只能使用命令 rm -rf /usr/hadoop-2.6.0/hadoop-root，删掉此文件夹，重新格式化 hdfs namenode -format</strong></p><p><strong>如果想要获取某一个切片数据怎么办呢？使用 sz命令层层查找，如图所示：</strong><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/e3b2f8c4-be62-4c14-bbd9-3d809d6ebe45.jpg" alt></p><h2 id="4-Hadoop架构图-三个服务节点详解"><a href="#4-Hadoop架构图-三个服务节点详解" class="headerlink" title="4 Hadoop架构图-三个服务节点详解"></a>4 Hadoop架构图-三个服务节点详解</h2><h3 id="4-1-回顾文件系统-FastDFS-MongDB架构对比"><a href="#4-1-回顾文件系统-FastDFS-MongDB架构对比" class="headerlink" title="4.1 回顾文件系统 FastDFS-MongDB架构对比"></a>4.1 回顾文件系统 FastDFS-MongDB架构对比</h3><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/984cd0ea-bfe4-4798-8ddb-4d6e57638359.jpg" alt><br><font color="red">木桶原理</font>：以性能最短的作为整个集群的上限。<br><font color="red">泳道原理</font>：各司其职，彼此独立。</p><h3 id="4-2-架构图"><a href="#4-2-架构图" class="headerlink" title="4.2 架构图"></a>4.2 架构图</h3><p><a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html" target="_blank" rel="noopener">HDFS</a></p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/77d58bfc-e130-4014-b8a2-5b97969a9ab9.jpg" alt></p><p><font color="red">Block</font>：HDFS底层将文件切割成<font color="red">Block</font>，默认切割尺度128MB（切割尺度可配置，若不足128MB，按照实际大小存储成一个Block）.<br><font color="red">Namenode</font>：管理集群元数据（文件名、数据块映射）、下发指令给Datenode<br><font color="red">Datenode</font>：数据节点，负责其存储数据块的读写请求，同时向Namenode汇报自己的状态信息<br><font color="red">Rack</font>：机架，优化存储，优化计算，可以通过命令<code>hdfs dfsadmin -printTopology</code>看到。<br><strong>架构理解：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDFS是一个主从架构，HDFS只维护了一个单一的Namenode节点，作为“老大”，这个主节点发号施令，并且存储元信息，监测Datenodes节点群的状态。HDFS有一系列的Datenode节点，作为Namenode的“小弟”， 小弟听从执行老大的各种指令，例如Creation,Deletion,Replication。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Namenode存储的是元数据，也可以理解为块的索引，”一个文件切割成块，就像把大象切割存到了冰箱里，未来如果想要大象在幻化拼接出来，就需要这种索引，即元数据.“，Namenode存的是元数据（索引），而不是数据。这些集群的元数据存储在Namenode节点的内存中，元数据即是文件路径、块到Datenode的映射关系等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Hadoop是以块的形式存储数据的，块的大小是128MB，这是一种切割尺度，例如存出一个文件，如果小于128MB，则切不开，一个块即可存储，此时块的大小即是文件的实际大小</font>,<font color="blue">但是，对于Namenode而言，再小的一个文件也需要记录，需要记录这个块存储在了那个Datenode上面，即块到Datenode的映射关系。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">举个例子：有一个文件，这个文件128MB，按照128MB的尺度去切，能切除一个块出来，Namenode就需要存储一个块的元信息即可；“Hadoop不适合存储小文件”。又比如：有1W个文件，加在一起是128MB，现在用同样的尺度去切，则每一个文件都是一个Block,会产生1W个Block,则Namenode上会存储1W个块的元信息（映射信息）,Datenode存储1W个文件，这1W个文件有128MB，对于Datenode而言，1个128MB的文件和1W个文件总共128MB加在一起去存储，没有任何影响，都是存，但是问题来了，Namenode则得不偿失，Namenode的内存浪费很严重（整个HDFS中只有1个Namenode,其内存及其宝贵）.Datenode不够可以线性扩展。</font></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看上图可知：Datenode节点之间没有关系，只不过他们之间的Block是有复制的，Hadoop的机制是每一个块，在整个集群中最起码有一个备份，（这里与FastDFS和MongoDB的备份不同，他们是服务器与服务器之间的备份，FastDFS卷内是机器间整体的备份，MongoDB是shard之间整体的备份，而Hadoop做的是块的备份，更细粒度的备份，FastDFS与MongoDB做的是整体间的备份，就要求副本集成员之间机器的配置必须是一样的，而Hadoop则没有这种要求，不管是什么类型的机器，只要能存储数据，我都能利用起来，哪怕是存储一个Block,这样意味着Hadoop对成百上千个Datanode的硬件要求极低(能存就行）。<font color="red">这是Hadoop与传统的分布式文件系统最大的差异,传统的是做机器内部整体的备份，Hadoop没有这个要求，Datanode之间彼此独立，依据各自性能存储不同数量的块。</font>如果有一个机器挂掉了，则有备份，这就是Hadopp做的故障转移，<font color="red">只要保证每个块，存在一定数量的副本即可</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看上面图可知：客户端只要是操作元数据，走的是Namenode。 只要是对块的读写，走的是Datenode,同时，Namenode负责向Datenode发号指令。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">Rack:机架</font>，类似于书架(书多了没地方放，有了书架可以更好的管理书籍)，机器多了，就需要机架，更方便的管理机器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似于上图，<font color="red">块的复制是机架间的复制，</font>我们都有风险意识，不要把鸡蛋放到一个篮子里，防止鸡飞蛋打。将一批机器放在一个物理的机架上，这批机器共享一个交换机，<font color="red">首先</font>，这样有助于运维，如果这个机架上的某个机器坏了，检修这个机架上的故障机器即可，对别的机架上的机器运转没有影响；<font color="red">其次</font>，如果有电气故障（失火，机器都烧没了），别的机架上的机器不受影响。<font color="blue">安全角度，块的副本集起码不是都在一个机架间的机器上，保证了容灾恢复块数据。</font>效率角度：尽可能做机架内部机器间的通讯，尽量避免跨机架间通信，因为要多走起码一个路由器.</p><p>** HDFS存储特点：**<br> 1）各个DataNode物理服务节点配置物理要求<br> 2）不擅长存储小文件<br><strong>NameNode和Secondary(辅助)NameNode</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为Namenode太忙了，就需要为Namenode配置一个<font color="red">秘书 SecondaryNamenode</font>.类比现实生活：<strong>假如说公司的领导跑路了，小秘在也不能担当领导的职责，总经理跑路了，总经理助理也不能下发任意指令。没有人听总经理助理的命令，不具备对集群的管理能力，充其量就是<font color="red">端茶、倒水、整理文件</font></strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">NameNode</font>主要是维系集群的元数据信息，主要是：<strong>fsimage、edits、edits_inprogress</strong>，而<font color="red">SecondayNameNode</font>充其量只有<strong>fsimage、edits</strong>，缺少了<font color="red">edits_inprogress</font> 类似于下图：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/02668115-cf77-4fc3-8a60-21552578ca51.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>edits与fsimage</strong>：存储在NameNode服务器本地的两个文件，edits文件类似于日志文件，记录的是用户对NameNode元数据的修改；fsimage记录的是内存中的数据。edits和fsimage加起来才等价于<font color="red">老大Memory中的元数据。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Hadoop启动过程与上述两文件的关系：（Memory中元数据的由来）</strong>Hadoop在启动NameNode的时候,<font color="purple">NameNode将fsimage和edits中的数据加载到内存中，fsimage是元数据的二进制信息，而edits是对元数据的修改操作信息；因此会利用edits中的日志对fsimage做一些执行操作，以达到内存中的数据恢复至上一次关机前的内存状态，当内存数据恢复之后，Namenode会刷新这两个文件，结果会导致edits被清空，而fsimage与内存保持高度一致。这些操作都发生在启动过程中</font>，接下来，NameNode开始正常工作，即开始管理Datenode,因为Datenode会汇报自己的状态信息，此时Namenode会将这些收集到的状态信息与自己内存中信息作对比，一旦对比通过，则集群可以正常运行；<font color="red">在此期间，外界可以对HDFS做一些文件上传、修改的指令，此时会分为两个阶段：修改的指令直接发到NameNode的内存中，此时达到了对元数据的修改；同时，内存中的数据是不稳定的，易丢，Hadoop为了保证用户的每一次操作都是安全的，会将写的数据存入edits日志中，此刻，内存中的数据才是整个NameNode所有的数据（原始的+新发送的指令数据）,edits+fsimage才等于内存中的数据，问题来了？如果Hadoop长时间工作在一个修改比较频繁的环境下，会导致edits会越来越大（Memory的内存消耗暂时不看），对比Redis的AOF持久化，AOF记录的是内存中所有的操作，而edits记录的只是从这一次启动到正常工作以后所有的修改操作的增量，会导致edits文件越来越大，如果edits有一种机制：可以flush就好了，即刷新fsimage到磁盘即可，只要刷新成功，edits中的数据既可以释放。</font>但是。如果去刷新fsimage,会拉低NameNode的性能（NameNode的神经是紧绷的，因为他要管理整个集群的信息，有成千上百个人等着我去主持会议，汇报工作，发布指令，能让我在家里整理内务？），如果刷新成功，当关闭再次开启的时候，edtits不会有那么大了，Namenode启动就会十分快了，反之，Namenode没有时间去整理自己的edits，下一次启动还是走上述两个阶段，还是慢的要死。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个公司的规模如果十分大了，就会想方设法提高效率，总裁级别的人一般都有小秘，小秘<font color="red">辅助</font>的做一些日常工作，再怎么辅助，不能干预公司的决定，古代宦官、后宫不能干政是一个道理。让小秘去整理内务，没让小秘去管理自己的小弟，况且小弟也不会听小秘的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red">SecondaryNameNode就相当于给NameNode请了一个小秘、保姆、助理</font>.助理没有非常大的权利，但是待遇很好，总裁在那个办公室，小秘就在总裁办公室的旁边，<strong>有点像皇帝身边的太监</strong>。为什么待遇这么好呢？小秘给总经理做事，总经理的一些私事是不想让小弟知道的，小秘要保密的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同理，NameNode负责去管理元数据和DateNode，但因为分身乏术，疏于对自己自身数据的持久化，丧失了对自己数据的管理能力，就需要有一个和NameNode内存、配置一样的机器，因为SecondaryNameNode会定时的去访问NameNode,问NameNode需不需要我来做整理啊？此处的“问”就是去查NameNode的edits文件有多大了，距离我上一次来整理你过了多长时间了，如果这两个条件满足了，即<font color="red">时间到了而且文件过大了</font>,小秘就会拷贝-下载（不能拿走，即剪切，总经理要用怎么办呢？）edits和fsimage各一份到自己的本地磁盘中，在拷贝的过程中，总经理还在忙（比如还有人要修改文件），怎么办呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="blue">NameNode中的edits_inprogress登场了，即准备一个临时的文件，如果有人发来的写的指令，总裁就先将指令暂存到edits_inprogerss文件中，同时，小秘会在自己内存中模拟总裁以前的NameNode的过程，加载、合并，拿到一个更新的fsimage,比总裁的fsimage心新，因为在小秘那里，原有的fsimage已经和edits合并了，当然是最新的了；然后小秘会将自己最新的fsimage(已经整理好的文件)再次上传给总裁那里，为了不与总裁原有的fsimage命名冲突，给他叫做fsimage.chk文件，（chk:取自50070中页面里的save checkpoint 检查点）。</font><font color="red">上传、下载走的都是http协议</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上传结束后，NameNode就不再需要edits和fsimage这两个文件了，会用edits_inprogress和fsimage.chk替换掉原有的edits和fsimage。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，NameNode工作起来就很流畅了，负责管理DateNode，管理元数据，没有时间整理内务，整理内务的工作由SecondaryNameNode来做，小秘至少的配置是内存与总裁的一致。小秘不在了，挂掉了，集群仍可以正常访问，NameNode会在第一次启动的时候整理自己的内存文件，会导致如果长时间运行，下次再启动的时候，启动时间过长。因此，<font color="red">NameNode挂了，休想通过SecondaryNaemNode来进行恢复，但有一种极端情况，在小秘下载合并之前，没有人对NameNode做出修改指令，此时是可以考虑从小秘那里来恢复的</font></p><h2 id="5-HDFS-Shell-amp-JAVA-API"><a href="#5-HDFS-Shell-amp-JAVA-API" class="headerlink" title="5 HDFS Shell &amp; JAVA API"></a>5 HDFS Shell &amp; JAVA API</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html" target="_blank" rel="noopener"><strong>HDFS命令参考</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">命令帮助：</span><br><span class="line">hdfs dfs -help   或者 hadoop fs -help</span><br><span class="line">常用命令解释：</span><br><span class="line">-appendToFile：追加至文件</span><br><span class="line">-cat：查看</span><br><span class="line">-chmod：修改权限</span><br><span class="line">-copyFromLocal：从本地上传文件到hdfs</span><br><span class="line">-copyToLocal：从hdfs下载文件到本地</span><br><span class="line">上面两个都是linux与hdfs跨机器间的文件交流</span><br><span class="line">-cp：hdfs文件间的相互拷贝，集群内部的</span><br><span class="line">-df：查看磁盘使用情况</span><br><span class="line">-du：查看目录使用情况</span><br><span class="line">-get：下载</span><br><span class="line">-ls：展示文件目录</span><br><span class="line">-mkdir:创建目录</span><br><span class="line">-moveFromLocal：从本机剪切文件到hdfs</span><br><span class="line">-moveToLocal：从hdfs剪切文件到本地</span><br><span class="line">-mv：hdfs集群内部文件的移动</span><br><span class="line">-put：上传</span><br><span class="line">-rm [-r] [-f] ：删除文件</span><br><span class="line">-tail -f :查看</span><br><span class="line">-text: 查看</span><br><span class="line">-touchz：创建衣一个空白文件</span><br><span class="line"></span><br><span class="line">案例</span><br><span class="line">[root@CentOS ~]# hadoop fs -appendToFile &#x2F;root&#x2F;install.log &#x2F;aa.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -cat  &#x2F;aa.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -copyToLocal &#x2F;aa.log &#x2F;root&#x2F;</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -mkdir -p &#x2F;dir1&#x2F;dir2</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -cp &#x2F;aa.log &#x2F;dir1&#x2F;dir2</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -mv &#x2F;aa.log &#x2F;ab.log</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -touchz &#x2F;hello.java</span><br><span class="line"></span><br><span class="line">[root@CentOS ~]# hadoop fs -rm -r -f &#x2F;dir1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>JAVA API 操作HDFS</strong></p><ol><li><p>搭建 window开发环境<br>a. 解压 hadoop安装包到 C:/</p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/c21d3f86-602a-4632-9b54-1c3ffb4bd5f3.png" alt></p><p>b. 配置 HADOOP_HOME 环境变量</p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/312f00b3-d45d-41aa-b1a6-a0fef6da117e.png" alt></p><p>c. 拷贝 winutil.exe和hadoop.dll文件到hadoop安装bin目录下</p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/3ac8ee8d-48dc-478d-bea4-3c0fd776e6b1.jpg" alt><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/683955c3-5970-4d07-bcce-7e909a6f6360.png" alt></p><p>d. 在Windows上配置CentOS上配置主机名和IP映射关系</p><p><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/f9897f92-69cf-4274-91e4-4c18d6ad7604.png" alt></p><p>e. 重启IDE<br><strong>导入Maven依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-common&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.hadoop&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;hadoop-hdfs&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>API代码</strong><br>上传1：<br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/9efe882e-1c3d-4850-9e54-692a77f8e337.jpg" alt><br><img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/5abcc04c-fda4-411f-a0e4-66041c5deae0.jpg" alt></p></li></ol><p><strong>启动报错：</strong>因为当前是在Windows下操作Hadoop,用户是Administrator,不是root,所以不能操作，Linux上的Root用户才有的操作方法。可以从两处修改：<br>  A：关闭Hadoop的系统权限，DFS permission配置  true改为false即可。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  修改hdfs-site.xml</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfspermission&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;value&gt;true&lt;value&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure><br>  B：修改虚拟机的启动参数，告诉虚拟机是以root用户去连接。<br>  <img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/7b50ef60-63f5-4b20-a613-f91b65ee85bc.jpg" alt><br>上传2：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/2748002c-4c99-4cdd-b356-237652509cf4.jpg" alt><br>结果：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/68b62ece-a2a3-4c62-a3db-88f5e0d59ef9.jpg" alt><br><font color="red">客户端可以用如下代码设置副本集个数</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Before</span><br><span class="line">public void before()throws IOException&#123;</span><br><span class="line">    Configuration conf &#x3D; new Configuration();</span><br><span class="line">    conf.set(&quot;fs.defaultFS&quot;,&quot;http:&#x2F;&#x2F;CentOS:9000&quot;);</span><br><span class="line">    conf.set(&quot;dfs.replication&quot;,&quot;1&quot;); &#x2F;&#x2F;设置副本集</span><br><span class="line">    fs &#x3D; FileSysten.get(conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/7a522c44-979c-4d76-947c-b16eaa0d094c.jpg" alt><br>创建目录（“true”存在就递归删除，不存在就创建）：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/430bfe18-50fc-4d96-afa7-82e86c19376d.jpg" alt><br>展示目录下的内容：<img src="/2018/12/10/Hadoop%E5%AD%A6%E4%B9%A0/198c9b96-5511-4adb-b818-745806da174e.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BigData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz学习</title>
      <link href="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p> <strong><a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz</a></strong>是一个开放源码的任务调度框架。Quartz功能强大。可以让你的程序在指定时间执行，也可以按照某一个频度执行，支持数据库、监听器</p><a id="more"></a><h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><h3 id="2-1-Maven坐标"><a href="#2-1-Maven坐标" class="headerlink" title="2.1 Maven坐标"></a>2.1 Maven坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-2-定义任务内容"><a href="#2-2-定义任务内容" class="headerlink" title="2.2 定义任务内容"></a>2.2 定义任务内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line">import java.util.Date;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 任务内容</span><br><span class="line">*&#x2F;</span><br><span class="line">public class MyJob implements Job&#123;</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throws</span><br><span class="line">JobExecutionException &#123;</span><br><span class="line">    &#x2F;&#x2F; 输出系统当前时间</span><br><span class="line">    System.out.println(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-构建调度任务"><a href="#2-3-构建调度任务" class="headerlink" title="2.3 构建调度任务"></a>2.3 构建调度任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.JobDetail;</span><br><span class="line">import org.quartz.Scheduler;</span><br><span class="line">import org.quartz.SchedulerException;</span><br><span class="line">import org.quartz.Trigger;</span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;</span><br><span class="line">import static org.quartz.JobBuilder.newJob;</span><br><span class="line">import static org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class="line">import static org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 构建调度任务</span><br><span class="line">*&#x2F;</span><br><span class="line">public class QuartzTest &#123;</span><br><span class="line">    public static void main(String[] args) throws SchedulerException &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取调度器器</span><br><span class="line">        Scheduler scheduler &#x3D; StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        &#x2F;&#x2F; 包装任务内容</span><br><span class="line">        JobDetail job &#x3D; newJob(MyJob.class)</span><br><span class="line">                    .withIdentity(&quot;job1&quot;, &quot;group1&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">        &#x2F;&#x2F; 定义触发器器</span><br><span class="line">        Trigger trigger &#x3D; newTrigger()</span><br><span class="line">                    .withIdentity(&quot;trigger1&quot;, &quot;group1&quot;)</span><br><span class="line">                    .startNow()</span><br><span class="line">                    .withSchedule(simpleSchedule()</span><br><span class="line">                    .withIntervalInSeconds(40)</span><br><span class="line">                    .repeatForever())</span><br><span class="line">                    .build();</span><br><span class="line">        &#x2F;&#x2F; 组装任务</span><br><span class="line">        scheduler.scheduleJob(job, trigger);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 启动调度器器 开始调度</span><br><span class="line">        scheduler.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、体系架构"><a href="#三、体系架构" class="headerlink" title="三、体系架构"></a>三、体系架构</h2><ul><li><strong>Job</strong><br>是一个接口，只定义一个方法execute(JobExecutionContext context)，在实现接口的execute方法中编写所需要定时执行的Job(任务),JobExecutionContext类提供了调度应用的一些信息。Job运行时的信息保存在JobDataMap实例中。</li><li><strong>JobDetail</strong><br>JobDetail 定义的是任务数据，⽽真正的执行逻辑是在Job中。sheduler每次执⾏，都会根据JobDetail创建一个新的Job实例。</li><li><strong>Trigger</strong><br>是一个类，描述触发Job执⾏的时间触发规则。主要有SimpleTrigger和CronTrigger这两个子类。当且仅当需调度一次或者以固定时间间隔周期执行调度，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如⼯作日周一到周五的15：00~16：00执⾏调度等</li></ul><p><span style="border-bottom:2px solid;">Cron表达式的格式</span>： 秒 分 时 日 月 周 年(可选)</p><table><thead><tr><th align="center">字段名</th><th align="center">允许的值</th><th align="center">允许的特殊字符</th></tr></thead><tbody><tr><td align="center">秒</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">分</td><td align="center">0-59</td><td align="center">, - * /</td></tr><tr><td align="center">时</td><td align="center">0-23</td><td align="center">，- * /</td></tr><tr><td align="center">日</td><td align="center">1-31</td><td align="center">, - * ? / L W C</td></tr><tr><td align="center">月</td><td align="center">1-12 or JAN-DEC</td><td align="center">, - * /</td></tr><tr><td align="center">周</td><td align="center">1-7 or SUN-SAT</td><td align="center">, - * ? / L C # MON FRI</td></tr><tr><td align="center">年</td><td align="center">empty,1970-2099</td><td align="center">, - * /</td></tr></tbody></table><p><span style="border-bottom:2px solid;">允许的特殊字符</span>：</p><ol><li>“?”字符：表示不确定值</li><li>“,”字符：指定数个值</li><li>“-“字符：指定一个值的范围</li><li>“/“字符：指定一个值得增加强度。n/m表示从n开始，每次增加m</li><li>“L”字符：用在日表示一个月中的最后一天，用在周表示该月最后一个星期X</li><li>“W”字符：指定离给定日期最近的工作日（周一到周五）</li><li>“#”字符：表示该月第一个周X。6#3表示该月第三个周五</li></ol><p><span>Cron表达式范例：</span></p><ol><li>每隔5秒执行一次：  */5 * * * * ?</li><li>每隔1分钟执行一次： 0 */1 * * * *</li><li>每天23点执行一次：  0 0 23 * * ？</li><li>每天凌晨1点执行一次： 0 0 1 * * ?</li><li>每月1号凌晨1点执行一次： 0 0 1 1 * ?</li><li>每月最后一天23点执行一次： 0 0 23 L * ?</li><li>每周星期天凌晨1点执行一次： 0 0 1 ？ * L</li><li>在26分、29分、33分执行一次： 0 26,29,33 * * * ？</li><li>每天的0点、13点、18点、21点执行一次：0 0 0,13,18,21 * * ?</li></ol><ul><li><p><strong>Scheduler</strong><br>代表一个Quartz的独立运行容器。Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，<br>Trigger的组及名称必须唯一，JobDetail的组及名称也必须唯一（但可以和Trigger的组和名称相同，因为他们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。</p></li><li><p><strong>JobBuilder</strong><br>用于定义/构建已经定义了Job实例的JobDetail实例</p></li><li><p><strong>TriggerBuilder</strong><br>用于定义/构建Trigger实例。</p></li></ul><h2 id="四、Spring集成"><a href="#四、Spring集成" class="headerlink" title="四、Spring集成"></a>四、Spring集成</h2><h3 id="4-1-Maven坐标"><a href="#4-1-Maven坐标" class="headerlink" title="4.1 Maven坐标"></a>4.1 Maven坐标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--spring依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="4-2-定义任务内容"><a href="#4-2-定义任务内容" class="headerlink" title="4.2 定义任务内容"></a>4.2 定义任务内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line">import java.util.Date;</span><br><span class="line">public class MyJob implements Job&#123;</span><br><span class="line">    public void execute(JobExecutionContext jobExecutionContext) throwsJobExecutionException &#123;</span><br><span class="line">           System.out.println(new Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-配置文件"><a href="#4-3-配置文件" class="headerlink" title="4.3 配置文件"></a>4.3 配置文件</h3><p>如：Spring-quartz.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line"> xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">     &lt;!--创建JobDetail--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">      &lt;!--指定任务类--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;MyJob&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">      &lt;!--当Job在没有可以使用的trigger的情况下 不删除--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;!--注意 spring quartz整合 一个trigger只可以绑定一个JobDetail 一个jobDetail可</span><br><span class="line">以被多个Trigger所使用--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;trigger&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line">      &lt;!--绑定JobDetail--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;0-30 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;trigger1&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;!--绑定JobDetail--&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;45-55 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--注册trigger--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;scheduler&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">                &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">       &lt;&#x2F;property&gt;</span><br><span class="line">     &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h3 id="4-4-测试"><a href="#4-4-测试" class="headerlink" title="4.4 测试"></a>4.4 测试</h3><p>启动<em>Spring</em>工厂测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/2018-10-31_222450.png" alt="spring方式启动quartz" title="spring方式启动quartz"></p><h2 id="五、存储方式"><a href="#五、存储方式" class="headerlink" title="五、存储方式"></a>五、存储方式</h2><h3 id="5-1-RAMJobStore和JDBCJobStore"><a href="#5-1-RAMJobStore和JDBCJobStore" class="headerlink" title="5.1 RAMJobStore和JDBCJobStore"></a>5.1 RAMJobStore和JDBCJobStore</h3><table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RAMJobStore(默认)</td><td>不要外部数据库，配置容易，运行速度快</td><td>因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存⾥里面，所以可以存储多少个Job和Trigger将会受到限制</td></tr><tr><td>JDBCJobStore</td><td>支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务</td><td>运行速度的快慢取决与连接数据库的快慢</td></tr></tbody></table><h3 id="5-2-设置JDBCJobStore"><a href="#5-2-设置JDBCJobStore" class="headerlink" title="5.2 设置JDBCJobStore"></a>5.2 设置JDBCJobStore</h3><p>在应用程序中设置使用JDBCJobStore需要两步：首先必须创建作业仓库使用的数据库表。JDBCJobStore 与所有主流数据库兼容。而且Quartz提供了一系列创建表的SQL脚本，能够简化设置过程。可以再Quartz发行包的“docs/dbTables”目录中找到创建的SQL脚本。第二，必须定义一些属性</p><ol><li>创建Quartz数据库表</li><li>在quartz.properties文件中指定JDBCJobStore属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.threadPool.class &#x3D; org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount &#x3D; 10</span><br><span class="line">org.quartz.threadPool.threadPriority &#x3D; 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread &#x3D; true</span><br><span class="line"></span><br><span class="line"># Using RAMJobStore</span><br><span class="line">## if using RAMJobStore, please be sure that you comment out the following</span><br><span class="line">## - org.quartz.jobStore.tablePrefix,</span><br><span class="line">## - org.quartz.jobStore.driverDelegateClass,</span><br><span class="line">## - org.quartz.jobStore.dataSource</span><br><span class="line">#org.quartz.jobStore.class &#x3D; org.quartz.simpl.RAMJobStore</span><br><span class="line"></span><br><span class="line"># Using JobStoreTX</span><br><span class="line">## Be sure to run the appropriate script(under docs&#x2F;dbTables) first to create tables</span><br><span class="line">org.quartz.jobStore.class &#x3D; org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line"></span><br><span class="line"># Configuring JDBCJobStore with the Table Prefix</span><br><span class="line">org.quartz.jobStore.tablePrefix &#x3D; QRTZ_</span><br><span class="line"></span><br><span class="line"># Using DriverDelegate</span><br><span class="line">org.quartz.jobStore.driverDelegateClass &#x3D;</span><br><span class="line">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"></span><br><span class="line"># Using datasource</span><br><span class="line">org.quartz.jobStore.dataSource &#x3D; qzDS</span><br><span class="line"></span><br><span class="line"># Define the datasource to use</span><br><span class="line">org.quartz.dataSource.qzDS.driver &#x3D; com.mysql.jdbc.Driver</span><br><span class="line">org.quartz.dataSource.qzDS.URL &#x3D; jdbc: mysql:&#x2F;&#x2F;localhost:3306&#x2F;quartz</span><br><span class="line">org.quartz.dataSource.qzDS.user &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.password &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.maxConnections &#x3D; 30</span><br></pre></td></tr></table></figure><h3 id="5-3-测试"><a href="#5-3-测试" class="headerlink" title="5.3 测试"></a>5.3 测试</h3><h2 id="六、集群支持"><a href="#六、集群支持" class="headerlink" title="六、集群支持"></a>六、集群支持</h2><h3 id="6-1-原理"><a href="#6-1-原理" class="headerlink" title="6.1 原理"></a>6.1 原理</h3><p>虽然单个Quartz实例能给予你很好的Job调度能力，但他不能满足典型的企业需求，如可伸缩性、高可靠性满足、假如你需要故障转移的能力并能运行日益增多的JOB，QUARTZ集群势必成为你应用的一部分了。使用Quartz的集群能力可以很好的支持你的业务需求，并且即使是其中一台机器在最糟的时间崩溃了也能确保所有的Job得到执行。</p><p>一个Quartz集群中的每个节点都是一个独立的Quartz应用，它又管理者其他的节点。意思是你必须对每个节点分别启动或者停止。不像许多应用服务器的集群，独立的Quartz节点并不与另一其他的节点或是管理节点通信。Quartz应用是通过数据库表来感知另一应用的。</p><p>图：表示了每个节点直接与数据库通信，若离开数据库将对其他节点一无所知<br>     <img src="/2018/10/09/Quartz%E5%AD%A6%E4%B9%A0/2018-10-31_231044.png" alt="Quartz集群" title="Quartz集群"></p><h3 id="6-2-搭建步骤"><a href="#6-2-搭建步骤" class="headerlink" title="6.2 搭建步骤"></a>6.2 搭建步骤</h3><ol><li>备配置文件</li><li>修改 spring-quartz。xml</li><li>启动Spring工厂测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceName: TestScheduler</span><br><span class="line">org.quartz.scheduler.instanceId: auto</span><br><span class="line"></span><br><span class="line">org.quartz.scheduler.skipUpdateCheck: true</span><br><span class="line"></span><br><span class="line">org.quartz.threadPool.class &#x3D; org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount &#x3D; 10</span><br><span class="line">org.quartz.threadPool.threadPriority &#x3D; 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread &#x3D; true</span><br><span class="line"></span><br><span class="line"># Using RAMJobStore</span><br><span class="line">## if using RAMJobStore, please be sure that you comment out the following</span><br><span class="line">## - org.quartz.jobStore.tablePrefix,</span><br><span class="line">## - org.quartz.jobStore.driverDelegateClass,</span><br><span class="line">## - org.quartz.jobStore.dataSource</span><br><span class="line">#org.quartz.jobStore.class &#x3D; org.quartz.simpl.RAMJobStore</span><br><span class="line"></span><br><span class="line"># Using JobStoreTX</span><br><span class="line">## Be sure to run the appropriate script(under docs&#x2F;dbTables) first to create tables</span><br><span class="line">org.quartz.jobStore.class &#x3D; org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line">org.quartz.jobStore.isClustered &#x3D; true</span><br><span class="line"></span><br><span class="line"># Configuring JDBCJobStore with the Table Prefix</span><br><span class="line">org.quartz.jobStore.tablePrefix &#x3D; QRTZ_</span><br><span class="line"></span><br><span class="line"># Using DriverDelegate</span><br><span class="line">org.quartz.jobStore.driverDelegateClass &#x3D;</span><br><span class="line">org.quartz.impl.jdbcjobstore.StdJDBCDelegate</span><br><span class="line"></span><br><span class="line"># Using datasource</span><br><span class="line">org.quartz.jobStore.dataSource &#x3D; qzDS</span><br><span class="line"></span><br><span class="line"># Define the datasource to use</span><br><span class="line">org.quartz.dataSource.qzDS.driver &#x3D; com.mysql.jdbc.Driver</span><br><span class="line">org.quartz.dataSource.qzDS.URL &#x3D; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;quartz</span><br><span class="line">org.quartz.dataSource.qzDS.user &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.password &#x3D; root</span><br><span class="line">org.quartz.dataSource.qzDS.maxConnections &#x3D; 30</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;scheduler&quot;</span><br><span class="line">class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:quartz.properties&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">          &lt;list&gt;</span><br><span class="line">             &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">             &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">      &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>请求与响应</title>
      <link href="/2018/09/17/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"/>
      <url>/2018/09/17/%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-Request-Headers"><a href="#1-Request-Headers" class="headerlink" title="1 Request Headers"></a>1 Request Headers</h1><p>origin: 客户端发出请求的地址</p><p>Access-Control-Request-Headers:authorization</p><p>Access-Control-Request-Method:Get</p><a id="more"></a><h1 id="2-Response-Headers"><a href="#2-Response-Headers" class="headerlink" title="2 Response Headers"></a>2 Response Headers</h1><p>Access-Controll-Allow-Origin: httpRequest.getHeader(“Origin”)</p><p>Access-Control-Allow-Headers:<br>Authorization,<br>Content-Type,<br>Depth,<br>User-Agent,<br>X-File-Size,<br>X-Requested-With,<br>X-Requested-By,<br>If-Modified-Since,<br>X-File-Name,<br>X-File-Type,<br>Cache-Control,<br>Origin</p><p>Access-Control-Allow-Methods:<br>POST , GET, OPTIONS, PUT, DELETE</p><p>Access-Control-Max-Age: 3600</p><p>Access-Control-Allow-Credentials: true</p><p>Access-Control-Expose-Headers:<br>Authorization,<br>Content-Disposition</p><h1 id="3-http-中的options-请求是什么鬼？"><a href="#3-http-中的options-请求是什么鬼？" class="headerlink" title="3 http 中的options 请求是什么鬼？"></a>3 http 中的options 请求是什么鬼？</h1><h2 id="3-1-为什么会出现-options-请求呢？"><a href="#3-1-为什么会出现-options-请求呢？" class="headerlink" title="3.1 为什么会出现 options 请求呢？"></a>3.1 为什么会出现 options 请求呢？</h2><ol><li><p>获取目的资源所支持的通信方式<br>黑客有可能经常用到这个；在响应报文中包含一个<strong>Allow</strong>首部字段，该字段的值表明了该服务器支持的<strong>HTTP方法</strong>，</p></li><li><p>跨域请求中，<strong>options</strong>请求是浏览器自发起的 <strong>preflight request(预检请求)</strong>,以检测实际请求是否可以被浏览器接受。</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp; preflight request 请求报文中有两个需要关注测首部字段：</p><p>（1）Access-Control-Request-Method: 告知服务器实际请求所使用的HTTP方法。</p><p>（2）Access-Control-Request-Headers:告知服务器实际请求所携带的自定义首部字段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 同时服务器也会添加 origin header，告知服务器实际上请求的客户端地址。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 服务器所返回的 <strong>Access-Control-Allow-Methods</strong>首部字段 将所有允许的请求方法告知客户端，返回  <strong>Access-Control-Allow-Headers</strong>: 将所有允许的客户端自定义请求头告知。此外，服务器还可返回 <strong>Access-Control-Max-Age</strong> 首部字段，允许浏览器在指定时间内，无需再次发送预检请求，直接用本次结果即可。</p><p>&nbsp;&nbsp;&nbsp;&nbsp; 在我们开发中，出现的浏览器自发起的Options请求，实际上是上述第二种情。实际上，跨域请求中的“复杂请求”发出前会进行 一次方法是：options的 preflight request。</p><h2 id="3-2-当跨域请求是简单请求时不会进行-preflight-request，只有复杂请求才会进行-preflight-request。"><a href="#3-2-当跨域请求是简单请求时不会进行-preflight-request，只有复杂请求才会进行-preflight-request。" class="headerlink" title="3.2 当跨域请求是简单请求时不会进行 preflight request，只有复杂请求才会进行 preflight request。"></a>3.2 当跨域请求是简单请求时不会进行 preflight request，只有复杂请求才会进行 preflight request。</h2><p>跨域请求分两种：简单请求、复杂请求</p><p>复杂请求：</p><ol><li>使用方法put 或者 delete</li><li>发送 json 格式的数据（content-type;application/json）</li><li>请求中带有自定义头部</li></ol><p>其他的就是简单请求。</p><h1 id="4-为什么跨域的复杂请求需要-preflight-request"><a href="#4-为什么跨域的复杂请求需要-preflight-request" class="headerlink" title="4 为什么跨域的复杂请求需要 preflight request?"></a>4 为什么跨域的复杂请求需要 preflight request?</h1><p>&nbsp;&nbsp;&nbsp;&nbsp; 复杂请求可能对服务器数据产生副作用。例如：<strong>delete</strong> 或者 <strong>put</strong> ,都会对服务器数据进行修改，所以在请求之前都要先询问服务器，当前网页所在域名是否在服务器的许可名单中，服务器允许后，浏览器才会发出正式的请求，否则不发送正是请求。</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TextRank基本了解</title>
      <link href="/2018/09/01/TextRank/"/>
      <url>/2018/09/01/TextRank/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="一-TextRank算法介绍"><a href="#一-TextRank算法介绍" class="headerlink" title="一. TextRank算法介绍"></a>一. TextRank算法介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法相对来说，是一种很简单的算法。算法的流程类似于Kleinberg的HITS算法，<font color="red">Google</font>的PageRank算法，不得不说GooglePageRank算法的出现引发了搜索引擎的一次变革。PageRank算法成功运用到互联网上来评估网页的重要性，当用户搜索时，返回与搜索问题相关又有质量的网页。TextRank算法可以说借鉴了PageRank算法的思想，也非常成功的运用到文章的引文提取，关键词提取上。当然一个单纯的算法来提取关键词，可能效果并不如意，可以结合其他算法，比如TF-IDF来筛选有力表达主题/文章中心思想的词语。</p><a id="more"></a><h1 id="二-TextRank算法解析"><a href="#二-TextRank算法解析" class="headerlink" title="二. TextRank算法解析"></a>二. TextRank算法解析</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法对文章关键词进行提取的过程，实际就是迭代计算一个由文章中的词语构建的有向有权图G=(V,E) 。其中集合V(图中的节点)有文章中的词语构成，中文我们可以利用ansj_seg进行分词筛选特定词性的词。集合E(图中的边)由文章中的词在特定的滑动窗口下组成。E是一个VxV的子集。图中任意两节点Vi,Vj之间的权重为Wij，而对于一个节点Vi，In(Vi)表示图中指向该节点的其他节点集合，入度。而Out(Vi)为节点Vi指向的其他节点的集合。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于TextRank算法每次迭代是Vi节点的得分的计算公式为：<img src="/2018/09/01/TextRank/6d3a90f9-54f5-411b-bf3d-5e119062f76e.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;其中d是一个阻尼系数，其值在0到1之间。代表从图中一节点指向其他任意一节点的概率, 一般取值为 0.85。上述的公式，表示当前节点Vi的值为所有指向Vi的节点Vj给予的值的和。就相当于，我现在手上有1个苹果，如果我收集了我朋友给我的苹果，我将有多少个苹果的问题。假如我有两个朋友，他们会给我一些苹果，而我现在拥有的苹果数量就是他们给我的苹果数量的和。朋友A有3个苹果，但是同样他有3个朋友，而且需要给苹果给他的朋友，所以只能给我3/3＝1个苹果。朋友B有6个苹果，他有3个朋友，那么他给我6/3=2个苹果。那我现在手头将有1+1+3=5个苹果。实际中还要乘阻尼系数。TextRank算法就是这样迭代计算每个节点的值，而算法停止可以采用指定的迭代次数或者图中节点的值跟上次结果值的误差是否小于一个制定的极限值，一般取值为：0.0001。</p><h1 id="三-TextRank算法文本关键词提取"><a href="#三-TextRank算法文本关键词提取" class="headerlink" title="三. TextRank算法文本关键词提取"></a>三. TextRank算法文本关键词提取</h1><p>主要步骤：</p><ol><li>利用分词工具对文本进行分词</li><li>指定滑动窗口大小</li><li>滑动窗口经过文本词组，构建有向有权图。</li><li>迭代计算有向有权图，直到收敛。</li></ol><p>注意：在构建有向有权图时候，只筛选特定词性的词作为节点，比如名词，动词，形容词等，同时删除停用词。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol><li><p>一个文本，对其进行分词后，词组组成一个集合：<br>T = [S1,S2,S3,S1,S5,S6,S7,S8,S9]</p></li><li><p>指定滑动窗口大小为3</p></li><li><p>窗口里面的词组构建图，每次都是以窗口头结点为主节点。如下图所示：</p></li></ol><p>A：窗口第一次经过的词组，那么组成的边有:(S1,S2),(S2,S1),(S1,S3),(S3,S1)<br><img src="/2018/09/01/TextRank/e78a6e11-0507-4e6e-a289-a6bd1d4365b2.jpg" alt><br>B：窗口第二次经过的词组,组成的边有：(S2,S3),(S3,S1),(S2,S1),(S1,S2)。遇到重叠的边，则权重加1.<br><img src="/2018/09/01/TextRank/59840975-e639-4ab7-970b-171816be466e.jpg" alt><br>C：构建图完成之后，按照textRank算法的执行步骤，迭代计算，直到收敛。</p><p>D：最后对节点的权重排序输出。</p><h1 id="四-TextRank算法Scala代码实现"><a href="#四-TextRank算法Scala代码实现" class="headerlink" title="四. TextRank算法Scala代码实现"></a>四. TextRank算法Scala代码实现</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;TextRank算法的实现，这里采用scala，分词工具采用ansj_seg，这里scala代码实现的TextRank算法，只实现关键词的提取，没有实现句子提取，后续再补充。代码略。<br>调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">object TextRankTest&#123;</span><br><span class="line">  def main(args: Array[String]) &#123;</span><br><span class="line">    val tr &#x3D; new TextRank</span><br><span class="line">    tr.setStopword(Config.STOP_WORDS_FILE)&#x2F;&#x2F;停用词</span><br><span class="line">    val text &#x3D; &quot;机器学习是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。&quot;</span><br><span class="line">    val tags &#x3D; tr.textrank(sentence &#x3D; text,topK &#x3D; 10, allowPOS &#x3D; List(&quot;ns&quot;, &quot;vn&quot;, &quot;n&quot;, &quot;nr&quot;, &quot;nt&quot;, &quot;mama&quot;))</span><br><span class="line">    tags.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(算法,n,1.0)</span><br><span class="line">(学科,n,0.963356)</span><br><span class="line">(理论,n,0.934734)</span><br><span class="line">(分析,vn,0.85816)</span><br><span class="line">(机器学习,n,0.723762)</span><br><span class="line">(数据,n,0.615997)</span><br><span class="line">(规律,n,0.537537)</span><br><span class="line">(设计,vn,0.474728)</span><br><span class="line">(概率论,n,0.466409)</span><br><span class="line">(复杂度,n,0.442039)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(5)Hexo踩坑_主题优化</title>
      <link href="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
      <url>/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="0-字体乱码问题"><a href="#0-字体乱码问题" class="headerlink" title="0 字体乱码问题"></a>0 字体乱码问题</h2><p>Windows 上新建的文件一般都是 <strong>gb2312或iso-8859-1</strong>，这样windows下的文件传递到Linux可能会出乱码问题</p><p>用 Git进去文件使用命令查看文件是否是<strong>utf-8</strong> 格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file -i word.ejs</span><br><span class="line">word.ejs: text&#x2F;html; charset&#x3D;iso-8859-1(或是其他)</span><br></pre></td></tr></table></figure><p><strong>第一种</strong><br>最简单的办法就是  vim  word.ejs</p><a id="more"></a><p>设置 set fileencoding=utf-8，强制保存，此时中文会乱码，再次输入即可</p><p><strong>第二种</strong></p><p>找一个 是 utf-8文件的 直接粘贴到需要位置，改名删除内容，写上自己的内容即可。</p><h2 id="1-图片无法加载"><a href="#1-图片无法加载" class="headerlink" title="1 图片无法加载"></a>1 图片无法加载</h2><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><p>效果如下图：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/83b0faba-efa5-477e-b4bf-be002402fb8b.jpg" alt></p><h2 id="2-点击所有文章-缺失模块"><a href="#2-点击所有文章-缺失模块" class="headerlink" title="2 点击所有文章 缺失模块"></a>2 点击所有文章 缺失模块</h2><p>缺失模块。<br>1、请确保node版本大于6.2<br>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br>npm i hexo-generator-json-content –save</p><p>3、在根目录_config.yml里添加配置：直接粘贴复制即可。（自己手打可能出错）</p><pre q-show="jsonFail" style="box-sizing: border-box; overflow: auto; white-space: pre-wrap; overflow-wrap: break-word; font-family: monospace, monospace; font-size: 12px;">  jsonContent:    meta: false    pages: false    posts:      title: true      date: true      path: true      text: false      raw: false      content: false      slug: false      updated: false      comments: false      link: false      permalink: false      excerpt: false      categories: false      tags: true</pre><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9266a57c-8ba0-4ea9-831d-5d868b6de1de.jpg" alt></p><h2 id="3-个人头像及网站图标"><a href="#3-个人头像及网站图标" class="headerlink" title="3 个人头像及网站图标"></a>3 个人头像及网站图标</h2><h3 id="3-1-存放位置"><a href="#3-1-存放位置" class="headerlink" title="3.1 存放位置"></a>3.1 存放位置</h3><p>头像/图标图片的存放位置是<code>/themes/yilia/source/</code>下任意位置，可以自己新建一个文件夹存放，我存放在<code>assets</code>文件夹下。</p><h3 id="3-2-配置设置"><a href="#3-2-配置设置" class="headerlink" title="3.2 配置设置"></a>3.2 配置设置</h3><p>配置文件为<code>/themes/yilia/_config.yml</code>。设置头像为配置文件中<code>avatar</code>一项，设置图标为配置文件中<code>favicon</code>一项，设置路径的根目录为<code>/themes/yilia/source/</code>。例如，我的头像存放的地址是<code>/themes/yilia/source/assets/avatar.png</code>，设置则为<code>avatar: /assets/avatar.png</code>。（图标同理）</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f3f4cf22-244b-4dc6-9ec6-80772d70eeb5.jpg" alt></p><h2 id="4-文章摘要"><a href="#4-文章摘要" class="headerlink" title="4 文章摘要"></a>4 文章摘要</h2><p>目前主要是两种方式在首页显示文章摘要而不是全文</p><h3 id="4-1-方法1"><a href="#4-1-方法1" class="headerlink" title="4.1 方法1 "></a>4.1 方法1 <!--more--></h3><p>ps: 之前最好不要有空格</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/EBX_29_24AY7O_5DK_7EUZCSA2LR1BN.png" alt></p><h3 id="4-2-方法2-description-in-Front-matter"><a href="#4-2-方法2-description-in-Front-matter" class="headerlink" title="4.2 方法2 description in Front-matter"></a>4.2 方法2 description in Front-matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Hello World</span><br><span class="line">date: 2015-12-03 00:00:00</span><br><span class="line">description: &quot;Welcome to Hexo! This is your very first post.&quot;</span><br><span class="line">---</span><br><span class="line">&lt;Contents&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>description</code> 添加的摘要只能为纯文本</p><p><code>description</code> 中的内容加引号，可以避免一些程序错误，例如当内容里包含英文冒号时。</p><h2 id="5-主菜单"><a href="#5-主菜单" class="headerlink" title="5 主菜单"></a>5 主菜单</h2><p>按下面格式添加侧边栏，菜单前的<font color="red">#</font>表示隐藏该条目<font color="red">themes/yilia/_config.yml</font>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按需求更改</span><br><span class="line"></span><br><span class="line">menu:</span><br><span class="line">  主页: &#x2F;</span><br><span class="line">  所有文章: &#x2F;archives&#x2F;</span><br><span class="line">  #随笔: &#x2F;tags&#x2F;随笔</span><br><span class="line">  标签云: &#x2F;tags&#x2F;</span><br><span class="line">  关于我: &#x2F;about&#x2F;</span><br></pre></td></tr></table></figure><h2 id="6-标签云"><a href="#6-标签云" class="headerlink" title="6 标签云"></a>6 标签云</h2><p>使用 Hexo 命令新建一个tags的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/60e3c4cd-8d7d-43ab-8d6d-70d12b414979.png" alt></p><p>该页面标题可以在 /hexo/source/tags/index.md 中修改</p><p>同一片文章设置多个分类后的问题 <a href="https://github.com/MOxFIVE/hexo-theme-yelee/issues/4" target="_blank" rel="noopener">issue#4</a></p><h2 id="7-关于我"><a href="#7-关于我" class="headerlink" title="7 关于我"></a>7 关于我</h2><p>使用 Hexo 命令新建一个名为 <code>about</code> 的页面即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><p>该页面内容在文件 <code>\hexo\source\about\index.md</code> 中修改</p><h2 id="8-本地搜索"><a href="#8-本地搜索" class="headerlink" title="8 本地搜索"></a>8 本地搜索</h2><p>使用搜索需先安装对应插件，用于生成索引数据</p><p>插件主页: <a href="https://github.com/PaicHyperionDev/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>配置插件启用为true 到根目录下的_config.yml中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line"> on: true</span><br><span class="line"> onload: false</span><br></pre></td></tr></table></figure><p><strong>onload: true：</strong> 索引数据<strong>search.xml</strong>随页面一起加载（效率优先）<br><strong>onload：false：</strong> 当激活搜索框时在下载索引数据（按需加载）</p><h2 id="9-社交图标"><a href="#9-社交图标" class="headerlink" title="9 社交图标"></a>9 社交图标</h2><p>去掉前面的 # 再填写链接即可</p><p><font color="red">themes/yilia/_config.yml</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subnav:</span><br><span class="line"> Email: &quot;haoransunlin@163.com&quot;</span><br><span class="line"> #新浪微博: &quot;sina weibo&quot;</span><br><span class="line"> GitHub: ...</span><br><span class="line"> #RSS: &quot;&#x2F;aotm.xml&quot;</span><br></pre></td></tr></table></figure><p>设置 Email 时保留 <code>mailto:</code> 可考虑加密邮件地址 <a href="http://ctrlq.org/encode/" target="_blank" rel="noopener">http://ctrlq.org/encode/</a></p><p>使用 RSS 需先安装对应插件 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><h2 id="10-网站运行时间-暂时没有配置"><a href="#10-网站运行时间-暂时没有配置" class="headerlink" title="10 网站运行时间(暂时没有配置)"></a>10 网站运行时间(暂时没有配置)</h2><h3 id="10-1-修改-themes-yilia-config-yml-添加如下内容"><a href="#10-1-修改-themes-yilia-config-yml-添加如下内容" class="headerlink" title="10.1 修改 \themes\yilia_config.yml 添加如下内容"></a>10.1 修改 \themes\yilia_config.yml 添加如下内容</h3><p>网站运行时间，格式形如：“本站已安全运行 50 天 12 小时 13 分 41 秒”<br>Runing Time<br>running_time:<br> enable: true<br> create_time: ‘07/25/2019 12:00:00’ #此处修改你的建站时间或者网站上线时间</p><h3 id="10-2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容："><a href="#10-2-修改-themes-yilia-layout-partial-footer-ejs，在-lt-footer-gt-上面添加如下内容：" class="headerlink" title="10.2 修改\themes\yilia\layout\_partial\footer.ejs，在&lt;/footer&gt;上面添加如下内容："></a>10.2 修改<code>\themes\yilia\layout\_partial\footer.ejs</code>，在<code>&lt;/footer&gt;</code>上面添加如下内容：</h3><!--《添加网站运行时间  <br/>--><p>&lt;% if (theme.running_time &amp;&amp; theme.running_time.enable &amp;&amp; theme.running_time.create_time){ %&gt;<br>    <span id="timeDate">载入天数…</span><span id="times">载入时分秒…</span><br>    <script><br>    var now = new Date();<br>    function createtime() {<br>        //此处修改你的建站时间或者网站上线时间<br>        var create_time = '<%- theme.running_time.create_time %>';<br>        now.setTime(now.getTime() + 250);<br>        days = (now - grt) / 1000 / 60 / 60 / 24;<br>        dnum = Math.floor(days);<br>        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);<br>        hnum = Math.floor(hours);<br>        if (String(hnum).length == 1) {<br>            hnum = "0" + hnum;<br>        }<br>        minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);<br>        mnum = Math.floor(minutes);<br>        if (String(mnum).length == 1) {<br>            mnum = "0" + mnum;<br>        }<br>        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);<br>        snum = Math.round(seconds);<br>        if (String(snum).length == 1) {<br>            snum = "0" + snum;<br>        }<br>        document.getElementById("timeDate").innerHTML = " | 本站已安全运行 " + dnum + " 天 ";<br>        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";<br>    }<br>    setInterval("createtime()", 250);<br>    </script><br>&lt;% } %&gt;</p><!-- 添加网站运行时间》--><h2 id="11-背景图片"><a href="#11-背景图片" class="headerlink" title="11 背景图片"></a>11 背景图片</h2><p>*<em>推荐大小：700 x 1200 *</em></p><h3 id="11-1-找到-themes-lilia-目录下的-config-yml-修改配置如下："><a href="#11-1-找到-themes-lilia-目录下的-config-yml-修改配置如下：" class="headerlink" title="11.1 找到 themes\lilia\目录下的 _config.yml,修改配置如下："></a>11.1 找到 themes\lilia\目录下的 _config.yml,修改配置如下：</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/2488f7cb-b9a9-4f5e-b191-8b9fd0200767.png" alt></p><h3 id="11-2-将选好的背景图片放入-themes-yilia-source-assets-目录下"><a href="#11-2-将选好的背景图片放入-themes-yilia-source-assets-目录下" class="headerlink" title="11.2 将选好的背景图片放入 themes\yilia\source\assets 目录下"></a>11.2 将选好的背景图片放入 themes\yilia\source\assets 目录下</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/a9d8f38d-868e-48ba-8299-1f2dd027adaa.jpg" alt></p><h3 id="11-3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）"><a href="#11-3-打开-yilia-source-目录下的-main-xxx-css，进行修改（xxx-因人而异）" class="headerlink" title="11.3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）"></a>11.3 打开 yilia\source 目录下的 main.xxx.css，进行修改（xxx 因人而异）</h3><p><strong>ctrl + f 搜索：.left-col{ 、.left-col .overlay{ 、#mobile-nav .overlay</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/aeda14f1-204f-4735-a71a-b5df19eb9bc4.png" alt></p><p>里面添加 <strong>background-image:url(“图片地址”)即可</strong></p><p>字体颜色需要自己根据背景图片来调配</p><p>搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.left-col #header a&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header a:hover&#123;</span><br><span class="line"></span><br><span class="line">.left-col #header .header-subtitle&#123;</span><br></pre></td></tr></table></figure><h3 id="11-4-打开-yilia-layout-partial-left-col-ejs"><a href="#11-4-打开-yilia-layout-partial-left-col-ejs" class="headerlink" title="11.4 打开 yilia\layout_partial\left-col,ejs"></a>11.4 打开 yilia\layout_partial\left-col,ejs</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9c9a363b-d5e2-4785-b13d-5b4e4945b8ce.png" alt></p><p>重新部署即可看到效果</p><h2 id="12-文章目录"><a href="#12-文章目录" class="headerlink" title="12 文章目录"></a>12 文章目录</h2><h3 id="12-1-添加-CSS-样式"><a href="#12-1-添加-CSS-样式" class="headerlink" title="12.1 添加 CSS 样式"></a>12.1 添加 CSS 样式</h3><p>打开 <code>themes\yilia\source</code> 下的 <code>main.234bc0.css</code> 文件，直接在后面添加如下代码：</p><p>/<em>新添加的</em>/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#container .show-toc-btn,#container .toc-article&#123;display:block&#125;</span><br><span class="line">.toc-article&#123;z-index:100;background:#fff;border:1px solid #ccc;max-width:250px;min-width:150px;max-height:500px;overflow-y:auto;-webkit-box-shadow:5px 5px 2px #ccc;box-shadow:5px 5px 2px #ccc;font-size:12px;padding:10px;position:fixed;right:35px;top:129px&#125;.toc-article .toc-close&#123;font-weight:700;font-size:20px;cursor:pointer;float:right;color:#ccc&#125;.toc-article .toc-close:hover&#123;color:#000&#125;.toc-article .toc&#123;font-size:12px;padding:0;line-height:20px&#125;.toc-article .toc .toc-number&#123;color:#333&#125;.toc-article .toc .toc-text:hover&#123;text-decoration:underline;color:#2a6496&#125;.toc-article li&#123;list-style-type:none&#125;.toc-article .toc-level-1&#123;margin:4px 0&#125;.toc-article .toc-child&#123;&#125;@-moz-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-webkit-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@-o-keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;@keyframes cd-bounce-1&#123;0%&#123;opacity:0;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;60%&#123;opacity:1;-o-transform:scale(1.01);-webkit-transform:scale(1.01);-moz-transform:scale(1.01);-ms-transform:scale(1.01);transform:scale(1.01)&#125;100%&#123;-o-transform:scale(1);-webkit-transform:scale(1);-moz-transform:scale(1);-ms-transform:scale(1);transform:scale(1)&#125;&#125;.show-toc-btn&#123;display:none;z-index:10;width:30px;min-height:14px;overflow:hidden;padding:4px 6px 8px 5px;border:1px solid #ddd;border-right:none;position:fixed;right:40px;text-align:center;background-color:#f9f9f9&#125;.show-toc-btn .btn-bg&#123;margin-top:2px;display:block;width:16px;height:14px;background:url(http:&#x2F;&#x2F;7xtawy.com1.z0.glb.clouddn.com&#x2F;show.png) no-repeat;-webkit-background-size:100%;-moz-background-size:100%;background-size:100%&#125;.show-toc-btn .btn-text&#123;color:#999;font-size:12px&#125;.show-toc-btn:hover&#123;cursor:pointer&#125;.show-toc-btn:hover .btn-bg&#123;background-position:0 -16px&#125;.show-toc-btn:hover .btn-text&#123;font-size:12px;color:#ea8010&#125;</span><br><span class="line">.toc-article li ol, .toc-article li ul &#123;</span><br><span class="line">    margin-left: 30px;</span><br><span class="line">&#125;</span><br><span class="line">.toc-article ol, .toc-article ul &#123;</span><br><span class="line">    margin: 10px 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-2-修改-article-ejs-文件"><a href="#12-2-修改-article-ejs-文件" class="headerlink" title="12.2 修改 article.ejs 文件"></a>12.2 修改 article.ejs 文件</h3><p>打开 <code>themes\yilia\layout\_partial</code> 文件夹下的 <code>article.ejs</code> 文件, 在 <code>&lt;/header&gt; &lt;% } %&gt;</code> 下面加入如下内容（注意位置）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 目录内容 --&gt;</span><br><span class="line">&lt;% if (!index &amp;&amp; post.toc)&#123; %&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;show-toc-btn&quot; id&#x3D;&quot;show-toc-btn&quot; onclick&#x3D;&quot;showToc();&quot; style&#x3D;&quot;display:none&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-bg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;btn-text&quot;&gt;文章导航&lt;&#x2F;span&gt;</span><br><span class="line">          &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;toc-article&quot; class&#x3D;&quot;toc-article&quot;&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;toc-close&quot; class&#x3D;&quot;toc-close&quot; title&#x3D;&quot;隐藏导航&quot; onclick&#x3D;&quot;showBtn();&quot;&gt;×&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;strong class&#x3D;&quot;toc-title&quot;&gt;文章目录&lt;&#x2F;strong&gt;</span><br><span class="line">           &lt;%- toc(post.content) %&gt;</span><br><span class="line">         &lt;&#x2F;div&gt;</span><br><span class="line">   &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function showToc()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">    function showBtn()&#123;</span><br><span class="line">        var toc_article &#x3D; document.getElementById(&quot;toc-article&quot;);</span><br><span class="line">        var show_toc_btn &#x3D; document.getElementById(&quot;show-toc-btn&quot;);</span><br><span class="line">        toc_article.setAttribute(&quot;style&quot;,&quot;display:none&quot;);</span><br><span class="line">        show_toc_btn.setAttribute(&quot;style&quot;,&quot;display:block&quot;);</span><br><span class="line">        &#125;;</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">      &lt;% &#125; %&gt;</span><br><span class="line">&lt;!-- 目录内容结束 --&gt;</span><br></pre></td></tr></table></figure><p>想要温江显示目录，在每篇文章开头加入：toc: true 即可。</p><h2 id="13-版权"><a href="#13-版权" class="headerlink" title="13 版权"></a>13 版权</h2><p>待定</p><h2 id="14-友情链接"><a href="#14-友情链接" class="headerlink" title="14 友情链接"></a>14 友情链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 编辑友链</span><br><span class="line">friends:</span><br><span class="line">  Hexo: https:&#x2F;&#x2F;hexo.io</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;pages.github.com&#x2F;</span><br><span class="line">  MOxFIVE: http:&#x2F;&#x2F;moxfive.xyz&#x2F;</span><br><span class="line"></span><br><span class="line">## 关闭友链</span><br><span class="line">friends: false</span><br></pre></td></tr></table></figure><h2 id="15-关于我"><a href="#15-关于我" class="headerlink" title="15 关于我"></a>15 关于我</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启“关于我”。</span><br><span class="line">aboutme: 专注于前端</span><br><span class="line"></span><br><span class="line"># 关闭“关于我”</span><br><span class="line">aboutme: false</span><br></pre></td></tr></table></figure><h2 id="16-评论"><a href="#16-评论" class="headerlink" title="16 评论"></a>16 评论</h2><p><strong>GitHub OAuth授权：Settings/Developer settings/OAuth Apps</strong></p><p><a href="https://github.com/settings/applications/1265561" target="_blank" rel="noopener">https://github.com/settings/applications/1265561</a></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0_3_C@_7EZ_609_5DF_4_7E1_240_24S0L5.png" alt></p><h3 id="16-1-在layout-partial-post目录下新增gitalk-ejs文件"><a href="#16-1-在layout-partial-post目录下新增gitalk-ejs文件" class="headerlink" title="16.1 在layout/_partial/post目录下新增gitalk.ejs文件"></a>16.1 在<code>layout/_partial/post</code>目录下新增<code>gitalk.ejs</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;gitalk-container&quot; style&#x3D;&quot;padding: 0px 30px 0px 30px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;gitalk@1&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">if(&lt;%&#x3D;theme.gitalk.enable%&gt;)&#123;</span><br><span class="line"> var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line"> clientID: &#39;&lt;%&#x3D;theme.gitalk.ClientID%&gt;&#39;,</span><br><span class="line"> clientSecret: &#39;&lt;%&#x3D;theme.gitalk.ClientSecret%&gt;&#39;,</span><br><span class="line"> repo: &#39;&lt;%&#x3D;theme.gitalk.repo%&gt;&#39;,</span><br><span class="line"> owner: &#39;&lt;%&#x3D;theme.gitalk.githubID%&gt;&#39;,</span><br><span class="line"> admin: [&#39;&lt;%&#x3D;theme.gitalk.adminUser%&gt;&#39;],</span><br><span class="line"> id: &#39;&lt;%&#x3D; page.date %&gt;&#39;,</span><br><span class="line"> distractionFreeMode: &#39;&lt;%&#x3D;theme.gitalk.distractionFreeMode%&gt;&#39;</span><br><span class="line">&#125;)</span><br><span class="line">gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="16-2-修改source-src-css-目录下comment-scss文件"><a href="#16-2-修改source-src-css-目录下comment-scss文件" class="headerlink" title="16.2 修改source-src/css/目录下comment.scss文件"></a>16.2 修改<code>source-src/css</code>/目录下<code>comment.scss</code>文件</h3><p>注意第一行最后添加了 #gitalk-container</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#disqus_thread, .duoshuo, .cloud-tie-wrapper, #SOHUCS, #gitment-ctn, #gitalk-container &#123;</span><br><span class="line"> padding: 0 30px !important;</span><br><span class="line"> min-height: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#SOHUCS &#123;</span><br><span class="line"> #SOHU_MAIN .module-cmt-list .block-cont-gw &#123;</span><br><span class="line"> border-bottom: 1px dashed #c8c8c8 !important;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-3-在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码："><a href="#16-3-在layout-partial目录下的article-ejs文件内新增gitalk相关的配置代码：" class="headerlink" title="16.3 在layout/_partial目录下的article.ejs文件内新增gitalk相关的配置代码："></a>16.3 在<code>layout/_partial</code>目录下的<code>article.ejs</code>文件内新增<code>gitalk</code>相关的配置代码：</h3><p>在最后一行 &lt;% } %&gt; 前加入，如下图所示<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9f43f555-78c6-44fa-a465-3b55891297fd.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if(theme.gitalk.enable)&#123; %&gt;</span><br><span class="line"> &lt;%- partial(&#39;post&#x2F;gitalk&#39;, &#123;</span><br><span class="line"> key: post.slug,</span><br><span class="line"> title: post.title,</span><br><span class="line"> url: config.url+url_for(post.path)</span><br><span class="line"> &#125;) %&gt;</span><br><span class="line"> &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="16-4-最后在yilia主题配置文件中新增gitalk相关的配置："><a href="#16-4-最后在yilia主题配置文件中新增gitalk相关的配置：" class="headerlink" title="16.4 最后在yilia主题配置文件中新增gitalk相关的配置："></a>16.4 最后在<code>yilia</code>主题配置文件中新增<code>gitalk</code>相关的配置：</h3><p>属性名要与 配置文件中保持一致 ,如：<br>theme.gitalk.client_id  要与配置文件中 client_id 这几个字母一致<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/63179418-0e08-4864-bc85-b444e6067360.png" alt></p><p><strong>githubID：是自己的GitHub账户名称，如我的是JavaSsun</strong><br><strong>repo：是新建的评论仓库名称</strong><br><strong>adminuser:是自己的账户名称JavaSsun</strong></p><p>更新一下即可。</p><p><strong>基本完成，现在解决常见问题</strong>.</p><h2 id="17-文章字数及统计阅读时长-注意乱码"><a href="#17-文章字数及统计阅读时长-注意乱码" class="headerlink" title="17 文章字数及统计阅读时长(注意乱码)"></a>17 文章字数及统计阅读时长(注意乱码)</h2><h3 id="17-1-安装-hexo-wordcount"><a href="#17-1-安装-hexo-wordcount" class="headerlink" title="17.1 安装 hexo-wordcount"></a>17.1 安装 hexo-wordcount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><h3 id="17-2-文件配置"><a href="#17-2-文件配置" class="headerlink" title="17.2 文件配置"></a>17.2 文件配置</h3><p>在theme\yilia\layout_partial\post下创建word.ejs文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;margin-top:10px;&quot;&gt;</span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  字数统计: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">    &lt;span class&#x3D;&quot;post-time&quot;&gt;</span><br><span class="line">      &amp;nbsp; | &amp;nbsp;</span><br><span class="line">      &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">        &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt;  阅读时长: &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>然后在 themes/yilia/layout/_partial/article.ejs中添加(在 /header 之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;article-inner&quot;&gt;</span><br><span class="line">    &lt;% if (post.link || post.title)&#123; %&gt;</span><br><span class="line">      &lt;header class&#x3D;&quot;article-header&quot;&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;title&#39;, &#123;class_name: &#39;article-title&#39;&#125;) %&gt;</span><br><span class="line">        &lt;% if (!post.noDate)&#123; %&gt;</span><br><span class="line">        &lt;%- partial(&#39;post&#x2F;date&#39;, &#123;class_name: &#39;archive-article-date&#39;, date_format: null&#125;) %&gt;</span><br><span class="line">        &lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">        &lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">        &lt;% if(theme.word_count &amp;&amp; !post.no_word_count)&#123;%&gt;</span><br><span class="line">          &lt;%- partial(&#39;post&#x2F;word&#39;) %&gt;</span><br><span class="line">          &lt;% &#125; %&gt;</span><br><span class="line">        &lt;!-- 添加完成 --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">      &lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure><h3 id="17-3-开启功能"><a href="#17-3-开启功能" class="headerlink" title="17.3 开启功能"></a>17.3 开启功能</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e0da8fad-4be8-436b-9491-b943d26853f1.png" alt></p><p>效果如图所示：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/0c5c293d-95ac-47c3-a2cc-b3a589682a23.png" alt></p><h2 id="18-添加背景音乐"><a href="#18-添加背景音乐" class="headerlink" title="18 添加背景音乐"></a>18 添加背景音乐</h2><h3 id="18-1-打开网易云音乐首页，然后搜索要添加的背景音乐"><a href="#18-1-打开网易云音乐首页，然后搜索要添加的背景音乐" class="headerlink" title="18.1 打开网易云音乐首页，然后搜索要添加的背景音乐"></a>18.1 打开网易云音乐首页，然后搜索要添加的背景音乐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;music.163.com&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/65d6c7e8-80bf-45c9-8092-a46d177d5dfa.jpg" alt></p><h3 id="18-2-搜索到歌曲点击生成外链播放器，进去下一个界面"><a href="#18-2-搜索到歌曲点击生成外链播放器，进去下一个界面" class="headerlink" title="18.2 搜索到歌曲点击生成外链播放器，进去下一个界面"></a>18.2 搜索到歌曲点击生成外链播放器，进去下一个界面</h3><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/19e4d9b9-e95b-4313-947f-5f0fc33bea71.png" alt></p><h3 id="18-3-复制外链播放器的代码"><a href="#18-3-复制外链播放器的代码" class="headerlink" title="18.3 复制外链播放器的代码"></a>18.3 复制外链播放器的代码</h3><p>打开 /yilia/layout/_partia/left-col.ejs 文件 <strong>nav标签中添加代码</strong><br>注：放在<code>&lt;nav&gt;</code>和<code>&lt;/nav&gt;</code>之内</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/9dd56bf0-40f8-46ae-acb7-764d7074be59.png" alt><br>[========]</p><h2 id="19-鼠标点击桃心效果"><a href="#19-鼠标点击桃心效果" class="headerlink" title="19 鼠标点击桃心效果"></a>19 鼠标点击桃心效果</h2><p>在 themes/yilia/source文件夹下，建立resources文件夹，再新建click.js文件，代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">! function(e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e &#x3D; 0; e &lt; d.length; e++)</span><br><span class="line">            d[e].alpha &lt;&#x3D; 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale +&#x3D; .004, d[e].alpha -&#x3D; .013, d[e].el.style.cssText &#x3D; &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t &#x3D; &quot;function&quot; &#x3D;&#x3D; typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick &#x3D; function(e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className &#x3D; &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a &#x3D; t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type &#x3D; &quot;text&#x2F;css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText &#x3D; e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d &#x3D; [];</span><br><span class="line">    e.requestAnimationFrame &#x3D; function() &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function(e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 &#x2F; 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure><p>然后在themes/yilia/layout/_partial文件夹下的after-footer.ejs中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&lt;%&#x3D;config.root%&gt;.&#x2F;resources&#x2F;click.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/68ee37c3-7cb5-49b0-9d82-d670cf2bf98c.png" alt></p><p>重新部署即可</p><h2 id="20-添加网站运行时间"><a href="#20-添加网站运行时间" class="headerlink" title="20 添加网站运行时间"></a>20 添加网站运行时间</h2><h2 id="21-Hexo博客添加-helper-live2d动态模型插件"><a href="#21-Hexo博客添加-helper-live2d动态模型插件" class="headerlink" title="21 Hexo博客添加 helper-live2d动态模型插件"></a>21 Hexo博客添加 helper-live2d动态模型插件</h2><h3 id="前导"><a href="#前导" class="headerlink" title="前导"></a>前导</h3><ul><li>yilia主题</li><li>插件地址 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener" title="hexo-helper-live2d">hexo-helper-live2d</a></li><li><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></li></ul><h3 id="21-1-安装模块"><a href="#21-1-安装模块" class="headerlink" title="21.1 安装模块"></a>21.1 安装模块</h3><p>在hexo根目录执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h3 id="21-2-下载模型"><a href="#21-2-下载模型" class="headerlink" title="21.2 下载模型"></a>21.2 下载模型</h3><p>作者各种模型包展示 ➡️ <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener" title=" hexo live2d插件 2.0 !">hexo live2d插件 2.0 !</a></p><p><a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener" title="live2d模型仓库">live2d模型仓库</a></p><ul><li><code>live2d-widget-model-chitose</code></li><li><code>live2d-widget-model-epsilon2_1</code></li><li><code>live2d-widget-model-gf</code></li><li><code>live2d-widget-model-haru/01</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haru/02</code> (use <code>npm install --save live2d-widget-model-haru</code>)</li><li><code>live2d-widget-model-haruto</code></li><li><code>live2d-widget-model-hibiki</code> 黑猫</li><li><code>live2d-widget-model-hijiki</code></li><li><code>live2d-widget-model-izumi</code></li><li><code>live2d-widget-model-koharu</code></li><li><code>live2d-widget-model-miku</code></li><li><code>live2d-widget-model-ni-j</code></li><li><code>live2d-widget-model-nico</code></li><li><code>live2d-widget-model-nietzsche</code></li><li><code>live2d-widget-model-nipsilon</code></li><li><code>live2d-widget-model-nito</code></li><li><code>live2d-widget-model-shizuku</code></li><li><code>live2d-widget-model-tororo</code> 白猫</li><li><code>live2d-widget-model-tsumiki</code></li><li><code>live2d-widget-model-unitychan</code></li><li><code>live2d-widget-model-wanko</code></li><li><code>live2d-widget-model-z16</code></li></ul><p>使用<code>npm install {packagename}</code>安装模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># npm install live2d-widget-model-hibiki</span><br></pre></td></tr></table></figure><h3 id="21-3-详细配置"><a href="#21-3-详细配置" class="headerlink" title="21.3 详细配置"></a>21.3 详细配置</h3><p>在Hexo的 <code>_config.yml</code> 文件中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  #enable: false</span><br><span class="line">  scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  # scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hibiki</span><br><span class="line">    # use: live2d-widget-model-wanko # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: true # 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure><p>hexo g | hexo s即可</p><h2 id="22-Hexo添加访问量统计"><a href="#22-Hexo添加访问量统计" class="headerlink" title="22 Hexo添加访问量统计"></a>22 Hexo添加访问量统计</h2><ul><li>主题 yilia</li><li>访问统计量使用 <strong><a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener" title="不蒜子">不蒜子</a></strong></li></ul><h3 id="22-1-配置是否开启不蒜子访问量统计功能"><a href="#22-1-配置是否开启不蒜子访问量统计功能" class="headerlink" title="22.1 配置是否开启不蒜子访问量统计功能"></a>22.1 配置是否开启不蒜子访问量统计功能</h3><p>在 <strong>themes/yilia/_config.yml</strong> 添加属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启访问量统计功能（不蒜子）</span><br><span class="line">busuanzi:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="22-2-引入不蒜子并添加站点访问量"><a href="#22-2-引入不蒜子并添加站点访问量" class="headerlink" title="22.2 引入不蒜子并添加站点访问量"></a>22.2 引入不蒜子并添加站点访问量</h3><p>在<code>themes/yilia/layout/_partial/footer.ejs</code>末尾添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">                本站总访问量&lt;span id&#x3D;&quot;busuanzi_value_site_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_site_uv&quot; style&#x3D;&#39;display:none&#39;&gt;</span><br><span class="line">                本站访客数&lt;span id&#x3D;&quot;busuanzi_value_site_uv&quot;&gt;&lt;&#x2F;span&gt;人</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;script async src&#x3D;&quot;&#x2F;&#x2F;busuanzi.ibruce.info&#x2F;busuanzi&#x2F;2.3&#x2F;busuanzi.pure.mini.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/760ffbaf-8a71-415e-8869-74c555cddcf8.png" alt></p><h3 id="22-3-添加文章访问量"><a href="#22-3-添加文章访问量" class="headerlink" title="22.3 添加文章访问量"></a>22.3 添加文章访问量</h3><p>在<code>themes/yilia/layout/_partial/post/date.ejs</code>开头添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.busuanzi &amp;&amp; theme.busuanzi.enable &amp;&amp; !index)&#123; %&gt;</span><br><span class="line">        &lt;!-- 不蒜子统计 --&gt;</span><br><span class="line">        &lt;span id&#x3D;&quot;busuanzi_container_page_pv&quot; style&#x3D;&#39;display:none&#39; class&#x3D;&quot;&lt;%&#x3D; class_name %&gt;&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;icon-smile icon&quot;&gt;&lt;&#x2F;i&gt; 阅读数：&lt;span id&#x3D;&quot;busuanzi_value_page_pv&quot;&gt;&lt;&#x2F;span&gt;次</span><br><span class="line">        &lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>如图所示：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/daf13bfc-f651-4963-99bd-3cec83a0b71a.png" alt></p><meta charset="utf-8"><h3 id="22-4-注意事项"><a href="#22-4-注意事项" class="headerlink" title="22.4 注意事项"></a>22.4 注意事项</h3><ul><li><p>两种方法选择一种使用即可，都使用可能会出现无法显示的问题</p></li><li><p>使用<code>hexo s</code>部署在本地预览效果的时候，uv数和pv数会过大，这是由于不蒜子用户使用一个存储空间，所以使用<code>localhost:4000</code>进行本地预览的时候会导致数字异常，这是正常现象，只需要将博客部署至云端即可恢复正常。</p></li></ul><h2 id="23-RSS"><a href="#23-RSS" class="headerlink" title="23 RSS"></a>23 RSS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/fafa6df3-68ca-4b15-aaa9-b8ebb2ea0dec.png" alt></p><h2 id="24-Hexo设置-标签-分类-归档"><a href="#24-Hexo设置-标签-分类-归档" class="headerlink" title="24 Hexo设置 标签 分类 归档"></a>24 Hexo设置 标签 分类 归档</h2><p>举例：</p><h3 id="24-1-添加-分类页面"><a href="#24-1-添加-分类页面" class="headerlink" title="24.1 添加 分类页面"></a>24.1 添加 分类页面</h3><p>使用：<code>hexo new page categories</code> 新建一个 分类 页面。</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/50a49785-9652-4252-af8d-f67fbc85784c.png" alt></p><p>添加 type: “categories”<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/ac3196b3-f7f0-4483-8f0b-581b673c3e04.png" alt></p><p>tags类似：</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/db61e102-242e-404a-8f6e-9026770bcf82.png" alt></p><p>主题的 <code>_config.yml</code> 文件中的 <code>menu</code> 中进行匹配</p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/24627704-f7a0-4686-9c87-bd3ecc9d433e.png" alt></p><h2 id="25-Hexo博客优化之文章置顶-置顶标签"><a href="#25-Hexo博客优化之文章置顶-置顶标签" class="headerlink" title="25 Hexo博客优化之文章置顶+置顶标签"></a>25 Hexo博客优化之文章置顶+置顶标签</h2><h3 id="25-1-博文置顶"><a href="#25-1-博文置顶" class="headerlink" title="25.1 博文置顶"></a>25.1 博文置顶</h3><p>一种方法是手动对相关文件进行修改，具体可参考<a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">这篇文章</a>。</p><p>另一种方法就是，目前已经有修改后支持置顶的<a href="https://github.com/netcan/hexo-generator-index-pin-top" target="_blank" rel="noopener">仓库</a>，可以直接用以下命令安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index  --save </span><br><span class="line">$ npm install hexo-generator-index-pin-top  --save</span><br></pre></td></tr></table></figure><p>然后在需要置顶的文章的<code>Front-matter</code>中加上<code>top: true</code>即可。比如下面这篇文章：<br>注意有 <strong>空格</strong></p><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/062b9442-ca03-4376-b1c2-52287944889b.png" alt></p><h3 id="25-2-配置置顶标准"><a href="#25-2-配置置顶标准" class="headerlink" title="25.2 配置置顶标准"></a>25.2 配置置顶标准</h3><p>打开：/themes/*/layout（/_macro）/post.ejs<br>直接在最前面加入以下代码即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (page.top) &#123; %&gt;</span><br><span class="line"> &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line"> &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line"> &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><h3 id="25-3-配置文章"><a href="#25-3-配置文章" class="headerlink" title="25.3 配置文章"></a>25.3 配置文章</h3><p>然后在需要置顶的文章的Front-matter中加上top选项即可<br>top后面的数字越大，优先级越高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> title: (5)Hexo踩坑_主题优化</span><br><span class="line"> date: 2018-08-21 17:15:09</span><br><span class="line"> tags: Hexo-yilia</span><br><span class="line"> categories: Hexo</span><br><span class="line"> top: 5</span><br><span class="line"> ---</span><br></pre></td></tr></table></figure><h3 id="25-4-优先级配置"><a href="#25-4-优先级配置" class="headerlink" title="25.4 优先级配置"></a>25.4 优先级配置</h3><p>修改根目录配置文件/_config.yml,top值-1标示根据top值倒序（正序设置为1即可），同样date也是根据创建日期倒序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index_generator:</span><br><span class="line"> path: &#39;&#39;</span><br><span class="line"> per_page: 10</span><br><span class="line"> order_by:</span><br><span class="line"> top: -1</span><br><span class="line"> date: -1</span><br></pre></td></tr></table></figure><h3 id="25-5-设置置顶标志"><a href="#25-5-设置置顶标志" class="headerlink" title="25.5 设置置顶标志"></a>25.5 设置置顶标志</h3><p>暂时用默认的</p><h2 id="26-去掉配置文件中的-more"><a href="#26-去掉配置文件中的-more" class="headerlink" title="26 去掉配置文件中的 more"></a>26 去掉配置文件中的 more</h2><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/957764e6-d0ac-4b0c-8cc2-4b05f6327872.png" alt></p><h2 id="27-在左侧显示总文章数"><a href="#27-在左侧显示总文章数" class="headerlink" title="27 在左侧显示总文章数"></a>27 在左侧显示总文章数</h2><p>将themes\yilia\layout_partial\left-col.ejs文件的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav class&#x3D;&quot;header-menu&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line"> &lt;% for (var i in theme.menu)&#123; %&gt;</span><br><span class="line"> &lt;li&gt;&lt;a href&#x3D;&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;&gt;&lt;%&#x3D; i %&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;</span><br><span class="line"> &lt;%&#125;%&gt;</span><br><span class="line"> &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav style&#x3D;&quot;color: #7FFFD4;&quot;&gt;总文章数 &lt;%&#x3D;site.posts.length%&gt;&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure><h2 id="28-Hexo博客绑定个人域名"><a href="#28-Hexo博客绑定个人域名" class="headerlink" title="28 Hexo博客绑定个人域名"></a>28 Hexo博客绑定个人域名</h2><h3 id="28-1-购买域名"><a href="#28-1-购买域名" class="headerlink" title="28.1 购买域名"></a>28.1 购买域名</h3><p>阿里云或者腾讯云购买，步骤省略。</p><h3 id="28-2-域名解析"><a href="#28-2-域名解析" class="headerlink" title="28.2 域名解析"></a>28.2 域名解析</h3><h4 id="28-2-1-方法1（不推荐）"><a href="#28-2-1-方法1（不推荐）" class="headerlink" title="28.2.1 方法1（不推荐）"></a>28.2.1 方法1（不推荐）</h4><p>首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：</p><hr><p>本人Ip是： xxx.xxx.xxx.xxx<br>通过域名解析将购买的域名指向 github的二级域名：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/35ca50f9-eac8-442b-a9e4-077c30fc26a7.png" alt></p><p>之后如图所示记为成功：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/f9f80e1e-7684-4810-99aa-24e77adb447f.png" alt></p><h4 id="28-2-2-方法2（推荐）"><a href="#28-2-2-方法2（推荐）" class="headerlink" title="28.2.2 方法2（推荐）"></a>28.2.2 方法2（推荐）</h4><p>直接解析域名的CNAME记录到你的Git二级域名，不要使用方法一中的A记录，因为ip地址可能会一段时间之后会改变，所以建议记录类型选择CNAME进行解析，<a href="http://xn--username-273mz98dvpjuoju9wmi6c0myd.github.io/" target="_blank" rel="noopener">记录值填的就是username.github.io</a>，比如：</p><hr><h4 id="28-3-设置CNAME"><a href="#28-3-设置CNAME" class="headerlink" title="28.3 设置CNAME"></a>28.3 设置CNAME</h4><p>在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如：<br>blog.enjoytoshare.club</p><p>在 github 上面，打开 <a href="http://username.github.io/" target="_blank" rel="noopener">username.github.io</a> 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如：<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/e3d7dfeb-116d-4e35-94b3-4fee60ff37ec.png" alt></p><p>好了，新域名配置完成，可以访问了。</p><h2 id="29-Hexo-d-部署后重新修改域名？"><a href="#29-Hexo-d-部署后重新修改域名？" class="headerlink" title="29 Hexo d 部署后重新修改域名？"></a>29 Hexo d 部署后重新修改域名？</h2><ol><li>在source目录下（不是hexo根目录下），创建一个CNAME文件，可以用sublime创建，然后保存成（All files格式）<br>CNAME文件里写自己新的域名<br><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/18f0c754-8461-4294-870e-dfba518b16b8.jpg" alt></li></ol><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haoran.tech</span><br></pre></td></tr></table></figure><ol start="2"><li><p>hexo g 重新生成一下</p></li><li><p>hexo d 部署到github上</p></li></ol><p><img src="/2018/08/21/Hexo%E8%B8%A9%E5%9D%91-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/13cc17e1-13a2-46ff-ab2a-7b3898cbb87f.png" alt></p><p>此时可以通过域名访问了。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(4)Hexo撰写文章</title>
      <link href="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/"/>
      <url>/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><img src="/2018/08/19/Hexo%E6%92%B0%E5%86%99%E6%96%87%E7%AB%A0/60bbee39-dccc-48d2-9fb5-149a40253315.png" alt></p><a id="more"></a><h3 id="一-创建文章"><a href="#一-创建文章" class="headerlink" title="一 创建文章"></a>一 创建文章</h3><p>在站点文件夹中打开 git bash，输入如下命令创建文章，其中 <code>title</code> 为文章的标题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>当输入命令后，就会在 <strong>source/_post</strong> 文件夹下创建一个文件，命名为：<strong>title.md</strong></p><p>这个文件就是将要发布到网站上的原始文件，用于记录文章内容</p><p>下面，我们将要在这个文件中写下我们的第一篇博客</p><h3 id="二-编写文章（基于Markdown）"><a href="#二-编写文章（基于Markdown）" class="headerlink" title="二 编写文章（基于Markdown）"></a>二 编写文章（基于Markdown）</h3><h4 id="1-Markdown基本语法略"><a href="#1-Markdown基本语法略" class="headerlink" title="1 Markdown基本语法略"></a>1 <strong>Markdown基本语法略</strong></h4><h4 id="2-说明："><a href="#2-说明：" class="headerlink" title="2 说明："></a>2 <strong>说明：</strong></h4><p>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>1 将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p><p>2.在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p><p><strong>ps:如果上述 安装包不能正确加载图片，建议下述低版本安装包：</strong><br><font color="red"> 使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。</font></p><hr><p><font color="red"> 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。</font></p><hr><p>3 这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![图片文字说明，可用于图片加载不出来时](title/example.PNG)</code> 即可成功添加图片</p><h4 id="3-高级设置"><a href="#3-高级设置" class="headerlink" title="3 高级设置"></a>3 高级设置</h4><p><strong>1 模板设置</strong></p><p>当我们使用命令 <strong>hexo new “title”</strong> 创建文章时，Hexo 会根据 <strong>/scaffolds/post.md</strong> 对新文章进行初始化</p><p>换言之，<strong>/scaffolds/post.md</strong> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories</span><br></pre></td></tr></table></figure><p><strong>2 头部设置</strong></p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置<strong>文章标题</strong>、<strong>发布日期</strong>等基础信息外，还可以为文章<strong>添加标签</strong>、<strong>分类</strong>等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><font color="red"><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</font></p><p><strong>3 首页显示</strong></p><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，<strong>表示只会显示标志前面的内容</strong></p><h3 id="三-部署发布"><a href="#三-部署发布" class="headerlink" title="三 部署发布"></a>三 部署发布</h3><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h3 id="四-Hexo一篇文章多个categories"><a href="#四-Hexo一篇文章多个categories" class="headerlink" title="四 Hexo一篇文章多个categories"></a>四 Hexo一篇文章多个categories</h3><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写一篇 《Servlet笔记》，我既想将它放在 <strong>Java</strong> 这个分类中，又想将它放入 <strong>Servlet</strong> 这个分类。</p><p>  按照官方的解释，<code>categories</code> 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h4 id="4-1-子分类"><a href="#4-1-子分类" class="headerlink" title="4.1 子分类"></a>4.1 子分类</h4><p>下面的分类会将该分章放到 <code>Java/Servlet</code>这个分类下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Java</span><br><span class="line">  - Servlet</span><br></pre></td></tr></table></figure><p>同样的作用我们也可以这样写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: [Java, Servlet]</span><br></pre></td></tr></table></figure><h4 id="4-2-多个分类"><a href="#4-2-多个分类" class="headerlink" title="4.2 多个分类"></a>4.2 多个分类</h4><p>如果我们的要求是将文章同时分到多个不同的分类中呢，我们应该这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java]</span><br><span class="line">  -[Servlet]</span><br></pre></td></tr></table></figure><p>这样，就可以将上面的文章分类到 <code>Java</code> 和 <code>Servlet</code> 这两个不同的目录中了。</p><p>扩展一下，如果我们将其分类到 <code>Java/Servlet</code> 和 <code>Programming</code> 两个不同的目录下，我们应该如下写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  -[Java, Servlet]</span><br><span class="line">  -[Programming]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(3)Hexo常用命令详解</title>
      <link href="/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/19/Hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p><strong>Hexo 框架建立的网站中，存在两份重要的配置文件，它们的文件名称都是 _config.yml</strong><br><strong>一份是 站点配置文件，位于 站点根目录 下，用于网站的基础配置</strong><br><strong>另外一份是 主题配置文件，位于 themes 目录 下，用于主题的相关配置</strong><br><strong>不同的主题会有不同的主题配置文件，由主题作者所提供</strong>.</p><a id="more"></a><h3 id="1-hexo-init"><a href="#1-hexo-init" class="headerlink" title="1 hexo init"></a>1 hexo init</h3><p><strong>hexo init</strong> 命令用于初始化本地文件夹为网站的根目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><ul><li><strong>folder</strong> 可选参数，用以指定初始化目录的路径，若无指定则默认为当前目录</li></ul><h3 id="2-hexo-new"><a href="#2-hexo-new" class="headerlink" title="2 hexo new"></a>2 hexo new</h3><p><strong>hexo new</strong> 命令用于新建文章，一般可以简写为<strong>hexo n</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><ul><li><p><strong>layout</strong> 可选参数，用以指定文章类型，若无指定则默认由配置文件中的 default_layout 选项决定</p></li><li><p><strong>title</strong> 必填参数，用以指定文章标题，如果参数值中含有空格，则需要使用双引号包围</p></li></ul><h3 id="3-hexo-generate"><a href="#3-hexo-generate" class="headerlink" title="3 hexo generate"></a>3 hexo generate</h3><p><strong>hexo generate</strong> 命令用于生成静态文件，一般可以简写为 hexo g</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><ul><li><strong>-d</strong> 选项，指定生成后部署，与 <strong>hexo d -g</strong> 等价</li></ul><p>详细信息请参考：<a href="https://hexo.io/docs/generating" target="_blank" rel="noopener">https://hexo.io/docs/generating</a></p><h3 id="4-hexo-server"><a href="#4-hexo-server" class="headerlink" title="4 hexo server"></a>4 hexo server</h3><p><strong>hexo server</strong> 命令用于启动本地服务器，一般可以简写为 <strong>hexo s</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><ul><li><p>-p 选项，指定服务器端口，默认为 4000</p></li><li><p>-i 选项，指定服务器 IP 地址，默认为 0.0.0.0</p></li><li><p>-s 选项，静态模式 ，仅提供 public 文件夹中的文件并禁用文件监视</p></li></ul><p>说明 ：运行服务器前需要安装 hexo-server 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">https://hexo.io/docs/server.html</a></p><h3 id="5-hexo-deploy"><a href="#5-hexo-deploy" class="headerlink" title="5 hexo deploy"></a>5 hexo deploy</h3><p><strong>hexo deploy</strong> 命令用于部署网站，一般可以简写为 hexo d</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><ul><li><strong>-g</strong> 选项，指定生成后部署，与 hexo g -d 等价</li></ul><p>说明 ：部署前需要修改 _config.yml 配置文件，下面以 git 为例进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: &lt;repository url&gt;</span><br><span class="line">    branch:    master</span><br><span class="line">    message: 自定义提交消息，默认为Site updated: &#123;&#123; now(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#125;&#125;</span><br></pre></td></tr></table></figure><p>详细信息请参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></p><h3 id="6-hexo-clean"><a href="#6-hexo-clean" class="headerlink" title="6 hexo clean"></a>6 hexo clean</h3><p><strong>hexo clean</strong> 命令用于清理缓存文件，是一个比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>网站显示异常时可尝试此操作</p><h3 id="7-Option"><a href="#7-Option" class="headerlink" title="7 Option"></a>7 Option</h3><p><strong>（1）hexo –safe</strong></p><p><strong>hexo –safe</strong> 表示安全模式，用于禁用加载插件和脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>安装新插件时遇到问题可尝试此操作</p><p><strong>（2）hexo –debug</strong></p><p><strong>hexo –debug</strong> 表示调试模式，用于将消息详细记录到终端和 debug.log 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p><strong>（3）hexo –silent</strong></p><p><strong>hexo –silent</strong> 表示静默模式，用于静默输出到终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(2)Hexo配置文件详解</title>
      <link href="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>转载自 <a href="https://blog.csdn.net/wsmrzx/article/details/81477926" target="_blank" rel="noopener">https://blog.csdn.net/wsmrzx/article/details/81477926</a></p><p>Hexo 是一款极为优秀的博客框架，使用 Hexo 搭建一个个人博客后，还需要编写位于站点根目录下的 <code>_config.yml</code> 文件来满足定制化的需求。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">#副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">#简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">#博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">#博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">#时区</span><br><span class="line">timezone:</span><br><span class="line">#博客地址,与申请的GitHub一致</span><br><span class="line">url: http:&#x2F;&#x2F;elfwalk.github.io</span><br><span class="line">root: &#x2F;</span><br><span class="line">#博客链接格式</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads&#x2F;code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line">#日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">#分页，每页文章数量</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line">#博客主题</span><br><span class="line">theme: landscape</span><br><span class="line">#发布设置</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  #elfwalk改为你的github用户名</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;elfwalk&#x2F;elfwalk.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1d62242a-d3b1-417a-bf11-e69e000b36f1.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/c95a5140-a299-4492-9006-3827168ab8e9.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/6ef267ec-cfd0-411b-891a-15de0966c39b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/92065ad3-a506-4066-8ccf-0dc4f6804458.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/97fd8861-b2b9-48a8-8c6a-545d0f31b2d0.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/7fdb3429-0dd3-4363-bf04-c03636d1702b.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/d3ea4182-f75f-4576-904c-71883facc176.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/cb23844c-160e-47e9-97d3-753d06414ab8.png" alt></p><hr><p><img src="/2018/08/17/Hexo%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/801539a4-704b-4a63-b4f3-b824a474f7cd.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Firewalld二三事</title>
      <link href="/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2018/08/15/%E5%85%B3%E4%BA%8EFirewalld%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>文章来源：<br><a href="http://www.excelib.com/article/287/show/#u0pW4f" target="_blank" rel="noopener">http://www.excelib.com/article/287/show/#u0pW4f</a></p><h3 id="1-Firewalld简介"><a href="#1-Firewalld简介" class="headerlink" title="1 Firewalld简介"></a>1 Firewalld简介</h3><p>Centos7中默认将原来的防火墙iptables升级为了firewalld，firewalld跟iptables比起来至少有两大好处：</p><ol><li>firewalld可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效；</li><li>firewalld在使用上要比iptables人性化很多，即使不明白“五张表五条链”而且对TCP/IP协议也不理解也可以实现大部分功能。<a id="more"></a><h3 id="2-iptables-五表"><a href="#2-iptables-五表" class="headerlink" title="2 iptables 五表"></a>2 iptables 五表</h3>大部分iptables的资料都介绍说iptables包含四张表、五条链，不过实际上iptables还有第五张表——security表，但是这张表需要和selinux结合使用，而selinux虽然已经发布了十多年了但是直到现在还有很多人对他的理解不够透彻，甚至有很多人会将其关闭！</li></ol><p>其实selinux的设计理念在安全上来说是非常优秀的，而且理解了其设计理念之后再去使用也没那么复杂，只不过其内置的规则是非常复杂的，有机会再说。现在还回到iptables的五张表，他们分别是<strong>filter、nat、mangle、raw和security</strong>。</p><p>filter表就是我们最常使用的过滤表；nat表主要用于数据包转发，比如局域网的电脑如果想连接互联网，那么就可以使用nat给转发一下；mangle表的规则可以对数据包进行修改，比如修改ttl值等；raw表主要是为了提高效率使用的，raw本身的含义是指“原生的”、“未经过加工的”，符合raw表所对应规则的数据包将会跳过一些检查，这样就可以提高效率，当然，raw表的优先级也是最高的；security是跟selinux相关的MAC模式的安全过滤。</p><h3 id="3-firewalld和iptables的关系"><a href="#3-firewalld和iptables的关系" class="headerlink" title="3 firewalld和iptables的关系"></a>3 firewalld和iptables的关系</h3><p>firewalld自身并不具备防火墙的功能，而是和iptables一样需要通过内核的netfilter来实现，也就是说firewalld和iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的netfilter，只不过firewalld和iptables的结构以及使用方法不一样罢了。</p><h3 id="4-firewalld的配置文件结构"><a href="#4-firewalld的配置文件结构" class="headerlink" title="4 firewalld的配置文件结构"></a>4 firewalld的配置文件结构</h3><p>在具体介绍firewalld配置文件结构之前先介绍一下firewalld的配置模式，firewalld的配置模式设计的非常巧妙，而且这种设计思路也非常值得我们借鉴和学习。</p><h4 id="4-1-firewalld的配置模式"><a href="#4-1-firewalld的配置模式" class="headerlink" title="4.1 firewalld的配置模式"></a>4.1 firewalld的配置模式</h4><p>firewalld的配置文件以xml格式为主（主配置文件firewalld.conf例外），他们有两个存储位置</p><p>1.<code>/etc/firewalld/</code></p><p>2.<code>/usr/lib/firewalld/</code></p><p>使用时的规则是这样的：当需要一个文件时firewalld会首先到第一个目录中去查找，如果可以找到，那么就直接使用，否则会继续到第二个目录中查找。</p><p>firewalld的这种配置文件结构的主要作用是这样的：在第二个目录中存放的是firewalld给提供的通用配置文件，如果我们想修改配置，那么可以copy一份到第一个目录中，然后再进行修改。这么做有两个好处：首先我们日后可以非常清晰地看到都有哪些文件是我们自己创建或者修改过的，其次，如果想恢复firewalld给提供的默认配置，只需要将自己在第一个目录中的配置文件删除即可，非常简单，而不需要像其他很多软件那样在修改之前还得先备份一下，而且时间长了还有可能忘掉之前备份的是什么版本。</p><p>当然，这种配置模式也并不是firewalld的首创，在其他很多地方也都有用到，比如java中用于记录日志的logback也是这种模式，他在查找配置文件时会首先在根目录下找logback-test.xml文件，如果可以找到就直接使用，如果找不到就会接着找logback.xml文件，如果还找不到就会使用自己包里边自带的配置文件，这样使用起来就非常方便了，比如我们可以把logback-test.xml和logback.xml两个文件都创建出来，在开发机上使用logback-test.xml文件，然后在往服务器部署的时候直接将其删掉就可以了！</p><h4 id="4-2-配置文件结构"><a href="#4-2-配置文件结构" class="headerlink" title="4.2 配置文件结构"></a>4.2 配置文件结构</h4><p>firewalld的配置文件结构非常简单，主要有两个文件和三个目录：<br>文件：firewalld.conf、lockdown-whitelist.xml<br>目录：zones、services、icmptypes</p><p>另外，如果使用到direct，还会有一个direct.xml文件。我们要注意，在保存默认配置的目录 <code>/usr/lib/firewalld/</code> 中只有我们这里所说的目录，而没有firewalld.conf、lockdown-whitelist.xml和direct.xml这三个文件，也就是说这三个文件只存在于 <code>/etc/firewalld/</code> 目录中。</p><h4 id="4-3-文件和目录的作用"><a href="#4-3-文件和目录的作用" class="headerlink" title="4.3 文件和目录的作用"></a>4.3 文件和目录的作用</h4><ul><li><p>irewalld.conf：firewalld的主配置文件，是键值对的格式，不过非常简单，只有五个配置项</p></li><li><p>DefaultZone：默认使用的zone，关于zone学生稍后给大家详细介绍，默认值为public；</p></li><li><p>MinimalMark： 标记的最小值，linux内核会对每个进入的数据包都进行标记，目的当然是为了对他们进行区分，前面给大家补充iptables五张表相关的内容时候介绍说符合raw表规则的数据包可以跳过一些检查，那么是怎么跳过的呢？这里其实就是使用的标记，当然对数据包的标记还有很多作用。这里所设置的 MinimalMark值就是标记的最小值，默认值为100，一般情况下我们不需要对其进行修改，但是如果我们有特殊需要的时候就可以通过对其进行修改来告诉linux所使用标记的最小值了，比如我们需要给符合某条件的数据包标记为123，这时候为了防止混淆就需要将MinimalMark设置为一个大于123的值了；</p></li><li><p>CleanupOnExit：这个配置项非常容易理解，他表示当退出firewalld后是否清除防火墙规则，默认值为yes；</p></li><li><p>Lockdown： 这个选项跟D-BUS接口操作firewalld有关，firewalld可以让别的程序通过D-BUS接口直接操作，当Lockdown设置为yes的 时候就可以通过lockdown-whitelist.xml文件来限制都有哪些程序可以对其进行操作，而当设置为no的时候就没有限制了，默认值为 no；</p></li><li><p>IPv6_rpfilter：其功能类似于rp_filter，只不过是针对ipv6版的，其作用是判断所接受到的包是否是伪造的，检查方式主要是通过路由表中的路由条目实现的，更多详细的信息大家可以搜索uRPF相关的资料，这里的默认值为yes。</p></li><li><p>lockdown-whitelist.xml：当Lockdown为yes的时候用来限制可以通过D-BUS接口操作firewalld的程序</p></li><li><p>direct.xml：通过这个文件可以直接使用防火墙的过滤规则，这对于熟悉iptables的用户来说会非常顺手，另外也对从原来的iptables到firewalld的迁移提供了一条绿色通道</p></li><li><p>zones：保存zone配置文件</p></li><li><p>services：保存service配置文件</p></li><li><p>icmptypes：保存和icmp类型相关的配置文件</p></li></ul><h3 id="5-zone"><a href="#5-zone" class="headerlink" title="5 zone"></a>5 zone</h3><p>firewalld默认提供了九个zone配置文件：block.xml、dmz.xml、drop.xml、external.xml、home.xml、internal.xml、public.xml、trusted.xml、work.xml，他们都保存在 <code>/usr/lib/firewalld/zones/</code> 目录下。这些zone之间是什么关系？他们分别适用用哪些场景呢？</p><p>防火墙就相当于一个门卫，门卫对具体某个来访的人判断是否应该放行是依靠规则来判断的，而我们这里的zone其实就是一套规则集，或者说是一套判断的方案</p><p>理解了这层含义firewalld就容易了，比如上面的九个zone其实就是九种方案，而且起决定作用的其实是每个xml文件所包含的内容，而不是文件名，所以大家不需要对每种zone（每个文件名）的含义花费过多的精力，比如trusted这个zone会信任所有的数据包，也就是说所有数据包都会放行，但是public这个zone只会放行其中所配置的服务，其他的一律不予放行，其实我们如果将这两个文件中的内容互换一下他们的规则就换过来了，也就是public这个zone会放行所有的数据包，下面我们来看一下这两个文件的内容</p><p>public.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone&gt;</span><br><span class="line">  &lt;short&gt;Public&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;For use in public areas. You do not trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;ssh&quot;&#x2F;&gt;</span><br><span class="line">  &lt;service name&#x3D;&quot;dhcpv6-client&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>trusted.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;zone target&#x3D;&quot;ACCEPT&quot;&gt;</span><br><span class="line">  &lt;short&gt;Trusted&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;All network connections are accepted.&lt;&#x2F;description&gt;</span><br><span class="line">&lt;&#x2F;zone&gt;</span><br></pre></td></tr></table></figure><p>我们要特别注意trusted.xml中zone的target，就是因为他设置为了ACCEPT，所以才会放行所有的数据包，而public.xml中的zone没有target属性，这样就会默认拒绝通过，所以public这个zone（这种方案）只有其中配置过的服务才可以通过。</p><h4 id="5-1-service"><a href="#5-1-service" class="headerlink" title="5.1 service"></a>5.1 service</h4><p>service是firewalld中另外一个非常重要的概念，不过其含义是非常简单的。还是拿门卫的例子来给大家做解释，在iptables的时代我们给门卫下达规则时需要告诉他“所有到22号楼的人全部予以放行”、“所有到80号楼的人全部予以放行”等等，不过到了firewalld的时代就不需要这样了，而是可以直接下达像“到销售部的全部予以放行”这样的命令，然后门卫再一查发现销售部在80号楼，那么所有到80号楼的人门卫就都会放行了。我们这里的楼牌号和端口号相对应，部门名和服务名相对应，这样大家应该就可以理解service的作用了。</p><p>从端口号改为服务名主要有两个好处：首先是使用服务名配置的语义清晰，不容易出错；其次在对某个服务的端口号进行修改的时候只需要修改相应的service文件就可以了，而不需要再修改防火墙方案——zone。这其实跟DNS将ip地址和域名关联了起来是一样的道理。下面学生再来给大家介绍一下service的配置文件。</p><p>service配置文件的命名规则是&lt;服务名&gt;.xml，比如ssh的配置文件是ssh.xml，http的配置文件是http.xml等，他们默认保存在<code>/usr/lib/firewalld/services/</code>目录下，常见的服务其中都可以找到，如果我们想修改某个服务的配置，那么可以复制一份到<code>/etc/firewalld/services/</code>目录下然后进行修改就可以了，要想恢复默认配置直接将我们自己的配置文件删除就可以了。我们来看一下ssh服务的ssh.xml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;service&gt;</span><br><span class="line">  &lt;short&gt;SSH&lt;&#x2F;short&gt;</span><br><span class="line">  &lt;description&gt;Secure Shell (SSH) is a protocol for logging into and executing commands on remote machines. It provides secure encrypted communications. If you plan on accessing your machine remotely via SSH over a firewalled interface, enable this option. You need the openssh-server package installed for this option to be useful.&lt;&#x2F;description&gt;</span><br><span class="line">  &lt;port protocol&#x3D;&quot;tcp&quot; port&#x3D;&quot;22&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure><p>可以看到这里配置了tcp的22号端口，所以将ssh服务配置到所使用的zone（默认public）中后tcp的22号端口就开放了。如果我们想将ssh的端口修改为222，那么只需要将ssh.xml复制一份到“<code>/firewalld/</code>services/”中，然后将端口号修改为222就可以了。当然直接修改“/usr/lib/firewalld/services/”中的配置文件也可以实现，但是强烈建议不要那么做，原因相信大家都明白。</p><p>明白原理之后使用起来就可以非常灵活了，比如我们将“<code>/etc/firewalld/</code>services/ssh.xml”文件复制一份到“<code>/etc/firewalld/</code>services/”中，然后将名字改为abc.xml，并且将abc这个服务配置到所使用的zone中，这时22端口就会开放。也就是说在zone中所配置的服务其实跟实际的服务并不存在直接联系，而是和相应配置文件中配置的内容有关系。</p><h3 id="6-配置方法"><a href="#6-配置方法" class="headerlink" title="6 配置方法"></a>6 配置方法</h3><p>firewalld的配置方法主要有三种：firewall-config、firewall-cmd和直接编辑xml文件，其中firewall-config是图形化工具，firewall-cmd是命令行工具，而对于linux来说大家应该更习惯使用命令行方式的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(1)Hexo博客搭建</title>
      <link href="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h2 id="一-搭建GitHub-Pages"><a href="#一-搭建GitHub-Pages" class="headerlink" title="一 搭建GitHub Pages"></a>一 搭建GitHub Pages</h2><h3 id="1-注册一个GitHub账号，且登录"><a href="#1-注册一个GitHub账号，且登录" class="headerlink" title="1 注册一个GitHub账号，且登录"></a>1 注册一个GitHub账号，且登录</h3><h3 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2 创建仓库"></a>2 创建仓库</h3><p>1、点击 “NEW”</p><a id="more"></a><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_24_5DH_7B_5DR_7DU5PLM_602_7BV_29_24GMOCB.png" alt></p><p>2、填写的仓库名为”用户名.github.io”，用户名要与左边用户名一致，否则后面会报错</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7CKL_252_5DIX_25UYRE7_6K_5D16VK.png" alt></p><h3 id="3-启用Github-Pages"><a href="#3-启用Github-Pages" class="headerlink" title="3 启用Github Pages"></a>3 启用Github Pages</h3><p>1、点击”Settings”进入设置</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4FW_60V5O_7EEU_5D_DXF_7BD_7DQ_5B__G.png" alt></p><p>2、往下拉找到”GitHub Pages”,显示如图所示，即表明已经开启（一般创建完成后会默认自动开启）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_298GL_28RD@J3TIU5_5DN_24YGQUZC.png" alt></p><h3 id="4-选择主题"><a href="#4-选择主题" class="headerlink" title="4 选择主题"></a>4 选择主题</h3><p>1、点击 “Choose a theme”选择主题</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/AXQ5_5DWYAVR_5B2U3_X4KV6_5B3M.png" alt></p><p>2、任意选择一个主题，然后点击”select theme”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/DCVLHREVPA_7EZDM_V86_60C_WI.png" alt></p><h3 id="5-下载安装Node-js和Git"><a href="#5-下载安装Node-js和Git" class="headerlink" title="5 下载安装Node.js和Git"></a>5 下载安装Node.js和Git</h3><p>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/G_7B_29SB4U_5B2JZTZ_28OVV_243YXKQ.png" alt></p><p>2、安装Git和配置好Git环境</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3_28_24R8E_24Y_25D_29GX_7BCCX_24W002D.png" alt></p><h2 id="二-Hexo"><a href="#二-Hexo" class="headerlink" title="二 Hexo"></a>二 Hexo</h2><h3 id="1-安装Hexo"><a href="#1-安装Hexo" class="headerlink" title="1 安装Hexo"></a>1 安装Hexo</h3><p>1、在自己认为合适的地方创建文件夹，然后在此文件夹中打开 Git命令行，即右击鼠标，选择”Git Bash here”</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/R59B_29DJVG8CWW8R295GJ9_252.png" alt></p><p>2、输入 npm install -g hexo 进行安装</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/T@JPUVO_5BMOEO3E8IOLQX_29CK.png" alt></p><p>然后使用 hexo -v，出现下面界面说明安装成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/CK1_28_29ELV_5DWSZMIE1QLVOW_7EQ.png" alt></p><p>3、输入 hexo init  初始化文件夹（漫长等待<del>~</del> ）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9L_7E7EU_7E_7E2YODCLXO_250_7DTS_25K.png" alt></p><p>看到最后的”Start blogging with Hexo! “，表示成功</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/JN9YT_7BBQNQ5_60E_60BA89EX_T41586526832595.png" alt></p><p>4、输入 npm install，安装所需组件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SLIJWA4ITMT_25NDREFVWOITN.png" alt></p><p>5、输入 hexo g, 生成源文件</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/TXXGDI6ZN_25HZM_5BQM7K@_24Z_7DI.png" alt></p><p>6、输入 hexo s,启动本地服务器，通过访问 <strong><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></strong>,正式体验 Hexo</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5D_7BH_24LAXS3ZCI_29F_7DJ1DM_7BL_28E.png" alt>\</p><p>成功界面如下所示</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/C_5BB075IG7XK_5DT0VNFR_60L1WR.png" alt></p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2 更换主题"></a>2 更换主题</h3><p>1、安装主题（yilia）</p><p>使用命令</p><p>hexo clean</p><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p><p>clone后面跟着的是主题的git repo地址，而themes/yilia则表示要将该主题克隆到blob/themes/yilia目录中</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/8OMPT6DL_7DD5RSCMCDNTR_5B_5DL.png" alt></p><p>2、启动主题</p><p>找到目录下的_config.yml文件，打开找到 theme:属性，并设置为 yilia</p><p>3、更新主题</p><p>好像没有用到下面这两个命令<br>cd themes/yilia<br>git pull</p><p>hexo g</p><p>hexo s</p><p>使用 localhost:4000 查新新主题</p><h2 id="三-部署到GitHub"><a href="#三-部署到GitHub" class="headerlink" title="三 部署到GitHub"></a>三 部署到GitHub</h2><h3 id="1-使用Hexo-deploy-部署到GitHub"><a href="#1-使用Hexo-deploy-部署到GitHub" class="headerlink" title="1 使用Hexo deploy 部署到GitHub"></a>1 使用Hexo deploy 部署到GitHub</h3><p>1、编辑根目录下_config.yml文件，添加如下代码（JavaSsun换成自己的用户名），并进行保存</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5_Z78JY_60M0M1KL21UV_24OH_H.png" alt></p><p>2、安装一个扩展</p><p>npm install hexo-deployer-git –save</p><h3 id="2-检查SSH-Keys设置"><a href="#2-检查SSH-Keys设置" class="headerlink" title="2 检查SSH Keys设置"></a>2 检查SSH Keys设置</h3><p>1、输入 cd ~/.ssh</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_5BWC_7D_28_5BOXTZI_X_28U_5B10BQPU0.png" alt></p><p>如果没有rsa文件，输入 ssh-keygen -t rsa -C “<a href="mailto:xxxxxxx@qq.com">xxxxxxx@qq.com</a>“(自己邮箱)</p><p>2、输入 eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/NRKM5_7EPRMR9B6TTSF2Z_28SAF.png" alt></p><p>3、再输入 ssh-add ~/.ssh/id_rsa ,添加生成的SSH Key到 ssh-agent</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_28_28K6H4_29IJE0N9XO716_7DXTJQ.png" alt></p><p>4 添加 SSH Key 到GitHub</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/SN_1UT78G_250HN_5DJ_293T_5B6_7BLG.png" alt></p><p>5 输入 ssh -T <a href="mailto:git@github.com">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明添加成功了（有一个会让输入yes）</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/_25YT4_7D_601_601_283MW__7D_7B3_29_28_60I@A.png" alt></p><p>6 设置个人账号信息</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/QV1PTZ_25XP966E3RO_7E0_7DZ_246H.png" alt></p><h3 id="3-部署到GitHub"><a href="#3-部署到GitHub" class="headerlink" title="3 部署到GitHub"></a>3 部署到GitHub</h3><p>hexo d -g</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7e9d1463-32aa-42f1-b3de-f627a98136fa.png" alt></p><h2 id="四-日常维护"><a href="#四-日常维护" class="headerlink" title="四 日常维护"></a>四 日常维护</h2><p>当部署成功后，日常只需</p><ol><li>新建文章(new)</li><li>找到生成的.md然后编辑并保存</li><li>生成博客（generate）</li><li>部署（deploy）</li></ol><p>即可完成新文章的发布</p><p>日常使用命令如下：</p><p><img src="/2018/08/11/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/71900d3f-350a-4750-8a47-4bff361282d3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo-yilia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改Vim_tab为4个空格</title>
      <link href="/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/"/>
      <url>/2018/08/06/%E4%BF%AE%E6%94%B9Vim-tab%E4%B8%BA4%E4%B8%AA%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>为了 vim 更好的支持 python写代码，修改tab默认4个空格的两种设置方法：</strong></p><ul><li><p><strong>vim /etc/vimrc</strong><br>set ts=4<br>set sw=4</p></li><li><p><strong>vim/etc/vimrc</strong><br>set ts=4<br>set expandtab<br>set autoindent</p></li></ul><p>推荐第二种，按 tab 键时产生4个空格，兼容性更好。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOs7防火墙开端口测试</title>
      <link href="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="1-防火墙"><a href="#1-防火墙" class="headerlink" title="1 防火墙"></a>1 防火墙</h2><p>CentOS7之后，无法使用 iptables控制 Linux的端口，而是换成了<strong>firewalld</strong>。</p><ul><li><strong>查看防火墙状态</strong><br>systemctl status firewalld</li></ul><a id="more"></a><ul><li><p><strong>开启防火墙</strong><br>systemctl start firewalld</p></li><li><p><strong>关闭防火墙</strong><br>systemctl stop firewalld</p></li><li><p><strong>开机启用防火墙</strong><br>systemctl enable firewalld</p></li><li><p><strong>禁止开机启动防火墙</strong><br>systemctl disable firewalld</p></li><li><p><strong>查看当前firewall状态</strong><br>firewall-cmd --state</p></li><li><p><strong>重启防火墙</strong><br>firewall-cmd --reload</p></li></ul><h2 id="2-开启端口"><a href="#2-开启端口" class="headerlink" title="2 开启端口"></a>2 开启端口</h2><ul><li><p><strong>查看那已经开放的端口</strong><br>firewall-cmd --list-ports</p></li><li><p><strong>删除指定端口</strong><br>firewall-cmd --zone=public --remove-port=80/tcp --permanent</p></li><li><p>*<em>查看已启动的服务列表 *</em><br>systemctl list-unit-files|grep enabled</p></li><li><p><strong>查看启动失败的服务列表</strong><br>systemctl --failed</p></li><li><p><strong>查看内核版本</strong><br>uname -r</p></li><li><p><strong>查看版本</strong><br>firewall-cmd --version</p></li><li><p><strong>查看所有打开的端口</strong><br>firewall-cmd --zone=public --list-ports</p></li><li><p><strong>查看区域信息</strong><br>firewall-cmd --get-active-zones</p></li><li><p><strong>查看指定接口所属区域</strong><br>firewall-cmd --get-zone-of-interface=eth0</p></li><li><p><strong>开启端口</strong><br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br>命令含义：<br>--zone 作用域<br>--add-port=80/tcp 添加端口 ，格式为：端口/通讯协议<br>--permanent 永久生效，没有此参数重启后失效</p></li></ul><p><strong>开启端口后，需要重启防火墙</strong><br>firewall-cmd --reload</p><h2 id="3-测试端口"><a href="#3-测试端口" class="headerlink" title="3 测试端口"></a>3 测试端口</h2><p>在开启的端口中启动一个服务，如 nginx 或者 可运行 jar包.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;80&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">nohup java jar -Dserver.port&#x3D;80 xxx.jar &gt; console.log 2&gt;&amp;1 &amp;</span><br><span class="line">tail -f console.log</span><br></pre></td></tr></table></figure><p><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/ac8de13d-3c1c-4959-8a85-c89d3288175f.png" alt></p><p>在 windows下 打开 cmd telnet 服务器ip 80（刚开的端口），如下界面表示端口开启成功。<br><img src="/2018/08/01/CentOs7%E9%98%B2%E7%81%AB%E5%A2%99%E5%BC%80%E7%AB%AF%E5%8F%A3%E6%B5%8B%E8%AF%95/d785cee1-1fc9-4afa-8358-a3ddc085eae0.png" alt></p><h2 id="4-查看端口占用"><a href="#4-查看端口占用" class="headerlink" title="4 查看端口占用"></a>4 查看端口占用</h2><p>netstat -tunlp命令——查看端口占用</p><p>t：表示查看tcp</p><p>u：表示查看udp</p><p>n：表示端口以数字形式表示，没有n直接显示服务名。</p><p>l：表示显示所监听的端口</p><p>p：表示占用端口的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep xx：xx可以是端口号、服务名称或者ip地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis所需安装包及各种依赖</title>
      <link href="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/"/>
      <url>/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>安装包在个人云盘中，还在想办法分享出来。</p><p><img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/redis-cluster.png" alt></p><a id="more"></a><p><img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/5a60af17fb059969a94b73f89dee43de.png" alt>)<img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/5338a60e2cf7cae3ce1bdfc4eedce0c1.png" alt>)<img src="/2018/07/25/Redis%E6%89%80%E9%9C%80%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96/284346cec5dd86104255a44561167c51.png" alt>    </p><p>安装包：</p><p>gcc.zip</p><p>java操作redis所需jar包.zip</p><p>redis cluster.zip</p><p>redis-3.2.6.tar.gz</p><p>redis-desktop-manager-0.9.3.817.exe</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习</title>
      <link href="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Author:haoransun<br>Wechat:SHR—97</p><h2 id="1-Redis技术简介"><a href="#1-Redis技术简介" class="headerlink" title="1 Redis技术简介"></a>1 Redis技术简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Redis</strong> 是一个开源免费的基于内存的Key-value存储系统，它可以用作<font color="red">数据库、缓存、消息中间件</font>。它支持多种类型的数据结构，如：字符串（string）,散列（hash）,列表（list）,集合（set），有序集合（sorted set）与范围查询和地理空间（geospatial）索引半径查询等。<strong>Redis</strong>特性丰富，客户端支持现阶段流行的大多数编程语音。</p><a id="more"></a><h3 id="1-1-Redis的特点"><a href="#1-1-Redis的特点" class="headerlink" title="1.1 Redis的特点"></a>1.1 Redis的特点</h3><ol><li><strong>Redis</strong>是一个高性能的key/value<strong>内存型</strong>数据库</li><li><strong>Redis</strong>数据类型丰富（string list set zset hash等）</li><li><strong>Redis</strong>支持数据持久化（AOF和RDB两种持久化方式）</li><li><strong>Redis</strong>读写性能优异，单线程运行效率高。</li></ol><h3 id="1-2-Redis的安装"><a href="#1-2-Redis的安装" class="headerlink" title="1.2 Redis的安装"></a>1.2 Redis的安装</h3><ol><li>准备环境<br>1.1  VMware11<br>1.2  CentOS6.5<br>1.3  安装Redis依赖gcc(64位）<br>&nbsp;rpm -Uvh<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-common-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;libgcc-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;tzdata-2018e-3.el6.noarch.rpm<br>&nbsp;rpm -ivh<br>&nbsp;&nbsp;&nbsp;&nbsp;cloog-ppl-0.15.7-1.2.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;cpp-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-devel-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;glibc-headers-2.12-1.209.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;kernel-headers-2.6.32-696.30.1.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;libgomp-4.4.7-18.el6_9.2.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;mpfr-2.4.1-6.el6.x86_64.rpm<br>&nbsp;&nbsp;&nbsp;&nbsp;ppl-0.10.2-11.el6.x86_64.rpm<br>&nbsp;rpm -ivh<br>&nbsp;&nbsp;&nbsp;&nbsp;gcc-4.4.7-18.el6_9.2.x86_64.rpm</li><li>下载Redis<br>wget <a href="http://download.redis.io/releases/redis-3.2.8.tar.gz" target="_blank" rel="noopener"><u>http://download.redis.io/releases/redis-3.2.8.tar.gz</u></a></li><li>安装<br>&nbsp;&nbsp;解压<br>&nbsp;&nbsp;tar -zxvf redis-3.2.8.tar.gz<br>&nbsp;&nbsp;移动解压文件<br>&nbsp;&nbsp;mv redis-3.2.8 /usr/local/<br>&nbsp;&nbsp;编译<br>&nbsp;&nbsp;cd /usr/local/redis-3.2.8/<br>&nbsp;&nbsp;make<br>&nbsp;&nbsp;安装<br>&nbsp;&nbsp;make PREFIX=/usr/local/redis install<br>&nbsp;&nbsp;安装目录文件图解<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6C64.tmp.jpg" alt><br>&nbsp;&nbsp;启动<br>&nbsp;&nbsp; cp /usr/local/redis-3.2.8/redis.conf /usr/local/redis/<br>&nbsp;&nbsp; ./bin/redis-server redis.conf<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD1DD.tmp.jpg" alt><br>&nbsp;&nbsp; 使用客户端连接<br>&nbsp;&nbsp; 本机换用不用加 ip 和 port<br>&nbsp;&nbsp; ./bin/redis-cli [-h ipaddr] [-p port]<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3D50.tmp.jpg" alt><br>&nbsp;&nbsp; 配置redis服务端以后台守护进程运行<br>&nbsp;&nbsp; 修改redis.conf配置文件<br>&nbsp;&nbsp; <font color="red"> daemonize yes</font><h2 id="2-Redis-基本操作"><a href="#2-Redis-基本操作" class="headerlink" title="2 Redis 基本操作"></a>2 Redis 基本操作</h2><h3 id="2-1-Redis中常用的与数据库有关的指令"><a href="#2-1-Redis中常用的与数据库有关的指令" class="headerlink" title="2.1 Redis中常用的与数据库有关的指令"></a>2.1 Redis中常用的与数据库有关的指令</h3><font color="red">注意：Redis默认会存在16个数据库,编号从0-15，默认使用0号库</font><br>&nbsp;&nbsp;&nbsp; 1. 选择数据库: select index[0-15]<br>&nbsp;&nbsp;&nbsp; 2. 数据库操作<br>&nbsp;&nbsp;&nbsp; 清空当前数据库数据 flushdb<br>&nbsp;&nbsp;&nbsp; 清空所有数据库数据 flushall<h3 id="2-2-Redis对于key的操作命令"><a href="#2-2-Redis对于key的操作命令" class="headerlink" title="2.2 Redis对于key的操作命令"></a>2.2 Redis对于key的操作命令</h3><ol><li>del key1 key2 …keyn<br>作用：删除1个或多个键<br>返回值：不存在的key忽略掉，返回真正删除的key的数量</li><li>rename key newkey<br>作用：给key赋一个新的key名<br>注意：如果newkey已存在，则newkey的原值会被覆盖</li><li>move key db<br>作用：移动key到指定的数据库<br>返回值：移动成功返回1，失败返回0</li><li>keys pattern<br>作用：查找所有符合给定模式pattern的key<br>keys * 匹配数据库中所有key<br>keys h?llo 占位匹配符合条件一个字符key,如：hello、hallo、hxllo等<br>keys h*llo 通配匹配一个或多个字符key,如：hllo heeeello等。<br>keys h[ae]llo 选择匹配一个或多个字符key,如：hello hallo等<br>特殊符号：用 \ 隔开<br>返回值：符合条件的key列表</li><li>random key<br>作用：返回随机key<br>返回值：数据库为空返回nil,不为空返回key名</li><li>exists key<br>作用：判断key是否存在<br>返回值：存在返回1，不存在返回0</li><li>type key<br>作用：返回key存储的值类型<br>返回值：string list set zset hash</li><li>ttl key<br>作用：查询key的生命周期<br>返回值：<br>当key不存在时，返回-2<br>没有设置剩余生存时间时，返回-1<br>否则，以秒为单位，返回key的剩余生存时间</li><li>expire key<br>作用：设置key的生命周期，以秒为单位<br>返回值：<br>如果生存时间设置成功，返回1<br>当key不存在或者没办法设置生存时间，返回0<br>同理：<br>pexpire key 毫秒数，设置生命周期<br>pttl key, 以毫秒为单位返回生命周期</li><li>persist key<br>作用：把指定key置为永久有效<h2 id="3-Redis数据类型操作"><a href="#3-Redis数据类型操作" class="headerlink" title="3 Redis数据类型操作"></a>3 Redis数据类型操作</h2><h3 id="3-1-string类型操作"><a href="#3-1-string类型操作" class="headerlink" title="3.1 string类型操作"></a>3.1 string类型操作</h3></li></ol></li></ol><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| set  | 设置一个key/value  |<br>| get  | 根据key获得对应的value  |<br>| mset  | 一次设置多个key value  |<br>| mget  | 一次获得多个key的value  |<br>| getset  | 获得原始key的值，同时设置新值  |<br>| strlen  | 获得对应key存储value的长度  |<br>| append  | 为对应key的value追加内容  |<br>| getrange  |截取value的内容   |<br>| setex  | 设置一个key存活的有效期（秒）  |<br>| psetex  |设置一个key存活的有效期（毫秒）  |<br>| setnx  | 存在不做任何操作，不存在则添加  |<br>| msetnx  |同时设置多个key,只要有一个存在则都不保存   |<br>| decr  | 进行数值类型的-1操作  |<br>| decrby  |根据提供的数据进行减法操作   |<br>| incr  | 进行数值类型的+1操作  |<br>| incrby  |根据提供的数据进行加法操作   |<br>| incrbyfloat  |根据提供的数据加入浮点数   |</p><h3 id="3-2-list类型的操作"><a href="#3-2-list类型的操作" class="headerlink" title="3.2 list类型的操作"></a>3.2 list类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps455C.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| lpush  | 将某个值加入到一个key列表头部  |<br>| lpushx  | 同lpush，但是必须保证key存在  |<br>| rpush  | 将某个值加入到一个key列表末尾  |<br>| rpushx  |同rpush，但是必须保证key存在  |<br>| lpop  | 返回和移除列表的第一个元素  |<br>| rpop  | 返回和移除列表的最后一个元素  |<br>| lrange  | 获取某一个下标区间内的元素  |<br>| llen  |获取列表元素个数  |<br>| lset  | 设置某一个指定索引的值（索引必须存在）  |<br>| lindex  |获取某一个指定索引位置的元素 |<br>| lrem | 删除重复元素  |<br>| ltrim  |保留列表中特定区间内的元素   |<br>| linsert | 在某一个元素之前，之后插入新元素 |</p><h3 id="3-3-set类型的操作"><a href="#3-3-set类型的操作" class="headerlink" title="3.3 set类型的操作"></a>3.3 set类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD626.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| sadd  | 为集合添加元素  |<br>| smembers  | 显示集合中所有元素（无序）  |<br>| scard  | 返回集合中元素的个数  |<br>| spop  | 随机返回一个元素 |<br>| smove  | 从一个集合中向另一个集合移动元素  |<br>| srem  | 从集合中删除一个元素  |<br>| sismember  | 判断一个集合中是否含有这个元素  |<br>| srandmember  |随机返回元素 |<br>| sdiff  | 去掉第一个集合中其他集合含有相同的元素  （求差集）|<br>| sinter  |求交集 |<br>| sunion | 求和集  |</p><h3 id="3-4-zset类型的操作"><a href="#3-4-zset类型的操作" class="headerlink" title="3.4 zset类型的操作"></a>3.4 zset类型的操作</h3><p>图示：<img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1877.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| zadd  | 添加一个元素至有序集合中 |<br>| zcard  | 返回有序集合中元素的个数  |<br>| zrange  | 随机返回一个范围内的元素 |<br>| zrangebyscore  | 按照分数查找一个范围内的元素  |<br>| zrank  | 返回排名 |<br>| zrevrank  | 倒序排名  |<br>| zscore  |返回某一个元素的分数 |<br>| zrem  | 移除某一个元素|<br>| zincrby  |给某个特定元素加分 |</p><h3 id="3-5-hash类型的操作"><a href="#3-5-hash类型的操作" class="headerlink" title="3.5 hash类型的操作"></a>3.5 hash类型的操作</h3><p>图示： <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsCB8D.tmp.jpg" alt></p><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| hset  | 设置一个key/value对  |<br>| hget  | 获得一个key对应的value  |<br>| hgetall  | 获得所有key/value对 |<br>| hdel  | 删除某一个key/value对 |<br>| hexists  | 判断一个key是否存在  |<br>| hkeys  | 获得所有的key  |<br>| hvals  | 获得所有的value  |<br>| hmset  |设置多个key/value |<br>| hmget  | 获得多个key的value|<br>| hsetnx  |设置一个不存在的key的值 |<br>| hincrby | 为value进行加法运算  |<br>| hincrbyfloat | 为value加入浮点值  |</p><h2 id="4-Java-API操作Redis"><a href="#4-Java-API操作Redis" class="headerlink" title="4 Java API操作Redis"></a>4 Java API操作Redis</h2><h3 id="4-1-使用方法"><a href="#4-1-使用方法" class="headerlink" title="4.1 使用方法"></a>4.1 使用方法</h3><ol><li>导入jar包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps68E0.tmp.jpg" alt></li><li>测试</li></ol><ul><li>测试连接redis<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试redis连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// 创建jedis连接池配置对象</span></span><br><span class="line">    JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">//最小空闲数</span></span><br><span class="line">    jpc.setMinIdle(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//最大空闲数</span></span><br><span class="line">    jpc.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    jpc.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大等待时间</span></span><br><span class="line">    jpc.setMaxWaitMillis(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//创建连接池</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jpc,<span class="string">"192.168.0.0"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>测试结果：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1593.tmp.jpg" alt><br><font color="red">注意：出现此异常，是因为redis服务端默认只允许127.0.0.1连接，如何允许其他网络地址访问服务端呢？只需修改redis.conf配置文件</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps10B8.tmp.jpg" alt></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">JedisTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 测试redis连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建jedis连接池配置对象</span></span><br><span class="line">    JedisPoolConfig jpc = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">//最小空闲数</span></span><br><span class="line">    jpc.setMinIdle(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//最大空闲数</span></span><br><span class="line">    jpc.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大连接数</span></span><br><span class="line">    jpc.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//最大等待时间</span></span><br><span class="line">    jpc.setMaxWaitMillis(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">//创建连接池</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jpc,<span class="string">"192.168.0.0"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试Redis 基本相关操作</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBasicAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//选择数据库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取所有key集合</span></span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">for</span>(String str:keys)&#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空数据库</span></span><br><span class="line">        <span class="comment">//jedis.flushDB();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//存放string类型的key/value</span></span><br><span class="line">        jedis.set(<span class="string">"age"</span>,<span class="string">"18"</span>);</span><br><span class="line">        </span><br><span class="line">        jedis.append(<span class="string">"age"</span>,<span class="string">"岁"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key的value</span></span><br><span class="line">        String value = jedis.get(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"> <strong>Redis的相关命令，对应Jedis中的方法。使用时需要什么命令，调用Jedis对应方法即可</strong></font></p><h2 id="5-Redis持久化机制"><a href="#5-Redis持久化机制" class="headerlink" title="5 Redis持久化机制"></a>5 Redis持久化机制</h2><p><strong>说明：Redis提供了两种不同的持久化方法来将数据存储到硬盘里面</strong></p><ol><li><font color="red">快照（snapshotting）快照文件</font><br>这种方式可以将某一时刻的所有数据都写入硬盘中，当然这也是redis的默认持久化方式，<br>保存的文件是以.rdb形式结尾的文件因此这种方式也称之为RDB快照文件持久化方式.</li><li><font color="red">AOF（append only file）追加文件</font><br>这种方式可以将所有客户端执行的写命令记录到日志文件中，保存的日志文件以.aof结尾<h3 id="5-1-RDB快照持久化"><a href="#5-1-RDB快照持久化" class="headerlink" title="5.1 RDB快照持久化"></a>5.1 RDB快照持久化</h3></li></ol><ul><li>快照持久化也是redis中的默认开启的持久化方案，根据redis.conf中的配置，快照将被写入dbfilename指定的文件里面(默认写入到名为dump.rdb文件中)<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps37C1.tmp.jpg" alt></li><li>指定dump.rdb快照文件的保存目录（默认保存在配置文件所属目录，aof日志文件默认也保存在此目录）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps232B.tmp.jpg" alt></li><li>RDB持久化原理<br>每隔<font color="red">几分钟</font>或者<font color="red">N次写</font>操作后，将内存中数据以快照的方式写入到二进制文件中，默认的文件名为dump.rdb。压缩放在备份目录。当因为宕机或者断电等原因造成redis内存数据丢失时，再将rdb快照文件中保存数据载入到内存中。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps9CCC.tmp.jpg" alt></li><li>RDB持久化触发时机<ol><li>手动触发（客户端命令bgsave或者save）<br>save命令（不推荐使用）：save操作是在主线程中保存快照，由于redis是用一个主线程来处理所有客户端请求，这种方式会阻塞所有客户端请求。<br>bgsave命令：当接收到客户端的bgsave命令时，redis会调用fork来创建一个子进程，父进程继续处理client请求，子进程负责将内存内容写入到临时文件。 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。</li><li>自动触发<br>触发条件：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps2685.tmp.jpg" alt><br>执行机制：<br><font color="red">如果用户在redis.conf中设置了save配置选项，redis会在save选项条件满足之后自动触发一次bgsave命令，如果设置多个save配置选，当任意一个save配置选项条件满足,redis也会触发一次bgsave命令</font><table><tr><td bgcolor="#7FFFD4">注意：每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步脏数据。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。</td></tr></table>缺点由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof持久化方式。### 5.2 AOF追加日志持久化</li></ol></li><li>AOF持久化机制默认没有开启，<table><tr><td bgcolor="red">使用aof持久化方式时，redis会将每一个收到的写命令都通过write函数追加到文件中(默认是appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。</td></tr></table></li><li>原理图：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA7CF.tmp.jpg" alt></li></ul><ol><li><p>开启AOF持久化机制，需要修改redis.conf的配置文件</p><ol><li>通过修改redis.conf配置中appendonly yes来开启AOF持久化</li><li>通过appendfilename指定日志文件名字(默认为:appendonly.aof)</li><li>通过appendfsync指定日志记录频率</li></ol></li><li><p>AOF日志记录频率的选项<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps28AE.tmp.jpg" alt></p></li><li><p>AOF日志文件重写<br>aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为了压缩aof的持久化文件Redis提供了AOF重写机制。</p><ol><li><font color="red">aof重写是指把内存中的数据,逆化成命令,写入到.aof日志里</font></li><li>手动重写aof文件     客户端执行命令bgrewriteaof</li><li>自动重写aof文件     配置redis.conf<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5BD6.tmp.jpg" alt></li><li>AOF日志文件重写原理<br>redis调用fork，创建子进程。子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令。 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。<br>注意：<font color="red">重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。</font></li><li>常见问题<br>问：恢复时rdb和aof哪个恢复数据快<br>答：rdb快，因为其是数据的内存映射二进制文件，直接载入到内存，而aof    是命令，需要逐条执行<br>问：如果rdb文件，和aof文件都存在，优先用谁来恢复数据<br>答：aof<br>问：在dump rdb过程中，aof如果停止同步，会不会丢失数据<br>答：会，所有的操作缓存在内存的队列里， dump完成后，统一操作。</li></ol><h2 id="6-Redis-应用"><a href="#6-Redis-应用" class="headerlink" title="6. Redis 应用"></a>6. Redis 应用</h2><h3 id="6-1-使用Redis作为Cache-以Mybatis-二级缓存为例"><a href="#6-1-使用Redis作为Cache-以Mybatis-二级缓存为例" class="headerlink" title="6.1 使用Redis作为Cache(以Mybatis 二级缓存为例)"></a>6.1 使用Redis作为Cache(以Mybatis 二级缓存为例)</h3><p>在Mybatis中，缓存的功能由根接口Cache（org.apache.ibatis.cache.Cache）定义。Mybatis的缓存分为了一级缓存和二级缓存，一级缓存的生命周期和SqlSession相同。二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，也可配置如encache等的第三方缓存。<br><font color="red">原理：缓存结构为key value格式存储，符合redis存储数据特征，并且mybatis提供了Cache接口，我们只需要自定义缓存类实现Cache接口，并将缓存结果保存在redis中即可。</font></p><ol><li>导包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5B39.tmp.jpg" alt></li><li>自定义cache类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@description</span> 使用redis作为mybatis缓存管理</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomCache</span> <span class="keyword">implements</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock readwriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomCache</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cache instance require an ID"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在进行 insert update delete 时需要清空缓存</span></span><br><span class="line">        getRedis.flushDB();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存对象的唯一标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存对象中获取key对应的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] value = getRedis().get(</span><br><span class="line">            SerializationUtils.serialize((Serializable)key);</span><br><span class="line">            <span class="comment">//反序列化 返回的value</span></span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> SerializationUtils.deserialize(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取读写锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A ReaderWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReaderWriteLock <span class="title">getReaderWriteLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> readerWriteLock;</span><br><span class="line">        &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存对象中存储的键值对的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">geSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//获取redis中key、value数。返回Long的结果，需转换为int类型返回</span></span><br><span class="line">        Long size = <span class="keyword">new</span> Long(getRedis().dbSize());</span><br><span class="line">        <span class="keyword">return</span> size.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存key/value到缓存对象中 key可以是任意对，但一般是CacheKey对象 value是查询结果，为List类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key,Object value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//序列化存储key，value为byte[],并保存在redis中</span></span><br><span class="line">        getRedis().set(SerializationUtils.serialize((Serializable)key,</span><br><span class="line">            SerializationUtils.serialize((Serializable)value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试<br>a) 需要在xxxMapper.xml中开启缓存<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps89BB.tmp.jpg" alt><br>b) 测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 测试redis缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisCacheTest</span></span>&#123;</span><br><span class="line">    SqlSession session = nul;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span>throw IOException</span>&#123;</span><br><span class="line">        InputStream is = Resource.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">        SqlSessionFactory ssf = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        session = ssf.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查一个 新增一条缓存到redis中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisCache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = userDao.findUserById(id);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试查所有，新增一条记录到redis中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRedisCache1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;User&gt; users = userDao.findUser();</span><br><span class="line">        <span class="keyword">for</span>(User user:users)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试新增动作 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlushRedisDB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserDao userDao = session.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"张三丰"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">        user.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 二级缓存（2）**<br>导入相关jar包<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6F1F.tmp.jpg" alt><br>Mybatis与redis整合时所需要的配置文件<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsD4C0.tmp.jpg" alt><br>在mybatis的mapper文件中设置缓存服务器<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps43F5.tmp.jpg" alt></p><h3 id="6-2-使用Redis管理HttpSession"><a href="#6-2-使用Redis管理HttpSession" class="headerlink" title="6.2 使用Redis管理HttpSession"></a>6.2 使用Redis管理HttpSession</h3><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6748.tmp.jpg" alt><br>使用负载均衡服务器Nginx，Nginx配置为non-sticky运行模式，请求会随机的分配到Tomcat集群中某一节点，且每台Tomcat的Session会话都保存到Redis数据库中.</p><ol><li>准备环境（准备两台tomcat，版本需为6.0.xx，修改server.xml端口号，保证两台tomcat同时启动端口号不占用）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1519.tmp.jpg" alt></li><li>将所需jar包分别导入到tomcat的lib目录<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8CBB.tmp.jpg" alt></li><li>配置（分别在每台tomcat的context.xml中加入如下配置）<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps92F.tmp.jpg" alt></li><li>修改页面（分别修改tomcat1\webapps\ROOT目录的index.jsp页面）<br>Tomcat1如下：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsE121.tmp.jpg" alt><br>Tomcat2如下：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3ACB.tmp.jpg" alt></li><li>测试<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA917.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsCCEC.tmp.jpg" alt></li></ol><h2 id="7-Redis事务"><a href="#7-Redis事务" class="headerlink" title="7 Redis事务"></a>7 Redis事务</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：<br>1 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>2 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。<br>3 一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务</li><li>命令入队</li><li>执行事务<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8CD0.tmp.jpg" alt><br>从输出中可以看到，当输入MULTI命令后，服务器返回OK表示事务开始成功，然后依次输入需要在本次事务中执行的所有命令，每次输入一个命令服务器并不会马上执行，而是返回”QUEUED”，这表示命令已经被服务器接受并且暂时保存起来，最后输入EXEC命令后，本次事务中的所有命令才会被依次执行，可以看到最后服务器一次性返回了三个OK，这里返回的结果与发送的命令是按顺序一一对应的，这说明这次事务中的命令全都执行成功了。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF426.tmp.jpg" alt><br>先输入MULTI最后输入EXEC表示中间的命令属于一个事务，不同的是中间输入的命令有一个错误(set写成了sett)，这样因为有一个错误的命令导致事务中的其他命令都不执行了(通过后续的get命令可以验证)。<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5B8C.tmp.jpg" alt><br>语法本身没错，但适用对象有问题。比如sadd 操作string类型，Exec之后，会执行正确的语句，并跳过有不适当的语句。这个问题是调用了错误的类型，由程序员负责。</li></ul></li></ol><ul><li>watch命令（乐观锁）<br><font color="red">Redis的事务中，启用的是乐观锁，只负责监控key是否被改动。如果改动回滚事务，<br>  未改动提交事务。</font></li><li>unwatch<br>取消 WATCH 命令对所有 key 的监视。</li></ul><h2 id="8-Redis发布订阅"><a href="#8-Redis发布订阅" class="headerlink" title="8.Redis发布订阅"></a>8.Redis发布订阅</h2><p><font color="red">Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis作为一个pub/sub server，在订阅者和发布者之间起到了消息路由的功能。订阅者可以通过subscribe和psubscribe命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为通道(channel)。当发布者通过publish命令向redis server发送特定类型的消息时。订阅该消息类型的全部client都会收到此消息。这里消息的传递是多对多的。一个client可以订阅多个 channel,也可以向多个channel发送消息。</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps1BA7.tmp.jpg" alt><br>工作流程如上图：当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端。</p><ol><li>相关命令</li></ol><p>|  <strong>命令</strong> | <strong>说明</strong>  |<br>|:—–:|:——-:|:———–:|<br>| subscribe  | 订阅给定的一个或多个频道的信息  |<br>| publish  | 将信息 message 发送到指定的频道 channel  |<br>| psubscribe  | 订阅一个或多个符合给定模式的频道|<br>| punsubscribe  | 退订所有给定模式的频道 |<br>| unsubscribe  | 指退订给定的频道  |<br>| pubsub  | 查看订阅与发布系统状态  |</p><ul><li>订阅频道<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8E44.tmp.jpg" alt></li><li>消息发布<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps3D90.tmp.jpg" alt></li><li>模糊订阅<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB060.tmp.jpg" alt></li></ul><h2 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9. Redis集群"></a>9. Redis集群</h2><h3 id="9-1-Redis主从复制集群"><a href="#9-1-Redis主从复制集群" class="headerlink" title="9.1 Redis主从复制集群"></a>9.1 Redis主从复制集群</h3><p>一般来说，要将Redis运用于工程项目中，使用一台Redis是万万不能的，原因如下：</p><ol><li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；</li><li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内容容量为256G，也不能将所有内容用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。<br>考虑如下一种场景：<br>电子商务网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是“多读少写”。对于这种场景，我们可以使如下这种架构：<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps41C5.tmp.jpg" alt></li></ol><p>如图中所示，我们将一台Redis服务器作主库(Matser)，其他三台作为从库(Slave)，主库只负责写数据，每次有数据更新都将更新的数据同步到它所有的从库，而从库只负责读数据。这样一来，就有了两个好处：</p><ol><li>读写分离，不仅可以提高服务器的负载能力，并且可以根据读请求的规模自由增加或者减少从库的数量。</li><li>解决单节点故障问题，数据被复制成了了好几份，就算有一台机器出现故障，也可以使用其他机器的数据快速恢复。<br><font color="red"> 在Redis主从模式中，一台主库可以拥有多个从库，但是一个从库只能隶属于一个主库。</font></li></ol><ul><li>Redis 主从环境搭建<br>配置：Redis主从复制架构，主数据库不需要做任何配置，只需要在从数据库配置文件中加入以下命令<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA44F.tmp.jpg" alt></li><li>测试<br>分别启动主数据库master 、从数据库slave<br>./bin/redis-server 6379.conf<br>./bin/redis-server 6380.conf</li></ul><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps5792.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB8ED.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF480.tmp.jpg" alt><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps23CE.tmp.jpg" alt><br><font color="red">注意：默认从数据库是只读的，如果在从数据库写数据会报错，可以修改配置允许从数据库写数据，不建议从数据库设置为可写</font></p><ul><li>原理<br>当一个从数据库启动时，会向主数据库发送SYNC命令，主数据库收到命令后会开始在后台保存快照（即RDB持久化过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和缓存的命令发给从数据库，从数据库收到数据后，会载入快照文件并执行缓存的命令。以上过程称为<font color="red">复制初始化。</font>复制初始化之结束后，主数据库每收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致，这一过程称为<font color="red">复制同步阶段</font>。</li></ul><h3 id="9-2-Redis集群Cluster"><a href="#9-2-Redis集群Cluster" class="headerlink" title="9.2 Redis集群Cluster"></a>9.2 Redis集群Cluster</h3><ol><li>Redis集群是一个分布式（distributed）、容错（fault-tolerant）的 Redis内存K/V服务。redis的集群支持节点的自动发现、支持slave-master选举、集群容错、支持在线分片、集群管理等特性。</li><li>Redis cluster架构<br>a) redis-cluster架构图<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6EF3.tmp.png" alt><br>架构细节:<br>(1) 所有的redis节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。<br>(2) 节点的fail是通过集群中超过半数的master节点检测失效时才生效。    客户端与redis节点直连，不需要中间proxy层.客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。<br>(3) redis-cluster把所有的物理节点映射到[0-16383]slot上，cluster 负责维护node&lt;-&gt;slot&lt;-&gt;key<br>b) redis-cluster选举和容错<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps42D9.tmp.png" alt><br>(1) 领着选举过程是集群中所有master参与，如果半数以上master节点与故障节点通信超过(cluster-node-timeout)，认为该节点故障，自动触发故障转移操作。<br>(2) 什么时候整个集群不可用(cluster_state:fail)?<br>如果集群任意master挂掉，且当前master没有slave。集群进入fail状态，也可以理解成集群的slot映射[0-16383]不完成时进入fail状态。Ps： redis-3.0.0.rc1加入cluster-require-full-coverage参数，默认关闭，打开集群兼容部分失败。<br>如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态。<br>当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误。</li><li>Redis的cluster搭建<br>a) 集群需要安装ruby环境<br>  aa) 互联网安装<pre><code>yum install -y ruby rubygemsgem install redis</code></pre>  bb) 本地安装<br>  1）上传ruby安装文件<br>  <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsEBDD.tmp.jpg" alt><br>  2）安装<br>  cd ruby-64<br>  rpm -ivh *<br>  cd rubygems-64<br>  rpm -ivh *<br>  cd redisgems<br>  gem install redis<br>  b) redis环境搭建<br>  注：redis服务端在启动时，需要指定一个redis.conf，表示一个进程，所以可以在     同一台主机上模拟出多个redis进程（也可以使用多台主机搭建环境）<br>   aa) 创建文件夹<br>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsB45A.tmp.jpg" alt><br>   bb) 每个文件夹中都复制一份redis.conf，如：<br>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps241C.tmp.jpg" alt><br>   cc) 修改每一个redis.conf配置文件，如：</li></ol><p>vi  6380.conf</p><p>修改：<br>port 6380      //修改每个配置文件端口号，如6380、6381…<br>daemonize yes  //后台守护进程启动<br>cluster-enabled  yes                 //开启集群模式<br>cluster-config-file  nodes.conf     //集群节点配置文件<br>cluster-node-timeout  5000          //集群节点超时时间<br>appendonly  yes                   //开启AOF持久化</p><p>c)redis集群配置<br>     aa) 分别启动redis server  (6380、6381、6382、6383、6384、6385、6386)<br>        cd 6380<br>        ../bin/redis-server 6380.conf<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps43F6.tmp.jpg" alt><br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6A3C.tmp.jpg" alt><br>     bb) 创建集群<br>     cd /usr/local/redis-3.2.8/src<br>     ./redis-trib.rb create –replicas 1 192.168.128.133:6380 192.168.128.133:6381 192.168.128.133:6382 192.168.128.133:6383         192.168.128.133:6384 192.168.128.133:6385<br>     <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps68B2.tmp.jpg" alt><br>     cc) 集群基本操作<br>      1）客户端访问集群<br>      ./bin/redis-cli -c -h 192.168.128.133 -p 6384</p><p>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps6226.tmp.jpg" alt><br>      2）查看集群节点状态<br>      ./redis-trib.rb check 192.168.128.133:6382</p><p>   <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF8F8.tmp.jpg" alt><br>      3）节点状态说明<br>      <font color="red"><br>          主节点:<br>        1、主节点存在hash slots,且主节点的hash slots 没有交叉<br>        2、主节点不能删除<br>        3、一个主节点可以有多个从节点<br>        4、主节点宕机时多个副本之间自动选举主节点<br>        从节点：<br>        1、从节点没有hash slots<br>        2、从节点可以删除<br>        3、从节点不负责数据的写,只负责数据的同步<br>    </font><br>  4）集群节点操作</p><ol><li>集群中添加一个主节点<br> 命令：<font color="red">启动一台 redis server</font><br> ../bin/redis-server 6386.conf</li></ol><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps73F2.tmp.jpg" alt></p><p><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsA786.tmp.jpg" alt><br><font color="red">将新启动的redis server加入到集群中</font><br>./redis-trib.rb add-node 192.168.128.133:6386 192.168.128.133:6381<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps524E.tmp.jpg" alt><br><font color="red">查看新加入集群的主节点信息</font><br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps9867.tmp.jpg" alt><br> 注意：<br>1、 该节点必须以集群模式启动<br>2、 默认情况下该节点就是以master节点形式添加，但是该节点没有hashslots。<br>2. 集群中添加一个从节点<br>     命令：<br>    <font color="red">启动一台redis server</font><br>    ../bin/redis-server 6387.conf<br>    <font color="red">将新启动的redis server加入到集群中</font><br>    ./redis-trib.rb add-node –slave 192.168.128.133:6387   192.168.128.133:6381<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8E6B.tmp.jpg" alt><br>     注意：<br>    当添加副本节点时没有指定主节点，redis会随机给副本节点较少的主节点添加当前从节点。<br>3. 为指定主节点添加从节点<br>    命令：<br>    ./redis-trib.rb add-node –slave –master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 192.168.128.133:6387 192.168.128.133:6381<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsAD88.tmp.jpg" alt><br>4. 删除从节点<br>    命令：<br>    ./redis-trib.rb del-node 192.168.128.133:6387 4c5744d8f6c784cd4589149a8ce5f49dd22b86c5<br>    <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps4F38.tmp.jpg" alt><br>5. 主节点从新分片（为新加入主节点重新分配哈希槽）<br>    命令：<br>     ./redis-trib.rb reshard 192.168.128.133:6381<br>     <img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wpsF676.tmp.jpg" alt><br>注意：<br>1、需指定移动哈希槽数量<br>2、需指定接收哈希槽主节点id<br>3、需指定源节点id，确定完成后，输入all或者done完成重新分片。</p><ol start="6"><li>Java程序操作redis集群<br> a) 测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> haoransun</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">jedisClusterTest</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *集群环境测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tetCluster</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> Hashset&lt;HostAndPort&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6381</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6382</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6383</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6384</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6385</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.16.128.133"</span>,<span class="number">6387</span>));</span><br><span class="line">        JedisCluster cluster = <span class="keyword">new</span> JedisCluster(set);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            cluster.set(<span class="string">"aa"</span>+i,<span class="string">"bb"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        String value = cluster.get(<span class="string">"aa66"</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 测试结果<br><img src="/2018/07/15/Redis%E5%AD%A6%E4%B9%A0/wps8967.tmp.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWK三剑客</title>
      <link href="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/"/>
      <url>/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">转载出处</a></p><h2 id="1-awk简介"><a href="#1-awk简介" class="headerlink" title="1 awk简介"></a>1 awk简介</h2><p><strong>awk</strong>其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。</p><p>awk 是一种很棒的语言，它适合<strong>文本处理和报表生成</strong>，其语法较为常见，借鉴了某些语言的一些精华，如 C 语言等。在 linux 系统日常处理工作中，发挥很重要的作用，掌握了 awk将会使你的工作变的高大上。</p><a id="more"></a><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2 使用方法"></a>2 使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;pattern + action&#125;&#39; &#123;filenames&#125;</span><br></pre></td></tr></table></figure><p>尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。</p><p>awk语言的最基本功能是<strong>在文件或者字符串中基于指定规则浏览和抽取信息</strong>，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p><p>通常，<strong>awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本</strong>。</p><h2 id="3-awk-的原理"><a href="#3-awk-的原理" class="headerlink" title="3 awk 的原理"></a>3 awk 的原理</h2><p>通过一个简短的命令，我们来了解其工作原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin</span><br><span class="line">.....................................................</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo hhh|awk &#39;&#123;print &quot;hello,world&quot;&#125;&#39;</span><br><span class="line">hello,world</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# awk &#39;&#123;print &quot;hiya&quot;&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">&#96;hiya&#96;</span><br><span class="line">...............................................</span><br></pre></td></tr></table></figure><p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p><p>所有输出都发送到 stdout，所得到的结果与执行 cat /etc/passwd 完全相同。</p><p>解释{ print }代码块。在 awk 中，花括号用于将几块代码组合到一起，这一点类似于 C 语言。在代码块中只有一条 print 命令。在 awk 中，如果只出现 print 命令，那么将打印当前行的全部内容。</p><p><strong><font color="red">再次说明， awk 对输入文件中的每一行都执行这个脚本。</font></strong></p><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126222420597-662074402.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print $1 &quot; &quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">$ awk -F &quot;:&quot; &#39;&#123; print &quot;username: &quot; $1 &quot;\t\tuid:&quot; $3 &#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>-F 参数：指定分隔符，可指定一个或多个</p><p>print 后面做字符串的拼接</p><h2 id="4-实战了解awk工作原理"><a href="#4-实战了解awk工作原理" class="headerlink" title="4 实战了解awk工作原理"></a>4 实战了解awk工作原理</h2><h3 id="4-1-实例一：只查看test-txt文件（100行）内第20到第30行的内容"><a href="#4-1-实例一：只查看test-txt文件（100行）内第20到第30行的内容" class="headerlink" title="4.1 实例一：只查看test.txt文件（100行）内第20到第30行的内容"></a>4.1 实例一：只查看test.txt文件（100行）内第20到第30行的内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;if (NR&gt;&#x3D;20 &amp;&amp; NR&lt;&#x3D;30) print $1&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/3c5bee5c-ab0c-4985-ac20-b4a6c0dcc752.png" alt></p><h3 id="4-2-实例二：已知test-txt文件内容为："><a href="#4-2-实例二：已知test-txt文件内容为：" class="headerlink" title="4.2 实例二：已知test.txt文件内容为："></a>4.2 实例二：已知test.txt文件内容为：</h3><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ae59ac8d-9292-48e9-b271-8f715ae6f106.png" alt></p><p>请从该文件中过滤出’Poe’字符串与xxxx，最后输出的结果为：Poe xxxx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F &#39;[ ,]+&#39; &#39;&#123;print $3 &quot; &quot; $7&#125;&#39; test.txt</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/27ee340d-594c-4956-8d2b-e68b4fdae633.png" alt></p><h2 id="5-BEGIN-和-END-模块"><a href="#5-BEGIN-和-END-模块" class="headerlink" title="5 BEGIN 和 END 模块"></a>5 BEGIN 和 END 模块</h2><p>通常，对于每个输入行， awk 都会执行每个脚本代码块一次。然而，在许多编程情况中，可能需要在 awk 开始处理输入文件中的文本之前执行初始化代码。对于这种情况， awk 允许定义一个 BEGIN 块。</p><p>因为 awk 在开始处理输入文件之前会执行 BEGIN 块，因此它是初始化 FS（字段分隔符）变量、打印页眉或初始化其它在程序中以后会引用的全局变量的极佳位置。</p><p>awk 还提供了另一个特殊块，叫作 END 块。 awk 在处理了输入文件中的所有行之后执行这个块。通常， END 块用于执行最终计算或打印应该出现在输出流结尾的摘要信息。</p><h3 id="5-1-实例一：统计-etc-passwd的账户人数"><a href="#5-1-实例一：统计-etc-passwd的账户人数" class="headerlink" title="5.1 实例一：统计/etc/passwd的账户人数"></a>5.1 实例一：统计/etc/passwd的账户人数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#123;count++;print $0;&#125; END&#123;print &quot;user count is &quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/41d660b8-756b-45f5-bd17-fba6f535aa99.png" alt></p><p>count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;count&#x3D;0;print &quot;[start] user count is &quot;,count&#125; &#123;count&#x3D;count+1;print $0&#125; END&#123;print &quot;[end] user count is&quot;,count&#125;&#39; &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a5855665-c30a-42a4-9d90-75c1eae79a7c.png" alt></p><h3 id="5-2实例二：统计某个文件夹下的文件占用的字节数"><a href="#5-2实例二：统计某个文件夹下的文件占用的字节数" class="headerlink" title="5.2实例二：统计某个文件夹下的文件占用的字节数"></a>5.2实例二：统计某个文件夹下的文件占用的字节数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/b3fd5eaa-5af4-4a4e-82c4-1456c99aec5e.png" alt></p><p>如果以M为单位显示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# ll | awk &#39;BEGIN&#123;size&#x3D;0;&#125;&#123;size&#x3D;size+$5;&#125;END&#123;print &quot;[end]size is &quot;,size&#x2F;1024&#x2F;1024,&quot;M&quot;&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/5ece48af-16b1-491a-b0e3-fc2e698a7242.png" alt></p><h2 id="6-awk运算符"><a href="#6-awk运算符" class="headerlink" title="6 awk运算符"></a>6 awk运算符</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126224150269-207487187.jpg" alt></p><h3 id="6-1-awk-赋值运算符"><a href="#6-1-awk-赋值运算符" class="headerlink" title="6.1 awk 赋值运算符"></a>6.1 awk 赋值运算符</h3><p>awk 赋值运算符：a+=5;等价于： a=a+5;其他同类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;5;a+&#x3D;5;print a&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/9e725b31-125a-4837-9e11-8d8d4806566f.png" alt></p><h3 id="6-2-awk逻辑运算符："><a href="#6-2-awk逻辑运算符：" class="headerlink" title="6.2 awk逻辑运算符："></a>6.2 awk逻辑运算符：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;1;b&#x3D;2;print(a&gt;2 &amp;&amp; b&gt;1,a&#x3D;1||b&gt;1)&#125;&#39;</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/ff0172a3-07e4-4b77-bcb6-23bb947fa0b6.png" alt></p><h3 id="6-3-awk正则运算符："><a href="#6-3-awk正则运算符：" class="headerlink" title="6.3 awk正则运算符："></a>6.3 awk正则运算符：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;;if(a~&#x2F;100&#x2F;)&#123;print &quot;ok&quot;&#125;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">[root@haoransun etc]# echo | awk &#39;BEGIN&#123;a&#x3D;&quot;100testaa&quot;&#125; a~&#x2F;test&#x2F;&#123;print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8c085f3b-6749-4097-a370-3c4a43cae515.png" alt></p><h3 id="6-4-关系运算符："><a href="#6-4-关系运算符：" class="headerlink" title="6.4 关系运算符："></a>6.4 关系运算符：</h3><p>如： &gt; &lt; 可以作为字符串比较，也可以用作数值比较，关键看操作数如果是字符串就会转换为字符串比较。两个都为数字 才转为数值比较。字符串比较：按照ascii码顺序比较。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;11&quot;;if(a&gt;&#x3D;9)&#123;print &quot;ok&quot;&#125;&#125;&#39; #无输出</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;11;if(a&gt;&#x3D;9)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a;if(a&gt;&#x3D;b)print &quot;ok&quot;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/11e24ac8-1bde-4456-9c4c-4453b2688bd4.png" alt></p><h3 id="6-5-awk-算术运算符："><a href="#6-5-awk-算术运算符：" class="headerlink" title="6.5 awk 算术运算符："></a>6.5 awk 算术运算符：</h3><p>所有用作算术运算符进行操作，操作数自动转为数值，所有非数值都变为0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a++,++a&#125;&#39;</span><br><span class="line">0 2</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++;++a&#125;&#39;</span><br><span class="line">20</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;20b4&quot;;print a++,++a&#125;&#39;</span><br><span class="line">20 22</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/8afa7f71-52cb-4fbf-a979-08e0e007d195.png" alt></p><h3 id="6-6-三目运算符"><a href="#6-6-三目运算符" class="headerlink" title="6.6 三目运算符 ?:"></a>6.6 三目运算符 ?:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;b&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line">[root@haoransun etc]# awk &#39;BEGIN&#123;a&#x3D;&quot;b&quot;;print a&#x3D;&#x3D;&quot;c&quot;?&quot;ok&quot;:&quot;err&quot;&#125;&#39;</span><br><span class="line">err</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e6da1f28-ff78-4933-8914-5c0b6fec6fd1.png" alt></p><h2 id="7-常用-awk-内置变量"><a href="#7-常用-awk-内置变量" class="headerlink" title="7 常用 awk 内置变量"></a>7 常用 awk 内置变量</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126225731300-1873454323.jpg" alt><br>注：内置变量很多，参阅相关资料</p><h3 id="7-1-字段分隔符-FS"><a href="#7-1-字段分隔符-FS" class="headerlink" title="7.1 字段分隔符 FS"></a>7.1 字段分隔符 FS</h3><p>FS=”\t+” 一个或多个 Tab 分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">ww CC IDD</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;\t+&quot;&#125;&#123;print $1,$2,$3&#125;&#39; test.txt </span><br><span class="line">ww CC IDD</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c865da77-e766-40ea-a7f4-6f2d8093013f.png" alt></p><p>FS=[[:space:]+] 一个或多个空白空格，默认的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [[:space:]+] &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1cec6d3e-d39a-4173-bb21-4b54f51e73fe.png" alt></p><p>FS=[“ “:]+ 以一个或多个空格或：分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">we are studing awk now!</span><br><span class="line">[root@haoransun demo]# awk -F [&quot; &quot;:]+ &#39;&#123;print $1,$2,$3,$4,$5&#125;&#39; test.txt </span><br><span class="line">we are studing awk now!</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/d833df93-0259-4fa9-9069-dcc9f9393bd7.png" alt></p><p>字段数量 NF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat test.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk -F &quot;:&quot; &#39;NF&#x3D;&#x3D;8&#123;print $0&#125;&#39; test.txt </span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/393eb9b6-011c-475e-b90a-97ee7bbb7256.png" alt></p><p>记录数量 NR</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk -F [&quot; &quot;:]+ &#39;NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br><span class="line"></span><br><span class="line">## NR&#x3D;&#x3D;2即是取第二行数据</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/32a25c64-0e99-40f1-a668-3f8c77937b5d.png" alt></p><p>RS 记录分隔符变量</p><p>将 FS 设置成”\n”告诉 awk 每个字段都占据一行。通过将 RS 设置成””，还会告诉 awk每个地址记录都由空白行分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p>ps:** 凡是被#!注释的，统统是加载器(解释器)的路径。#!/bin/awk :指定使用此程序来运行本文件。**</p><p>OFS 输出字段分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat hello.txt </span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">bin:x:1:1:bin:&#x2F;bin:&#x2F;sbin&#x2F;nologin:888</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;&#125;&#123;print $1&quot;,&quot;$2&quot;,&quot;$3&#125;&#39; hello.txt </span><br><span class="line">root,x,0</span><br><span class="line">bin,x,1</span><br><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;FS&#x3D;&quot;:&quot;;OFS&#x3D;&quot;#&quot;&#125;&#123;print $1,$2,$3&#125;&#39; hello.txt </span><br><span class="line">root#x#0</span><br><span class="line">bin#x#1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c1f049a7-edea-4bb8-b786-356de8bbd561.png" alt></p><p>ORS 输出记录分隔符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# cat recode.txt </span><br><span class="line">Jimy the Weasel</span><br><span class="line">100 Pleasant Driver</span><br><span class="line">San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony</span><br><span class="line">200 Incognito Ave.</span><br><span class="line">Suburia,WA 64890</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# cat awk.txt </span><br><span class="line">#!&#x2F;bin&#x2F;awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    FS&#x3D;&quot;\n&quot;</span><br><span class="line">    RS&#x3D;&quot;&quot;</span><br><span class="line">    ORS&#x3D;&quot;\n\n&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    print $1&quot;,&quot;$2&quot;,&quot;$3</span><br><span class="line">&#125;</span><br><span class="line">[root@haoransun demo]# awk -f awk.txt recode.txt </span><br><span class="line">Jimy the Weasel,100 Pleasant Driver,San Francisco,CA 123456</span><br><span class="line"></span><br><span class="line">Big Tony,200 Incognito Ave.,Suburia,WA 64890</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/c4e9909e-c851-448d-affe-8d5acfd9ad66.png" alt></p><h2 id="8-awk正则"><a href="#8-awk正则" class="headerlink" title="8 awk正则"></a>8 awk正则</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126232437800-1355193233.jpg" alt></p><h3 id="8-1-正则应用"><a href="#8-1-正则应用" class="headerlink" title="8.1  正则应用"></a>8.1  正则应用</h3><p>规则表达式<br>awk ‘/REG/{action} ‘ file,/REG/为正则表达式，可以将$0 中，满足条件的记录送入到：action 进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd  ##匹配所有包含root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">operator:x:11:0:operator:&#x2F;root:&#x2F;sbin&#x2F;nologin</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# awk -F: &#39;$5~&#x2F;root&#x2F;&#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd ## 以冒号作为分隔符，匹配第5个字段是root的行</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">[root@haoransun demo]# ip addr | grep ens33 |awk &#39;BEGIN&#123;FS&#x3D;&quot;[[:space:]:]+&quot;&#125; NR&#x3D;&#x3D;2&#123;print $3&#125;&#39;</span><br><span class="line">192.168.121.100&#x2F;24</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/460ee8cf-76ae-41ce-8448-c212c858c5a9.png" alt></p><p>布尔表达式<br>awk ‘布尔表达式{action}’ file 仅当对前面的布尔表达式求值为真时， awk 才执行代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk -F : &#39;$1&#x3D;&#x3D;&quot;root&quot; &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br><span class="line">[root@haoransun demo]#</span><br><span class="line">[root@haoransun demo]# awk -F : &#39;($1&#x3D;&#x3D;&quot;root&quot;)&amp;&amp;($5&#x3D;&#x3D;&quot;root&quot;) &#123;print $0&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/53f21771-aef3-4683-a415-1839a4939df3.png" alt></p><h2 id="9-awk-的-if、循环和数组"><a href="#9-awk-的-if、循环和数组" class="headerlink" title="9 awk 的 if、循环和数组"></a>9 awk 的 if、循环和数组</h2><h3 id="9-1-条件语句"><a href="#9-1-条件语句" class="headerlink" title="9.1 条件语句"></a>9.1 条件语句</h3><p>awk 提供了非常好的类似于 C 语言的 if 语句。<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/cb35a7a2-c225-4d92-ad58-5f7d7dc977a0.png" alt></p><p>使用 if 语句还可以将代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">! &#x2F;matchme&#x2F; &#123;print $1 $3 $4&#125;</span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    if($0 !~ &#x2F;matchme&#x2F; )&#123;</span><br><span class="line">        print $1 $3 $4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-2-循环结构"><a href="#9-2-循环结构" class="headerlink" title="9.2 循环结构"></a>9.2 循环结构</h3><p>我们已经看到了 awk 的 while 循环结构，它等同于相应的 C 语言 while 循环。 awk 还有”do…while”循环，它在代码块结尾处对条件求值，而不像标准 while 循环那样在开始处求值。</p><p>它类似于其它语言中的”repeat…until”循环。以下是一个示例：<br>do…while 示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    count &#x3D; do&#123;</span><br><span class="line">        print &quot;xxxxx&quot;</span><br><span class="line">    &#125;while(count !&#x3D;1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-for-循环"><a href="#9-3-for-循环" class="headerlink" title="9.3 for 循环"></a>9.3 for 循环</h3><p>awk 允许创建 for 循环，它就象 while 循环，也等同于 C 语言的 for 循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (initial assignment; comparation; increment)&#123;</span><br><span class="line">    code block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(x&#x3D;1;x&lt;&#x3D;4;x++)&#123;</span><br><span class="line">    print &quot;iteration&quot;,x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iteration1</span><br><span class="line">iteration2</span><br><span class="line">iteration3</span><br><span class="line">iteration4</span><br></pre></td></tr></table></figure><h3 id="9-4-break-和-continue"><a href="#9-4-break-和-continue" class="headerlink" title="9.4 break 和 continue"></a>9.4 break 和 continue</h3><p>此外，如同 C 语言一样， awk 提供了 break 和 continue 语句。使用这些语句可以更好地控制 awk 的循环结构。以下是迫切需要 break 语句的代码片断：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/a425efad-8bdf-4bf8-8379-cfd3cb2f6930.png" alt></p><p>以下只执行10次<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e1f4652e-1c8c-4031-8fa5-19a84853429c.png" alt></p><p>这里， break 语句用于“逃出”最深层的循环。 “break”使循环立即终止，并继续执行循环代码块后面的语句。<br>continue 语句补充了 break，其作用如下：<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/e5cd9ad0-3212-4d52-8c60-ad07febf338b.png" alt></p><h3 id="9-5-数组"><a href="#9-5-数组" class="headerlink" title="9.5 数组"></a>9.5 数组</h3><p>AWK 中的数组都是关联数组,数字索引也会转变为字符串索引<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/06c347db-0e28-45cc-a3f6-a51ce62523bd.png" alt><br>for…in 输出，因为数组是关联数组，默认是无序的。所以通过 for…in 得到是无序的数组。如果需要得到有序数组，需要通过下标获得。</p><h3 id="9-6-数组的典型应用"><a href="#9-6-数组的典型应用" class="headerlink" title="9.6 数组的典型应用"></a>9.6 数组的典型应用</h3><p>用 awk 中查看服务器连接状态并汇总</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# netstat -an|awk &#39;&#x2F;^tcp&#x2F;&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;&#39;</span><br><span class="line">LISTEN 4</span><br><span class="line">ESTABLISHED 1</span><br></pre></td></tr></table></figure><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/2c9f17b2-4bf8-4fcc-8ff8-49b6a160c7c0.png" alt></p><p>统计 web 日志访问流量，要求输出访问次数，请求页面或图片，每个请求的总大小，总访问流量的大小汇总<br><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/065c3870-c2e8-4acc-9596-35d91ae183d1.png" alt></p><h2 id="10-常用字符串函数"><a href="#10-常用字符串函数" class="headerlink" title="10 常用字符串函数"></a>10 常用字符串函数</h2><p><img src="/2018/07/15/AWK%E4%B8%89%E5%89%91%E5%AE%A2/1089507-20170126235509019-257728577.jpg" alt></p><h3 id="10-1-字符串函数的应用"><a href="#10-1-字符串函数的应用" class="headerlink" title="10.1 字符串函数的应用"></a>10.1 字符串函数的应用</h3><p>替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;gsub(&#x2F;[0-9]+&#x2F;,&quot;!&quot;,info);print info&#125;&#39;</span><br><span class="line">this is a test!test!</span><br><span class="line"></span><br><span class="line">在info中查找满足正则表达式， &#x2F;[0-9]+&#x2F; 用 “！”替换，并且赋值给 info值，默认是$0</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print index(info,&quot;test&quot;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>匹配查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print match(info,&#x2F;[0-9]+&#x2F;)?&quot;ok&quot;:&quot;no found&quot;;&#125;&#39;</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">如果查找到数字匹配成功返回 ok</span><br></pre></td></tr></table></figure><p>截取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test2010test!&quot;;print substr(info,4,10);&#125;&#39;</span><br><span class="line">s is a tes</span><br><span class="line">从第4个字符开始，截取10个长度字符串。</span><br></pre></td></tr></table></figure><p>分割</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@haoransun demo]# awk &#39;BEGIN&#123;info&#x3D;&quot;this is a test&quot;;split(info,tA,&quot; &quot;);print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;&#39;</span><br><span class="line">4</span><br><span class="line">4 test</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">分割 info,动态创建数组tA,awk for ...循环 是一个无序的循环，并不是从数组下表1...n开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql安装</title>
      <link href="/2018/06/20/MySql%E5%AE%89%E8%A3%85/"/>
      <url>/2018/06/20/MySql%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-第一种方式"><a href="#1-第一种方式" class="headerlink" title="1 第一种方式"></a>1 第一种方式</h1><p>linux设置动态ip连接外网  yum=centos独有的指令，自动安装所有依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mysql-server mysql mysql-deve</span><br></pre></td></tr></table></figure><h1 id="2-第二种方式"><a href="#2-第二种方式" class="headerlink" title="2 第二种方式"></a>2 第二种方式</h1><p>rpm安装，需要持有rmp文件，见目录：附件</p><p><font color="red">安装过程：</font><br>2.1 将rpm复制到linux的 /x/xx中<br>rpm -ivh perl*<br>rpm -Uvh mysql-libs-5.1.73-7.el6.x86_64.rpm<br>rpm -ivh mysql-5.1.73-7.el6.x86_64.rpm mysql-server-5.1.73-7.el6.x86_64.rpm</p><p>安装mysql的主服务</p><a id="more"></a><h1 id="3-第三种方式"><a href="#3-第三种方式" class="headerlink" title="3 第三种方式"></a>3 第三种方式</h1><p>使用虚拟机克隆：打开提供好的克隆虚拟机即可。其中已经安装好所有依赖，可直接使用。</p><hr><h1 id="4-MySQL-初始化"><a href="#4-MySQL-初始化" class="headerlink" title="4 MySQL 初始化"></a>4 MySQL 初始化</h1><h2 id="4-1-MySQL启动：service-mysqld-start"><a href="#4-1-MySQL启动：service-mysqld-start" class="headerlink" title="4.1 MySQL启动：service mysqld start"></a>4.1 MySQL启动：service mysqld start</h2><h2 id="4-2-MySQL远程连接：Navicat软件（见soft文件夹）"><a href="#4-2-MySQL远程连接：Navicat软件（见soft文件夹）" class="headerlink" title="4.2 MySQL远程连接：Navicat软件（见soft文件夹）"></a>4.2 MySQL远程连接：Navicat软件（见soft文件夹）</h2><p>默认只允许localhost mysql―server</p><p>无法远程连接mysql，解决方案：</p><p>5.1 mysql -u root -p 打开mysql客户端    默认打开主机为 localhsot<br>或者：<br> mysql -u root -h ‘192.168.1.68’ -p  打开主机为 192.168.1.68</p><p> 5.2 use mysql 选择库：mysql<br> 5.3 将库mysql中的user表中的数据除了host为127.0.0.1的其他数据删除<br> 5.4 将user表中的host改为”%”<br> 5.5 flush privileges  //刷新权限<br> 5.6 关闭linux的防火墙</p><h1 id="5-为mysql的root用于分配登陆密码："><a href="#5-为mysql的root用于分配登陆密码：" class="headerlink" title="5 为mysql的root用于分配登陆密码："></a>5 为mysql的root用于分配登陆密码：</h1><p>mysql&gt;SET PASSWORD FOR ‘root’@’localhost’ = PASSWORD(‘123’);</p><p>如下命令，在初次开启mysql服务后，会提示给用户：<br>   [root@haoransun mysql_rpm]# mysqladmin -u root password ‘123’;<br>   如果已经有密码存在，要修改的话：<br>   [root@haoransun mysql_rpm]# mysqladmin -u root -p password ‘123’; 之后输入旧密码即可</p><h1 id="6-MySQL-操作"><a href="#6-MySQL-操作" class="headerlink" title="6 MySQL 操作"></a>6 MySQL 操作</h1><h2 id="6-1-客户端访问"><a href="#6-1-客户端访问" class="headerlink" title="6.1 客户端访问"></a>6.1 客户端访问</h2><p>mysql -u root -p 回车 输入密码回车 即可<br>  7.2 数据库查看：show databases;<br>  7.3 数据库选择：use xx;</p><h2 id="6-2-乱码解决："><a href="#6-2-乱码解决：" class="headerlink" title="6.2 乱码解决："></a>6.2 乱码解决：</h2><p>  8.1 建库时指定utf-8<br>  8.2 url中指定urt-8</p><h2 id="6-3-找到-etc-my-cnf-在此文件中添加如下"><a href="#6-3-找到-etc-my-cnf-在此文件中添加如下" class="headerlink" title="6.3 找到 /etc/my.cnf 在此文件中添加如下"></a>6.3 找到 /etc/my.cnf 在此文件中添加如下</h2><p>[client]<br>default-character-set=utf8<br>防止命令行乱码，此配置仅作用于用命令行操作数据时的乱码解决。<br>常规的应用运行乱码解决和此无关。</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java定时任务</title>
      <link href="/2018/05/13/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/05/13/Java%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>Author: haoranSun<br>Wechat: SHR—97</p><h3 id="一、什么是定时任务："><a href="#一、什么是定时任务：" class="headerlink" title="一、什么是定时任务："></a>一、什么是定时任务：</h3><blockquote><p>定时任务是指调度程序在指定的时间或周期触发执行的任务<br>使用场景：发送邮件、统计、状态修改、消息推送、活动开启、增量索引</p></blockquote><a id="more"></a><h3 id="二、定时任务实现技术："><a href="#二、定时任务实现技术：" class="headerlink" title="二、定时任务实现技术："></a>二、定时任务实现技术：</h3><ol><li><strong>Java自带的java.util.Time类，这个类允许你调度一个java.util.TimerTask任务。使用这种方法可以让你的程序按照某一个频度执行，但不能在指定时间运行。使用较少。</strong></li><li><strong>Spring3.0以后自主开发的定时任务工具Spring task，使用简单，支持线程池，可以高效处理许多不同的定时任务，除Spring相关的包外不需要额外的包，支持注解和配置文件两种形式。不能处理过于复杂的任务。</strong></li><li><strong>专业的定时任务框架Quartz，功能强大，可以让你的程序在指定时间执行，也可以按照某一个频度执行，支持数据库、监听器、插件、集群。</strong></li></ol><h3 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h3><p><strong>* 1. Timer单线程*</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * java timer  测试类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTimer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//  创建定时器</span></span><br><span class="line">          Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//  添加调度任务</span></span><br><span class="line">          <span class="comment">//  安排指定的任务在指定的时间开始进行重复的 固定延迟执行</span></span><br><span class="line">          timer.schedule(<span class="keyword">new</span> MyTask(),<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).parse(<span class="string">"2017-06-24 22:31:10"</span>),<span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">          <span class="comment">//  安排指定的任务在指定的延迟后开始进行重复的 固定速率执行</span></span><br><span class="line">          <span class="comment">//timer.scheduleAtFixedRate(new MyTask(),new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2017-06-24 22:31:10"),10*1000);</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  定义调度任务</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"log2:"</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>* 2. Spring Task4个标签+1个注解*</strong></p><ul><li>基于配置<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Spring Task  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTask</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m1:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-task.xml 配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springTask"</span> <span class="attr">class</span>=<span class="string">"com.haoran.task.SpringTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注册调度任务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 延迟 8 秒 执行任务 --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;task:scheduled ref="springTask" method="m1" fixed-delay="8000" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 固定速度 5 秒 执行任务 --&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--&lt;task:scheduled ref="springTask" method="m2" fixed-rate="5000"/&gt;--&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">           使用 cron 表达式 指定触发时间</span></span><br><span class="line"><span class="comment">           spring task  只支持 6 位的 cron 表达式 秒 分 时 日 月 星期</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"springTask"</span> <span class="attr">method</span>=<span class="string">"m3"</span> <span class="attr">cron</span>=<span class="string">"50-59 * * ? * *"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 执行器配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"threadPoolTaskExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> <span class="attr">keep-alive</span>=<span class="string">"5"</span>&gt;</span><span class="tag">&lt;/<span class="name">task:executor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">&lt;!-- 调度器配置 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"threadPoolTaskScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">task:scheduler</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基于注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Spring Task  任务类</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/24.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAnnotationTask</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH: mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* @Scheduled(fixedDelay = 8000)</span></span><br><span class="line"><span class="comment">       public void m1()&#123;</span></span><br><span class="line"><span class="comment">            System.out.println("m1:"+simpleDateFormat.format(new Date()));</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       @Scheduled(fixedRateString = "5000")</span></span><br><span class="line"><span class="comment">       public void m2()&#123;</span></span><br><span class="line"><span class="comment">            System.out.println("m2:"+simpleDateFormat.format(new Date()));</span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="meta">@Scheduled</span>(cron = <span class="string">"0-30 * * * * ?"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"m2:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启基于注解的 spring task--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">task:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"springAnnotationTask"</span> <span class="attr">class</span>=<span class="string">"com.haoranSun.task.SpringAnnotationTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>* 3. Quartz*</strong></p><ul><li><p>下载 <a href="http://www.quartz-scheduler.org/downloads/" target="_blank" rel="noopener">http://www.quartz-scheduler.org/downloads/</a></p></li><li><p>导入lib或者Maven依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.quartz-scheduler&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;quartz-jobs&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>核心接口<br>a. Scheduler 调度器<br>b. Job 任务<br>c. Trigger 触发器<br>d. JobDetail 任务信息</p></li><li><p>Trigger触发器<br>a. SimpleTrigger // 功能简单 指定时间、周期<br>b. CronTrigger   // 基于cron表达式触发器</p><blockquote><p>cron表达式：秒 分 时 日 月 周 年</p></blockquote></li><li><p>简单入门</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.  创建调度器工厂</span></span><br><span class="line">            SchedulerFactory schedulerFactory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.  获取调度器</span></span><br><span class="line">            Scheduler scheduler = schedulerFactory.getScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3.  创建任务详情</span></span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.  启动 10 秒后的时间</span></span><br><span class="line">            Date futureDate = DateBuilder.futureDate(<span class="number">10</span>, DateBuilder.IntervalUnit.SECOND);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.  创建触发器</span></span><br><span class="line">            Trigger trigger =</span><br><span class="line">TriggerBuilder.newTrigger().withIdentity(<span class="string">"myTrigger"</span>,<span class="string">"default"</span>).startAt(futureDate).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.  注册任务详情和触发器</span></span><br><span class="line">            scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//7.  启动调度任务</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"log:"</span>+simpleDateFormat.format(<span class="keyword">new</span> Date()));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于simpleSchedule的定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  简单触发器 调度程序</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25 .</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTriggerScheduler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">           Scheduler scheduler = factory.getScheduler();</span><br><span class="line"></span><br><span class="line">           JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").build();</span><br><span class="line">           <span class="comment">//  指定触发器</span></span><br><span class="line">           <span class="comment">// lucene  唐诗</span></span><br><span class="line">           <span class="comment">// 1.  获取数据库每天新增的诗</span></span><br><span class="line">           <span class="comment">// 2.  定时任务 每天零点触发</span></span><br><span class="line">           <span class="comment">// 3.  任务方法 增量索引</span></span><br><span class="line">           <span class="comment">//  简单定时 SimpleTrigger 间隔或者重复调用</span></span><br><span class="line">           Trigger trigger = TriggerBuilder.newTrigger().withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">10</span>).withRepeatCount(<span class="number">10</span>)).build();</span><br><span class="line"></span><br><span class="line">           scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">           scheduler.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于CronSchedule的定时任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  基于 CronTrigger</span></span><br><span class="line"><span class="comment">  * Created by haoranSun on 2017/6/25.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CronTriggerScheduler</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            StdSchedulerFactory factory = <span class="keyword">new</span> StdSchedulerFactory();</span><br><span class="line"></span><br><span class="line">            Scheduler scheduler = factory.getScheduler();</span><br><span class="line"></span><br><span class="line">            JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("myJob","default").</span><br><span class="line">usingJobData(<span class="string">"id"</span>,<span class="number">1</span>).usingJobData(<span class="string">"name"</span>,<span class="string">"zs"</span>).build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">              *  在 cron 表达式中 日和周中不能同时出现 *</span></span><br><span class="line"><span class="comment">              * quartz cron 表达式 6 位或者 7 位</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             Trigger trigger = TriggerBuilder.newTrigger().withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * ? * * 2017-2020"</span>)).</span><br><span class="line">withIdentity(<span class="string">"myTrigger"</span>,<span class="string">"default"</span>).build();</span><br><span class="line"></span><br><span class="line">             scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line"></span><br><span class="line">             scheduler.start();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Quartz和Spring集合</p><ul><li>依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-support&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring-version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>任务类继承QuartzJobBean或实现Job接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Created by  haoranSun on 2017/6/25 0025.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringQuartz</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:spring.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Spring.xml配置</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;User&quot;&gt;&lt;&#x2F;bean&gt;--&gt;</span><br><span class="line">&lt;!-- 创建 JobDetail--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">     &lt;!-- 指定任务类 --&gt;</span><br><span class="line">     &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;com.haoran.quartz4.MyJob&quot;&gt;      &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 指定 job 中 spring 工厂的名字 指定后 可以在 job 类中获取 spring 工厂 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;applicationContextJobDataKey&quot; value&#x3D;&quot;applicationContext&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;property name&#x3D;&quot;jobDataAsMap&quot;&gt;</span><br><span class="line">         &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;id&quot; value&#x3D;&quot;1&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;name&quot; value&#x3D;&quot;zhangsan&quot;&gt;&lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;!--&lt;entry key&#x3D;&quot;user&quot; value-ref&#x3D;&quot;user&quot;&gt;&lt;&#x2F;entry&gt;--&gt;</span><br><span class="line">         &lt;&#x2F;map&gt;</span><br><span class="line">      &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 当 Job 在没有可以使用的 trigger 的情况下 不删除 --&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;jobDetail1&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">       &lt;!-- 指定任务类 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;com.haoran.quartz4.MyJob1&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">       &lt;!-- 当 Job 在没有可以使用的 trigger 的情况下 不删除 --&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;durability&quot; value&#x3D;&quot;true&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">创建触发器</span><br><span class="line">    Simple</span><br><span class="line">    Cron</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注意 spring quartz 整合 一个 trigger 只可以绑定一个 JobDetail 一个 jobDetail 可以被多个 Trigger 所使用 --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;trigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">       &lt;!-- 绑定 JobDetail--&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">       &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;0-30 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--&lt;bean id&#x3D;&quot;&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;bean&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;trigger1&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 绑定 JobDetail--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;45-55 * * * * ?&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 注册 trigger--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;scheduler&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">           &lt;list&gt;</span><br><span class="line">              &lt;ref bean&#x3D;&quot;trigger&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">              &lt;ref bean&#x3D;&quot;trigger1&quot;&gt;&lt;&#x2F;ref&gt;</span><br><span class="line">           &lt;&#x2F;list&gt;</span><br><span class="line">       &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 定时任务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程瞎侃</title>
      <link href="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/"/>
      <url>/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/</url>
      
        <content type="html"><![CDATA[<p>文章出处：<a href="https://www.cnblogs.com/aoyeyuyan/p/5495219.html" target="_blank" rel="noopener">https://www.cnblogs.com/aoyeyuyan/p/5495219.html</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;那些年，空气中仿佛还能闻到汉唐盛世的余韵，因此决不允许自己的脸上有油光，时刻保持活力。然而，你一定称为那些“高深术语”感到过困惑。也许时至今日，你仍对他们一知半解。不过今天，讲以一种全新的高清视角进入奇妙的编程世界，领略涵涌在这些“高深术语”中活泼的底气，以及蹁跹于青萍之末的云水禅心。</p><a id="more"></a><h1 id="1-内聚"><a href="#1-内聚" class="headerlink" title="1 内聚"></a>1 内聚</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;内聚，通俗的来讲，就是自己的东西自己保管，自己的事情自己做。<br>&nbsp;&nbsp;&nbsp;&nbsp;经典理论告诉我们，程序的两大要素：一个是<strong>数据</strong>（data），一个是<strong>操作</strong>（opration）。而 PASCAL之父Nicklaus Wirth则进一步提出了<strong>“程序 = 数据结构 + 算法”</strong>的著名公式。虽然提法上有所差异，但是其根本内涵却是一致的，微妙的差别在于，<font color="red">“数据 + 操作”是微观的视域，</font> <font color="red">“数据结构 + 算法”则是中观的视域</font>。而在<strong>宏观的视域</strong>下，我认为<font color="red"><strong>“程序 = 对象 + 消息”</strong></font>。对象是什么？对象就是保管好自己的东西，做好自己的事情的程序模块——这就是内聚！传统的面向过程编程方法由于割裂了数据结构和算法，使得软件的内聚性普遍低迷，曾一度引发了软件危机。试想，大家都自己的东西不好好保管，自己的事情也不好好做，不引发危机才怪呢！当然，对象的内聚只是内聚的一个层次，在不同的尺度下其实都有内聚的要求，比如方法也要讲内聚，架构也要讲内聚。<br>&nbsp;&nbsp;&nbsp;&nbsp;《周易·彖传》中讲“乾道变化，各正性命，保合太和，乃利贞”，就是要求每一个个体因循着各自的禀赋而努力成就各自的品性，然后各自保全，彼此和合，最终达成宇宙的完满状态。《论语·宪问》中，子路问君子。子曰：“修己以敬。”曰：“如斯而已乎？”曰：“修己以安人”，更是明确的教导我们要不断提高自身的内聚性，最大限度地减少给他人造成的麻烦，从而达到安人、安百姓、安天下的目标。我想，成长的过程就是一个不断提升内聚的过程。“自己的东西自己保管，自己的事情自己做”，这些孩提时代的教诲，放到今天仍能让不少“大人”脸红不已。太多的人保管不好自己的“东西”，保管不好自己的身体，保管不好自己的婚姻，更保管不好自己如蛛丝般震颤飘荡的狂乱的心。至于做好自己的事情，则更是惘然，甚至很多人连自己的事情是什么都搞不清楚，因此浑浑噩噩，饱食终日。内聚，是一个值得我们好好反思的问题。</p><h1 id="2-依赖-耦合"><a href="#2-依赖-耦合" class="headerlink" title="2 依赖-耦合"></a>2 依赖-耦合</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在面向对象编程中，对象自身是内聚的，是保管好自己的数据，完成好自己的操作的，而对外界呈现出自己的状态和行为。但是，没有绝对的自力更生，对外开放也是必要的！一个对象，往往需要跟其他对象打交道，既包括获知其他对象的状态，也包括仰赖其他对象的行为，而一旦这样的事情发生时，我们便称该对象依赖于另一对象。只要两个对象之间存在一方依赖一方的关系，那么我们就称这两个对象之间存在耦合。 比如妈妈和baby，妈妈要随时关注baby的睡、醒、困、哭、尿等等状态，baby则要仰赖妈妈的喂奶、哄睡、换纸尿裤等行为，从程序的意义上说，二者互相依赖，因此也存在耦合。首先要说，耦合是必要的。我们来看以下这个实验。<br><strong>【王阳明与山中之花</strong>】<br>&nbsp;&nbsp;&nbsp;&nbsp;由于王阳明这个对象不依赖山花这个对象，又没有其他的方式来获知山花的盛开状态，所以他要么选择不说，要么瞎说，但不说编译是通不过，而瞎说作为王阳明来讲也是通不过的，所以这个系统是无法成立的。要想系统成立，必须要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> bool <span class="title">admireFlowers</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flower.IsBloomed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;无论这个山花对象是怎么来的，作为参数传入还是作为属性设置、还是在内部构造出来，总之，王阳明与山花之间发生了依赖，二者之间产生了耦合。 当然，这是一个很浅显的问题。有趣的是王阳明对此事的看法：“你未看花时，花与你同寂；你来看花，花于你则一时分明起来。可见心外无物！”王阳明讲的是对的！“心外无物”翻译技术语言是这样的：不存在耦合的两个对象必然拿不到对方的引用！</p><h1 id="3-耦合度-解耦合"><a href="#3-耦合度-解耦合" class="headerlink" title="3 耦合度-解耦合"></a>3 耦合度-解耦合</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;耦合的程度就是耦合度，也就是双方依赖的程度。上文所说的妈妈和baby就是强耦合。而你跟快递小哥之间则是弱耦合。一般来说耦合度过高并不是一件好事。就拿作为IT精英的你来说吧，上级随时敦促你的工作进度，新手频繁地需要你指导问题，隔三差五还需要参加酒局饭局，然后还要天天看领导的脸色、关注老婆的心情，然后你还要关注代码中的bug 、bug、bug，和需求的变化、变化、变化，都够焦头烂额了，还猝不及防的要关注眼睛、颈椎、前列腺和头发的状态，然后你再炒个股，这些加起来大概就是个强耦合了。从某种意义上来说，耦合天生就与自由为敌，无论是其他对象依赖于你，还是你依赖其他对象。比如有人嗜烟、酗酒，你有多依赖它们就有多不自由；比如有人家里生了七八个娃，还有年迈的父母、岳父母，他们有多依赖你，你就有多不自由。所以老子这样讲：“五音令人耳聋，五色令人目盲，驰骋狩猎令人心发狂，难得之货令人行妨。”卢梭也是不无悲凉的说“人生而自由，却又无往而不在枷锁中”。因此，要想自由，就必须要降低耦合，而这个过程就叫做解耦和。</p><h1 id="4-依赖倒置（Dependence-Inversion-Principle）"><a href="#4-依赖倒置（Dependence-Inversion-Principle）" class="headerlink" title="4 依赖倒置（Dependence Inversion Principle）"></a>4 依赖倒置（Dependence Inversion Principle）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;解耦合最重要的原则就是依赖倒置原则：<br><strong>高层模块不应该依赖底层模块，他们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;《资本论》中都曾阐释依赖倒转原则——在商品经济的萌芽时期，出现了物物交换。假设你要买一个IPhone，卖IPhone的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的APP来换他一头猪，他说换猪可以，但是得用一条金项链来换——所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了。</p><h1 id="5-控制反转（Inversion-Of-Control）"><a href="#5-控制反转（Inversion-Of-Control）" class="headerlink" title="5 控制反转（Inversion Of Control）"></a>5 控制反转（Inversion Of Control）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;控制反转跟依赖倒置是如出一辙的两个概念，当存在依赖倒置的时候往往也存在着控制反转。但是控制反转也有自己的独特内涵。<br>&nbsp;&nbsp;&nbsp;&nbsp;首先我们要区分两个角色，server 跟 Client，也就是服务方和客户方。提供服务端的一方称为服务方，请求服务的一方称为客户方。我们最熟悉的例子就是分布式应用的C/S架构，服务端和客户端。其实除此之外，C/S关系处处可见。比如在TCP/IP协议栈中，我们知道，每层协议为上一层提供服务，那么这里就是一个C/S关系。当我们使用开发框架时，开发框架就是作为服务方，而我们自己编写的业务应用就是客户方。当Client调用server时，这个叫做一般的控制；而当server调用Client时，就是我们所说的控制反转，同时我们也将这个调用称为“回调”。控制反转跟依赖倒置都是一种编程思想，依赖倒置着眼于调用的形式，而控制反转则着眼于程序流程的控制权。一般来说，程序的控制权属于server，而一旦控制权交到Client，就叫控制反转。比如你去下馆子，你是Client餐馆是server。你点菜，餐馆负责做菜，程序流程的控制权属于server；而如果你去自助餐厅，程序流程的控制权就转到Client了，也就是控制反转。<br><img src="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/81f9baa4235055faf8e17d371dd44774_r.jpg" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;控制反转的思想体现在诸多领域。比如事件的发布/ 订阅就是一种控制反转，GOF设计模式中也多处体现了控制反转，比如典型的模板方法模式等。而开发框架则是控制反转思想应用的集中体现。比如之前所举的ESFramework通信框架的例子，通信引擎回调用户自定义的消息处理器，这就是一个控制反转。以及ESFramework回调用户自定义的群组关系和好友关系，回调用户自定义的用户管理器以管理在线用户相关状态，回调用户自定义的登陆验证处理，等等不一而足。再比如与ESFramework一脉相承轻量级通信引擎StriveEnginetarget，通过回调用户自定义的通信协议来实现更加灵活的通信<br>&nbsp;&nbsp;&nbsp;&nbsp;由此我们也可以总结出开发框架与类库的区别：使用开发框架时，框架掌握程序流程的控制权，而使用类库时，则是应用程序掌握程序流程的控制权。或者说，使用框架时，程序的主循环位于框架中，而使用类库时，程序的主循环位于应用程序之中。框架会回调应用程序，而类库则不会回调应用程序。ESFramework和StriveEngine中最主要的对象都以engine来命名，我们也可以看出框架对于程序主循环的控制——它会为你把握方向、眼看前方、轻松驾驭！</p><h1 id="6-依赖注入（Dependency-Injection）"><a href="#6-依赖注入（Dependency-Injection）" class="headerlink" title="6 依赖注入（Dependency Injection）"></a>6 依赖注入（Dependency Injection）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;依赖注入与依赖倒置、控制反转的关系仍旧是一本万殊。依赖注入，就其广义而言，即是通过“注入”的方式，来获得依赖。我们知道，A对象依赖于B对象，等价于A对象内部存在对B对象的“调用”，而前提是A对象内部拿到了B对象的引用。B对象的引用的来源无非有以下几种：A对象内部创建（无论是作为字段还是作为临时变量）、构造器注入、属性注入、方法注入。后面三种方式统称为“依赖注入”，而第一种方式我也生造了一个名词，称为“依赖内生”，二者根本的差异即在于，我所依赖的对象的创建工作是否由我自己来完成。当然，这个是广义的依赖注入的概念，而我们一般不会这样来使用。我们通常使用的，是依赖注入的狭义的概念。不过，直接陈述其定义可能会过于诘屈聱牙，我们还是从具体的例子来看。<br><img src="/2018/04/18/Java%E7%BC%96%E7%A8%8B%E7%9E%8E%E4%BE%83/e3305283d36861d16c1985c8edf6b53c_hd.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;比如<font color="red">OMCS网络语音视频框架</font>，它实现了多媒体设备（麦克风、摄像头、桌面、电子白板）的采集、编码、网络传送、解码、播放（或显示）等相关的一整套流程，可以快速地开发出视频聊天系统、视频会议系统、远程医疗系统、远程教育系统、网络监控系统等等基于网络多媒体的应用系统。然而，OMCS直接支持的是通用的语音视频设备，而在某些系统中，需要使用网络摄像头或者特殊的视频采集卡作为视频源，或者其它的声音采集设备作为音频源，OMCS则提供了扩展接口——用户自己实现这个扩展的接口，然后以“依赖注入”的方式将对象实例注入到OMCS中，从而完成对音、视频设备的扩展。<br>&nbsp;&nbsp;&nbsp;&nbsp;“依赖注入”常常用于扩展，尤其是在开发框架的设计中。从某种意义上来说，任何开发框架，天生都是不完整的应用程序。因此，一个优秀的开发框架，不仅要让开发者能够重用这些久经考验的的卓越的解决方案，也要让开发者能够向框架中插入自定义的业务逻辑，从而灵活自由地适应特定的业务场景的需要——也就是说要具备良好的可扩展性。比如上面提到的OMCS网络语音视频框架可应用于音、视频聊天系统、视频会议系统、远程医疗系统、远程教育系统、网络监控系统等等基于网络多媒体的应用系统；以及ESFramework通信框架能够应用于即时通讯系统，大型多人在线游戏、在线网页游戏、文件传送系统、数据采集系统、分布式OA系统等任何需要分布式通信的软件系统中——这种良好的扩展性都与“依赖注入”的使用密不可分！</p><h1 id="7-面向接口编程"><a href="#7-面向接口编程" class="headerlink" title="7 面向接口编程"></a>7 面向接口编程</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;谈到最后，“面向接口编程”已经是呼之欲出。无论是依赖倒置、控制反转、还是依赖注入，都已经蕴含着“面向接口编程”的思想。面向接口，就意味着面向抽象。作为哲学范畴而言，规定性少称为抽象，规定性多称为具体。而接口，就是程序中的一种典型的“抽象”的形式。面向抽象，就意味着面向事物的本质规定性，摆脱感性杂多的牵绊，从而把握住“必然”——而这本身就意味着自由，因为自由就是对必然的认识。<br>&nbsp;&nbsp;&nbsp;&nbsp;也许以上的这段论述太过“哲学”，但是“一本之理”与“万殊之理”本身就“体用不二”——总结来看，依赖倒置、控制反转、依赖注入都围绕着“解耦和”的问题，而同时自始至终又都是“面向接口编程”的方法——因此，“面向接口编程”天生就是“解耦和”的好办法。由此也印证了从“抽象”到“自由”的这一段范畴的辩证衍化。<br>&nbsp;&nbsp;&nbsp;&nbsp;“面向对象”与“面向接口”并非两种不同的方法学，“面向接口”其实是“面向对象”的内在要求，是其一部分内涵的集中表述。我们对于理想软件的期待常被概括为“高内聚，低耦合”，这也是整个现代软件开发方法学所追求的目标。面向对象方法学作为现代软件开发方法学的代表，本身就蕴含着“高内聚，低耦合”的思想精髓，从这个意义上来说，“面向对象”这个表述更加侧重于“高内聚”，“面向接口”的表述则更加侧重于“低耦合”——不过是同一事物的不同侧面罢了。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim常用操作</title>
      <link href="/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/03/25/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><p><strong>Practice makes perfect</strong></p><h1 id="Vim-的前生今世"><a href="#Vim-的前生今世" class="headerlink" title="Vim 的前生今世"></a>Vim 的前生今世</h1><p>Vi 最初是由 Bill Joy 在 1976 年编码实现的。而 Vim (Vi IMproved) 则是改进的 Vi，由 Bram Moolenaar 在 1991 年开发并发布。Vi/Vim 是所有 Unix/Linux 操作系统默认配备的编辑器。因其强大的功能和高效的操作，Vi/Vim 也成为众多 Unix/Linux 用户、管理员必须掌握并熟练使用的编辑工具之一。尤其是在没有图形界面的情况下，更是离不开 Vi/Vim。Vi/Vim 命令非常多、用法极为灵活，掌握起来有一定的难度。本文为入门教程，关于 Vi/Vim 各种定制后的功能不在本文讨论范围之列。</p><a id="more"></a><h1 id="Vi和Vim"><a href="#Vi和Vim" class="headerlink" title="Vi和Vim"></a>Vi和Vim</h1><p>在 Linux 的世界中，绝大部分的配置文件都是以 ASCII 的<strong>纯文本</strong>形态存在，因此利用简单的文字编辑软件就能够修改！ 与微软 Windows 系统不同的是，如果你用惯了 Microsoft Word 的话，在 Linux 的文本模式下，会觉得文书编辑程序都没有窗口接口来的直观与方便，那么问题来了，干嘛还要学这个不是很友善和方便的vi编辑器呢？因为：</p><ul><li>跨平台无所不在。所有的 Unix 和 Linux 系统都会内建 vi 文本编辑器，其他的编辑器则不一定会有而且你无需担心到了其他平台需要学习新编辑器，除了Linux/Mac OS X外Windows系统也都可用。</li><li>很多个别软件的编辑接口都会主动调用 vi ；</li><li>可扩展性。你可以只用它来编辑配置文件，也可以将它当做你的开发平台。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计；</li><li>程序简单、功能强大、运行飞快</li></ul><h1 id="什么是Vim呢？"><a href="#什么是Vim呢？" class="headerlink" title="什么是Vim呢？"></a>什么是Vim呢？</h1><p>其实你可以将 vim 视作 vi 的进阶版本，vim 可以用颜色或底线等方式来显示一些特殊的信息。 举例来说，当你使用 vim 去编辑一个 C 程序语言的档案，或者是shell script程序时，vim 会依据档案的扩展名或者是档案内的开头信息， 判断该档案的内容而自动调用该程序的语法判断式，再以颜色来显示程序代码与一般信息。也就是说， 这个 vim 已经是个『程序编辑器』了！甚至一些 Linux 基础配置文件内的语法，都能用 vim 来检查！<br> 简单来说， vi 是老式的文本处理器，不过功能已经很齐全了，但是还是有可以进步的地方。vim 则可以说是程序开发者的『程序编辑器』了，就连 vim 的<a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">官网</a>也说 vim 是一个『程序开发工具』而不是文本处理软件。 因为 vim 里面加入了很多额外的功能，例如支持正规表示法的搜寻架构、多档案编辑、区块复制等等。</p><p><strong>学习 <a href="https://link.jianshu.com?t=http://www.vim.org/" target="_blank" rel="noopener">vim</a> 并且它可能会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用</strong>。</p><p><strong>提示</strong>：在 Linux 下，如果以 root 用户登录系统的话，通过 vi 命令打开的 Vim 编辑器往往只加载最基本的功能，像语法加亮着色的功能基本上没有。在 root 用户下使用 Vim 所有功能的技巧是用 vim 命令打开 Vim 编辑器。</p><h1 id="如何进入Vim"><a href="#如何进入Vim" class="headerlink" title="如何进入Vim?"></a>如何进入Vim?</h1><p>可以在终端（不明白什么是终端的，请自行谷歌命令行、终端、shell、bash了解）输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim [filename]</span><br></pre></td></tr></table></figure><p>其中<code>filename</code>是文件的路径。如果文件不存在，它将为你建立一个新文件。</p><h1 id="Vim的三种操作模式"><a href="#Vim的三种操作模式" class="headerlink" title="Vim的三种操作模式"></a>Vim的三种操作模式</h1><p>Vim编辑程序有三种操作模式，分别称为<strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>。</p><p><strong>编辑模式</strong>：用以执行命令，也称为Normal正常模式，也是进入Vim的缺省模式。进入Vim后会直接进入编辑模式(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来操作文本， 也可以使用『复制、剪切、粘贴』来处理文本数据，删除正文和插入新的正文。但是却是无法编辑文本内容的！</p><p><strong>插入模式</strong>：即 Insert 模式，用来输入文本，就像你用“记事本”一样。进入Vim后会直接进入编辑模式，要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。注意了！通常在 Linux 中，按下这些按键时，在画面的左下方会出现『 INSERT 或 REPLACE 』的字样，此时才可以进行编辑，可以输入字符。而如果要回到一般模式时， 则必须要按下『Esc』这个按键才可退出编辑模式。</p><p><strong>命令模式</strong>：用来执行冒号命令。在编辑模式下输入『 : / ? 』三个中的任何一个按钮，就可以将光标移动到最底下那一行。在这个模式当中，可以进行保存、查找、替换、显示行号、退出、配置Vim操作等等的动作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i → Insert 模式，按 ESC 回到 Normal 模式。</span><br><span class="line">x → 删当前光标所在的一个字符。</span><br><span class="line">dd → 删除当前行，并把删除的行存到剪贴板里。</span><br><span class="line">p → 粘贴剪贴板。</span><br><span class="line">:wq → 存盘 + 退出 (:w 存盘后可以跟文件名，:q 退出，:q!强制退出)</span><br><span class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。</span><br></pre></td></tr></table></figure><p><strong>推荐</strong>：<br>强例推荐使用hjkl键盘移动光标，但不必需，你也可以使用光标键 (←↓↑→)移动。<br>以 : 开始的命令你需要输入 <enter> 回车结束，例如我写成 :q 也就是说你要输入 :q然后回车。</enter></p><h1 id="编辑模式下命令"><a href="#编辑模式下命令" class="headerlink" title="编辑模式下命令"></a>编辑模式下命令</h1><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k或↑              上移</span><br><span class="line">j或↓               下移</span><br><span class="line">h或←            左移</span><br><span class="line">l或→             右移</span><br></pre></td></tr></table></figure><p>上面这４个键将光标位置每次移动一行或一个字符 。Vim还提供稍大范围移动光标的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f         在文件中前移一页（相当于 page down）</span><br><span class="line">ctrl+b        在文件中后移一页（相当于 page up）</span><br><span class="line">ctrl+d        屏幕向下移动半页</span><br><span class="line">ctrl+u        屏幕向上移动一页</span><br></pre></td></tr></table></figure><p>更大范围的移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*          当光标停留在一个单词上，* 键会在文件内搜索该单词，并跳转到下一处；</span><br><span class="line">#          当光标停留在一个单词上，# 在文件内搜索该单词，并跳转到上一处；</span><br><span class="line">(&#x2F;)        移动到 前&#x2F;后 句 的开始；</span><br><span class="line">&#123;&#x2F;&#125;        跳转到 当前&#x2F;下一个 段落 的开始。</span><br><span class="line">g_         到本行最后一个不是 blank 字符的位置。</span><br><span class="line">fa         到下一个为 a 的字符处，你也可以fs到下一个为s的字符。</span><br><span class="line">t,         到逗号前的第一个字符。逗号可以变成其它字符。</span><br><span class="line">3fa        在当前行查找第三个出现的 a。</span><br><span class="line">F&#x2F;T        和 f 和 t 一样，只不过是相反方向;</span><br></pre></td></tr></table></figure><p>在屏幕中找到需要的 一页 时，可以用下面的命令快速移动光标：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H                  将光标移到屏幕上的起始行（或最上行）</span><br><span class="line">M                  将光标移到屏幕中间</span><br><span class="line">L                  将光标移到屏幕最后一行</span><br><span class="line">G                  将光标定位到文件最后一行起始位置</span><br><span class="line">NG或Ngg            将光标定位到第 N 行的起始位置</span><br><span class="line">gg                 将光标定位到文件第一行起始位置</span><br><span class="line">N(ENTER)           光标下移N行</span><br></pre></td></tr></table></figure><p>同样需要注意字母的大小写。H 和 L 命令还可以加数字。如 2H 表示将光标移到屏幕的第２行，3L 表示将光标移到屏幕的倒数第3行。<br>当将光标移到所要的行是，行内移动 光标可以用下面的命令来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">w                右移光标到下一个字的开头；</span><br><span class="line">e                右移光标到一个字的末尾；</span><br><span class="line">b                左移光标到前一个字的开头；</span><br><span class="line">0                数字０，左移光标到本行的开始；</span><br><span class="line">$                右移光标，到本行的末尾；</span><br><span class="line">^                移动光标，到本行的第一个非空字符。</span><br><span class="line">+                光标移动到非空格符的下一行；</span><br><span class="line">-                光标移动到非空格符的上一行n；</span><br><span class="line">n                n表示数字，按下数字后按空格键，光标右移n个字符，会跨行移动。</span><br></pre></td></tr></table></figure><h2 id="查找。搜索匹配"><a href="#查找。搜索匹配" class="headerlink" title="查找。搜索匹配"></a>查找。搜索匹配</h2><p>和许多先进的编辑器一样，Vim 提供了强大的字符串搜索功能。要查找文件中指定字或短语出现的位置，可以用Vim直接进行搜索，而不必以手工方式进行。搜索方法是：键入字符 / ，后面跟以要搜索的字符串，然后按回车键。编辑程序执行正向搜索（即朝文件末尾方向），并在找到指定字符串后，将光标停到该字符串的开头；键入 n 命令可以继续执行搜索，找出这一字符串下次出现的位置。用字符 ? 取代 / ，可以实现反向搜索（朝文件开头方向）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;str1                正向搜索字符串 str1；</span><br><span class="line">n                    继续搜索，重复之前的查找，但是向上重复查找；</span><br><span class="line">N                    继续搜索，重复之前的查找，但是向下重复查找；</span><br><span class="line">?str2                反向搜索字符串 str2 。</span><br><span class="line">:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g   这个操作代表在n1与n2行之间查找word1并用word2来代替它</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;g     这个操作是从第一行到最后一行进行查找替换</span><br><span class="line">:1,$s&#x2F;word1&#x2F;word2&#x2F;gc    与上面一样只不过多了个确认confirm</span><br></pre></td></tr></table></figure><p>无论搜索方向如何，当到达文件末尾或开头时，搜索工作会循环到文件的另一端并继续执行。<br>Vim中执行搜索匹配最强大的地方是结合 正则表达式 来搜索，</p><h2 id="替换和删除"><a href="#替换和删除" class="headerlink" title="替换和删除"></a>替换和删除</h2><p>Vim常规的删除命令是 d、 x (前者删除 行 ，后者删除 字符 ),结合Vim的其他特性可以实现基础的删除功能。将光标定位于文件内指定位置后，可以用其他字符来替换光标所指向的字符，或从当前光标位置删除一个或多个字符或一行、多行。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rc                 用 c 替换光标所指向的当前字符；</span><br><span class="line">nrc                用 c 替换光标所指向的前 n 个字符；</span><br><span class="line">5rA                用 A 替换光标所指向的前 5 个字符；</span><br><span class="line">x                  删除光标所指向的当前字符；</span><br><span class="line">nx                 删除光标所指向的前 n 个字符；</span><br><span class="line">3x                 删除光标所指向的前 3 个字符；</span><br><span class="line">dw                 删除光标右侧的字；</span><br><span class="line">ndw                删除光标右侧的 n 个字；</span><br><span class="line">3dw                删除光标右侧的 3 个字；</span><br><span class="line">db                 删除光标左侧的字；</span><br><span class="line">ndb                删除光标左侧的 n 个字；</span><br><span class="line">5db                删除光标左侧的 5 个字；</span><br><span class="line">dd                 删除光标所在行，并去除空隙；</span><br><span class="line">ndd                删除（剪切） n 行内容，并去除空隙；</span><br><span class="line">3dd                删除（剪切） 3 行内容，并去除空隙；</span><br></pre></td></tr></table></figure><p>其他常用的删除命令有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d$                从当前光标起删除字符直到行的结束；</span><br><span class="line">d0                从当前光标起删除字符直到行的开始；</span><br><span class="line">J                 删除本行的回车符（CR），并和下一行合并。</span><br></pre></td></tr></table></figure><p>Vim常规的替换命令有 c 和 s ，结合Vim的其他特性可以实现基础的替换功能，不过替换命令执行以后，通常会由<strong>编辑模式</strong>进入<strong>插入模式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s                用输入的正文替换光标所指向的字符；</span><br><span class="line">S                删除当前行，并进入编辑模式；</span><br><span class="line">ns               用输入的正文替换光标右侧 n 个字符；</span><br><span class="line">nS               删除当前行在内的 n 行，并进入编辑模式；</span><br><span class="line">cw               用输入的正文替换光标右侧的字；</span><br><span class="line">cW               用输入的正文替换从光标到行尾的所有字符（同 c$ )；</span><br><span class="line">ncw              用输入的正文替换光标右侧的 n 个字；</span><br><span class="line">cb               用输入的正文替换光标左侧的字；</span><br><span class="line">ncb              用输入的正文替换光标左侧的 n 个字；</span><br><span class="line">cd               用输入的正文替换光标的所在行；</span><br><span class="line">ncd              用输入的正文替换光标下面的 n 行；</span><br><span class="line">c$               用输入的正文替换从光标开始到本行末尾的所有字符；</span><br><span class="line">c0               用输入的正文替换从本行开头到光标的所有字符。</span><br></pre></td></tr></table></figure><h2 id="临时显示行号"><a href="#临时显示行号" class="headerlink" title="临时显示行号"></a>临时显示行号</h2><p>如果只是临时显示vim的行号，只须按ESC键退出编辑内容模式，输入“：set number” / “:set nu”后按回车键，就可以显示行号了。行号显示只是暂时的，退出vim后再次打开vim就不显示行号了。</p><h2 id="永久显示行号"><a href="#永久显示行号" class="headerlink" title="永久显示行号"></a>永久显示行号</h2><p>果想让vim永久显示行号，则需要修改vim配置文件vimrc。whereis vimrc</p><p>如果没有此文件可以创建一个 vimrc<br>在打开的vimrc文件中最后一行输入：set number ，然后保存退出。再次用vim打开文件时，就会显示行号了。</p><h2 id="多区域选择"><a href="#多区域选择" class="headerlink" title="多区域选择"></a>多区域选择</h2><p>选中一个起始点后，按 ctrl+v 可以看到左下角出现 区块选择，然后点击上下左右选择即可。按下y即可剪切，按下p粘贴刚才剪切的内容.</p><p>在命令模式下输入 :files 可以列出目前这个vim开启到的所有档案。</p><h2 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h2><p>当我有一个档案非常的大，我查阅到后面的数据时，想要『对照』前面的数据， 是否需要使用 [ctrl]+f 与 [ctrl]+b (或 pageup, pagedown 功能键) 来跑前跑后查阅？</p><p>我有两个需要对照着看的档案，不想使用前面提到的多档案编辑功能；</p><p>在一般窗口接口下的编辑软件大多有『分割窗口』或者是『冻结窗口』的功能来将一个档案分割成多个窗口的展现， 那么 vim 能不能达到这个功能啊？可以啊！但是如何分割窗口并放入档案呢？ 很简单啊！在指令列模式输入『:sp {filename}』即可！那个 filename 可有可无， 如果想要在新窗口启动另一个档案，就加入档名，否则仅输入 :sp 时， 出现的则是同一个档案在两个窗口间！</p><p>还可以利用『[ctrl]+w+↑』及『[ctrl]+w+↓』 在两个窗口之间移动呢！这样的话，复制啊、查阅啊等等的，就变的很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">:sp [filename] </span><br><span class="line"></span><br><span class="line">开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新档案，否则表示两个窗口为同一个档案内容(同步显示)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ j  [ctrl]+w+↓</span><br><span class="line"></span><br><span class="line">按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ k  [ctrl]+w+↑</span><br><span class="line"></span><br><span class="line">同上，不过光标移动到上面的窗口。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[ctrl]+w+ q</span><br><span class="line"></span><br><span class="line">其实就是 :q 结束离开啦！ 举例来说，如果我想要结束下方的窗口，那么利用 [ctrl]+w+↓ 移动到下方窗口后，按下 :q 即可离开， 也可以按下 [ctrl]+w+q 啊！</span><br></pre></td></tr></table></figure><p><a href="https://link.jianshu.com/?t=http://blog.jobbole.com/86132/" target="_blank" rel="noopener">Vim 入门教程</a><br><a href="https://link.jianshu.com/?t=http://cn.linux.vbird.org/linux_basic/0310vi.php" target="_blank" rel="noopener">vim 程序编辑器</a><br><a href="https://www.jianshu.com/p/7678a7e6973e" target="_blank" rel="noopener">http://www.jianshu.com/p/7678a7e6973e</a><br><a href="https://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="noopener">http://www.jianshu.com/p/bcbe916f97e1</a><br><a href="https://link.jianshu.com/?t=http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">http://coolshell.cn/articles/5426.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时任务Crontab详解</title>
      <link href="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="noopener">文章出处</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Linux系统是由cron（crond）这个系统服务来控制的。Linux系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。</p><a id="more"></a><h1 id="一-crond简介"><a href="#一-crond简介" class="headerlink" title="一 crond简介"></a>一 crond简介</h1><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度</p><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>/etc/crontab文件包括下面几行：<br><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/e8696488-4891-4358-a0ed-22f305460374.png" alt></p><p>前 四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行 命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p><p>使用者权限文件：</p><p>/etc/cron.deny<br>说明：<br>该文件中所列用户不允许使用crontab命令</p><p>/etc/cron.allow<br>说明：<br>该文件中所列用户允许使用crontab命令</p><p>/var/spool/cron/<br>说明：<br>所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：</p><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><p>minute hour day month week command<br>其中：</p><p>minute： 表示分钟，可以是从0到59之间的任何整数。</p><p>hour：表示小时，可以是从0到23之间的任何整数。</p><p>day：表示日期，可以是从1到31之间的任何整数。</p><p>month：表示月份，可以是从1到12之间的任何整数。</p><p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p><p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p><p><img src="/2018/03/23/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1Crontab%E8%AF%A6%E8%A7%A3/513841-20160812102124078-171184924.png" alt></p><p>在以上各个字段中，还可以使用以下特殊字符：</p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><h1 id="二-crontab命令详解"><a href="#二-crontab命令详解" class="headerlink" title="二 crontab命令详解"></a>二 crontab命令详解</h1><h2 id="2-1-命令格式："><a href="#2-1-命令格式：" class="headerlink" title="2.1 命令格式："></a>2.1 命令格式：</h2><p>crontab [-u user] file</p><p>crontab [-u user] [ -e | -l | -r ]</p><h2 id="2-2-命令功能："><a href="#2-2-命令功能：" class="headerlink" title="2.2 命令功能："></a>2.2 命令功能：</h2><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p><h2 id="2-3-命令参数："><a href="#2-3-命令参数：" class="headerlink" title="2.3 命令参数："></a>2.3 命令参数：</h2><p>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</p><p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</p><p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</p><p>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</p><p>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</p><p>-i：在删除用户的crontab文件时给确认提示。</p><h2 id="2-4-常用方法："><a href="#2-4-常用方法：" class="headerlink" title="2.4 常用方法："></a>2.4 常用方法：</h2><h3 id="2-4-1-创建一个新的crontab文件"><a href="#2-4-1-创建一个新的crontab文件" class="headerlink" title="2.4.1 创建一个新的crontab文件"></a>2.4.1 创建一个新的crontab文件</h3><p>在 考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其 中加入这样一行：</p><p>EDITOR=vi; export EDITOR</p><p>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</user></user></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># (put your own initials here)echo the date to the console every</span><br><span class="line"></span><br><span class="line"># 15minutes between 6pm and 6am</span><br><span class="line"></span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo ‘date’ &gt; &#x2F;dev&#x2F;console</span><br></pre></td></tr></table></figure><p>保存并退出。确信前面5个域用空格分隔。</p><p>在 上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab davecron</span><br></pre></td></tr></table></figure><p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。</p><p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p><h3 id="2-4-2-列出crontab文件"><a href="#2-4-2-列出crontab文件" class="headerlink" title="2.4.2 列出crontab文件"></a>2.4.2 列出crontab文件</h3><p>为了列出crontab文件，可以用：</p><p>$ crontab -l</p><p>0,15,30,45,18-06 * * * /bin/echo <code>date</code> &gt; dev/tty1</p><p>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：</p><p>$ crontab -l &gt; $HOME/mycron</p><p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><h3 id="2-4-3-编辑crontab文件"><a href="#2-4-3-编辑crontab文件" class="headerlink" title="2.4.3 编辑crontab文件"></a>2.4.3 编辑crontab文件</h3><p>如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为：</p><p>$ crontab -e</p><p>可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p><p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line"></span><br><span class="line">30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name “core’ -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"></span><br><span class="line"># (crondave installed on Tue May 4 13:07:43 1999)</span><br><span class="line"></span><br><span class="line"># DT:ech the date to the console every 30 minites</span><br><span class="line"></span><br><span class="line">0,15,30,45 18-06 * * * &#x2F;bin&#x2F;echo &#96;date&#96; &gt; &#x2F;dev&#x2F;tty1</span><br><span class="line"></span><br><span class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span><br><span class="line"></span><br><span class="line">30 3 1,7,14,21,26 * * &#x2F;bin&#x2F;find -name “core’ -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><h3 id="2-4-4-删除crontab文件"><a href="#2-4-4-删除crontab文件" class="headerlink" title="2.4.4 删除crontab文件"></a>2.4.4 删除crontab文件</h3><p>要删除crontab文件，可以用：</p><p>$ crontab -r</p><h3 id="2-4-5-恢复丢失的crontab文件"><a href="#2-4-5-恢复丢失的crontab文件" class="headerlink" title="2.4.5 恢复丢失的crontab文件"></a>2.4.5 恢复丢失的crontab文件</h3><p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：</username></username></p><p>$ crontab <filename></filename></p><p>其中，<filename>是你在$ H O M E目录中副本的文件名。</filename></p><p>我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。</Ctrl-D></p><h1 id="三-使用实例"><a href="#三-使用实例" class="headerlink" title="三 使用实例"></a>三 使用实例</h1><p>实例1：每1分钟执行一次command<br>命令：</p><ul><li><ul><li><ul><li><ul><li><ul><li>command</li></ul></li></ul></li></ul></li></ul></li></ul><p>实例2：每小时的第3和第15分钟执行<br>命令：<br>3,15 * * * * command</p><p>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * * command</p><p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 */2 * * command</p><p>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<br>3,15 8-11 * * 1 command</p><p>实例6：每晚的21:30重启smb<br>命令：<br>30 21 * * * /etc/init.d/smb restart</p><p>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<br>45 4 1,10,22 * * /etc/init.d/smb restart</p><p>实例8：每周六、周日的1 : 10重启smb<br>命令：<br>10 1 * * 6,0 /etc/init.d/smb restart</p><p>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<br>0,30 18-23 * * * /etc/init.d/smb restart</p><p>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<br>0 23 * * 6 /etc/init.d/smb restart</p><p>实例11：每一小时重启smb<br>命令：</p><ul><li>*/1 * * * /etc/init.d/smb restart</li></ul><p>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：</p><ul><li>23-7/1 * * * /etc/init.d/smb restart</li></ul><p>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<br>0 11 4 * mon-wed /etc/init.d/smb restart</p><p>实例14：一月一号的4点重启smb<br>命令：<br>0 4 1 jan * /etc/init.d/smb restart</p><p>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<br>01 * * * * root run-parts /etc/cron.hourly<br>说明：<br>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p><h1 id="四-使用注意事项"><a href="#四-使用注意事项" class="headerlink" title="四 使用注意事项"></a>四 使用注意事项</h1><p>注意环境变量问题<br>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p><p>在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。</p><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><p>1）脚本中涉及文件路径时写全局路径；</p><p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line"></span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">export RUN_CONF&#x3D;&#x2F;home&#x2F;d139&#x2F;conf&#x2F;platform&#x2F;cbp&#x2F;cbp_jboss.conf</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;jboss-4.0.5&#x2F;bin&#x2F;run.sh -c mev &amp;</span><br></pre></td></tr></table></figure><p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><p>0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p><p>注意清理系统用户的邮件日志<br>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p><p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p><p>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p><p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p><p>系统级任务调度与用户级任务调度<br>系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。</p><p>其他注意事项<br>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p><p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用插件及乱码</title>
      <link href="/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/"/>
      <url>/2018/03/20/Linux%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="1-清空文件"><a href="#1-清空文件" class="headerlink" title="1. 清空文件"></a>1. 清空文件</h1><blockquote><p>filename 或者 : &gt; filename</p></blockquote><h1 id="2-configure-make-make-install"><a href="#2-configure-make-make-install" class="headerlink" title="2. ./configure make make install"></a>2. ./configure make make install</h1><ul><li><p>./configure 检测安装平台的目标特征的。如会检测是不是有CC或者GCC，并不是需要CC或者GCC，它是个shell脚本，生成Makefile,为下一步的编译做准备。</p><a id="more"></a></li><li><p>make 用来编译的，它从 Makefile读取指令，然后编译。</p></li><li><p>make install 用来安装。他也从 Makefile中读取指令，安装到指定的位置。</p></li></ul><h2 id="2-1-configure"><a href="#2-1-configure" class="headerlink" title="2.1 ./configure"></a>2.1 ./configure</h2><p>一般用来生成 Makefile，为下一步的编译做准备。</p><p>你可以通过在 configure 后加上参数来对安装进行控制，比如代码:</p><p>./configure –prefix=/usr<br>意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin)，资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。<br>同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><h2 id="2-2-make"><a href="#2-2-make" class="headerlink" title="2.2 make"></a>2.2 make</h2><p>make 的作用是开始进行源代码编译，</p><p>以及一些功能的提供，这些功能由他的 Makefile 设置文件提供相关的功能，比如 make install 一般表示进行安装，make uninstall 是卸载，不加参数就是默认的进行源代码编译。</p><p>如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行）。</p><p>make 是 Linux 开发套件里面自动化编译的一个控制程序，他通过借助 Makefile 里面编写的编译规范进行自动化的调用 gcc 、ld 以及运行某些需要的程序进行编译的程序。</p><p>一般情况下，他所使用的 Makefile ，由 configure 这个设置脚本根据给定的参数和系统环境生成。</p><h2 id="2-3-make-install"><a href="#2-3-make-install" class="headerlink" title="2.3 make install"></a>2.3 make install</h2><p>安装（当然有些软件需要先运行 make check 或 make test来进行一些测试），这一步一般需要你有 root 权限（sudo make install</p><h1 id="3-搜索安装包路径"><a href="#3-搜索安装包路径" class="headerlink" title="3. 搜索安装包路径"></a>3. 搜索安装包路径</h1><p>whereis 安装包<br>如：whereis vim<br>    whereis tree</p><h1 id="4-编辑器"><a href="#4-编辑器" class="headerlink" title="4. 编辑器"></a>4. 编辑器</h1><p>yum instsall vim</p><h1 id="5-树形目录"><a href="#5-树形目录" class="headerlink" title="5. 树形目录"></a>5. 树形目录</h1><p>yun install tree</p><h1 id="6-通用下载方式"><a href="#6-通用下载方式" class="headerlink" title="6. 通用下载方式"></a>6. 通用下载方式</h1><p>yum install wget</p><h1 id="7-上传下载下工具"><a href="#7-上传下载下工具" class="headerlink" title="7. 上传下载下工具"></a>7. 上传下载下工具</h1><p>yum install lrzsz</p><h1 id="8-CentOS6-中文乱码解决"><a href="#8-CentOS6-中文乱码解决" class="headerlink" title="8. CentOS6 中文乱码解决"></a>8. CentOS6 中文乱码解决</h1><h2 id="8-1-安装语言包"><a href="#8-1-安装语言包" class="headerlink" title="8.1 安装语言包"></a>8.1 安装语言包</h2><p>yum groupinstall chinese-support</p><h2 id="8-2-设置字符集"><a href="#8-2-设置字符集" class="headerlink" title="8.2 设置字符集"></a>8.2 设置字符集</h2><h3 id="8-2-1临时生效-好像不管用"><a href="#8-2-1临时生效-好像不管用" class="headerlink" title="8.2.1临时生效(好像不管用)"></a>8.2.1临时生效(好像不管用)</h3><p>export LANG=”zh_CN.UTF-8” ## 设置为中文<br>export LANG=”en-US.UTF-8” ## 设置为英文</p><h3 id="8-2-2永久生效"><a href="#8-2-2永久生效" class="headerlink" title="8.2.2永久生效"></a>8.2.2永久生效</h3><p>vi /etc/sysconfig/i18n(最好reboot下)<br>LANG =”zh_CN.UTF-8”</p><p>或者<br>vi /etc/profile配置文件，添加一行<br>export LANG=”zh_CN.UTF-8”<br>重新载入<br>./etc/profile</p><p>查看当前字符集<br>echo $LANG</p><h1 id="9-CentOS7中英文乱码解决"><a href="#9-CentOS7中英文乱码解决" class="headerlink" title="9. CentOS7中英文乱码解决"></a>9. CentOS7中英文乱码解决</h1><h2 id="9-1-安装中文库"><a href="#9-1-安装中文库" class="headerlink" title="9.1 安装中文库"></a>9.1 安装中文库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;fonts&quot;</span><br></pre></td></tr></table></figure><h2 id="9-2-检查是否有中文语言包"><a href="#9-2-检查是否有中文语言包" class="headerlink" title="9.2 检查是否有中文语言包"></a>9.2 检查是否有中文语言包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale -a</span><br></pre></td></tr></table></figure><h2 id="9-3-查看当前系统语言环境"><a href="#9-3-查看当前系统语言环境" class="headerlink" title="9.3 查看当前系统语言环境"></a>9.3 查看当前系统语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locale</span><br></pre></td></tr></table></figure><h2 id="9-4-修改本机语言环境"><a href="#9-4-修改本机语言环境" class="headerlink" title="9.4 修改本机语言环境"></a>9.4 修改本机语言环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">locale -a | grep &quot;zh_CN&quot;</span><br><span class="line"></span><br><span class="line">一个一个试。目前是 zh_CN有效果</span><br><span class="line"></span><br><span class="line">vim &#x2F;etc&#x2F;locale.conf</span><br><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">source &#x2F;etc&#x2F;locale.conf</span><br></pre></td></tr></table></figure><h2 id="9-5-重启系统"><a href="#9-5-重启系统" class="headerlink" title="9.5 重启系统"></a>9.5 重启系统</h2><p>个人电脑可以，公司还需谨慎。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装常用软件</title>
      <link href="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Author: haoransun<br>Wechat: SHR—97</p><h1 id="mysql国内镜像下载网址"><a href="#mysql国内镜像下载网址" class="headerlink" title="mysql国内镜像下载网址"></a>mysql国内镜像下载网址</h1><p><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><h1 id="开源镜像站点汇总"><a href="#开源镜像站点汇总" class="headerlink" title="开源镜像站点汇总"></a>开源镜像站点汇总</h1><p><a href="http://segmentfault.com/a/1190000000375848" target="_blank" rel="noopener">http://segmentfault.com/a/1190000000375848</a></p><p><a href="https://opsx.alibaba.com/mirror/search?q=mysq5.7&lang=zh-CN" target="_blank" rel="noopener">https://opsx.alibaba.com/mirror/search?q=mysq5.7&amp;lang=zh-CN</a></p><p><a href="http://mirrors.ustc.edu.cn/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/</a></p><h1 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h1><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">java包</a></p><h2 id="手动解压"><a href="#手动解压" class="headerlink" title="手动解压"></a>手动解压</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;geek&#x2F;</span><br><span class="line">make java</span><br><span class="line">[root@haoransun java]# wget https:&#x2F;&#x2F;download.oracle.com&#x2F;otn&#x2F;java&#x2F;jdk&#x2F;8u211-b12&#x2F;478a62b7d4e34b78b671c754eaaf38ab&#x2F;jdk-8u211-linux-x64.tar.gz</span><br><span class="line"></span><br><span class="line">此方式不推荐使用。</span><br><span class="line"></span><br><span class="line">或者直接将jar由 winSCP包传导至Linux指定目录</span><br><span class="line"></span><br><span class="line">配置环境变量</span><br><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line">将下列配置文件添加，保存退出(一定要去掉等号两边的空格)</span><br><span class="line"></span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;geek&#x2F;java&#x2F;jdk1.8.0</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin</span><br><span class="line">export CLASSPATH&#x3D;.$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib</span><br><span class="line">:wq</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line">java -version 或者 jps 验证即可</span><br></pre></td></tr></table></figure><p>wget 方式不推荐使用，会出现无法解压的情况，用wget命令直接下载的JDK，这是问题的根源。</p><p>去Oracle官网下载过jdk的童鞋应该都知道，下载之前需要同意Oracle的安装协议，不然不能下载，但是用wget的方式，默认是不同意，虽然能下载下来，但是下载下来的文件会有问题，所以在Linux上解压一直失败。</p><p>后来去官网下载好，然后传到服务器上，再解压就没有问题了。</p><hr><h2 id="yum-安装"><a href="#yum-安装" class="headerlink" title="yum 安装"></a>yum 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum search java | grep jdk</span><br><span class="line">yum install java-1.8.0-openjdk</span><br><span class="line">默认安装在 &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;</span><br><span class="line">配置环境变量及验证安装</span><br></pre></td></tr></table></figure><hr><h2 id="rpm-安装"><a href="#rpm-安装" class="headerlink" title="rpm 安装"></a>rpm 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh  指定安装包</span><br><span class="line">配置环境变量。验证安装</span><br></pre></td></tr></table></figure><h1 id="CentOS7-安装-MySQL5-7"><a href="#CentOS7-安装-MySQL5-7" class="headerlink" title="CentOS7 安装 MySQL5.7"></a>CentOS7 安装 MySQL5.7</h1><p>安装环境：CentOS7 64位 mini版，安装MySQL5.7</p><p>mysql-client和server的区别：<br><strong>本质上的区别是：server是执行一个crud操作，client是发送一个crud操作</strong></p><p>server是把sql语句翻译成对内存和文件的操作，也就是说，server是直接操作文件的。</p><p>而client是对数据库/表进行操作，不是直接对文件进行操作。</p><p>举个例子：<br>①client：我用一个Navicat去链接一个数据库，这个Navicat就是client。</p><p>②server：我有多个mysql服务实例，他们可以位于不同的端口（这句不重要），但是他们是挂载在了宿主机同一个目录下的（这句重要，对内存/文件进行操作了），而且数据共享（这句也不重要）。</p><p>小知识点：</p><p>①sql只是去知道server如何去操作数据。</p><p>②即使C/S在同一台机器上，他们也是通过网络通讯的。</p><h2 id="1-配置-YUM源"><a href="#1-配置-YUM源" class="headerlink" title="1. 配置 YUM源"></a>1. 配置 YUM源</h2><p>在<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">MySQL</a>官网中下载YUM源rpm安装包：<a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">http://dev.mysql.com/downloads/repo/yum/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">下载mysql源安装包</span><br><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">安装mysql源</span><br><span class="line">yum localinstall mysql57-community-release-el7-8.noarch.rpm</span><br></pre></td></tr></table></figure><p><strong><font color="red">由于某些原因，下载过慢，可以参考最上方的国内网址进行下载，</font>如下所示：</strong><br><a href="https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql57-community-el7/</a></p><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/060fa4bb-b320-4095-bd6c-aab5b5f1f232.png" alt></p><ul><li><strong>1</strong> 右键选择，复制链接地址，到Linux中  wget 链接地址，下载 xxx.rpm安装包<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/a7aa735c-9414-4e83-beae-d17b54ce252e.png" alt></li><li><strong>2</strong> sudo rpm -ivh 上述mysql安装包</li><li><strong>3</strong> 安装MySql sudo yum install mysql-server<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/adb53ba1-80e5-413e-8cf0-16cd3b40b621.png" alt></li></ul><p>看到上图所示，则表示安装成功。</p><h2 id="2-启动MySQL服务"><a href="#2-启动MySQL服务" class="headerlink" title="2. 启动MySQL服务"></a>2. 启动MySQL服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">systemctl status mysqld</span><br></pre></td></tr></table></figure><p>查看MySQL的启动状态<br><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/c8cbc2ec-f7aa-4adb-8729-3abbb7b9396b.png" alt></p><h2 id="3-开机启动"><a href="#3-开机启动" class="headerlink" title="3. 开机启动"></a>3. 开机启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><h2 id="4-修改root默认密码"><a href="#4-修改root默认密码" class="headerlink" title="4. 修改root默认密码"></a>4. 修改root默认密码</h2><p>mysql安装完成之后，在/var/log/mysqld.log文件中给root生成了一个默认密码。通过下面的方式找到root默认密码，然后登录mysql进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#39;temporary password&#39; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure><p><img src="/2018/03/19/Linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/5bbf95fd-6e34-40ef-a1c7-ad57bea532e0.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">mysql &gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;Sun@123456!&#39;;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;MyNewPass4!&#39;);</span><br></pre></td></tr></table></figure><p>注意：mysql5.7默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示ERROR 1819 (HY000): Your password does not satisfy the current policy requirements错误，如下图所示：</p><p>通过msyql环境变量可以查看密码策略的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;%password%&#39;;</span><br></pre></td></tr></table></figure><p> validate_password_policy：密码策略，默认为MEDIUM策略  validate_password_dictionary_file：密码策略文件，策略为STRONG才需要  validate_password_length：密码最少长度  validate_password_mixed_case_count：大小写字符长度，至少1个  validate_password_number_count ：数字至少1个  validate_password_special_char_count：特殊字符至少1个  _上述参数是默认策略MEDIUM的密码检查规则。</p><p>共有以下几种密码策略：</p><table><thead><tr><th>策略</th><th>检查规则</th></tr></thead><tbody><tr><td>0 or LOW</td><td>Length</td></tr><tr><td>1 or MEDIUM</td><td>Length; numeric, lowercase/uppercase, and special characters</td></tr><tr><td>2 or STRONG</td><td>Length; numeric, lowercase/uppercase, and special characters; dictionary file</td></tr><tr><td>MySQL官网密码策略详细说明：<a href="http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy</a></td><td></td></tr></tbody></table><h4 id="修改密码策略"><a href="#修改密码策略" class="headerlink" title="修改密码策略"></a>修改密码策略</h4><p>在/etc/my.cnf文件添加validate_password_policy配置，指定密码策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 选择0（LOW），1（MEDIUM），2（STRONG）其中一种，选择2需要提供密码字典文件</span><br><span class="line">validate_password_policy&#x3D;0</span><br></pre></td></tr></table></figure><p>如果不需要密码策略，添加my.cnf文件中添加如下配置禁用即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validate_password &#x3D; off</span><br></pre></td></tr></table></figure><p>重新启动mysql服务使配置生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h2 id="5-添加远程登录用户"><a href="#5-添加远程登录用户" class="headerlink" title="5. 添加远程登录用户"></a>5. 添加远程登录用户</h2><p>默认只允许root帐户在本地登录，如果要在其它机器上连接mysql，必须修改root允许远程连接，或者添加一个允许远程连接的帐户，为了安全起见，我添加一个新的帐户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;sunhaoran&#39;@&#39;%&#39; IDENTIFIED BY &#39;Sun@123456&#39; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure><h2 id="6-配置默认编码为-utf8"><a href="#6-配置默认编码为-utf8" class="headerlink" title="6. 配置默认编码为 utf8"></a>6. 配置默认编码为 utf8</h2><p>修改/etc/my.cnf配置文件，在[mysqld]下添加编码配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br></pre></td></tr></table></figure><p>重新启动mysql服务，查看<a href="http://lib.csdn.net/base/14" target="_blank" rel="noopener" title="MySQL知识库">数据库</a>默认编码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;character%&#39;;</span><br></pre></td></tr></table></figure><p><strong>默认配置文件路径：</strong>  配置文件：/etc/my.cnf  日志文件：/var/log//var/log/mysqld.log  服务启动脚本：/usr/lib/systemd/system/mysqld.service  socket文件：/var/run/mysqld/mysqld.pid</p><h3 id="mysql-基本操作"><a href="#mysql-基本操作" class="headerlink" title="mysql 基本操作"></a>mysql 基本操作</h3><h4 id="客户端访问"><a href="#客户端访问" class="headerlink" title="客户端访问"></a>客户端访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 回车</span><br><span class="line">输入密码回车即可</span><br><span class="line">数据库查看：show databases;</span><br><span class="line">数据库选择：use xx;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Host-Vm相互ping不同到的解决办法</title>
      <link href="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Author：haoransun<br>WeChat：SHR—97</p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天总结一下前段时间出现的一些虚拟机问题，之前配置的宿主机ping虚拟机以及虚拟机ping外网没有什么问题，但是后来不知道什么原因突然就ping不通了，经过网上各种找资料，研究了下VM0,1,8的区别，为了防止遗忘在此记录。</p><a id="more"></a><h2 id="两机互ping的问题"><a href="#两机互ping的问题" class="headerlink" title="两机互ping的问题"></a>两机互ping的问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VMnet0使用的是桥接模式，安装VM后默认的就是这种模式，这种模式一般是只需要一台虚拟机与宿主机可以互通，并且虚拟机可以访问外网。VMnet1是使用host-only模式，即虚拟机只能与主机构成内部通信，无法对外网进行通信。<font color="red">VMnet8使用的是NAT网络模式，这种模式一般是一台宿主机以及多台虚拟机，在构建hadoop分布式集群的时候就是采用这种模式的。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了上面三个的区别，下面就可以亲手实验一番了。首先看下自己创建的虚拟机的网关地址，看下面2张图，选择创建的虚拟机，在编辑中选择<font color="red">虚拟网络编辑器，选择VMnet8,点击NAT设置，可以看到虚拟机的网关地址是192.168.80.2</font><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/d1702534-20f1-4b7c-a261-e485335b1c32.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/51b2659f-8316-46d5-b5d2-2f4f519da6fe.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就是找到宿主机的网关地址，看下面两个图，在控制面板的网络连接中找到VMnet8，右键选择属性，在网络中找到IPv4选项再次点击属性，<font color="red">这里出现的问题时我这里不知道为什么手动选择IP地址下面的全成空了，</font>这就是我为什么出现ping不同的原因了，这里配置IP地址为192.168.80.1，子网掩码与虚拟机的子网掩码保持一致即可，保存。<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a5aeda05-11b2-4236-96e1-878a0e475db2.png" alt><br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/bd88b882-dec1-412b-85c5-c141dee5eba1.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后修改虚拟机的网络适配器模式为NAT模式，选择创建好的虚拟机，在网络适配器中选中即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来进入虚拟机，修改配置文件，</p><ol><li>CentOS6.5 vi /etc/sysconfig/network-scripts/ifcfg-eth0<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/91c717c7-f0a5-45fb-ae74-58cbaba603e7.png" alt></li><li>修改ifcfg-ens33配置文件，这里用的是CentOS7，按具体情况来，根据之前查到的虚拟机网关及子网掩码配置如下：<br><img src="/2018/03/16/Host-Vm%E7%9B%B8%E4%BA%92ping%E4%B8%8D%E5%90%8C%E5%88%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/a375362f-3899-4f21-b131-daf5fecc9009.png" alt><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;保存之后，通过 service network restart重启即可，在宿主机与虚拟机分别用ping命令测试发现可以ping通，OK。<h2 id="虚拟机上网问题"><a href="#虚拟机上网问题" class="headerlink" title="虚拟机上网问题"></a>虚拟机上网问题</h2>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就可以在宿主机使用xshell进行虚拟机连接了，方便操作，还有一个问题是之前虚拟机可以ping通外网的，现在突然连不上了，这样如果在虚拟机中下载一些软件安装包就会出现问题，查找了一下资料，发现:<font color="red">是因为没有设置dns服务器导致的，修改/etc/resolv.conf配置文件即可</font>，向里面加入dns服务器地址，它是DNS客户机配置文件，用于设置DNS服务器的IP地址地址及DNS域名，添加如下两个地址即可ping通外网了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 168.95.1.1</span><br><span class="line">nameserver 168.95.192.1</span><br></pre></td></tr></table></figure>测试一下，ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 发现ping通，OK</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
